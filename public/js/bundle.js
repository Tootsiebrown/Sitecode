webpackJsonp([1],Array(32).concat([
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($, jQuery) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = selectComponent;

var _camelCase = __webpack_require__(141);

var _camelCase2 = _interopRequireDefault(_camelCase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var componentSelectorTemplate = function componentSelectorTemplate(name) {
    return '[data-component=\'' + name + '\']';
};
var elementSelector = '[data-element]';
var componentSelector = '[data-component]';

function selectComponent(target) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var selector = $.type(target) === 'string' ? componentSelectorTemplate(target) : false;

    var $component = void 0;
    var elements = void 0;

    var init = function init() {
        if (target instanceof jQuery) {
            $component = target;
        } else {
            $component = selector ? $(selector) : $(target);
        }

        $component.elements = buildElements($component);
        $component.refresh = refresh;
        $component.selector = selector;
    };

    var buildElements = function buildElements(component) {
        var elementMap = {};
        var $elements = component.find(elementSelector);

        if (debug) {
            console.log('Original elements', $elements);
        }

        if ($elements.length) {
            var $excludedElements = $elements.filter(function (index, element) {
                return $(element).parentsUntil($component).filter(componentSelector).length;
            });

            $elements = $elements.not($excludedElements);

            if (debug) {
                console.log('Filtered elements', $elements);
            }

            $elements.each(function (index, element) {
                var $element = $(element);
                var elementName = (0, _camelCase2.default)($element.data('element'));

                if (elementMap.hasOwnProperty(elementName)) {
                    elementMap[elementName] = elementMap[elementName].add($element);
                } else {
                    elementMap[elementName] = $element;
                }
            });

            return elementMap;
        }

        return {};
    };

    var refresh = function refresh(debugSetting) {
        debug = debugSetting;
        $component.elements = buildElements($component);
    };

    init();

    return $component;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(6)))

/***/ }),
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(143);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery, jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! VelocityJS.org (1.5.0). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */

/*************************
 Velocity jQuery Shim
 *************************/

/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */

/* This file contains the jQuery functions that Velocity relies on, thereby removing Velocity's dependency on a full copy of jQuery, and allowing it to work in any environment. */
/* These shimmed functions are only used if jQuery isn't present. If both this shim and jQuery are loaded, Velocity defaults to jQuery proper. */
/* Browser support: Using this shim instead of jQuery proper removes support for IE8. */

(function(window) {
	"use strict";
	/***************
	 Setup
	 ***************/

	/* If jQuery is already loaded, there's no point in loading this shim. */
	if (__webpack_provided_window_dot_jQuery) {
		return;
	}

	/* jQuery base. */
	var $ = function(selector, context) {
		return new $.fn.init(selector, context);
	};

	/********************
	 Private Methods
	 ********************/

	/* jQuery */
	$.isWindow = function(obj) {
		/* jshint eqeqeq: false */
		return obj && obj === obj.window;
	};

	/* jQuery */
	$.type = function(obj) {
		if (!obj) {
			return obj + "";
		}

		return typeof obj === "object" || typeof obj === "function" ?
				class2type[toString.call(obj)] || "object" :
				typeof obj;
	};

	/* jQuery */
	$.isArray = Array.isArray || function(obj) {
		return $.type(obj) === "array";
	};

	/* jQuery */
	function isArraylike(obj) {
		var length = obj.length,
				type = $.type(obj);

		if (type === "function" || $.isWindow(obj)) {
			return false;
		}

		if (obj.nodeType === 1 && length) {
			return true;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
	}

	/***************
	 $ Methods
	 ***************/

	/* jQuery: Support removed for IE<9. */
	$.isPlainObject = function(obj) {
		var key;

		if (!obj || $.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {
			return false;
		}

		try {
			if (obj.constructor &&
					!hasOwn.call(obj, "constructor") &&
					!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}
		} catch (e) {
			return false;
		}

		for (key in obj) {
		}

		return key === undefined || hasOwn.call(obj, key);
	};

	/* jQuery */
	$.each = function(obj, callback, args) {
		var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike(obj);

		if (args) {
			if (isArray) {
				for (; i < length; i++) {
					value = callback.apply(obj[i], args);

					if (value === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (!obj.hasOwnProperty(i)) {
						continue;
					}
					value = callback.apply(obj[i], args);

					if (value === false) {
						break;
					}
				}
			}

		} else {
			if (isArray) {
				for (; i < length; i++) {
					value = callback.call(obj[i], i, obj[i]);

					if (value === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (!obj.hasOwnProperty(i)) {
						continue;
					}
					value = callback.call(obj[i], i, obj[i]);

					if (value === false) {
						break;
					}
				}
			}
		}

		return obj;
	};

	/* Custom */
	$.data = function(node, key, value) {
		/* $.getData() */
		if (value === undefined) {
			var getId = node[$.expando],
					store = getId && cache[getId];

			if (key === undefined) {
				return store;
			} else if (store) {
				if (key in store) {
					return store[key];
				}
			}
			/* $.setData() */
		} else if (key !== undefined) {
			var setId = node[$.expando] || (node[$.expando] = ++$.uuid);

			cache[setId] = cache[setId] || {};
			cache[setId][key] = value;

			return value;
		}
	};

	/* Custom */
	$.removeData = function(node, keys) {
		var id = node[$.expando],
				store = id && cache[id];

		if (store) {
			// Cleanup the entire store if no keys are provided.
			if (!keys) {
				delete cache[id];
			} else {
				$.each(keys, function(_, key) {
					delete store[key];
				});
			}
		}
	};

	/* jQuery */
	$.extend = function() {
		var src, copyIsArray, copy, name, options, clone,
				target = arguments[0] || {},
				i = 1,
				length = arguments.length,
				deep = false;

		if (typeof target === "boolean") {
			deep = target;

			target = arguments[i] || {};
			i++;
		}

		if (typeof target !== "object" && $.type(target) !== "function") {
			target = {};
		}

		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {
			if ((options = arguments[i])) {
				for (name in options) {
					if (!options.hasOwnProperty(name)) {
						continue;
					}
					src = target[name];
					copy = options[name];

					if (target === copy) {
						continue;
					}

					if (deep && copy && ($.isPlainObject(copy) || (copyIsArray = $.isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && $.isArray(src) ? src : [];

						} else {
							clone = src && $.isPlainObject(src) ? src : {};
						}

						target[name] = $.extend(deep, clone, copy);

					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		return target;
	};

	/* jQuery 1.4.3 */
	$.queue = function(elem, type, data) {
		function $makeArray(arr, results) {
			var ret = results || [];

			if (arr) {
				if (isArraylike(Object(arr))) {
					/* $.merge */
					(function(first, second) {
						var len = +second.length,
								j = 0,
								i = first.length;

						while (j < len) {
							first[i++] = second[j++];
						}

						if (len !== len) {
							while (second[j] !== undefined) {
								first[i++] = second[j++];
							}
						}

						first.length = i;

						return first;
					})(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					[].push.call(ret, arr);
				}
			}

			return ret;
		}

		if (!elem) {
			return;
		}

		type = (type || "fx") + "queue";

		var q = $.data(elem, type);

		if (!data) {
			return q || [];
		}

		if (!q || $.isArray(data)) {
			q = $.data(elem, type, $makeArray(data));
		} else {
			q.push(data);
		}

		return q;
	};

	/* jQuery 1.4.3 */
	$.dequeue = function(elems, type) {
		/* Custom: Embed element iteration. */
		$.each(elems.nodeType ? [elems] : elems, function(i, elem) {
			type = type || "fx";

			var queue = $.queue(elem, type),
					fn = queue.shift();

			if (fn === "inprogress") {
				fn = queue.shift();
			}

			if (fn) {
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				fn.call(elem, function() {
					$.dequeue(elem, type);
				});
			}
		});
	};

	/******************
	 $.fn Methods
	 ******************/

	/* jQuery */
	$.fn = $.prototype = {
		init: function(selector) {
			/* Just return the element wrapped inside an array; don't proceed with the actual jQuery node wrapping process. */
			if (selector.nodeType) {
				this[0] = selector;

				return this;
			} else {
				throw new Error("Not a DOM node.");
			}
		},
		offset: function() {
			/* jQuery altered code: Dropped disconnected DOM node checking. */
			var box = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {top: 0, left: 0};

			return {
				top: box.top + (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),
				left: box.left + (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)
			};
		},
		position: function() {
			/* jQuery */
			function offsetParentFn(elem) {
				var offsetParent = elem.offsetParent;

				while (offsetParent && offsetParent.nodeName.toLowerCase() !== "html" && offsetParent.style && offsetParent.style.position === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || document;
			}

			/* Zepto */
			var elem = this[0],
					offsetParent = offsetParentFn(elem),
					offset = this.offset(),
					parentOffset = /^(?:body|html)$/i.test(offsetParent.nodeName) ? {top: 0, left: 0} : $(offsetParent).offset();

			offset.top -= parseFloat(elem.style.marginTop) || 0;
			offset.left -= parseFloat(elem.style.marginLeft) || 0;

			if (offsetParent.style) {
				parentOffset.top += parseFloat(offsetParent.style.borderTopWidth) || 0;
				parentOffset.left += parseFloat(offsetParent.style.borderLeftWidth) || 0;
			}

			return {
				top: offset.top - parentOffset.top,
				left: offset.left - parentOffset.left
			};
		}
	};

	/**********************
	 Private Variables
	 **********************/

	/* For $.data() */
	var cache = {};
	$.expando = "velocity" + (new Date().getTime());
	$.uuid = 0;

	/* For $.queue() */
	var class2type = {},
			hasOwn = class2type.hasOwnProperty,
			toString = class2type.toString;

	var types = "Boolean Number String Function Array Date RegExp Object Error".split(" ");
	for (var i = 0; i < types.length; i++) {
		class2type["[object " + types[i] + "]"] = types[i].toLowerCase();
	}

	/* Makes $(node) possible, without having to call init. */
	$.fn.init.prototype = $.fn;

	/* Globalize Velocity onto the window, and assign its Utilities property. */
	window.Velocity = {Utilities: $};
})(window);

/******************
 Velocity.js
 ******************/

(function(factory) {
	"use strict";
	/* CommonJS module. */
	if (typeof module === "object" && typeof module.exports === "object") {
		module.exports = factory();
		/* AMD module. */
	} else if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		/* Browser globals. */
	} else {
		factory();
	}
}(function() {
	"use strict";
	return function(global, window, document, undefined) {

		/***************
		 Summary
		 ***************/

		/*
		 - CSS: CSS stack that works independently from the rest of Velocity.
		 - animate(): Core animation method that iterates over the targeted elements and queues the incoming call onto each element individually.
		 - Pre-Queueing: Prepare the element for animation by instantiating its data cache and processing the call's options.
		 - Queueing: The logic that runs once the call has reached its point of execution in the element's $.queue() stack.
		 Most logic is placed here to avoid risking it becoming stale (if the element's properties have changed).
		 - Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
		 - tick(): The single requestAnimationFrame loop responsible for tweening all in-progress calls.
		 - completeCall(): Handles the cleanup process for each Velocity call.
		 */

		/*********************
		 Helper Functions
		 *********************/

		/* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */
		var IE = (function() {
			if (document.documentMode) {
				return document.documentMode;
			} else {
				for (var i = 7; i > 4; i--) {
					var div = document.createElement("div");

					div.innerHTML = "<!--[if IE " + i + "]><span></span><![endif]-->";

					if (div.getElementsByTagName("span").length) {
						div = null;

						return i;
					}
				}
			}

			return undefined;
		})();

		/* rAF shim. Gist: https://gist.github.com/julianshapiro/9497513 */
		var rAFShim = (function() {
			var timeLast = 0;

			return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
				var timeCurrent = (new Date()).getTime(),
						timeDelta;

				/* Dynamically set delay on a per-tick basis to match 60fps. */
				/* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */
				timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
				timeLast = timeCurrent + timeDelta;

				return setTimeout(function() {
					callback(timeCurrent + timeDelta);
				}, timeDelta);
			};
		})();

		var performance = (function() {
			var perf = window.performance || {};

			if (typeof perf.now !== "function") {
				var nowOffset = perf.timing && perf.timing.navigationStart ? perf.timing.navigationStart : (new Date()).getTime();

				perf.now = function() {
					return (new Date()).getTime() - nowOffset;
				};
			}
			return perf;
		})();

		/* Array compacting. Copyright Lo-Dash. MIT License: https://github.com/lodash/lodash/blob/master/LICENSE.txt */
		function compactSparseArray(array) {
			var index = -1,
					length = array ? array.length : 0,
					result = [];

			while (++index < length) {
				var value = array[index];

				if (value) {
					result.push(value);
				}
			}

			return result;
		}

		/**
		 * Shim for "fixing" IE's lack of support (IE < 9) for applying slice
		 * on host objects like NamedNodeMap, NodeList, and HTMLCollection
		 * (technically, since host objects have been implementation-dependent,
		 * at least before ES2015, IE hasn't needed to work this way).
		 * Also works on strings, fixes IE < 9 to allow an explicit undefined
		 * for the 2nd argument (as in Firefox), and prevents errors when
		 * called on other DOM objects.
		 */
		var _slice = (function() {
			var slice = Array.prototype.slice;

			try {
				// Can't be used with DOM elements in IE < 9
				slice.call(document.documentElement);
				return slice;
			} catch (e) { // Fails in IE < 9

				// This will work for genuine arrays, array-like objects, 
				// NamedNodeMap (attributes, entities, notations),
				// NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
				// and will not fail on other DOM objects (as do DOM elements in IE < 9)
				return function(begin, end) {
					var len = this.length;

					if (typeof begin !== "number") {
						begin = 0;
					}
					// IE < 9 gets unhappy with an undefined end argument
					if (typeof end !== "number") {
						end = len;
					}
					// For native Array objects, we use the native slice function
					if (this.slice) {
						return slice.call(this, begin, end);
					}
					// For array like object we handle it ourselves.
					var i,
							cloned = [],
							// Handle negative value for "begin"
							start = (begin >= 0) ? begin : Math.max(0, len + begin),
							// Handle negative value for "end"
							upTo = end < 0 ? len + end : Math.min(end, len),
							// Actual expected size of the slice
							size = upTo - start;

					if (size > 0) {
						cloned = new Array(size);
						if (this.charAt) {
							for (i = 0; i < size; i++) {
								cloned[i] = this.charAt(start + i);
							}
						} else {
							for (i = 0; i < size; i++) {
								cloned[i] = this[start + i];
							}
						}
					}
					return cloned;
				};
			}
		})();

		/* .indexOf doesn't exist in IE<9 */
		var _inArray = (function() {
			if (Array.prototype.includes) {
				return function(arr, val) {
					return arr.includes(val);
				};
			}
			if (Array.prototype.indexOf) {
				return function(arr, val) {
					return arr.indexOf(val) >= 0;
				};
			}
			return function(arr, val) {
				for (var i = 0; i < arr.length; i++) {
					if (arr[i] === val) {
						return true;
					}
				}
				return false;
			};
		});

		function sanitizeElements(elements) {
			/* Unwrap jQuery/Zepto objects. */
			if (Type.isWrapped(elements)) {
				elements = _slice.call(elements);
				/* Wrap a single element in an array so that $.each() can iterate with the element instead of its node's children. */
			} else if (Type.isNode(elements)) {
				elements = [elements];
			}

			return elements;
		}

		var Type = {
			isNumber: function(variable) {
				return (typeof variable === "number");
			},
			isString: function(variable) {
				return (typeof variable === "string");
			},
			isArray: Array.isArray || function(variable) {
				return Object.prototype.toString.call(variable) === "[object Array]";
			},
			isFunction: function(variable) {
				return Object.prototype.toString.call(variable) === "[object Function]";
			},
			isNode: function(variable) {
				return variable && variable.nodeType;
			},
			/* Determine if variable is an array-like wrapped jQuery, Zepto or similar element, or even a NodeList etc. */
			/* NOTE: HTMLFormElements also have a length. */
			isWrapped: function(variable) {
				return variable
						&& variable !== window
						&& Type.isNumber(variable.length)
						&& !Type.isString(variable)
						&& !Type.isFunction(variable)
						&& !Type.isNode(variable)
						&& (variable.length === 0 || Type.isNode(variable[0]));
			},
			isSVG: function(variable) {
				return window.SVGElement && (variable instanceof window.SVGElement);
			},
			isEmptyObject: function(variable) {
				for (var name in variable) {
					if (variable.hasOwnProperty(name)) {
						return false;
					}
				}

				return true;
			}
		};

		/*****************
		 Dependencies
		 *****************/

		var $,
				isJQuery = false;

		if (global.fn && global.fn.jquery) {
			$ = global;
			isJQuery = true;
		} else {
			$ = window.Velocity.Utilities;
		}

		if (IE <= 8 && !isJQuery) {
			throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
		} else if (IE <= 7) {
			/* Revert to jQuery's $.animate(), and lose Velocity's extra features. */
			jQuery.fn.velocity = jQuery.fn.animate;

			/* Now that $.fn.velocity is aliased, abort this Velocity declaration. */
			return;
		}

		/*****************
		 Constants
		 *****************/

		var DURATION_DEFAULT = 400,
				EASING_DEFAULT = "swing";

		/*************
		 State
		 *************/

		var Velocity = {
			/* Container for page-wide Velocity state data. */
			State: {
				/* Detect mobile devices to determine if mobileHA should be turned on. */
				isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
				/* The mobileHA option's behavior changes on older Android devices (Gingerbread, versions 2.3.3-2.3.7). */
				isAndroid: /Android/i.test(navigator.userAgent),
				isGingerbread: /Android 2\.3\.[3-7]/i.test(navigator.userAgent),
				isChrome: window.chrome,
				isFirefox: /Firefox/i.test(navigator.userAgent),
				/* Create a cached element for re-use when checking for CSS property prefixes. */
				prefixElement: document.createElement("div"),
				/* Cache every prefix match to avoid repeating lookups. */
				prefixMatches: {},
				/* Cache the anchor used for animating window scrolling. */
				scrollAnchor: null,
				/* Cache the browser-specific property names associated with the scroll anchor. */
				scrollPropertyLeft: null,
				scrollPropertyTop: null,
				/* Keep track of whether our RAF tick is running. */
				isTicking: false,
				/* Container for every in-progress call to Velocity. */
				calls: [],
				delayedElements: {
					count: 0
				}
			},
			/* Velocity's custom CSS stack. Made global for unit testing. */
			CSS: {/* Defined below. */},
			/* A shim of the jQuery utility functions used by Velocity -- provided by Velocity's optional jQuery shim. */
			Utilities: $,
			/* Container for the user's custom animation redirects that are referenced by name in place of the properties map argument. */
			Redirects: {/* Manually registered by the user. */},
			Easings: {/* Defined below. */},
			/* Attempt to use ES6 Promises by default. Users can override this with a third-party promises library. */
			Promise: window.Promise,
			/* Velocity option defaults, which can be overriden by the user. */
			defaults: {
				queue: "",
				duration: DURATION_DEFAULT,
				easing: EASING_DEFAULT,
				begin: undefined,
				complete: undefined,
				progress: undefined,
				display: undefined,
				visibility: undefined,
				loop: false,
				delay: false,
				mobileHA: true,
				/* Advanced: Set to false to prevent property values from being cached between consecutive Velocity-initiated chain calls. */
				_cacheValues: true,
				/* Advanced: Set to false if the promise should always resolve on empty element lists. */
				promiseRejectEmpty: true
			},
			/* A design goal of Velocity is to cache data wherever possible in order to avoid DOM requerying. Accordingly, each element has a data cache. */
			init: function(element) {
				$.data(element, "velocity", {
					/* Store whether this is an SVG element, since its properties are retrieved and updated differently than standard HTML elements. */
					isSVG: Type.isSVG(element),
					/* Keep track of whether the element is currently being animated by Velocity.
					 This is used to ensure that property values are not transferred between non-consecutive (stale) calls. */
					isAnimating: false,
					/* A reference to the element's live computedStyle object. Learn more here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
					computedStyle: null,
					/* Tween data is cached for each animation on the element so that data can be passed across calls --
					 in particular, end values are used as subsequent start values in consecutive Velocity calls. */
					tweensContainer: null,
					/* The full root property values of each CSS hook being animated on this element are cached so that:
					 1) Concurrently-animating hooks sharing the same root can have their root values' merged into one while tweening.
					 2) Post-hook-injection root values can be transferred over to consecutively chained Velocity calls as starting root values. */
					rootPropertyValueCache: {},
					/* A cache for transform updates, which must be manually flushed via CSS.flushTransformCache(). */
					transformCache: {}
				});
			},
			/* A parallel to jQuery's $.css(), used for getting/setting Velocity's hooked CSS properties. */
			hook: null, /* Defined below. */
			/* Velocity-wide animation time remapping for testing purposes. */
			mock: false,
			version: {major: 1, minor: 5, patch: 0},
			/* Set to 1 or 2 (most verbose) to output debug info to console. */
			debug: false,
			/* Use rAF high resolution timestamp when available */
			timestamp: true,
			/* Pause all animations */
			pauseAll: function(queueName) {
				var currentTime = (new Date()).getTime();

				$.each(Velocity.State.calls, function(i, activeCall) {

					if (activeCall) {

						/* If we have a queueName and this call is not on that queue, skip */
						if (queueName !== undefined && ((activeCall[2].queue !== queueName) || (activeCall[2].queue === false))) {
							return true;
						}

						/* Set call to paused */
						activeCall[5] = {
							resume: false
						};
					}
				});

				/* Pause timers on any currently delayed calls */
				$.each(Velocity.State.delayedElements, function(k, element) {
					if (!element) {
						return;
					}
					pauseDelayOnElement(element, currentTime);
				});
			},
			/* Resume all animations */
			resumeAll: function(queueName) {
				var currentTime = (new Date()).getTime();

				$.each(Velocity.State.calls, function(i, activeCall) {

					if (activeCall) {

						/* If we have a queueName and this call is not on that queue, skip */
						if (queueName !== undefined && ((activeCall[2].queue !== queueName) || (activeCall[2].queue === false))) {
							return true;
						}

						/* Set call to resumed if it was paused */
						if (activeCall[5]) {
							activeCall[5].resume = true;
						}
					}
				});
				/* Resume timers on any currently delayed calls */
				$.each(Velocity.State.delayedElements, function(k, element) {
					if (!element) {
						return;
					}
					resumeDelayOnElement(element, currentTime);
				});
			}
		};

		/* Retrieve the appropriate scroll anchor and property name for the browser: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY */
		if (window.pageYOffset !== undefined) {
			Velocity.State.scrollAnchor = window;
			Velocity.State.scrollPropertyLeft = "pageXOffset";
			Velocity.State.scrollPropertyTop = "pageYOffset";
		} else {
			Velocity.State.scrollAnchor = document.documentElement || document.body.parentNode || document.body;
			Velocity.State.scrollPropertyLeft = "scrollLeft";
			Velocity.State.scrollPropertyTop = "scrollTop";
		}

		/* Shorthand alias for jQuery's $.data() utility. */
		function Data(element) {
			/* Hardcode a reference to the plugin name. */
			var response = $.data(element, "velocity");

			/* jQuery <=1.4.2 returns null instead of undefined when no match is found. We normalize this behavior. */
			return response === null ? undefined : response;
		}

		/**************
		 Delay Timer
		 **************/

		function pauseDelayOnElement(element, currentTime) {
			/* Check for any delay timers, and pause the set timeouts (while preserving time data)
			 to be resumed when the "resume" command is issued */
			var data = Data(element);
			if (data && data.delayTimer && !data.delayPaused) {
				data.delayRemaining = data.delay - currentTime + data.delayBegin;
				data.delayPaused = true;
				clearTimeout(data.delayTimer.setTimeout);
			}
		}

		function resumeDelayOnElement(element, currentTime) {
			/* Check for any paused timers and resume */
			var data = Data(element);
			if (data && data.delayTimer && data.delayPaused) {
				/* If the element was mid-delay, re initiate the timeout with the remaining delay */
				data.delayPaused = false;
				data.delayTimer.setTimeout = setTimeout(data.delayTimer.next, data.delayRemaining);
			}
		}



		/**************
		 Easing
		 **************/

		/* Step easing generator. */
		function generateStep(steps) {
			return function(p) {
				return Math.round(p * steps) * (1 / steps);
			};
		}

		/* Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
		function generateBezier(mX1, mY1, mX2, mY2) {
			var NEWTON_ITERATIONS = 4,
					NEWTON_MIN_SLOPE = 0.001,
					SUBDIVISION_PRECISION = 0.0000001,
					SUBDIVISION_MAX_ITERATIONS = 10,
					kSplineTableSize = 11,
					kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
					float32ArraySupported = "Float32Array" in window;

			/* Must contain four arguments. */
			if (arguments.length !== 4) {
				return false;
			}

			/* Arguments must be numbers. */
			for (var i = 0; i < 4; ++i) {
				if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
					return false;
				}
			}

			/* X values must be in the [0, 1] range. */
			mX1 = Math.min(mX1, 1);
			mX2 = Math.min(mX2, 1);
			mX1 = Math.max(mX1, 0);
			mX2 = Math.max(mX2, 0);

			var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

			function A(aA1, aA2) {
				return 1.0 - 3.0 * aA2 + 3.0 * aA1;
			}
			function B(aA1, aA2) {
				return 3.0 * aA2 - 6.0 * aA1;
			}
			function C(aA1) {
				return 3.0 * aA1;
			}

			function calcBezier(aT, aA1, aA2) {
				return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
			}

			function getSlope(aT, aA1, aA2) {
				return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
			}

			function newtonRaphsonIterate(aX, aGuessT) {
				for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
					var currentSlope = getSlope(aGuessT, mX1, mX2);

					if (currentSlope === 0.0) {
						return aGuessT;
					}

					var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
					aGuessT -= currentX / currentSlope;
				}

				return aGuessT;
			}

			function calcSampleValues() {
				for (var i = 0; i < kSplineTableSize; ++i) {
					mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
				}
			}

			function binarySubdivide(aX, aA, aB) {
				var currentX, currentT, i = 0;

				do {
					currentT = aA + (aB - aA) / 2.0;
					currentX = calcBezier(currentT, mX1, mX2) - aX;
					if (currentX > 0.0) {
						aB = currentT;
					} else {
						aA = currentT;
					}
				} while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

				return currentT;
			}

			function getTForX(aX) {
				var intervalStart = 0.0,
						currentSample = 1,
						lastSample = kSplineTableSize - 1;

				for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
					intervalStart += kSampleStepSize;
				}

				--currentSample;

				var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
						guessForT = intervalStart + dist * kSampleStepSize,
						initialSlope = getSlope(guessForT, mX1, mX2);

				if (initialSlope >= NEWTON_MIN_SLOPE) {
					return newtonRaphsonIterate(aX, guessForT);
				} else if (initialSlope === 0.0) {
					return guessForT;
				} else {
					return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
				}
			}

			var _precomputed = false;

			function precompute() {
				_precomputed = true;
				if (mX1 !== mY1 || mX2 !== mY2) {
					calcSampleValues();
				}
			}

			var f = function(aX) {
				if (!_precomputed) {
					precompute();
				}
				if (mX1 === mY1 && mX2 === mY2) {
					return aX;
				}
				if (aX === 0) {
					return 0;
				}
				if (aX === 1) {
					return 1;
				}

				return calcBezier(getTForX(aX), mY1, mY2);
			};

			f.getControlPoints = function() {
				return [{x: mX1, y: mY1}, {x: mX2, y: mY2}];
			};

			var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
			f.toString = function() {
				return str;
			};

			return f;
		}

		/* Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
		/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
		 then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
		var generateSpringRK4 = (function() {
			function springAccelerationForState(state) {
				return (-state.tension * state.x) - (state.friction * state.v);
			}

			function springEvaluateStateWithDerivative(initialState, dt, derivative) {
				var state = {
					x: initialState.x + derivative.dx * dt,
					v: initialState.v + derivative.dv * dt,
					tension: initialState.tension,
					friction: initialState.friction
				};

				return {dx: state.v, dv: springAccelerationForState(state)};
			}

			function springIntegrateState(state, dt) {
				var a = {
					dx: state.v,
					dv: springAccelerationForState(state)
				},
						b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
						c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
						d = springEvaluateStateWithDerivative(state, dt, c),
						dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
						dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

				state.x = state.x + dxdt * dt;
				state.v = state.v + dvdt * dt;

				return state;
			}

			return function springRK4Factory(tension, friction, duration) {

				var initState = {
					x: -1,
					v: 0,
					tension: null,
					friction: null
				},
						path = [0],
						time_lapsed = 0,
						tolerance = 1 / 10000,
						DT = 16 / 1000,
						have_duration, dt, last_state;

				tension = parseFloat(tension) || 500;
				friction = parseFloat(friction) || 20;
				duration = duration || null;

				initState.tension = tension;
				initState.friction = friction;

				have_duration = duration !== null;

				/* Calculate the actual time it takes for this animation to complete with the provided conditions. */
				if (have_duration) {
					/* Run the simulation without a duration. */
					time_lapsed = springRK4Factory(tension, friction);
					/* Compute the adjusted time delta. */
					dt = time_lapsed / duration * DT;
				} else {
					dt = DT;
				}

				while (true) {
					/* Next/step function .*/
					last_state = springIntegrateState(last_state || initState, dt);
					/* Store the position. */
					path.push(1 + last_state.x);
					time_lapsed += 16;
					/* If the change threshold is reached, break. */
					if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
						break;
					}
				}

				/* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
				 computed path and returns a snapshot of the position according to a given percentComplete. */
				return !have_duration ? time_lapsed : function(percentComplete) {
					return path[ (percentComplete * (path.length - 1)) | 0 ];
				};
			};
		}());

		/* jQuery easings. */
		Velocity.Easings = {
			linear: function(p) {
				return p;
			},
			swing: function(p) {
				return 0.5 - Math.cos(p * Math.PI) / 2;
			},
			/* Bonus "spring" easing, which is a less exaggerated version of easeInOutElastic. */
			spring: function(p) {
				return 1 - (Math.cos(p * 4.5 * Math.PI) * Math.exp(-p * 6));
			}
		};

		/* CSS3 and Robert Penner easings. */
		$.each(
				[
					["ease", [0.25, 0.1, 0.25, 1.0]],
					["ease-in", [0.42, 0.0, 1.00, 1.0]],
					["ease-out", [0.00, 0.0, 0.58, 1.0]],
					["ease-in-out", [0.42, 0.0, 0.58, 1.0]],
					["easeInSine", [0.47, 0, 0.745, 0.715]],
					["easeOutSine", [0.39, 0.575, 0.565, 1]],
					["easeInOutSine", [0.445, 0.05, 0.55, 0.95]],
					["easeInQuad", [0.55, 0.085, 0.68, 0.53]],
					["easeOutQuad", [0.25, 0.46, 0.45, 0.94]],
					["easeInOutQuad", [0.455, 0.03, 0.515, 0.955]],
					["easeInCubic", [0.55, 0.055, 0.675, 0.19]],
					["easeOutCubic", [0.215, 0.61, 0.355, 1]],
					["easeInOutCubic", [0.645, 0.045, 0.355, 1]],
					["easeInQuart", [0.895, 0.03, 0.685, 0.22]],
					["easeOutQuart", [0.165, 0.84, 0.44, 1]],
					["easeInOutQuart", [0.77, 0, 0.175, 1]],
					["easeInQuint", [0.755, 0.05, 0.855, 0.06]],
					["easeOutQuint", [0.23, 1, 0.32, 1]],
					["easeInOutQuint", [0.86, 0, 0.07, 1]],
					["easeInExpo", [0.95, 0.05, 0.795, 0.035]],
					["easeOutExpo", [0.19, 1, 0.22, 1]],
					["easeInOutExpo", [1, 0, 0, 1]],
					["easeInCirc", [0.6, 0.04, 0.98, 0.335]],
					["easeOutCirc", [0.075, 0.82, 0.165, 1]],
					["easeInOutCirc", [0.785, 0.135, 0.15, 0.86]]
				], function(i, easingArray) {
			Velocity.Easings[easingArray[0]] = generateBezier.apply(null, easingArray[1]);
		});

		/* Determine the appropriate easing type given an easing input. */
		function getEasing(value, duration) {
			var easing = value;

			/* The easing option can either be a string that references a pre-registered easing,
			 or it can be a two-/four-item array of integers to be converted into a bezier/spring function. */
			if (Type.isString(value)) {
				/* Ensure that the easing has been assigned to jQuery's Velocity.Easings object. */
				if (!Velocity.Easings[value]) {
					easing = false;
				}
			} else if (Type.isArray(value) && value.length === 1) {
				easing = generateStep.apply(null, value);
			} else if (Type.isArray(value) && value.length === 2) {
				/* springRK4 must be passed the animation's duration. */
				/* Note: If the springRK4 array contains non-numbers, generateSpringRK4() returns an easing
				 function generated with default tension and friction values. */
				easing = generateSpringRK4.apply(null, value.concat([duration]));
			} else if (Type.isArray(value) && value.length === 4) {
				/* Note: If the bezier array contains non-numbers, generateBezier() returns false. */
				easing = generateBezier.apply(null, value);
			} else {
				easing = false;
			}

			/* Revert to the Velocity-wide default easing type, or fall back to "swing" (which is also jQuery's default)
			 if the Velocity-wide default has been incorrectly modified. */
			if (easing === false) {
				if (Velocity.Easings[Velocity.defaults.easing]) {
					easing = Velocity.defaults.easing;
				} else {
					easing = EASING_DEFAULT;
				}
			}

			return easing;
		}

		/*****************
		 CSS Stack
		 *****************/

		/* The CSS object is a highly condensed and performant CSS stack that fully replaces jQuery's.
		 It handles the validation, getting, and setting of both standard CSS properties and CSS property hooks. */
		/* Note: A "CSS" shorthand is aliased so that our code is easier to read. */
		var CSS = Velocity.CSS = {
			/*************
			 RegEx
			 *************/

			RegEx: {
				isHex: /^#([A-f\d]{3}){1,2}$/i,
				/* Unwrap a property value's surrounding text, e.g. "rgba(4, 3, 2, 1)" ==> "4, 3, 2, 1" and "rect(4px 3px 2px 1px)" ==> "4px 3px 2px 1px". */
				valueUnwrap: /^[A-z]+\((.*)\)$/i,
				wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,
				/* Split a multi-value property into an array of subvalues, e.g. "rgba(4, 3, 2, 1) 4px 3px 2px 1px" ==> [ "rgba(4, 3, 2, 1)", "4px", "3px", "2px", "1px" ]. */
				valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/ig
			},
			/************
			 Lists
			 ************/

			Lists: {
				colors: ["fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor"],
				transformsBase: ["translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ"],
				transforms3D: ["transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY"],
				units: [
					"%", // relative
					"em", "ex", "ch", "rem", // font relative
					"vw", "vh", "vmin", "vmax", // viewport relative
					"cm", "mm", "Q", "in", "pc", "pt", "px", // absolute lengths
					"deg", "grad", "rad", "turn", // angles
					"s", "ms" // time
				],
				colorNames: {
					"aliceblue": "240,248,255",
					"antiquewhite": "250,235,215",
					"aquamarine": "127,255,212",
					"aqua": "0,255,255",
					"azure": "240,255,255",
					"beige": "245,245,220",
					"bisque": "255,228,196",
					"black": "0,0,0",
					"blanchedalmond": "255,235,205",
					"blueviolet": "138,43,226",
					"blue": "0,0,255",
					"brown": "165,42,42",
					"burlywood": "222,184,135",
					"cadetblue": "95,158,160",
					"chartreuse": "127,255,0",
					"chocolate": "210,105,30",
					"coral": "255,127,80",
					"cornflowerblue": "100,149,237",
					"cornsilk": "255,248,220",
					"crimson": "220,20,60",
					"cyan": "0,255,255",
					"darkblue": "0,0,139",
					"darkcyan": "0,139,139",
					"darkgoldenrod": "184,134,11",
					"darkgray": "169,169,169",
					"darkgrey": "169,169,169",
					"darkgreen": "0,100,0",
					"darkkhaki": "189,183,107",
					"darkmagenta": "139,0,139",
					"darkolivegreen": "85,107,47",
					"darkorange": "255,140,0",
					"darkorchid": "153,50,204",
					"darkred": "139,0,0",
					"darksalmon": "233,150,122",
					"darkseagreen": "143,188,143",
					"darkslateblue": "72,61,139",
					"darkslategray": "47,79,79",
					"darkturquoise": "0,206,209",
					"darkviolet": "148,0,211",
					"deeppink": "255,20,147",
					"deepskyblue": "0,191,255",
					"dimgray": "105,105,105",
					"dimgrey": "105,105,105",
					"dodgerblue": "30,144,255",
					"firebrick": "178,34,34",
					"floralwhite": "255,250,240",
					"forestgreen": "34,139,34",
					"fuchsia": "255,0,255",
					"gainsboro": "220,220,220",
					"ghostwhite": "248,248,255",
					"gold": "255,215,0",
					"goldenrod": "218,165,32",
					"gray": "128,128,128",
					"grey": "128,128,128",
					"greenyellow": "173,255,47",
					"green": "0,128,0",
					"honeydew": "240,255,240",
					"hotpink": "255,105,180",
					"indianred": "205,92,92",
					"indigo": "75,0,130",
					"ivory": "255,255,240",
					"khaki": "240,230,140",
					"lavenderblush": "255,240,245",
					"lavender": "230,230,250",
					"lawngreen": "124,252,0",
					"lemonchiffon": "255,250,205",
					"lightblue": "173,216,230",
					"lightcoral": "240,128,128",
					"lightcyan": "224,255,255",
					"lightgoldenrodyellow": "250,250,210",
					"lightgray": "211,211,211",
					"lightgrey": "211,211,211",
					"lightgreen": "144,238,144",
					"lightpink": "255,182,193",
					"lightsalmon": "255,160,122",
					"lightseagreen": "32,178,170",
					"lightskyblue": "135,206,250",
					"lightslategray": "119,136,153",
					"lightsteelblue": "176,196,222",
					"lightyellow": "255,255,224",
					"limegreen": "50,205,50",
					"lime": "0,255,0",
					"linen": "250,240,230",
					"magenta": "255,0,255",
					"maroon": "128,0,0",
					"mediumaquamarine": "102,205,170",
					"mediumblue": "0,0,205",
					"mediumorchid": "186,85,211",
					"mediumpurple": "147,112,219",
					"mediumseagreen": "60,179,113",
					"mediumslateblue": "123,104,238",
					"mediumspringgreen": "0,250,154",
					"mediumturquoise": "72,209,204",
					"mediumvioletred": "199,21,133",
					"midnightblue": "25,25,112",
					"mintcream": "245,255,250",
					"mistyrose": "255,228,225",
					"moccasin": "255,228,181",
					"navajowhite": "255,222,173",
					"navy": "0,0,128",
					"oldlace": "253,245,230",
					"olivedrab": "107,142,35",
					"olive": "128,128,0",
					"orangered": "255,69,0",
					"orange": "255,165,0",
					"orchid": "218,112,214",
					"palegoldenrod": "238,232,170",
					"palegreen": "152,251,152",
					"paleturquoise": "175,238,238",
					"palevioletred": "219,112,147",
					"papayawhip": "255,239,213",
					"peachpuff": "255,218,185",
					"peru": "205,133,63",
					"pink": "255,192,203",
					"plum": "221,160,221",
					"powderblue": "176,224,230",
					"purple": "128,0,128",
					"red": "255,0,0",
					"rosybrown": "188,143,143",
					"royalblue": "65,105,225",
					"saddlebrown": "139,69,19",
					"salmon": "250,128,114",
					"sandybrown": "244,164,96",
					"seagreen": "46,139,87",
					"seashell": "255,245,238",
					"sienna": "160,82,45",
					"silver": "192,192,192",
					"skyblue": "135,206,235",
					"slateblue": "106,90,205",
					"slategray": "112,128,144",
					"snow": "255,250,250",
					"springgreen": "0,255,127",
					"steelblue": "70,130,180",
					"tan": "210,180,140",
					"teal": "0,128,128",
					"thistle": "216,191,216",
					"tomato": "255,99,71",
					"turquoise": "64,224,208",
					"violet": "238,130,238",
					"wheat": "245,222,179",
					"whitesmoke": "245,245,245",
					"white": "255,255,255",
					"yellowgreen": "154,205,50",
					"yellow": "255,255,0"
				}
			},
			/************
			 Hooks
			 ************/

			/* Hooks allow a subproperty (e.g. "boxShadowBlur") of a compound-value CSS property
			 (e.g. "boxShadow: X Y Blur Spread Color") to be animated as if it were a discrete property. */
			/* Note: Beyond enabling fine-grained property animation, hooking is necessary since Velocity only
			 tweens properties with single numeric values; unlike CSS transitions, Velocity does not interpolate compound-values. */
			Hooks: {
				/********************
				 Registration
				 ********************/

				/* Templates are a concise way of indicating which subproperties must be individually registered for each compound-value CSS property. */
				/* Each template consists of the compound-value's base name, its constituent subproperty names, and those subproperties' default values. */
				templates: {
					"textShadow": ["Color X Y Blur", "black 0px 0px 0px"],
					"boxShadow": ["Color X Y Blur Spread", "black 0px 0px 0px 0px"],
					"clip": ["Top Right Bottom Left", "0px 0px 0px 0px"],
					"backgroundPosition": ["X Y", "0% 0%"],
					"transformOrigin": ["X Y Z", "50% 50% 0px"],
					"perspectiveOrigin": ["X Y", "50% 50%"]
				},
				/* A "registered" hook is one that has been converted from its template form into a live,
				 tweenable property. It contains data to associate it with its root property. */
				registered: {
					/* Note: A registered hook looks like this ==> textShadowBlur: [ "textShadow", 3 ],
					 which consists of the subproperty's name, the associated root property's name,
					 and the subproperty's position in the root's value. */
				},
				/* Convert the templates into individual hooks then append them to the registered object above. */
				register: function() {
					/* Color hooks registration: Colors are defaulted to white -- as opposed to black -- since colors that are
					 currently set to "transparent" default to their respective template below when color-animated,
					 and white is typically a closer match to transparent than black is. An exception is made for text ("color"),
					 which is almost always set closer to black than white. */
					for (var i = 0; i < CSS.Lists.colors.length; i++) {
						var rgbComponents = (CSS.Lists.colors[i] === "color") ? "0 0 0 1" : "255 255 255 1";
						CSS.Hooks.templates[CSS.Lists.colors[i]] = ["Red Green Blue Alpha", rgbComponents];
					}

					var rootProperty,
							hookTemplate,
							hookNames;

					/* In IE, color values inside compound-value properties are positioned at the end the value instead of at the beginning.
					 Thus, we re-arrange the templates accordingly. */
					if (IE) {
						for (rootProperty in CSS.Hooks.templates) {
							if (!CSS.Hooks.templates.hasOwnProperty(rootProperty)) {
								continue;
							}
							hookTemplate = CSS.Hooks.templates[rootProperty];
							hookNames = hookTemplate[0].split(" ");

							var defaultValues = hookTemplate[1].match(CSS.RegEx.valueSplit);

							if (hookNames[0] === "Color") {
								/* Reposition both the hook's name and its default value to the end of their respective strings. */
								hookNames.push(hookNames.shift());
								defaultValues.push(defaultValues.shift());

								/* Replace the existing template for the hook's root property. */
								CSS.Hooks.templates[rootProperty] = [hookNames.join(" "), defaultValues.join(" ")];
							}
						}
					}

					/* Hook registration. */
					for (rootProperty in CSS.Hooks.templates) {
						if (!CSS.Hooks.templates.hasOwnProperty(rootProperty)) {
							continue;
						}
						hookTemplate = CSS.Hooks.templates[rootProperty];
						hookNames = hookTemplate[0].split(" ");

						for (var j in hookNames) {
							if (!hookNames.hasOwnProperty(j)) {
								continue;
							}
							var fullHookName = rootProperty + hookNames[j],
									hookPosition = j;

							/* For each hook, register its full name (e.g. textShadowBlur) with its root property (e.g. textShadow)
							 and the hook's position in its template's default value string. */
							CSS.Hooks.registered[fullHookName] = [rootProperty, hookPosition];
						}
					}
				},
				/*****************************
				 Injection and Extraction
				 *****************************/

				/* Look up the root property associated with the hook (e.g. return "textShadow" for "textShadowBlur"). */
				/* Since a hook cannot be set directly (the browser won't recognize it), style updating for hooks is routed through the hook's root property. */
				getRoot: function(property) {
					var hookData = CSS.Hooks.registered[property];

					if (hookData) {
						return hookData[0];
					} else {
						/* If there was no hook match, return the property name untouched. */
						return property;
					}
				},
				getUnit: function(str, start) {
					var unit = (str.substr(start || 0, 5).match(/^[a-z%]+/) || [])[0] || "";

					if (unit && _inArray(CSS.Lists.units, unit)) {
						return unit;
					}
					return "";
				},
				fixColors: function(str) {
					return str.replace(/(rgba?\(\s*)?(\b[a-z]+\b)/g, function($0, $1, $2) {
						if (CSS.Lists.colorNames.hasOwnProperty($2)) {
							return ($1 ? $1 : "rgba(") + CSS.Lists.colorNames[$2] + ($1 ? "" : ",1)");
						}
						return $1 + $2;
					});
				},
				/* Convert any rootPropertyValue, null or otherwise, into a space-delimited list of hook values so that
				 the targeted hook can be injected or extracted at its standard position. */
				cleanRootPropertyValue: function(rootProperty, rootPropertyValue) {
					/* If the rootPropertyValue is wrapped with "rgb()", "clip()", etc., remove the wrapping to normalize the value before manipulation. */
					if (CSS.RegEx.valueUnwrap.test(rootPropertyValue)) {
						rootPropertyValue = rootPropertyValue.match(CSS.RegEx.valueUnwrap)[1];
					}

					/* If rootPropertyValue is a CSS null-value (from which there's inherently no hook value to extract),
					 default to the root's default value as defined in CSS.Hooks.templates. */
					/* Note: CSS null-values include "none", "auto", and "transparent". They must be converted into their
					 zero-values (e.g. textShadow: "none" ==> textShadow: "0px 0px 0px black") for hook manipulation to proceed. */
					if (CSS.Values.isCSSNullValue(rootPropertyValue)) {
						rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
					}

					return rootPropertyValue;
				},
				/* Extracted the hook's value from its root property's value. This is used to get the starting value of an animating hook. */
				extractValue: function(fullHookName, rootPropertyValue) {
					var hookData = CSS.Hooks.registered[fullHookName];

					if (hookData) {
						var hookRoot = hookData[0],
								hookPosition = hookData[1];

						rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);

						/* Split rootPropertyValue into its constituent hook values then grab the desired hook at its standard position. */
						return rootPropertyValue.toString().match(CSS.RegEx.valueSplit)[hookPosition];
					} else {
						/* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
						return rootPropertyValue;
					}
				},
				/* Inject the hook's value into its root property's value. This is used to piece back together the root property
				 once Velocity has updated one of its individually hooked values through tweening. */
				injectValue: function(fullHookName, hookValue, rootPropertyValue) {
					var hookData = CSS.Hooks.registered[fullHookName];

					if (hookData) {
						var hookRoot = hookData[0],
								hookPosition = hookData[1],
								rootPropertyValueParts,
								rootPropertyValueUpdated;

						rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);

						/* Split rootPropertyValue into its individual hook values, replace the targeted value with hookValue,
						 then reconstruct the rootPropertyValue string. */
						rootPropertyValueParts = rootPropertyValue.toString().match(CSS.RegEx.valueSplit);
						rootPropertyValueParts[hookPosition] = hookValue;
						rootPropertyValueUpdated = rootPropertyValueParts.join(" ");

						return rootPropertyValueUpdated;
					} else {
						/* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
						return rootPropertyValue;
					}
				}
			},
			/*******************
			 Normalizations
			 *******************/

			/* Normalizations standardize CSS property manipulation by pollyfilling browser-specific implementations (e.g. opacity)
			 and reformatting special properties (e.g. clip, rgba) to look like standard ones. */
			Normalizations: {
				/* Normalizations are passed a normalization target (either the property's name, its extracted value, or its injected value),
				 the targeted element (which may need to be queried), and the targeted property value. */
				registered: {
					clip: function(type, element, propertyValue) {
						switch (type) {
							case "name":
								return "clip";
								/* Clip needs to be unwrapped and stripped of its commas during extraction. */
							case "extract":
								var extracted;

								/* If Velocity also extracted this value, skip extraction. */
								if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
									extracted = propertyValue;
								} else {
									/* Remove the "rect()" wrapper. */
									extracted = propertyValue.toString().match(CSS.RegEx.valueUnwrap);

									/* Strip off commas. */
									extracted = extracted ? extracted[1].replace(/,(\s+)?/g, " ") : propertyValue;
								}

								return extracted;
								/* Clip needs to be re-wrapped during injection. */
							case "inject":
								return "rect(" + propertyValue + ")";
						}
					},
					blur: function(type, element, propertyValue) {
						switch (type) {
							case "name":
								return Velocity.State.isFirefox ? "filter" : "-webkit-filter";
							case "extract":
								var extracted = parseFloat(propertyValue);

								/* If extracted is NaN, meaning the value isn't already extracted. */
								if (!(extracted || extracted === 0)) {
									var blurComponent = propertyValue.toString().match(/blur\(([0-9]+[A-z]+)\)/i);

									/* If the filter string had a blur component, return just the blur value and unit type. */
									if (blurComponent) {
										extracted = blurComponent[1];
										/* If the component doesn't exist, default blur to 0. */
									} else {
										extracted = 0;
									}
								}

								return extracted;
								/* Blur needs to be re-wrapped during injection. */
							case "inject":
								/* For the blur effect to be fully de-applied, it needs to be set to "none" instead of 0. */
								if (!parseFloat(propertyValue)) {
									return "none";
								} else {
									return "blur(" + propertyValue + ")";
								}
						}
					},
					/* <=IE8 do not support the standard opacity property. They use filter:alpha(opacity=INT) instead. */
					opacity: function(type, element, propertyValue) {
						if (IE <= 8) {
							switch (type) {
								case "name":
									return "filter";
								case "extract":
									/* <=IE8 return a "filter" value of "alpha(opacity=\d{1,3})".
									 Extract the value and convert it to a decimal value to match the standard CSS opacity property's formatting. */
									var extracted = propertyValue.toString().match(/alpha\(opacity=(.*)\)/i);

									if (extracted) {
										/* Convert to decimal value. */
										propertyValue = extracted[1] / 100;
									} else {
										/* When extracting opacity, default to 1 since a null value means opacity hasn't been set. */
										propertyValue = 1;
									}

									return propertyValue;
								case "inject":
									/* Opacified elements are required to have their zoom property set to a non-zero value. */
									element.style.zoom = 1;

									/* Setting the filter property on elements with certain font property combinations can result in a
									 highly unappealing ultra-bolding effect. There's no way to remedy this throughout a tween, but dropping the
									 value altogether (when opacity hits 1) at leasts ensures that the glitch is gone post-tweening. */
									if (parseFloat(propertyValue) >= 1) {
										return "";
									} else {
										/* As per the filter property's spec, convert the decimal value to a whole number and wrap the value. */
										return "alpha(opacity=" + parseInt(parseFloat(propertyValue) * 100, 10) + ")";
									}
							}
							/* With all other browsers, normalization is not required; return the same values that were passed in. */
						} else {
							switch (type) {
								case "name":
									return "opacity";
								case "extract":
									return propertyValue;
								case "inject":
									return propertyValue;
							}
						}
					}
				},
				/*****************************
				 Batched Registrations
				 *****************************/

				/* Note: Batched normalizations extend the CSS.Normalizations.registered object. */
				register: function() {

					/*****************
					 Transforms
					 *****************/

					/* Transforms are the subproperties contained by the CSS "transform" property. Transforms must undergo normalization
					 so that they can be referenced in a properties map by their individual names. */
					/* Note: When transforms are "set", they are actually assigned to a per-element transformCache. When all transform
					 setting is complete complete, CSS.flushTransformCache() must be manually called to flush the values to the DOM.
					 Transform setting is batched in this way to improve performance: the transform style only needs to be updated
					 once when multiple transform subproperties are being animated simultaneously. */
					/* Note: IE9 and Android Gingerbread have support for 2D -- but not 3D -- transforms. Since animating unsupported
					 transform properties results in the browser ignoring the *entire* transform string, we prevent these 3D values
					 from being normalized for these browsers so that tweening skips these properties altogether
					 (since it will ignore them as being unsupported by the browser.) */
					if ((!IE || IE > 9) && !Velocity.State.isGingerbread) {
						/* Note: Since the standalone CSS "perspective" property and the CSS transform "perspective" subproperty
						 share the same name, the latter is given a unique token within Velocity: "transformPerspective". */
						CSS.Lists.transformsBase = CSS.Lists.transformsBase.concat(CSS.Lists.transforms3D);
					}

					for (var i = 0; i < CSS.Lists.transformsBase.length; i++) {
						/* Wrap the dynamically generated normalization function in a new scope so that transformName's value is
						 paired with its respective function. (Otherwise, all functions would take the final for loop's transformName.) */
						(function() {
							var transformName = CSS.Lists.transformsBase[i];

							CSS.Normalizations.registered[transformName] = function(type, element, propertyValue) {
								switch (type) {
									/* The normalized property name is the parent "transform" property -- the property that is actually set in CSS. */
									case "name":
										return "transform";
										/* Transform values are cached onto a per-element transformCache object. */
									case "extract":
										/* If this transform has yet to be assigned a value, return its null value. */
										if (Data(element) === undefined || Data(element).transformCache[transformName] === undefined) {
											/* Scale CSS.Lists.transformsBase default to 1 whereas all other transform properties default to 0. */
											return /^scale/i.test(transformName) ? 1 : 0;
											/* When transform values are set, they are wrapped in parentheses as per the CSS spec.
											 Thus, when extracting their values (for tween calculations), we strip off the parentheses. */
										}
										return Data(element).transformCache[transformName].replace(/[()]/g, "");
									case "inject":
										var invalid = false;

										/* If an individual transform property contains an unsupported unit type, the browser ignores the *entire* transform property.
										 Thus, protect users from themselves by skipping setting for transform values supplied with invalid unit types. */
										/* Switch on the base transform type; ignore the axis by removing the last letter from the transform's name. */
										switch (transformName.substr(0, transformName.length - 1)) {
											/* Whitelist unit types for each transform. */
											case "translate":
												invalid = !/(%|px|em|rem|vw|vh|\d)$/i.test(propertyValue);
												break;
												/* Since an axis-free "scale" property is supported as well, a little hack is used here to detect it by chopping off its last letter. */
											case "scal":
											case "scale":
												/* Chrome on Android has a bug in which scaled elements blur if their initial scale
												 value is below 1 (which can happen with forcefeeding). Thus, we detect a yet-unset scale property
												 and ensure that its first value is always 1. More info: http://stackoverflow.com/questions/10417890/css3-animations-with-transform-causes-blurred-elements-on-webkit/10417962#10417962 */
												if (Velocity.State.isAndroid && Data(element).transformCache[transformName] === undefined && propertyValue < 1) {
													propertyValue = 1;
												}

												invalid = !/(\d)$/i.test(propertyValue);
												break;
											case "skew":
												invalid = !/(deg|\d)$/i.test(propertyValue);
												break;
											case "rotate":
												invalid = !/(deg|\d)$/i.test(propertyValue);
												break;
										}

										if (!invalid) {
											/* As per the CSS spec, wrap the value in parentheses. */
											Data(element).transformCache[transformName] = "(" + propertyValue + ")";
										}

										/* Although the value is set on the transformCache object, return the newly-updated value for the calling code to process as normal. */
										return Data(element).transformCache[transformName];
								}
							};
						})();
					}

					/*************
					 Colors
					 *************/

					/* Since Velocity only animates a single numeric value per property, color animation is achieved by hooking the individual RGBA components of CSS color properties.
					 Accordingly, color values must be normalized (e.g. "#ff0000", "red", and "rgb(255, 0, 0)" ==> "255 0 0 1") so that their components can be injected/extracted by CSS.Hooks logic. */
					for (var j = 0; j < CSS.Lists.colors.length; j++) {
						/* Wrap the dynamically generated normalization function in a new scope so that colorName's value is paired with its respective function.
						 (Otherwise, all functions would take the final for loop's colorName.) */
						(function() {
							var colorName = CSS.Lists.colors[j];

							/* Note: In IE<=8, which support rgb but not rgba, color properties are reverted to rgb by stripping off the alpha component. */
							CSS.Normalizations.registered[colorName] = function(type, element, propertyValue) {
								switch (type) {
									case "name":
										return colorName;
										/* Convert all color values into the rgb format. (Old IE can return hex values and color names instead of rgb/rgba.) */
									case "extract":
										var extracted;

										/* If the color is already in its hookable form (e.g. "255 255 255 1") due to having been previously extracted, skip extraction. */
										if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
											extracted = propertyValue;
										} else {
											var converted,
													colorNames = {
														black: "rgb(0, 0, 0)",
														blue: "rgb(0, 0, 255)",
														gray: "rgb(128, 128, 128)",
														green: "rgb(0, 128, 0)",
														red: "rgb(255, 0, 0)",
														white: "rgb(255, 255, 255)"
													};

											/* Convert color names to rgb. */
											if (/^[A-z]+$/i.test(propertyValue)) {
												if (colorNames[propertyValue] !== undefined) {
													converted = colorNames[propertyValue];
												} else {
													/* If an unmatched color name is provided, default to black. */
													converted = colorNames.black;
												}
												/* Convert hex values to rgb. */
											} else if (CSS.RegEx.isHex.test(propertyValue)) {
												converted = "rgb(" + CSS.Values.hexToRgb(propertyValue).join(" ") + ")";
												/* If the provided color doesn't match any of the accepted color formats, default to black. */
											} else if (!(/^rgba?\(/i.test(propertyValue))) {
												converted = colorNames.black;
											}

											/* Remove the surrounding "rgb/rgba()" string then replace commas with spaces and strip
											 repeated spaces (in case the value included spaces to begin with). */
											extracted = (converted || propertyValue).toString().match(CSS.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ");
										}

										/* So long as this isn't <=IE8, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
										if ((!IE || IE > 8) && extracted.split(" ").length === 3) {
											extracted += " 1";
										}

										return extracted;
									case "inject":
										/* If we have a pattern then it might already have the right values */
										if (/^rgb/.test(propertyValue)) {
											return propertyValue;
										}

										/* If this is IE<=8 and an alpha component exists, strip it off. */
										if (IE <= 8) {
											if (propertyValue.split(" ").length === 4) {
												propertyValue = propertyValue.split(/\s+/).slice(0, 3).join(" ");
											}
											/* Otherwise, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
										} else if (propertyValue.split(" ").length === 3) {
											propertyValue += " 1";
										}

										/* Re-insert the browser-appropriate wrapper("rgb/rgba()"), insert commas, and strip off decimal units
										 on all values but the fourth (R, G, and B only accept whole numbers). */
										return (IE <= 8 ? "rgb" : "rgba") + "(" + propertyValue.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")";
								}
							};
						})();
					}

					/**************
					 Dimensions
					 **************/
					function augmentDimension(name, element, wantInner) {
						var isBorderBox = CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() === "border-box";

						if (isBorderBox === (wantInner || false)) {
							/* in box-sizing mode, the CSS width / height accessors already give the outerWidth / outerHeight. */
							var i,
									value,
									augment = 0,
									sides = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"],
									fields = ["padding" + sides[0], "padding" + sides[1], "border" + sides[0] + "Width", "border" + sides[1] + "Width"];

							for (i = 0; i < fields.length; i++) {
								value = parseFloat(CSS.getPropertyValue(element, fields[i]));
								if (!isNaN(value)) {
									augment += value;
								}
							}
							return wantInner ? -augment : augment;
						}
						return 0;
					}
					function getDimension(name, wantInner) {
						return function(type, element, propertyValue) {
							switch (type) {
								case "name":
									return name;
								case "extract":
									return parseFloat(propertyValue) + augmentDimension(name, element, wantInner);
								case "inject":
									return (parseFloat(propertyValue) - augmentDimension(name, element, wantInner)) + "px";
							}
						};
					}
					CSS.Normalizations.registered.innerWidth = getDimension("width", true);
					CSS.Normalizations.registered.innerHeight = getDimension("height", true);
					CSS.Normalizations.registered.outerWidth = getDimension("width");
					CSS.Normalizations.registered.outerHeight = getDimension("height");
				}
			},
			/************************
			 CSS Property Names
			 ************************/

			Names: {
				/* Camelcase a property name into its JavaScript notation (e.g. "background-color" ==> "backgroundColor").
				 Camelcasing is used to normalize property names between and across calls. */
				camelCase: function(property) {
					return property.replace(/-(\w)/g, function(match, subMatch) {
						return subMatch.toUpperCase();
					});
				},
				/* For SVG elements, some properties (namely, dimensional ones) are GET/SET via the element's HTML attributes (instead of via CSS styles). */
				SVGAttribute: function(property) {
					var SVGAttributes = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";

					/* Certain browsers require an SVG transform to be applied as an attribute. (Otherwise, application via CSS is preferable due to 3D support.) */
					if (IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) {
						SVGAttributes += "|transform";
					}

					return new RegExp("^(" + SVGAttributes + ")$", "i").test(property);
				},
				/* Determine whether a property should be set with a vendor prefix. */
				/* If a prefixed version of the property exists, return it. Otherwise, return the original property name.
				 If the property is not at all supported by the browser, return a false flag. */
				prefixCheck: function(property) {
					/* If this property has already been checked, return the cached value. */
					if (Velocity.State.prefixMatches[property]) {
						return [Velocity.State.prefixMatches[property], true];
					} else {
						var vendors = ["", "Webkit", "Moz", "ms", "O"];

						for (var i = 0, vendorsLength = vendors.length; i < vendorsLength; i++) {
							var propertyPrefixed;

							if (i === 0) {
								propertyPrefixed = property;
							} else {
								/* Capitalize the first letter of the property to conform to JavaScript vendor prefix notation (e.g. webkitFilter). */
								propertyPrefixed = vendors[i] + property.replace(/^\w/, function(match) {
									return match.toUpperCase();
								});
							}

							/* Check if the browser supports this property as prefixed. */
							if (Type.isString(Velocity.State.prefixElement.style[propertyPrefixed])) {
								/* Cache the match. */
								Velocity.State.prefixMatches[property] = propertyPrefixed;

								return [propertyPrefixed, true];
							}
						}

						/* If the browser doesn't support this property in any form, include a false flag so that the caller can decide how to proceed. */
						return [property, false];
					}
				}
			},
			/************************
			 CSS Property Values
			 ************************/

			Values: {
				/* Hex to RGB conversion. Copyright Tim Down: http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb */
				hexToRgb: function(hex) {
					var shortformRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
							longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
							rgbParts;

					hex = hex.replace(shortformRegex, function(m, r, g, b) {
						return r + r + g + g + b + b;
					});

					rgbParts = longformRegex.exec(hex);

					return rgbParts ? [parseInt(rgbParts[1], 16), parseInt(rgbParts[2], 16), parseInt(rgbParts[3], 16)] : [0, 0, 0];
				},
				isCSSNullValue: function(value) {
					/* The browser defaults CSS values that have not been set to either 0 or one of several possible null-value strings.
					 Thus, we check for both falsiness and these special strings. */
					/* Null-value checking is performed to default the special strings to 0 (for the sake of tweening) or their hook
					 templates as defined as CSS.Hooks (for the sake of hook injection/extraction). */
					/* Note: Chrome returns "rgba(0, 0, 0, 0)" for an undefined color whereas IE returns "transparent". */
					return (!value || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(value));
				},
				/* Retrieve a property's default unit type. Used for assigning a unit type when one is not supplied by the user. */
				getUnitType: function(property) {
					if (/^(rotate|skew)/i.test(property)) {
						return "deg";
					} else if (/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(property)) {
						/* The above properties are unitless. */
						return "";
					} else {
						/* Default to px for all other properties. */
						return "px";
					}
				},
				/* HTML elements default to an associated display type when they're not set to display:none. */
				/* Note: This function is used for correctly setting the non-"none" display value in certain Velocity redirects, such as fadeIn/Out. */
				getDisplayType: function(element) {
					var tagName = element && element.tagName.toString().toLowerCase();

					if (/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(tagName)) {
						return "inline";
					} else if (/^(li)$/i.test(tagName)) {
						return "list-item";
					} else if (/^(tr)$/i.test(tagName)) {
						return "table-row";
					} else if (/^(table)$/i.test(tagName)) {
						return "table";
					} else if (/^(tbody)$/i.test(tagName)) {
						return "table-row-group";
						/* Default to "block" when no match is found. */
					} else {
						return "block";
					}
				},
				/* The class add/remove functions are used to temporarily apply a "velocity-animating" class to elements while they're animating. */
				addClass: function(element, className) {
					if (element) {
						if (element.classList) {
							element.classList.add(className);
						} else if (Type.isString(element.className)) {
							// Element.className is around 15% faster then set/getAttribute
							element.className += (element.className.length ? " " : "") + className;
						} else {
							// Work around for IE strict mode animating SVG - and anything else that doesn't behave correctly - the same way jQuery does it
							var currentClass = element.getAttribute(IE <= 7 ? "className" : "class") || "";

							element.setAttribute("class", currentClass + (currentClass ? " " : "") + className);
						}
					}
				},
				removeClass: function(element, className) {
					if (element) {
						if (element.classList) {
							element.classList.remove(className);
						} else if (Type.isString(element.className)) {
							// Element.className is around 15% faster then set/getAttribute
							// TODO: Need some jsperf tests on performance - can we get rid of the regex and maybe use split / array manipulation?
							element.className = element.className.toString().replace(new RegExp("(^|\\s)" + className.split(" ").join("|") + "(\\s|$)", "gi"), " ");
						} else {
							// Work around for IE strict mode animating SVG - and anything else that doesn't behave correctly - the same way jQuery does it
							var currentClass = element.getAttribute(IE <= 7 ? "className" : "class") || "";

							element.setAttribute("class", currentClass.replace(new RegExp("(^|\s)" + className.split(" ").join("|") + "(\s|$)", "gi"), " "));
						}
					}
				}
			},
			/****************************
			 Style Getting & Setting
			 ****************************/

			/* The singular getPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
			getPropertyValue: function(element, property, rootPropertyValue, forceStyleLookup) {
				/* Get an element's computed property value. */
				/* Note: Retrieving the value of a CSS property cannot simply be performed by checking an element's
				 style attribute (which only reflects user-defined values). Instead, the browser must be queried for a property's
				 *computed* value. You can read more about getComputedStyle here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
				function computePropertyValue(element, property) {
					/* When box-sizing isn't set to border-box, height and width style values are incorrectly computed when an
					 element's scrollbars are visible (which expands the element's dimensions). Thus, we defer to the more accurate
					 offsetHeight/Width property, which includes the total dimensions for interior, border, padding, and scrollbar.
					 We subtract border and padding to get the sum of interior + scrollbar. */
					var computedValue = 0;

					/* IE<=8 doesn't support window.getComputedStyle, thus we defer to jQuery, which has an extensive array
					 of hacks to accurately retrieve IE8 property values. Re-implementing that logic here is not worth bloating the
					 codebase for a dying browser. The performance repercussions of using jQuery here are minimal since
					 Velocity is optimized to rarely (and sometimes never) query the DOM. Further, the $.css() codepath isn't that slow. */
					if (IE <= 8) {
						computedValue = $.css(element, property); /* GET */
						/* All other browsers support getComputedStyle. The returned live object reference is cached onto its
						 associated element so that it does not need to be refetched upon every GET. */
					} else {
						/* Browsers do not return height and width values for elements that are set to display:"none". Thus, we temporarily
						 toggle display to the element type's default value. */
						var toggleDisplay = false;

						if (/^(width|height)$/.test(property) && CSS.getPropertyValue(element, "display") === 0) {
							toggleDisplay = true;
							CSS.setPropertyValue(element, "display", CSS.Values.getDisplayType(element));
						}

						var revertDisplay = function() {
							if (toggleDisplay) {
								CSS.setPropertyValue(element, "display", "none");
							}
						};

						if (!forceStyleLookup) {
							if (property === "height" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
								var contentBoxHeight = element.offsetHeight - (parseFloat(CSS.getPropertyValue(element, "borderTopWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderBottomWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingTop")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingBottom")) || 0);
								revertDisplay();

								return contentBoxHeight;
							} else if (property === "width" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
								var contentBoxWidth = element.offsetWidth - (parseFloat(CSS.getPropertyValue(element, "borderLeftWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderRightWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingLeft")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingRight")) || 0);
								revertDisplay();

								return contentBoxWidth;
							}
						}

						var computedStyle;

						/* For elements that Velocity hasn't been called on directly (e.g. when Velocity queries the DOM on behalf
						 of a parent of an element its animating), perform a direct getComputedStyle lookup since the object isn't cached. */
						if (Data(element) === undefined) {
							computedStyle = window.getComputedStyle(element, null); /* GET */
							/* If the computedStyle object has yet to be cached, do so now. */
						} else if (!Data(element).computedStyle) {
							computedStyle = Data(element).computedStyle = window.getComputedStyle(element, null); /* GET */
							/* If computedStyle is cached, use it. */
						} else {
							computedStyle = Data(element).computedStyle;
						}

						/* IE and Firefox do not return a value for the generic borderColor -- they only return individual values for each border side's color.
						 Also, in all browsers, when border colors aren't all the same, a compound value is returned that Velocity isn't setup to parse.
						 So, as a polyfill for querying individual border side colors, we just return the top border's color and animate all borders from that value. */
						if (property === "borderColor") {
							property = "borderTopColor";
						}

						/* IE9 has a bug in which the "filter" property must be accessed from computedStyle using the getPropertyValue method
						 instead of a direct property lookup. The getPropertyValue method is slower than a direct lookup, which is why we avoid it by default. */
						if (IE === 9 && property === "filter") {
							computedValue = computedStyle.getPropertyValue(property); /* GET */
						} else {
							computedValue = computedStyle[property];
						}

						/* Fall back to the property's style value (if defined) when computedValue returns nothing,
						 which can happen when the element hasn't been painted. */
						if (computedValue === "" || computedValue === null) {
							computedValue = element.style[property];
						}

						revertDisplay();
					}

					/* For top, right, bottom, and left (TRBL) values that are set to "auto" on elements of "fixed" or "absolute" position,
					 defer to jQuery for converting "auto" to a numeric value. (For elements with a "static" or "relative" position, "auto" has the same
					 effect as being set to 0, so no conversion is necessary.) */
					/* An example of why numeric conversion is necessary: When an element with "position:absolute" has an untouched "left"
					 property, which reverts to "auto", left's value is 0 relative to its parent element, but is often non-zero relative
					 to its *containing* (not parent) element, which is the nearest "position:relative" ancestor or the viewport (and always the viewport in the case of "position:fixed"). */
					if (computedValue === "auto" && /^(top|right|bottom|left)$/i.test(property)) {
						var position = computePropertyValue(element, "position"); /* GET */

						/* For absolute positioning, jQuery's $.position() only returns values for top and left;
						 right and bottom will have their "auto" value reverted to 0. */
						/* Note: A jQuery object must be created here since jQuery doesn't have a low-level alias for $.position().
						 Not a big deal since we're currently in a GET batch anyway. */
						if (position === "fixed" || (position === "absolute" && /top|left/i.test(property))) {
							/* Note: jQuery strips the pixel unit from its returned values; we re-add it here to conform with computePropertyValue's behavior. */
							computedValue = $(element).position()[property] + "px"; /* GET */
						}
					}

					return computedValue;
				}

				var propertyValue;

				/* If this is a hooked property (e.g. "clipLeft" instead of the root property of "clip"),
				 extract the hook's value from a normalized rootPropertyValue using CSS.Hooks.extractValue(). */
				if (CSS.Hooks.registered[property]) {
					var hook = property,
							hookRoot = CSS.Hooks.getRoot(hook);

					/* If a cached rootPropertyValue wasn't passed in (which Velocity always attempts to do in order to avoid requerying the DOM),
					 query the DOM for the root property's value. */
					if (rootPropertyValue === undefined) {
						/* Since the browser is now being directly queried, use the official post-prefixing property name for this lookup. */
						rootPropertyValue = CSS.getPropertyValue(element, CSS.Names.prefixCheck(hookRoot)[0]); /* GET */
					}

					/* If this root has a normalization registered, peform the associated normalization extraction. */
					if (CSS.Normalizations.registered[hookRoot]) {
						rootPropertyValue = CSS.Normalizations.registered[hookRoot]("extract", element, rootPropertyValue);
					}

					/* Extract the hook's value. */
					propertyValue = CSS.Hooks.extractValue(hook, rootPropertyValue);

					/* If this is a normalized property (e.g. "opacity" becomes "filter" in <=IE8) or "translateX" becomes "transform"),
					 normalize the property's name and value, and handle the special case of transforms. */
					/* Note: Normalizing a property is mutually exclusive from hooking a property since hook-extracted values are strictly
					 numerical and therefore do not require normalization extraction. */
				} else if (CSS.Normalizations.registered[property]) {
					var normalizedPropertyName,
							normalizedPropertyValue;

					normalizedPropertyName = CSS.Normalizations.registered[property]("name", element);

					/* Transform values are calculated via normalization extraction (see below), which checks against the element's transformCache.
					 At no point do transform GETs ever actually query the DOM; initial stylesheet values are never processed.
					 This is because parsing 3D transform matrices is not always accurate and would bloat our codebase;
					 thus, normalization extraction defaults initial transform values to their zero-values (e.g. 1 for scaleX and 0 for translateX). */
					if (normalizedPropertyName !== "transform") {
						normalizedPropertyValue = computePropertyValue(element, CSS.Names.prefixCheck(normalizedPropertyName)[0]); /* GET */

						/* If the value is a CSS null-value and this property has a hook template, use that zero-value template so that hooks can be extracted from it. */
						if (CSS.Values.isCSSNullValue(normalizedPropertyValue) && CSS.Hooks.templates[property]) {
							normalizedPropertyValue = CSS.Hooks.templates[property][1];
						}
					}

					propertyValue = CSS.Normalizations.registered[property]("extract", element, normalizedPropertyValue);
				}

				/* If a (numeric) value wasn't produced via hook extraction or normalization, query the DOM. */
				if (!/^[\d-]/.test(propertyValue)) {
					/* For SVG elements, dimensional properties (which SVGAttribute() detects) are tweened via
					 their HTML attribute values instead of their CSS style values. */
					var data = Data(element);

					if (data && data.isSVG && CSS.Names.SVGAttribute(property)) {
						/* Since the height/width attribute values must be set manually, they don't reflect computed values.
						 Thus, we use use getBBox() to ensure we always get values for elements with undefined height/width attributes. */
						if (/^(height|width)$/i.test(property)) {
							/* Firefox throws an error if .getBBox() is called on an SVG that isn't attached to the DOM. */
							try {
								propertyValue = element.getBBox()[property];
							} catch (error) {
								propertyValue = 0;
							}
							/* Otherwise, access the attribute value directly. */
						} else {
							propertyValue = element.getAttribute(property);
						}
					} else {
						propertyValue = computePropertyValue(element, CSS.Names.prefixCheck(property)[0]); /* GET */
					}
				}

				/* Since property lookups are for animation purposes (which entails computing the numeric delta between start and end values),
				 convert CSS null-values to an integer of value 0. */
				if (CSS.Values.isCSSNullValue(propertyValue)) {
					propertyValue = 0;
				}

				if (Velocity.debug >= 2) {
					console.log("Get " + property + ": " + propertyValue);
				}

				return propertyValue;
			},
			/* The singular setPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
			setPropertyValue: function(element, property, propertyValue, rootPropertyValue, scrollData) {
				var propertyName = property;

				/* In order to be subjected to call options and element queueing, scroll animation is routed through Velocity as if it were a standard CSS property. */
				if (property === "scroll") {
					/* If a container option is present, scroll the container instead of the browser window. */
					if (scrollData.container) {
						scrollData.container["scroll" + scrollData.direction] = propertyValue;
						/* Otherwise, Velocity defaults to scrolling the browser window. */
					} else {
						if (scrollData.direction === "Left") {
							window.scrollTo(propertyValue, scrollData.alternateValue);
						} else {
							window.scrollTo(scrollData.alternateValue, propertyValue);
						}
					}
				} else {
					/* Transforms (translateX, rotateZ, etc.) are applied to a per-element transformCache object, which is manually flushed via flushTransformCache().
					 Thus, for now, we merely cache transforms being SET. */
					if (CSS.Normalizations.registered[property] && CSS.Normalizations.registered[property]("name", element) === "transform") {
						/* Perform a normalization injection. */
						/* Note: The normalization logic handles the transformCache updating. */
						CSS.Normalizations.registered[property]("inject", element, propertyValue);

						propertyName = "transform";
						propertyValue = Data(element).transformCache[property];
					} else {
						/* Inject hooks. */
						if (CSS.Hooks.registered[property]) {
							var hookName = property,
									hookRoot = CSS.Hooks.getRoot(property);

							/* If a cached rootPropertyValue was not provided, query the DOM for the hookRoot's current value. */
							rootPropertyValue = rootPropertyValue || CSS.getPropertyValue(element, hookRoot); /* GET */

							propertyValue = CSS.Hooks.injectValue(hookName, propertyValue, rootPropertyValue);
							property = hookRoot;
						}

						/* Normalize names and values. */
						if (CSS.Normalizations.registered[property]) {
							propertyValue = CSS.Normalizations.registered[property]("inject", element, propertyValue);
							property = CSS.Normalizations.registered[property]("name", element);
						}

						/* Assign the appropriate vendor prefix before performing an official style update. */
						propertyName = CSS.Names.prefixCheck(property)[0];

						/* A try/catch is used for IE<=8, which throws an error when "invalid" CSS values are set, e.g. a negative width.
						 Try/catch is avoided for other browsers since it incurs a performance overhead. */
						if (IE <= 8) {
							try {
								element.style[propertyName] = propertyValue;
							} catch (error) {
								if (Velocity.debug) {
									console.log("Browser does not support [" + propertyValue + "] for [" + propertyName + "]");
								}
							}
							/* SVG elements have their dimensional properties (width, height, x, y, cx, etc.) applied directly as attributes instead of as styles. */
							/* Note: IE8 does not support SVG elements, so it's okay that we skip it for SVG animation. */
						} else {
							var data = Data(element);

							if (data && data.isSVG && CSS.Names.SVGAttribute(property)) {
								/* Note: For SVG attributes, vendor-prefixed property names are never used. */
								/* Note: Not all CSS properties can be animated via attributes, but the browser won't throw an error for unsupported properties. */
								element.setAttribute(property, propertyValue);
							} else {
								element.style[propertyName] = propertyValue;
							}
						}

						if (Velocity.debug >= 2) {
							console.log("Set " + property + " (" + propertyName + "): " + propertyValue);
						}
					}
				}

				/* Return the normalized property name and value in case the caller wants to know how these values were modified before being applied to the DOM. */
				return [propertyName, propertyValue];
			},
			/* To increase performance by batching transform updates into a single SET, transforms are not directly applied to an element until flushTransformCache() is called. */
			/* Note: Velocity applies transform properties in the same order that they are chronogically introduced to the element's CSS styles. */
			flushTransformCache: function(element) {
				var transformString = "",
						data = Data(element);

				/* Certain browsers require that SVG transforms be applied as an attribute. However, the SVG transform attribute takes a modified version of CSS's transform string
				 (units are dropped and, except for skewX/Y, subproperties are merged into their master property -- e.g. scaleX and scaleY are merged into scale(X Y). */
				if ((IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) && data && data.isSVG) {
					/* Since transform values are stored in their parentheses-wrapped form, we use a helper function to strip out their numeric values.
					 Further, SVG transform properties only take unitless (representing pixels) values, so it's okay that parseFloat() strips the unit suffixed to the float value. */
					var getTransformFloat = function(transformProperty) {
						return parseFloat(CSS.getPropertyValue(element, transformProperty));
					};

					/* Create an object to organize all the transforms that we'll apply to the SVG element. To keep the logic simple,
					 we process *all* transform properties -- even those that may not be explicitly applied (since they default to their zero-values anyway). */
					var SVGTransforms = {
						translate: [getTransformFloat("translateX"), getTransformFloat("translateY")],
						skewX: [getTransformFloat("skewX")], skewY: [getTransformFloat("skewY")],
						/* If the scale property is set (non-1), use that value for the scaleX and scaleY values
						 (this behavior mimics the result of animating all these properties at once on HTML elements). */
						scale: getTransformFloat("scale") !== 1 ? [getTransformFloat("scale"), getTransformFloat("scale")] : [getTransformFloat("scaleX"), getTransformFloat("scaleY")],
						/* Note: SVG's rotate transform takes three values: rotation degrees followed by the X and Y values
						 defining the rotation's origin point. We ignore the origin values (default them to 0). */
						rotate: [getTransformFloat("rotateZ"), 0, 0]
					};

					/* Iterate through the transform properties in the user-defined property map order.
					 (This mimics the behavior of non-SVG transform animation.) */
					$.each(Data(element).transformCache, function(transformName) {
						/* Except for with skewX/Y, revert the axis-specific transform subproperties to their axis-free master
						 properties so that they match up with SVG's accepted transform properties. */
						if (/^translate/i.test(transformName)) {
							transformName = "translate";
						} else if (/^scale/i.test(transformName)) {
							transformName = "scale";
						} else if (/^rotate/i.test(transformName)) {
							transformName = "rotate";
						}

						/* Check that we haven't yet deleted the property from the SVGTransforms container. */
						if (SVGTransforms[transformName]) {
							/* Append the transform property in the SVG-supported transform format. As per the spec, surround the space-delimited values in parentheses. */
							transformString += transformName + "(" + SVGTransforms[transformName].join(" ") + ")" + " ";

							/* After processing an SVG transform property, delete it from the SVGTransforms container so we don't
							 re-insert the same master property if we encounter another one of its axis-specific properties. */
							delete SVGTransforms[transformName];
						}
					});
				} else {
					var transformValue,
							perspective;

					/* Transform properties are stored as members of the transformCache object. Concatenate all the members into a string. */
					$.each(Data(element).transformCache, function(transformName) {
						transformValue = Data(element).transformCache[transformName];

						/* Transform's perspective subproperty must be set first in order to take effect. Store it temporarily. */
						if (transformName === "transformPerspective") {
							perspective = transformValue;
							return true;
						}

						/* IE9 only supports one rotation type, rotateZ, which it refers to as "rotate". */
						if (IE === 9 && transformName === "rotateZ") {
							transformName = "rotate";
						}

						transformString += transformName + transformValue + " ";
					});

					/* If present, set the perspective subproperty first. */
					if (perspective) {
						transformString = "perspective" + perspective + " " + transformString;
					}
				}

				CSS.setPropertyValue(element, "transform", transformString);
			}
		};

		/* Register hooks and normalizations. */
		CSS.Hooks.register();
		CSS.Normalizations.register();

		/* Allow hook setting in the same fashion as jQuery's $.css(). */
		Velocity.hook = function(elements, arg2, arg3) {
			var value;

			elements = sanitizeElements(elements);

			$.each(elements, function(i, element) {
				/* Initialize Velocity's per-element data cache if this element hasn't previously been animated. */
				if (Data(element) === undefined) {
					Velocity.init(element);
				}

				/* Get property value. If an element set was passed in, only return the value for the first element. */
				if (arg3 === undefined) {
					if (value === undefined) {
						value = CSS.getPropertyValue(element, arg2);
					}
					/* Set property value. */
				} else {
					/* sPV returns an array of the normalized propertyName/propertyValue pair used to update the DOM. */
					var adjustedSet = CSS.setPropertyValue(element, arg2, arg3);

					/* Transform properties don't automatically set. They have to be flushed to the DOM. */
					if (adjustedSet[0] === "transform") {
						Velocity.CSS.flushTransformCache(element);
					}

					value = adjustedSet;
				}
			});

			return value;
		};

		/*****************
		 Animation
		 *****************/

		var animate = function() {
			var opts;

			/******************
			 Call Chain
			 ******************/

			/* Logic for determining what to return to the call stack when exiting out of Velocity. */
			function getChain() {
				/* If we are using the utility function, attempt to return this call's promise. If no promise library was detected,
				 default to null instead of returning the targeted elements so that utility function's return value is standardized. */
				if (isUtility) {
					return promiseData.promise || null;
					/* Otherwise, if we're using $.fn, return the jQuery-/Zepto-wrapped element set. */
				} else {
					return elementsWrapped;
				}
			}

			/*************************
			 Arguments Assignment
			 *************************/

			/* To allow for expressive CoffeeScript code, Velocity supports an alternative syntax in which "elements" (or "e"), "properties" (or "p"), and "options" (or "o")
			 objects are defined on a container object that's passed in as Velocity's sole argument. */
			/* Note: Some browsers automatically populate arguments with a "properties" object. We detect it by checking for its default "names" property. */
			var syntacticSugar = (arguments[0] && (arguments[0].p || (($.isPlainObject(arguments[0].properties) && !arguments[0].properties.names) || Type.isString(arguments[0].properties)))),
					/* Whether Velocity was called via the utility function (as opposed to on a jQuery/Zepto object). */
					isUtility,
					/* When Velocity is called via the utility function ($.Velocity()/Velocity()), elements are explicitly
					 passed in as the first parameter. Thus, argument positioning varies. We normalize them here. */
					elementsWrapped,
					argumentIndex;

			var elements,
					propertiesMap,
					options;

			/* Detect jQuery/Zepto elements being animated via the $.fn method. */
			if (Type.isWrapped(this)) {
				isUtility = false;

				argumentIndex = 0;
				elements = this;
				elementsWrapped = this;
				/* Otherwise, raw elements are being animated via the utility function. */
			} else {
				isUtility = true;

				argumentIndex = 1;
				elements = syntacticSugar ? (arguments[0].elements || arguments[0].e) : arguments[0];
			}

			/***************
			 Promises
			 ***************/

			var promiseData = {
				promise: null,
				resolver: null,
				rejecter: null
			};

			/* If this call was made via the utility function (which is the default method of invocation when jQuery/Zepto are not being used), and if
			 promise support was detected, create a promise object for this call and store references to its resolver and rejecter methods. The resolve
			 method is used when a call completes naturally or is prematurely stopped by the user. In both cases, completeCall() handles the associated
			 call cleanup and promise resolving logic. The reject method is used when an invalid set of arguments is passed into a Velocity call. */
			/* Note: Velocity employs a call-based queueing architecture, which means that stopping an animating element actually stops the full call that
			 triggered it -- not that one element exclusively. Similarly, there is one promise per call, and all elements targeted by a Velocity call are
			 grouped together for the purposes of resolving and rejecting a promise. */
			if (isUtility && Velocity.Promise) {
				promiseData.promise = new Velocity.Promise(function(resolve, reject) {
					promiseData.resolver = resolve;
					promiseData.rejecter = reject;
				});
			}

			if (syntacticSugar) {
				propertiesMap = arguments[0].properties || arguments[0].p;
				options = arguments[0].options || arguments[0].o;
			} else {
				propertiesMap = arguments[argumentIndex];
				options = arguments[argumentIndex + 1];
			}

			elements = sanitizeElements(elements);

			if (!elements) {
				if (promiseData.promise) {
					if (!propertiesMap || !options || options.promiseRejectEmpty !== false) {
						promiseData.rejecter();
					} else {
						promiseData.resolver();
					}
				}
				return;
			}

			/* The length of the element set (in the form of a nodeList or an array of elements) is defaulted to 1 in case a
			 single raw DOM element is passed in (which doesn't contain a length property). */
			var elementsLength = elements.length,
					elementsIndex = 0;

			/***************************
			 Argument Overloading
			 ***************************/

			/* Support is included for jQuery's argument overloading: $.animate(propertyMap [, duration] [, easing] [, complete]).
			 Overloading is detected by checking for the absence of an object being passed into options. */
			/* Note: The stop/finish/pause/resume actions do not accept animation options, and are therefore excluded from this check. */
			if (!/^(stop|finish|finishAll|pause|resume)$/i.test(propertiesMap) && !$.isPlainObject(options)) {
				/* The utility function shifts all arguments one position to the right, so we adjust for that offset. */
				var startingArgumentPosition = argumentIndex + 1;

				options = {};

				/* Iterate through all options arguments */
				for (var i = startingArgumentPosition; i < arguments.length; i++) {
					/* Treat a number as a duration. Parse it out. */
					/* Note: The following RegEx will return true if passed an array with a number as its first item.
					 Thus, arrays are skipped from this check. */
					if (!Type.isArray(arguments[i]) && (/^(fast|normal|slow)$/i.test(arguments[i]) || /^\d/.test(arguments[i]))) {
						options.duration = arguments[i];
						/* Treat strings and arrays as easings. */
					} else if (Type.isString(arguments[i]) || Type.isArray(arguments[i])) {
						options.easing = arguments[i];
						/* Treat a function as a complete callback. */
					} else if (Type.isFunction(arguments[i])) {
						options.complete = arguments[i];
					}
				}
			}

			/*********************
			 Action Detection
			 *********************/

			/* Velocity's behavior is categorized into "actions": Elements can either be specially scrolled into view,
			 or they can be started, stopped, paused, resumed, or reversed . If a literal or referenced properties map is passed in as Velocity's
			 first argument, the associated action is "start". Alternatively, "scroll", "reverse", "pause", "resume" or "stop" can be passed in 
			 instead of a properties map. */
			var action;

			switch (propertiesMap) {
				case "scroll":
					action = "scroll";
					break;

				case "reverse":
					action = "reverse";
					break;

				case "pause":

					/*******************
					 Action: Pause
					 *******************/

					var currentTime = (new Date()).getTime();

					/* Handle delay timers */
					$.each(elements, function(i, element) {
						pauseDelayOnElement(element, currentTime);
					});

					/* Pause and Resume are call-wide (not on a per element basis). Thus, calling pause or resume on a 
					 single element will cause any calls that containt tweens for that element to be paused/resumed
					 as well. */

					/* Iterate through all calls and pause any that contain any of our elements */
					$.each(Velocity.State.calls, function(i, activeCall) {

						var found = false;
						/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
						if (activeCall) {
							/* Iterate through the active call's targeted elements. */
							$.each(activeCall[1], function(k, activeElement) {
								var queueName = (options === undefined) ? "" : options;

								if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
									return true;
								}

								/* Iterate through the calls targeted by the stop command. */
								$.each(elements, function(l, element) {
									/* Check that this call was applied to the target element. */
									if (element === activeElement) {

										/* Set call to paused */
										activeCall[5] = {
											resume: false
										};

										/* Once we match an element, we can bounce out to the next call entirely */
										found = true;
										return false;
									}
								});

								/* Proceed to check next call if we have already matched */
								if (found) {
									return false;
								}
							});
						}

					});

					/* Since pause creates no new tweens, exit out of Velocity. */
					return getChain();

				case "resume":

					/*******************
					 Action: Resume
					 *******************/

					/* Handle delay timers */
					$.each(elements, function(i, element) {
						resumeDelayOnElement(element, currentTime);
					});

					/* Pause and Resume are call-wide (not on a per elemnt basis). Thus, calling pause or resume on a 
					 single element will cause any calls that containt tweens for that element to be paused/resumed
					 as well. */

					/* Iterate through all calls and pause any that contain any of our elements */
					$.each(Velocity.State.calls, function(i, activeCall) {
						var found = false;
						/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
						if (activeCall) {
							/* Iterate through the active call's targeted elements. */
							$.each(activeCall[1], function(k, activeElement) {
								var queueName = (options === undefined) ? "" : options;

								if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
									return true;
								}

								/* Skip any calls that have never been paused */
								if (!activeCall[5]) {
									return true;
								}

								/* Iterate through the calls targeted by the stop command. */
								$.each(elements, function(l, element) {
									/* Check that this call was applied to the target element. */
									if (element === activeElement) {

										/* Flag a pause object to be resumed, which will occur during the next tick. In
										 addition, the pause object will at that time be deleted */
										activeCall[5].resume = true;

										/* Once we match an element, we can bounce out to the next call entirely */
										found = true;
										return false;
									}
								});

								/* Proceed to check next call if we have already matched */
								if (found) {
									return false;
								}
							});
						}

					});

					/* Since resume creates no new tweens, exit out of Velocity. */
					return getChain();

				case "finish":
				case "finishAll":
				case "stop":
					/*******************
					 Action: Stop
					 *******************/

					/* Clear the currently-active delay on each targeted element. */
					$.each(elements, function(i, element) {
						if (Data(element) && Data(element).delayTimer) {
							/* Stop the timer from triggering its cached next() function. */
							clearTimeout(Data(element).delayTimer.setTimeout);

							/* Manually call the next() function so that the subsequent queue items can progress. */
							if (Data(element).delayTimer.next) {
								Data(element).delayTimer.next();
							}

							delete Data(element).delayTimer;
						}

						/* If we want to finish everything in the queue, we have to iterate through it
						 and call each function. This will make them active calls below, which will
						 cause them to be applied via the duration setting. */
						if (propertiesMap === "finishAll" && (options === true || Type.isString(options))) {
							/* Iterate through the items in the element's queue. */
							$.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
								/* The queue array can contain an "inprogress" string, which we skip. */
								if (Type.isFunction(item)) {
									item();
								}
							});

							/* Clearing the $.queue() array is achieved by resetting it to []. */
							$.queue(element, Type.isString(options) ? options : "", []);
						}
					});

					var callsToStop = [];

					/* When the stop action is triggered, the elements' currently active call is immediately stopped. The active call might have
					 been applied to multiple elements, in which case all of the call's elements will be stopped. When an element
					 is stopped, the next item in its animation queue is immediately triggered. */
					/* An additional argument may be passed in to clear an element's remaining queued calls. Either true (which defaults to the "fx" queue)
					 or a custom queue string can be passed in. */
					/* Note: The stop command runs prior to Velocity's Queueing phase since its behavior is intended to take effect *immediately*,
					 regardless of the element's current queue state. */

					/* Iterate through every active call. */
					$.each(Velocity.State.calls, function(i, activeCall) {
						/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
						if (activeCall) {
							/* Iterate through the active call's targeted elements. */
							$.each(activeCall[1], function(k, activeElement) {
								/* If true was passed in as a secondary argument, clear absolutely all calls on this element. Otherwise, only
								 clear calls associated with the relevant queue. */
								/* Call stopping logic works as follows:
								 - options === true --> stop current default queue calls (and queue:false calls), including remaining queued ones.
								 - options === undefined --> stop current queue:"" call and all queue:false calls.
								 - options === false --> stop only queue:false calls.
								 - options === "custom" --> stop current queue:"custom" call, including remaining queued ones (there is no functionality to only clear the currently-running queue:"custom" call). */
								var queueName = (options === undefined) ? "" : options;

								if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
									return true;
								}

								/* Iterate through the calls targeted by the stop command. */
								$.each(elements, function(l, element) {
									/* Check that this call was applied to the target element. */
									if (element === activeElement) {
										/* Optionally clear the remaining queued calls. If we're doing "finishAll" this won't find anything,
										 due to the queue-clearing above. */
										if (options === true || Type.isString(options)) {
											/* Iterate through the items in the element's queue. */
											$.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
												/* The queue array can contain an "inprogress" string, which we skip. */
												if (Type.isFunction(item)) {
													/* Pass the item's callback a flag indicating that we want to abort from the queue call.
													 (Specifically, the queue will resolve the call's associated promise then abort.)  */
													item(null, true);
												}
											});

											/* Clearing the $.queue() array is achieved by resetting it to []. */
											$.queue(element, Type.isString(options) ? options : "", []);
										}

										if (propertiesMap === "stop") {
											/* Since "reverse" uses cached start values (the previous call's endValues), these values must be
											 changed to reflect the final value that the elements were actually tweened to. */
											/* Note: If only queue:false animations are currently running on an element, it won't have a tweensContainer
											 object. Also, queue:false animations can't be reversed. */
											var data = Data(element);
											if (data && data.tweensContainer && queueName !== false) {
												$.each(data.tweensContainer, function(m, activeTween) {
													activeTween.endValue = activeTween.currentValue;
												});
											}

											callsToStop.push(i);
										} else if (propertiesMap === "finish" || propertiesMap === "finishAll") {
											/* To get active tweens to finish immediately, we forcefully shorten their durations to 1ms so that
											 they finish upon the next rAf tick then proceed with normal call completion logic. */
											activeCall[2].duration = 1;
										}
									}
								});
							});
						}
					});

					/* Prematurely call completeCall() on each matched active call. Pass an additional flag for "stop" to indicate
					 that the complete callback and display:none setting should be skipped since we're completing prematurely. */
					if (propertiesMap === "stop") {
						$.each(callsToStop, function(i, j) {
							completeCall(j, true);
						});

						if (promiseData.promise) {
							/* Immediately resolve the promise associated with this stop call since stop runs synchronously. */
							promiseData.resolver(elements);
						}
					}

					/* Since we're stopping, and not proceeding with queueing, exit out of Velocity. */
					return getChain();

				default:
					/* Treat a non-empty plain object as a literal properties map. */
					if ($.isPlainObject(propertiesMap) && !Type.isEmptyObject(propertiesMap)) {
						action = "start";

						/****************
						 Redirects
						 ****************/

						/* Check if a string matches a registered redirect (see Redirects above). */
					} else if (Type.isString(propertiesMap) && Velocity.Redirects[propertiesMap]) {
						opts = $.extend({}, options);

						var durationOriginal = opts.duration,
								delayOriginal = opts.delay || 0;

						/* If the backwards option was passed in, reverse the element set so that elements animate from the last to the first. */
						if (opts.backwards === true) {
							elements = $.extend(true, [], elements).reverse();
						}

						/* Individually trigger the redirect for each element in the set to prevent users from having to handle iteration logic in their redirect. */
						$.each(elements, function(elementIndex, element) {
							/* If the stagger option was passed in, successively delay each element by the stagger value (in ms). Retain the original delay value. */
							if (parseFloat(opts.stagger)) {
								opts.delay = delayOriginal + (parseFloat(opts.stagger) * elementIndex);
							} else if (Type.isFunction(opts.stagger)) {
								opts.delay = delayOriginal + opts.stagger.call(element, elementIndex, elementsLength);
							}

							/* If the drag option was passed in, successively increase/decrease (depending on the presense of opts.backwards)
							 the duration of each element's animation, using floors to prevent producing very short durations. */
							if (opts.drag) {
								/* Default the duration of UI pack effects (callouts and transitions) to 1000ms instead of the usual default duration of 400ms. */
								opts.duration = parseFloat(durationOriginal) || (/^(callout|transition)/.test(propertiesMap) ? 1000 : DURATION_DEFAULT);

								/* For each element, take the greater duration of: A) animation completion percentage relative to the original duration,
								 B) 75% of the original duration, or C) a 200ms fallback (in case duration is already set to a low value).
								 The end result is a baseline of 75% of the redirect's duration that increases/decreases as the end of the element set is approached. */
								opts.duration = Math.max(opts.duration * (opts.backwards ? 1 - elementIndex / elementsLength : (elementIndex + 1) / elementsLength), opts.duration * 0.75, 200);
							}

							/* Pass in the call's opts object so that the redirect can optionally extend it. It defaults to an empty object instead of null to
							 reduce the opts checking logic required inside the redirect. */
							Velocity.Redirects[propertiesMap].call(element, element, opts || {}, elementIndex, elementsLength, elements, promiseData.promise ? promiseData : undefined);
						});

						/* Since the animation logic resides within the redirect's own code, abort the remainder of this call.
						 (The performance overhead up to this point is virtually non-existant.) */
						/* Note: The jQuery call chain is kept intact by returning the complete element set. */
						return getChain();
					} else {
						var abortError = "Velocity: First argument (" + propertiesMap + ") was not a property map, a known action, or a registered redirect. Aborting.";

						if (promiseData.promise) {
							promiseData.rejecter(new Error(abortError));
						} else if (window.console) {
							console.log(abortError);
						}

						return getChain();
					}
			}

			/**************************
			 Call-Wide Variables
			 **************************/

			/* A container for CSS unit conversion ratios (e.g. %, rem, and em ==> px) that is used to cache ratios across all elements
			 being animated in a single Velocity call. Calculating unit ratios necessitates DOM querying and updating, and is therefore
			 avoided (via caching) wherever possible. This container is call-wide instead of page-wide to avoid the risk of using stale
			 conversion metrics across Velocity animations that are not immediately consecutively chained. */
			var callUnitConversionData = {
				lastParent: null,
				lastPosition: null,
				lastFontSize: null,
				lastPercentToPxWidth: null,
				lastPercentToPxHeight: null,
				lastEmToPx: null,
				remToPx: null,
				vwToPx: null,
				vhToPx: null
			};

			/* A container for all the ensuing tween data and metadata associated with this call. This container gets pushed to the page-wide
			 Velocity.State.calls array that is processed during animation ticking. */
			var call = [];

			/************************
			 Element Processing
			 ************************/

			/* Element processing consists of three parts -- data processing that cannot go stale and data processing that *can* go stale (i.e. third-party style modifications):
			 1) Pre-Queueing: Element-wide variables, including the element's data storage, are instantiated. Call options are prepared. If triggered, the Stop action is executed.
			 2) Queueing: The logic that runs once this call has reached its point of execution in the element's $.queue() stack. Most logic is placed here to avoid risking it becoming stale.
			 3) Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
			 `elementArrayIndex` allows passing index of the element in the original array to value functions.
			 If `elementsIndex` were used instead the index would be determined by the elements' per-element queue.
			 */
			function processElement(element, elementArrayIndex) {

				/*************************
				 Part I: Pre-Queueing
				 *************************/

				/***************************
				 Element-Wide Variables
				 ***************************/

				var /* The runtime opts object is the extension of the current call's options and Velocity's page-wide option defaults. */
						opts = $.extend({}, Velocity.defaults, options),
						/* A container for the processed data associated with each property in the propertyMap.
						 (Each property in the map produces its own "tween".) */
						tweensContainer = {},
						elementUnitConversionData;

				/******************
				 Element Init
				 ******************/

				if (Data(element) === undefined) {
					Velocity.init(element);
				}

				/******************
				 Option: Delay
				 ******************/

				/* Since queue:false doesn't respect the item's existing queue, we avoid injecting its delay here (it's set later on). */
				/* Note: Velocity rolls its own delay function since jQuery doesn't have a utility alias for $.fn.delay()
				 (and thus requires jQuery element creation, which we avoid since its overhead includes DOM querying). */
				if (parseFloat(opts.delay) && opts.queue !== false) {
					$.queue(element, opts.queue, function(next) {
						/* This is a flag used to indicate to the upcoming completeCall() function that this queue entry was initiated by Velocity. See completeCall() for further details. */
						Velocity.velocityQueueEntryFlag = true;

						/* The ensuing queue item (which is assigned to the "next" argument that $.queue() automatically passes in) will be triggered after a setTimeout delay.
						 The setTimeout is stored so that it can be subjected to clearTimeout() if this animation is prematurely stopped via Velocity's "stop" command, and
						 delayBegin/delayTime is used to ensure we can "pause" and "resume" a tween that is still mid-delay. */

						/* Temporarily store delayed elements to facilite access for global pause/resume */
						var callIndex = Velocity.State.delayedElements.count++;
						Velocity.State.delayedElements[callIndex] = element;

						var delayComplete = (function(index) {
							return function() {
								/* Clear the temporary element */
								Velocity.State.delayedElements[index] = false;

								/* Finally, issue the call */
								next();
							};
						})(callIndex);


						Data(element).delayBegin = (new Date()).getTime();
						Data(element).delay = parseFloat(opts.delay);
						Data(element).delayTimer = {
							setTimeout: setTimeout(next, parseFloat(opts.delay)),
							next: delayComplete
						};
					});
				}

				/*********************
				 Option: Duration
				 *********************/

				/* Support for jQuery's named durations. */
				switch (opts.duration.toString().toLowerCase()) {
					case "fast":
						opts.duration = 200;
						break;

					case "normal":
						opts.duration = DURATION_DEFAULT;
						break;

					case "slow":
						opts.duration = 600;
						break;

					default:
						/* Remove the potential "ms" suffix and default to 1 if the user is attempting to set a duration of 0 (in order to produce an immediate style change). */
						opts.duration = parseFloat(opts.duration) || 1;
				}

				/************************
				 Global Option: Mock
				 ************************/

				if (Velocity.mock !== false) {
					/* In mock mode, all animations are forced to 1ms so that they occur immediately upon the next rAF tick.
					 Alternatively, a multiplier can be passed in to time remap all delays and durations. */
					if (Velocity.mock === true) {
						opts.duration = opts.delay = 1;
					} else {
						opts.duration *= parseFloat(Velocity.mock) || 1;
						opts.delay *= parseFloat(Velocity.mock) || 1;
					}
				}

				/*******************
				 Option: Easing
				 *******************/

				opts.easing = getEasing(opts.easing, opts.duration);

				/**********************
				 Option: Callbacks
				 **********************/

				/* Callbacks must functions. Otherwise, default to null. */
				if (opts.begin && !Type.isFunction(opts.begin)) {
					opts.begin = null;
				}

				if (opts.progress && !Type.isFunction(opts.progress)) {
					opts.progress = null;
				}

				if (opts.complete && !Type.isFunction(opts.complete)) {
					opts.complete = null;
				}

				/*********************************
				 Option: Display & Visibility
				 *********************************/

				/* Refer to Velocity's documentation (VelocityJS.org/#displayAndVisibility) for a description of the display and visibility options' behavior. */
				/* Note: We strictly check for undefined instead of falsiness because display accepts an empty string value. */
				if (opts.display !== undefined && opts.display !== null) {
					opts.display = opts.display.toString().toLowerCase();

					/* Users can pass in a special "auto" value to instruct Velocity to set the element to its default display value. */
					if (opts.display === "auto") {
						opts.display = Velocity.CSS.Values.getDisplayType(element);
					}
				}

				if (opts.visibility !== undefined && opts.visibility !== null) {
					opts.visibility = opts.visibility.toString().toLowerCase();
				}

				/**********************
				 Option: mobileHA
				 **********************/

				/* When set to true, and if this is a mobile device, mobileHA automatically enables hardware acceleration (via a null transform hack)
				 on animating elements. HA is removed from the element at the completion of its animation. */
				/* Note: Android Gingerbread doesn't support HA. If a null transform hack (mobileHA) is in fact set, it will prevent other tranform subproperties from taking effect. */
				/* Note: You can read more about the use of mobileHA in Velocity's documentation: VelocityJS.org/#mobileHA. */
				opts.mobileHA = (opts.mobileHA && Velocity.State.isMobile && !Velocity.State.isGingerbread);

				/***********************
				 Part II: Queueing
				 ***********************/

				/* When a set of elements is targeted by a Velocity call, the set is broken up and each element has the current Velocity call individually queued onto it.
				 In this way, each element's existing queue is respected; some elements may already be animating and accordingly should not have this current Velocity call triggered immediately. */
				/* In each queue, tween data is processed for each animating property then pushed onto the call-wide calls array. When the last element in the set has had its tweens processed,
				 the call array is pushed to Velocity.State.calls for live processing by the requestAnimationFrame tick. */
				function buildQueue(next) {
					var data, lastTweensContainer;

					/*******************
					 Option: Begin
					 *******************/

					/* The begin callback is fired once per call -- not once per elemenet -- and is passed the full raw DOM element set as both its context and its first argument. */
					if (opts.begin && elementsIndex === 0) {
						/* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
						try {
							opts.begin.call(elements, elements);
						} catch (error) {
							setTimeout(function() {
								throw error;
							}, 1);
						}
					}

					/*****************************************
					 Tween Data Construction (for Scroll)
					 *****************************************/

					/* Note: In order to be subjected to chaining and animation options, scroll's tweening is routed through Velocity as if it were a standard CSS property animation. */
					if (action === "scroll") {
						/* The scroll action uniquely takes an optional "offset" option -- specified in pixels -- that offsets the targeted scroll position. */
						var scrollDirection = (/^x$/i.test(opts.axis) ? "Left" : "Top"),
								scrollOffset = parseFloat(opts.offset) || 0,
								scrollPositionCurrent,
								scrollPositionCurrentAlternate,
								scrollPositionEnd;

						/* Scroll also uniquely takes an optional "container" option, which indicates the parent element that should be scrolled --
						 as opposed to the browser window itself. This is useful for scrolling toward an element that's inside an overflowing parent element. */
						if (opts.container) {
							/* Ensure that either a jQuery object or a raw DOM element was passed in. */
							if (Type.isWrapped(opts.container) || Type.isNode(opts.container)) {
								/* Extract the raw DOM element from the jQuery wrapper. */
								opts.container = opts.container[0] || opts.container;
								/* Note: Unlike other properties in Velocity, the browser's scroll position is never cached since it so frequently changes
								 (due to the user's natural interaction with the page). */
								scrollPositionCurrent = opts.container["scroll" + scrollDirection]; /* GET */

								/* $.position() values are relative to the container's currently viewable area (without taking into account the container's true dimensions
								 -- say, for example, if the container was not overflowing). Thus, the scroll end value is the sum of the child element's position *and*
								 the scroll container's current scroll position. */
								scrollPositionEnd = (scrollPositionCurrent + $(element).position()[scrollDirection.toLowerCase()]) + scrollOffset; /* GET */
								/* If a value other than a jQuery object or a raw DOM element was passed in, default to null so that this option is ignored. */
							} else {
								opts.container = null;
							}
						} else {
							/* If the window itself is being scrolled -- not a containing element -- perform a live scroll position lookup using
							 the appropriate cached property names (which differ based on browser type). */
							scrollPositionCurrent = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + scrollDirection]]; /* GET */
							/* When scrolling the browser window, cache the alternate axis's current value since window.scrollTo() doesn't let us change only one value at a time. */
							scrollPositionCurrentAlternate = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + (scrollDirection === "Left" ? "Top" : "Left")]]; /* GET */

							/* Unlike $.position(), $.offset() values are relative to the browser window's true dimensions -- not merely its currently viewable area --
							 and therefore end values do not need to be compounded onto current values. */
							scrollPositionEnd = $(element).offset()[scrollDirection.toLowerCase()] + scrollOffset; /* GET */
						}

						/* Since there's only one format that scroll's associated tweensContainer can take, we create it manually. */
						tweensContainer = {
							scroll: {
								rootPropertyValue: false,
								startValue: scrollPositionCurrent,
								currentValue: scrollPositionCurrent,
								endValue: scrollPositionEnd,
								unitType: "",
								easing: opts.easing,
								scrollData: {
									container: opts.container,
									direction: scrollDirection,
									alternateValue: scrollPositionCurrentAlternate
								}
							},
							element: element
						};

						if (Velocity.debug) {
							console.log("tweensContainer (scroll): ", tweensContainer.scroll, element);
						}

						/******************************************
						 Tween Data Construction (for Reverse)
						 ******************************************/

						/* Reverse acts like a "start" action in that a property map is animated toward. The only difference is
						 that the property map used for reverse is the inverse of the map used in the previous call. Thus, we manipulate
						 the previous call to construct our new map: use the previous map's end values as our new map's start values. Copy over all other data. */
						/* Note: Reverse can be directly called via the "reverse" parameter, or it can be indirectly triggered via the loop option. (Loops are composed of multiple reverses.) */
						/* Note: Reverse calls do not need to be consecutively chained onto a currently-animating element in order to operate on cached values;
						 there is no harm to reverse being called on a potentially stale data cache since reverse's behavior is simply defined
						 as reverting to the element's values as they were prior to the previous *Velocity* call. */
					} else if (action === "reverse") {
						data = Data(element);

						/* Abort if there is no prior animation data to reverse to. */
						if (!data) {
							return;
						}

						if (!data.tweensContainer) {
							/* Dequeue the element so that this queue entry releases itself immediately, allowing subsequent queue entries to run. */
							$.dequeue(element, opts.queue);

							return;
						} else {
							/*********************
							 Options Parsing
							 *********************/

							/* If the element was hidden via the display option in the previous call,
							 revert display to "auto" prior to reversal so that the element is visible again. */
							if (data.opts.display === "none") {
								data.opts.display = "auto";
							}

							if (data.opts.visibility === "hidden") {
								data.opts.visibility = "visible";
							}

							/* If the loop option was set in the previous call, disable it so that "reverse" calls aren't recursively generated.
							 Further, remove the previous call's callback options; typically, users do not want these to be refired. */
							data.opts.loop = false;
							data.opts.begin = null;
							data.opts.complete = null;

							/* Since we're extending an opts object that has already been extended with the defaults options object,
							 we remove non-explicitly-defined properties that are auto-assigned values. */
							if (!options.easing) {
								delete opts.easing;
							}

							if (!options.duration) {
								delete opts.duration;
							}

							/* The opts object used for reversal is an extension of the options object optionally passed into this
							 reverse call plus the options used in the previous Velocity call. */
							opts = $.extend({}, data.opts, opts);

							/*************************************
							 Tweens Container Reconstruction
							 *************************************/

							/* Create a deepy copy (indicated via the true flag) of the previous call's tweensContainer. */
							lastTweensContainer = $.extend(true, {}, data ? data.tweensContainer : null);

							/* Manipulate the previous tweensContainer by replacing its end values and currentValues with its start values. */
							for (var lastTween in lastTweensContainer) {
								/* In addition to tween data, tweensContainers contain an element property that we ignore here. */
								if (lastTweensContainer.hasOwnProperty(lastTween) && lastTween !== "element") {
									var lastStartValue = lastTweensContainer[lastTween].startValue;

									lastTweensContainer[lastTween].startValue = lastTweensContainer[lastTween].currentValue = lastTweensContainer[lastTween].endValue;
									lastTweensContainer[lastTween].endValue = lastStartValue;

									/* Easing is the only option that embeds into the individual tween data (since it can be defined on a per-property basis).
									 Accordingly, every property's easing value must be updated when an options object is passed in with a reverse call.
									 The side effect of this extensibility is that all per-property easing values are forcefully reset to the new value. */
									if (!Type.isEmptyObject(options)) {
										lastTweensContainer[lastTween].easing = opts.easing;
									}

									if (Velocity.debug) {
										console.log("reverse tweensContainer (" + lastTween + "): " + JSON.stringify(lastTweensContainer[lastTween]), element);
									}
								}
							}

							tweensContainer = lastTweensContainer;
						}

						/*****************************************
						 Tween Data Construction (for Start)
						 *****************************************/

					} else if (action === "start") {

						/*************************
						 Value Transferring
						 *************************/

						/* If this queue entry follows a previous Velocity-initiated queue entry *and* if this entry was created
						 while the element was in the process of being animated by Velocity, then this current call is safe to use
						 the end values from the prior call as its start values. Velocity attempts to perform this value transfer
						 process whenever possible in order to avoid requerying the DOM. */
						/* If values aren't transferred from a prior call and start values were not forcefed by the user (more on this below),
						 then the DOM is queried for the element's current values as a last resort. */
						/* Note: Conversely, animation reversal (and looping) *always* perform inter-call value transfers; they never requery the DOM. */

						data = Data(element);

						/* The per-element isAnimating flag is used to indicate whether it's safe (i.e. the data isn't stale)
						 to transfer over end values to use as start values. If it's set to true and there is a previous
						 Velocity call to pull values from, do so. */
						if (data && data.tweensContainer && data.isAnimating === true) {
							lastTweensContainer = data.tweensContainer;
						}

						/***************************
						 Tween Data Calculation
						 ***************************/

						/* This function parses property data and defaults endValue, easing, and startValue as appropriate. */
						/* Property map values can either take the form of 1) a single value representing the end value,
						 or 2) an array in the form of [ endValue, [, easing] [, startValue] ].
						 The optional third parameter is a forcefed startValue to be used instead of querying the DOM for
						 the element's current value. Read Velocity's docmentation to learn more about forcefeeding: VelocityJS.org/#forcefeeding */
						var parsePropertyValue = function(valueData, skipResolvingEasing) {
							var endValue, easing, startValue;

							/* If we have a function as the main argument then resolve it first, in case it returns an array that needs to be split */
							if (Type.isFunction(valueData)) {
								valueData = valueData.call(element, elementArrayIndex, elementsLength);
							}

							/* Handle the array format, which can be structured as one of three potential overloads:
							 A) [ endValue, easing, startValue ], B) [ endValue, easing ], or C) [ endValue, startValue ] */
							if (Type.isArray(valueData)) {
								/* endValue is always the first item in the array. Don't bother validating endValue's value now
								 since the ensuing property cycling logic does that. */
								endValue = valueData[0];

								/* Two-item array format: If the second item is a number, function, or hex string, treat it as a
								 start value since easings can only be non-hex strings or arrays. */
								if ((!Type.isArray(valueData[1]) && /^[\d-]/.test(valueData[1])) || Type.isFunction(valueData[1]) || CSS.RegEx.isHex.test(valueData[1])) {
									startValue = valueData[1];
									/* Two or three-item array: If the second item is a non-hex string easing name or an array, treat it as an easing. */
								} else if ((Type.isString(valueData[1]) && !CSS.RegEx.isHex.test(valueData[1]) && Velocity.Easings[valueData[1]]) || Type.isArray(valueData[1])) {
									easing = skipResolvingEasing ? valueData[1] : getEasing(valueData[1], opts.duration);

									/* Don't bother validating startValue's value now since the ensuing property cycling logic inherently does that. */
									startValue = valueData[2];
								} else {
									startValue = valueData[1] || valueData[2];
								}
								/* Handle the single-value format. */
							} else {
								endValue = valueData;
							}

							/* Default to the call's easing if a per-property easing type was not defined. */
							if (!skipResolvingEasing) {
								easing = easing || opts.easing;
							}

							/* If functions were passed in as values, pass the function the current element as its context,
							 plus the element's index and the element set's size as arguments. Then, assign the returned value. */
							if (Type.isFunction(endValue)) {
								endValue = endValue.call(element, elementArrayIndex, elementsLength);
							}

							if (Type.isFunction(startValue)) {
								startValue = startValue.call(element, elementArrayIndex, elementsLength);
							}

							/* Allow startValue to be left as undefined to indicate to the ensuing code that its value was not forcefed. */
							return [endValue || 0, easing, startValue];
						};

						var fixPropertyValue = function(property, valueData) {
							/* In case this property is a hook, there are circumstances where we will intend to work on the hook's root property and not the hooked subproperty. */
							var rootProperty = CSS.Hooks.getRoot(property),
									rootPropertyValue = false,
									/* Parse out endValue, easing, and startValue from the property's data. */
									endValue = valueData[0],
									easing = valueData[1],
									startValue = valueData[2],
									pattern;

							/**************************
							 Start Value Sourcing
							 **************************/

							/* Other than for the dummy tween property, properties that are not supported by the browser (and do not have an associated normalization) will
							 inherently produce no style changes when set, so they are skipped in order to decrease animation tick overhead.
							 Property support is determined via prefixCheck(), which returns a false flag when no supported is detected. */
							/* Note: Since SVG elements have some of their properties directly applied as HTML attributes,
							 there is no way to check for their explicit browser support, and so we skip skip this check for them. */
							if ((!data || !data.isSVG) && rootProperty !== "tween" && CSS.Names.prefixCheck(rootProperty)[1] === false && CSS.Normalizations.registered[rootProperty] === undefined) {
								if (Velocity.debug) {
									console.log("Skipping [" + rootProperty + "] due to a lack of browser support.");
								}
								return;
							}

							/* If the display option is being set to a non-"none" (e.g. "block") and opacity (filter on IE<=8) is being
							 animated to an endValue of non-zero, the user's intention is to fade in from invisible, thus we forcefeed opacity
							 a startValue of 0 if its startValue hasn't already been sourced by value transferring or prior forcefeeding. */
							if (((opts.display !== undefined && opts.display !== null && opts.display !== "none") || (opts.visibility !== undefined && opts.visibility !== "hidden")) && /opacity|filter/.test(property) && !startValue && endValue !== 0) {
								startValue = 0;
							}

							/* If values have been transferred from the previous Velocity call, extract the endValue and rootPropertyValue
							 for all of the current call's properties that were *also* animated in the previous call. */
							/* Note: Value transferring can optionally be disabled by the user via the _cacheValues option. */
							if (opts._cacheValues && lastTweensContainer && lastTweensContainer[property]) {
								if (startValue === undefined) {
									startValue = lastTweensContainer[property].endValue + lastTweensContainer[property].unitType;
								}

								/* The previous call's rootPropertyValue is extracted from the element's data cache since that's the
								 instance of rootPropertyValue that gets freshly updated by the tweening process, whereas the rootPropertyValue
								 attached to the incoming lastTweensContainer is equal to the root property's value prior to any tweening. */
								rootPropertyValue = data.rootPropertyValueCache[rootProperty];
								/* If values were not transferred from a previous Velocity call, query the DOM as needed. */
							} else {
								/* Handle hooked properties. */
								if (CSS.Hooks.registered[property]) {
									if (startValue === undefined) {
										rootPropertyValue = CSS.getPropertyValue(element, rootProperty); /* GET */
										/* Note: The following getPropertyValue() call does not actually trigger a DOM query;
										 getPropertyValue() will extract the hook from rootPropertyValue. */
										startValue = CSS.getPropertyValue(element, property, rootPropertyValue);
										/* If startValue is already defined via forcefeeding, do not query the DOM for the root property's value;
										 just grab rootProperty's zero-value template from CSS.Hooks. This overwrites the element's actual
										 root property value (if one is set), but this is acceptable since the primary reason users forcefeed is
										 to avoid DOM queries, and thus we likewise avoid querying the DOM for the root property's value. */
									} else {
										/* Grab this hook's zero-value template, e.g. "0px 0px 0px black". */
										rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
									}
									/* Handle non-hooked properties that haven't already been defined via forcefeeding. */
								} else if (startValue === undefined) {
									startValue = CSS.getPropertyValue(element, property); /* GET */
								}
							}

							/**************************
							 Value Data Extraction
							 **************************/

							var separatedValue,
									endValueUnitType,
									startValueUnitType,
									operator = false;

							/* Separates a property value into its numeric value and its unit type. */
							var separateValue = function(property, value) {
								var unitType,
										numericValue;

								numericValue = (value || "0")
										.toString()
										.toLowerCase()
										/* Match the unit type at the end of the value. */
										.replace(/[%A-z]+$/, function(match) {
											/* Grab the unit type. */
											unitType = match;

											/* Strip the unit type off of value. */
											return "";
										});

								/* If no unit type was supplied, assign one that is appropriate for this property (e.g. "deg" for rotateZ or "px" for width). */
								if (!unitType) {
									unitType = CSS.Values.getUnitType(property);
								}

								return [numericValue, unitType];
							};

							if (startValue !== endValue && Type.isString(startValue) && Type.isString(endValue)) {
								pattern = "";
								var iStart = 0, // index in startValue
										iEnd = 0, // index in endValue
										aStart = [], // array of startValue numbers
										aEnd = [], // array of endValue numbers
										inCalc = 0, // Keep track of being inside a "calc()" so we don't duplicate it
										inRGB = 0, // Keep track of being inside an RGB as we can't use fractional values
										inRGBA = 0; // Keep track of being inside an RGBA as we must pass fractional for the alpha channel

								startValue = CSS.Hooks.fixColors(startValue);
								endValue = CSS.Hooks.fixColors(endValue);
								while (iStart < startValue.length && iEnd < endValue.length) {
									var cStart = startValue[iStart],
											cEnd = endValue[iEnd];

									if (/[\d\.-]/.test(cStart) && /[\d\.-]/.test(cEnd)) {
										var tStart = cStart, // temporary character buffer
												tEnd = cEnd, // temporary character buffer
												dotStart = ".", // Make sure we can only ever match a single dot in a decimal
												dotEnd = "."; // Make sure we can only ever match a single dot in a decimal

										while (++iStart < startValue.length) {
											cStart = startValue[iStart];
											if (cStart === dotStart) {
												dotStart = ".."; // Can never match two characters
											} else if (!/\d/.test(cStart)) {
												break;
											}
											tStart += cStart;
										}
										while (++iEnd < endValue.length) {
											cEnd = endValue[iEnd];
											if (cEnd === dotEnd) {
												dotEnd = ".."; // Can never match two characters
											} else if (!/\d/.test(cEnd)) {
												break;
											}
											tEnd += cEnd;
										}
										var uStart = CSS.Hooks.getUnit(startValue, iStart), // temporary unit type
												uEnd = CSS.Hooks.getUnit(endValue, iEnd); // temporary unit type

										iStart += uStart.length;
										iEnd += uEnd.length;
										if (uStart === uEnd) {
											// Same units
											if (tStart === tEnd) {
												// Same numbers, so just copy over
												pattern += tStart + uStart;
											} else {
												// Different numbers, so store them
												pattern += "{" + aStart.length + (inRGB ? "!" : "") + "}" + uStart;
												aStart.push(parseFloat(tStart));
												aEnd.push(parseFloat(tEnd));
											}
										} else {
											// Different units, so put into a "calc(from + to)" and animate each side to/from zero
											var nStart = parseFloat(tStart),
													nEnd = parseFloat(tEnd);

											pattern += (inCalc < 5 ? "calc" : "") + "("
													+ (nStart ? "{" + aStart.length + (inRGB ? "!" : "") + "}" : "0") + uStart
													+ " + "
													+ (nEnd ? "{" + (aStart.length + (nStart ? 1 : 0)) + (inRGB ? "!" : "") + "}" : "0") + uEnd
													+ ")";
											if (nStart) {
												aStart.push(nStart);
												aEnd.push(0);
											}
											if (nEnd) {
												aStart.push(0);
												aEnd.push(nEnd);
											}
										}
									} else if (cStart === cEnd) {
										pattern += cStart;
										iStart++;
										iEnd++;
										// Keep track of being inside a calc()
										if (inCalc === 0 && cStart === "c"
												|| inCalc === 1 && cStart === "a"
												|| inCalc === 2 && cStart === "l"
												|| inCalc === 3 && cStart === "c"
												|| inCalc >= 4 && cStart === "("
												) {
											inCalc++;
										} else if ((inCalc && inCalc < 5)
												|| inCalc >= 4 && cStart === ")" && --inCalc < 5) {
											inCalc = 0;
										}
										// Keep track of being inside an rgb() / rgba()
										if (inRGB === 0 && cStart === "r"
												|| inRGB === 1 && cStart === "g"
												|| inRGB === 2 && cStart === "b"
												|| inRGB === 3 && cStart === "a"
												|| inRGB >= 3 && cStart === "("
												) {
											if (inRGB === 3 && cStart === "a") {
												inRGBA = 1;
											}
											inRGB++;
										} else if (inRGBA && cStart === ",") {
											if (++inRGBA > 3) {
												inRGB = inRGBA = 0;
											}
										} else if ((inRGBA && inRGB < (inRGBA ? 5 : 4))
												|| inRGB >= (inRGBA ? 4 : 3) && cStart === ")" && --inRGB < (inRGBA ? 5 : 4)) {
											inRGB = inRGBA = 0;
										}
									} else {
										inCalc = 0;
										// TODO: changing units, fixing colours
										break;
									}
								}
								if (iStart !== startValue.length || iEnd !== endValue.length) {
									if (Velocity.debug) {
										console.error("Trying to pattern match mis-matched strings [\"" + endValue + "\", \"" + startValue + "\"]");
									}
									pattern = undefined;
								}
								if (pattern) {
									if (aStart.length) {
										if (Velocity.debug) {
											console.log("Pattern found \"" + pattern + "\" -> ", aStart, aEnd, "[" + startValue + "," + endValue + "]");
										}
										startValue = aStart;
										endValue = aEnd;
										endValueUnitType = startValueUnitType = "";
									} else {
										pattern = undefined;
									}
								}
							}

							if (!pattern) {
								/* Separate startValue. */
								separatedValue = separateValue(property, startValue);
								startValue = separatedValue[0];
								startValueUnitType = separatedValue[1];

								/* Separate endValue, and extract a value operator (e.g. "+=", "-=") if one exists. */
								separatedValue = separateValue(property, endValue);
								endValue = separatedValue[0].replace(/^([+-\/*])=/, function(match, subMatch) {
									operator = subMatch;

									/* Strip the operator off of the value. */
									return "";
								});
								endValueUnitType = separatedValue[1];

								/* Parse float values from endValue and startValue. Default to 0 if NaN is returned. */
								startValue = parseFloat(startValue) || 0;
								endValue = parseFloat(endValue) || 0;

								/***************************************
								 Property-Specific Value Conversion
								 ***************************************/

								/* Custom support for properties that don't actually accept the % unit type, but where pollyfilling is trivial and relatively foolproof. */
								if (endValueUnitType === "%") {
									/* A %-value fontSize/lineHeight is relative to the parent's fontSize (as opposed to the parent's dimensions),
									 which is identical to the em unit's behavior, so we piggyback off of that. */
									if (/^(fontSize|lineHeight)$/.test(property)) {
										/* Convert % into an em decimal value. */
										endValue = endValue / 100;
										endValueUnitType = "em";
										/* For scaleX and scaleY, convert the value into its decimal format and strip off the unit type. */
									} else if (/^scale/.test(property)) {
										endValue = endValue / 100;
										endValueUnitType = "";
										/* For RGB components, take the defined percentage of 255 and strip off the unit type. */
									} else if (/(Red|Green|Blue)$/i.test(property)) {
										endValue = (endValue / 100) * 255;
										endValueUnitType = "";
									}
								}
							}

							/***************************
							 Unit Ratio Calculation
							 ***************************/

							/* When queried, the browser returns (most) CSS property values in pixels. Therefore, if an endValue with a unit type of
							 %, em, or rem is animated toward, startValue must be converted from pixels into the same unit type as endValue in order
							 for value manipulation logic (increment/decrement) to proceed. Further, if the startValue was forcefed or transferred
							 from a previous call, startValue may also not be in pixels. Unit conversion logic therefore consists of two steps:
							 1) Calculating the ratio of %/em/rem/vh/vw relative to pixels
							 2) Converting startValue into the same unit of measurement as endValue based on these ratios. */
							/* Unit conversion ratios are calculated by inserting a sibling node next to the target node, copying over its position property,
							 setting values with the target unit type then comparing the returned pixel value. */
							/* Note: Even if only one of these unit types is being animated, all unit ratios are calculated at once since the overhead
							 of batching the SETs and GETs together upfront outweights the potential overhead
							 of layout thrashing caused by re-querying for uncalculated ratios for subsequently-processed properties. */
							/* Todo: Shift this logic into the calls' first tick instance so that it's synced with RAF. */
							var calculateUnitRatios = function() {

								/************************
								 Same Ratio Checks
								 ************************/

								/* The properties below are used to determine whether the element differs sufficiently from this call's
								 previously iterated element to also differ in its unit conversion ratios. If the properties match up with those
								 of the prior element, the prior element's conversion ratios are used. Like most optimizations in Velocity,
								 this is done to minimize DOM querying. */
								var sameRatioIndicators = {
									myParent: element.parentNode || document.body, /* GET */
									position: CSS.getPropertyValue(element, "position"), /* GET */
									fontSize: CSS.getPropertyValue(element, "fontSize") /* GET */
								},
										/* Determine if the same % ratio can be used. % is based on the element's position value and its parent's width and height dimensions. */
										samePercentRatio = ((sameRatioIndicators.position === callUnitConversionData.lastPosition) && (sameRatioIndicators.myParent === callUnitConversionData.lastParent)),
										/* Determine if the same em ratio can be used. em is relative to the element's fontSize. */
										sameEmRatio = (sameRatioIndicators.fontSize === callUnitConversionData.lastFontSize);

								/* Store these ratio indicators call-wide for the next element to compare against. */
								callUnitConversionData.lastParent = sameRatioIndicators.myParent;
								callUnitConversionData.lastPosition = sameRatioIndicators.position;
								callUnitConversionData.lastFontSize = sameRatioIndicators.fontSize;

								/***************************
								 Element-Specific Units
								 ***************************/

								/* Note: IE8 rounds to the nearest pixel when returning CSS values, thus we perform conversions using a measurement
								 of 100 (instead of 1) to give our ratios a precision of at least 2 decimal values. */
								var measurement = 100,
										unitRatios = {};

								if (!sameEmRatio || !samePercentRatio) {
									var dummy = data && data.isSVG ? document.createElementNS("http://www.w3.org/2000/svg", "rect") : document.createElement("div");

									Velocity.init(dummy);
									sameRatioIndicators.myParent.appendChild(dummy);

									/* To accurately and consistently calculate conversion ratios, the element's cascaded overflow and box-sizing are stripped.
									 Similarly, since width/height can be artificially constrained by their min-/max- equivalents, these are controlled for as well. */
									/* Note: Overflow must be also be controlled for per-axis since the overflow property overwrites its per-axis values. */
									$.each(["overflow", "overflowX", "overflowY"], function(i, property) {
										Velocity.CSS.setPropertyValue(dummy, property, "hidden");
									});
									Velocity.CSS.setPropertyValue(dummy, "position", sameRatioIndicators.position);
									Velocity.CSS.setPropertyValue(dummy, "fontSize", sameRatioIndicators.fontSize);
									Velocity.CSS.setPropertyValue(dummy, "boxSizing", "content-box");

									/* width and height act as our proxy properties for measuring the horizontal and vertical % ratios. */
									$.each(["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height"], function(i, property) {
										Velocity.CSS.setPropertyValue(dummy, property, measurement + "%");
									});
									/* paddingLeft arbitrarily acts as our proxy property for the em ratio. */
									Velocity.CSS.setPropertyValue(dummy, "paddingLeft", measurement + "em");

									/* Divide the returned value by the measurement to get the ratio between 1% and 1px. Default to 1 since working with 0 can produce Infinite. */
									unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth = (parseFloat(CSS.getPropertyValue(dummy, "width", null, true)) || 1) / measurement; /* GET */
									unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight = (parseFloat(CSS.getPropertyValue(dummy, "height", null, true)) || 1) / measurement; /* GET */
									unitRatios.emToPx = callUnitConversionData.lastEmToPx = (parseFloat(CSS.getPropertyValue(dummy, "paddingLeft")) || 1) / measurement; /* GET */

									sameRatioIndicators.myParent.removeChild(dummy);
								} else {
									unitRatios.emToPx = callUnitConversionData.lastEmToPx;
									unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth;
									unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight;
								}

								/***************************
								 Element-Agnostic Units
								 ***************************/

								/* Whereas % and em ratios are determined on a per-element basis, the rem unit only needs to be checked
								 once per call since it's exclusively dependant upon document.body's fontSize. If this is the first time
								 that calculateUnitRatios() is being run during this call, remToPx will still be set to its default value of null,
								 so we calculate it now. */
								if (callUnitConversionData.remToPx === null) {
									/* Default to browsers' default fontSize of 16px in the case of 0. */
									callUnitConversionData.remToPx = parseFloat(CSS.getPropertyValue(document.body, "fontSize")) || 16; /* GET */
								}

								/* Similarly, viewport units are %-relative to the window's inner dimensions. */
								if (callUnitConversionData.vwToPx === null) {
									callUnitConversionData.vwToPx = parseFloat(window.innerWidth) / 100; /* GET */
									callUnitConversionData.vhToPx = parseFloat(window.innerHeight) / 100; /* GET */
								}

								unitRatios.remToPx = callUnitConversionData.remToPx;
								unitRatios.vwToPx = callUnitConversionData.vwToPx;
								unitRatios.vhToPx = callUnitConversionData.vhToPx;

								if (Velocity.debug >= 1) {
									console.log("Unit ratios: " + JSON.stringify(unitRatios), element);
								}
								return unitRatios;
							};

							/********************
							 Unit Conversion
							 ********************/

							/* The * and / operators, which are not passed in with an associated unit, inherently use startValue's unit. Skip value and unit conversion. */
							if (/[\/*]/.test(operator)) {
								endValueUnitType = startValueUnitType;
								/* If startValue and endValue differ in unit type, convert startValue into the same unit type as endValue so that if endValueUnitType
								 is a relative unit (%, em, rem), the values set during tweening will continue to be accurately relative even if the metrics they depend
								 on are dynamically changing during the course of the animation. Conversely, if we always normalized into px and used px for setting values, the px ratio
								 would become stale if the original unit being animated toward was relative and the underlying metrics change during the animation. */
								/* Since 0 is 0 in any unit type, no conversion is necessary when startValue is 0 -- we just start at 0 with endValueUnitType. */
							} else if ((startValueUnitType !== endValueUnitType) && startValue !== 0) {
								/* Unit conversion is also skipped when endValue is 0, but *startValueUnitType* must be used for tween values to remain accurate. */
								/* Note: Skipping unit conversion here means that if endValueUnitType was originally a relative unit, the animation won't relatively
								 match the underlying metrics if they change, but this is acceptable since we're animating toward invisibility instead of toward visibility,
								 which remains past the point of the animation's completion. */
								if (endValue === 0) {
									endValueUnitType = startValueUnitType;
								} else {
									/* By this point, we cannot avoid unit conversion (it's undesirable since it causes layout thrashing).
									 If we haven't already, we trigger calculateUnitRatios(), which runs once per element per call. */
									elementUnitConversionData = elementUnitConversionData || calculateUnitRatios();

									/* The following RegEx matches CSS properties that have their % values measured relative to the x-axis. */
									/* Note: W3C spec mandates that all of margin and padding's properties (even top and bottom) are %-relative to the *width* of the parent element. */
									var axis = (/margin|padding|left|right|width|text|word|letter/i.test(property) || /X$/.test(property) || property === "x") ? "x" : "y";

									/* In order to avoid generating n^2 bespoke conversion functions, unit conversion is a two-step process:
									 1) Convert startValue into pixels. 2) Convert this new pixel value into endValue's unit type. */
									switch (startValueUnitType) {
										case "%":
											/* Note: translateX and translateY are the only properties that are %-relative to an element's own dimensions -- not its parent's dimensions.
											 Velocity does not include a special conversion process to account for this behavior. Therefore, animating translateX/Y from a % value
											 to a non-% value will produce an incorrect start value. Fortunately, this sort of cross-unit conversion is rarely done by users in practice. */
											startValue *= (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
											break;

										case "px":
											/* px acts as our midpoint in the unit conversion process; do nothing. */
											break;

										default:
											startValue *= elementUnitConversionData[startValueUnitType + "ToPx"];
									}

									/* Invert the px ratios to convert into to the target unit. */
									switch (endValueUnitType) {
										case "%":
											startValue *= 1 / (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
											break;

										case "px":
											/* startValue is already in px, do nothing; we're done. */
											break;

										default:
											startValue *= 1 / elementUnitConversionData[endValueUnitType + "ToPx"];
									}
								}
							}

							/*********************
							 Relative Values
							 *********************/

							/* Operator logic must be performed last since it requires unit-normalized start and end values. */
							/* Note: Relative *percent values* do not behave how most people think; while one would expect "+=50%"
							 to increase the property 1.5x its current value, it in fact increases the percent units in absolute terms:
							 50 points is added on top of the current % value. */
							switch (operator) {
								case "+":
									endValue = startValue + endValue;
									break;

								case "-":
									endValue = startValue - endValue;
									break;

								case "*":
									endValue = startValue * endValue;
									break;

								case "/":
									endValue = startValue / endValue;
									break;
							}

							/**************************
							 tweensContainer Push
							 **************************/

							/* Construct the per-property tween object, and push it to the element's tweensContainer. */
							tweensContainer[property] = {
								rootPropertyValue: rootPropertyValue,
								startValue: startValue,
								currentValue: startValue,
								endValue: endValue,
								unitType: endValueUnitType,
								easing: easing
							};
							if (pattern) {
								tweensContainer[property].pattern = pattern;
							}

							if (Velocity.debug) {
								console.log("tweensContainer (" + property + "): " + JSON.stringify(tweensContainer[property]), element);
							}
						};

						/* Create a tween out of each property, and append its associated data to tweensContainer. */
						for (var property in propertiesMap) {

							if (!propertiesMap.hasOwnProperty(property)) {
								continue;
							}
							/* The original property name's format must be used for the parsePropertyValue() lookup,
							 but we then use its camelCase styling to normalize it for manipulation. */
							var propertyName = CSS.Names.camelCase(property),
									valueData = parsePropertyValue(propertiesMap[property]);

							/* Find shorthand color properties that have been passed a hex string. */
							/* Would be quicker to use CSS.Lists.colors.includes() if possible */
							if (_inArray(CSS.Lists.colors, propertyName)) {
								/* Parse the value data for each shorthand. */
								var endValue = valueData[0],
										easing = valueData[1],
										startValue = valueData[2];

								if (CSS.RegEx.isHex.test(endValue)) {
									/* Convert the hex strings into their RGB component arrays. */
									var colorComponents = ["Red", "Green", "Blue"],
											endValueRGB = CSS.Values.hexToRgb(endValue),
											startValueRGB = startValue ? CSS.Values.hexToRgb(startValue) : undefined;

									/* Inject the RGB component tweens into propertiesMap. */
									for (var i = 0; i < colorComponents.length; i++) {
										var dataArray = [endValueRGB[i]];

										if (easing) {
											dataArray.push(easing);
										}

										if (startValueRGB !== undefined) {
											dataArray.push(startValueRGB[i]);
										}

										fixPropertyValue(propertyName + colorComponents[i], dataArray);
									}
									/* If we have replaced a shortcut color value then don't update the standard property name */
									continue;
								}
							}
							fixPropertyValue(propertyName, valueData);
						}

						/* Along with its property data, store a reference to the element itself onto tweensContainer. */
						tweensContainer.element = element;
					}

					/*****************
					 Call Push
					 *****************/

					/* Note: tweensContainer can be empty if all of the properties in this call's property map were skipped due to not
					 being supported by the browser. The element property is used for checking that the tweensContainer has been appended to. */
					if (tweensContainer.element) {
						/* Apply the "velocity-animating" indicator class. */
						CSS.Values.addClass(element, "velocity-animating");

						/* The call array houses the tweensContainers for each element being animated in the current call. */
						call.push(tweensContainer);

						data = Data(element);

						if (data) {
							/* Store the tweensContainer and options if we're working on the default effects queue, so that they can be used by the reverse command. */
							if (opts.queue === "") {

								data.tweensContainer = tweensContainer;
								data.opts = opts;
							}

							/* Switch on the element's animating flag. */
							data.isAnimating = true;
						}

						/* Once the final element in this call's element set has been processed, push the call array onto
						 Velocity.State.calls for the animation tick to immediately begin processing. */
						if (elementsIndex === elementsLength - 1) {
							/* Add the current call plus its associated metadata (the element set and the call's options) onto the global call container.
							 Anything on this call container is subjected to tick() processing. */
							Velocity.State.calls.push([call, elements, opts, null, promiseData.resolver, null, 0]);

							/* If the animation tick isn't running, start it. (Velocity shuts it off when there are no active calls to process.) */
							if (Velocity.State.isTicking === false) {
								Velocity.State.isTicking = true;

								/* Start the tick loop. */
								tick();
							}
						} else {
							elementsIndex++;
						}
					}
				}

				/* When the queue option is set to false, the call skips the element's queue and fires immediately. */
				if (opts.queue === false) {
					/* Since this buildQueue call doesn't respect the element's existing queue (which is where a delay option would have been appended),
					 we manually inject the delay property here with an explicit setTimeout. */
					if (opts.delay) {

						/* Temporarily store delayed elements to facilitate access for global pause/resume */
						var callIndex = Velocity.State.delayedElements.count++;
						Velocity.State.delayedElements[callIndex] = element;

						var delayComplete = (function(index) {
							return function() {
								/* Clear the temporary element */
								Velocity.State.delayedElements[index] = false;

								/* Finally, issue the call */
								buildQueue();
							};
						})(callIndex);

						Data(element).delayBegin = (new Date()).getTime();
						Data(element).delay = parseFloat(opts.delay);
						Data(element).delayTimer = {
							setTimeout: setTimeout(buildQueue, parseFloat(opts.delay)),
							next: delayComplete
						};
					} else {
						buildQueue();
					}
					/* Otherwise, the call undergoes element queueing as normal. */
					/* Note: To interoperate with jQuery, Velocity uses jQuery's own $.queue() stack for queuing logic. */
				} else {
					$.queue(element, opts.queue, function(next, clearQueue) {
						/* If the clearQueue flag was passed in by the stop command, resolve this call's promise. (Promises can only be resolved once,
						 so it's fine if this is repeatedly triggered for each element in the associated call.) */
						if (clearQueue === true) {
							if (promiseData.promise) {
								promiseData.resolver(elements);
							}

							/* Do not continue with animation queueing. */
							return true;
						}

						/* This flag indicates to the upcoming completeCall() function that this queue entry was initiated by Velocity.
						 See completeCall() for further details. */
						Velocity.velocityQueueEntryFlag = true;

						buildQueue(next);
					});
				}

				/*********************
				 Auto-Dequeuing
				 *********************/

				/* As per jQuery's $.queue() behavior, to fire the first non-custom-queue entry on an element, the element
				 must be dequeued if its queue stack consists *solely* of the current call. (This can be determined by checking
				 for the "inprogress" item that jQuery prepends to active queue stack arrays.) Regardless, whenever the element's
				 queue is further appended with additional items -- including $.delay()'s or even $.animate() calls, the queue's
				 first entry is automatically fired. This behavior contrasts that of custom queues, which never auto-fire. */
				/* Note: When an element set is being subjected to a non-parallel Velocity call, the animation will not begin until
				 each one of the elements in the set has reached the end of its individually pre-existing queue chain. */
				/* Note: Unfortunately, most people don't fully grasp jQuery's powerful, yet quirky, $.queue() function.
				 Lean more here: http://stackoverflow.com/questions/1058158/can-somebody-explain-jquery-queue-to-me */
				if ((opts.queue === "" || opts.queue === "fx") && $.queue(element)[0] !== "inprogress") {
					$.dequeue(element);
				}
			}

			/**************************
			 Element Set Iteration
			 **************************/

			/* If the "nodeType" property exists on the elements variable, we're animating a single element.
			 Place it in an array so that $.each() can iterate over it. */
			$.each(elements, function(i, element) {
				/* Ensure each element in a set has a nodeType (is a real element) to avoid throwing errors. */
				if (Type.isNode(element)) {
					processElement(element, i);
				}
			});

			/******************
			 Option: Loop
			 ******************/

			/* The loop option accepts an integer indicating how many times the element should loop between the values in the
			 current call's properties map and the element's property values prior to this call. */
			/* Note: The loop option's logic is performed here -- after element processing -- because the current call needs
			 to undergo its queue insertion prior to the loop option generating its series of constituent "reverse" calls,
			 which chain after the current call. Two reverse calls (two "alternations") constitute one loop. */
			opts = $.extend({}, Velocity.defaults, options);
			opts.loop = parseInt(opts.loop, 10);
			var reverseCallsCount = (opts.loop * 2) - 1;

			if (opts.loop) {
				/* Double the loop count to convert it into its appropriate number of "reverse" calls.
				 Subtract 1 from the resulting value since the current call is included in the total alternation count. */
				for (var x = 0; x < reverseCallsCount; x++) {
					/* Since the logic for the reverse action occurs inside Queueing and therefore this call's options object
					 isn't parsed until then as well, the current call's delay option must be explicitly passed into the reverse
					 call so that the delay logic that occurs inside *Pre-Queueing* can process it. */
					var reverseOptions = {
						delay: opts.delay,
						progress: opts.progress
					};

					/* If a complete callback was passed into this call, transfer it to the loop redirect's final "reverse" call
					 so that it's triggered when the entire redirect is complete (and not when the very first animation is complete). */
					if (x === reverseCallsCount - 1) {
						reverseOptions.display = opts.display;
						reverseOptions.visibility = opts.visibility;
						reverseOptions.complete = opts.complete;
					}

					animate(elements, "reverse", reverseOptions);
				}
			}

			/***************
			 Chaining
			 ***************/

			/* Return the elements back to the call chain, with wrapped elements taking precedence in case Velocity was called via the $.fn. extension. */
			return getChain();
		};

		/* Turn Velocity into the animation function, extended with the pre-existing Velocity object. */
		Velocity = $.extend(animate, Velocity);
		/* For legacy support, also expose the literal animate method. */
		Velocity.animate = animate;

		/**************
		 Timing
		 **************/

		/* Ticker function. */
		var ticker = window.requestAnimationFrame || rAFShim;

		/* Inactive browser tabs pause rAF, which results in all active animations immediately sprinting to their completion states when the tab refocuses.
		 To get around this, we dynamically switch rAF to setTimeout (which the browser *doesn't* pause) when the tab loses focus. We skip this for mobile
		 devices to avoid wasting battery power on inactive tabs. */
		/* Note: Tab focus detection doesn't work on older versions of IE, but that's okay since they don't support rAF to begin with. */
		if (!Velocity.State.isMobile && document.hidden !== undefined) {
			var updateTicker = function() {
				/* Reassign the rAF function (which the global tick() function uses) based on the tab's focus state. */
				if (document.hidden) {
					ticker = function(callback) {
						/* The tick function needs a truthy first argument in order to pass its internal timestamp check. */
						return setTimeout(function() {
							callback(true);
						}, 16);
					};

					/* The rAF loop has been paused by the browser, so we manually restart the tick. */
					tick();
				} else {
					ticker = window.requestAnimationFrame || rAFShim;
				}
			};

			/* Page could be sitting in the background at this time (i.e. opened as new tab) so making sure we use correct ticker from the start */
			updateTicker();

			/* And then run check again every time visibility changes */
			document.addEventListener("visibilitychange", updateTicker);
		}

		/************
		 Tick
		 ************/

		/* Note: All calls to Velocity are pushed to the Velocity.State.calls array, which is fully iterated through upon each tick. */
		function tick(timestamp) {
			/* An empty timestamp argument indicates that this is the first tick occurence since ticking was turned on.
			 We leverage this metadata to fully ignore the first tick pass since RAF's initial pass is fired whenever
			 the browser's next tick sync time occurs, which results in the first elements subjected to Velocity
			 calls being animated out of sync with any elements animated immediately thereafter. In short, we ignore
			 the first RAF tick pass so that elements being immediately consecutively animated -- instead of simultaneously animated
			 by the same Velocity call -- are properly batched into the same initial RAF tick and consequently remain in sync thereafter. */
			if (timestamp) {
				/* We normally use RAF's high resolution timestamp but as it can be significantly offset when the browser is
				 under high stress we give the option for choppiness over allowing the browser to drop huge chunks of frames.
				 We use performance.now() and shim it if it doesn't exist for when the tab is hidden. */
				var timeCurrent = Velocity.timestamp && timestamp !== true ? timestamp : performance.now();

				/********************
				 Call Iteration
				 ********************/

				var callsLength = Velocity.State.calls.length;

				/* To speed up iterating over this array, it is compacted (falsey items -- calls that have completed -- are removed)
				 when its length has ballooned to a point that can impact tick performance. This only becomes necessary when animation
				 has been continuous with many elements over a long period of time; whenever all active calls are completed, completeCall() clears Velocity.State.calls. */
				if (callsLength > 10000) {
					Velocity.State.calls = compactSparseArray(Velocity.State.calls);
					callsLength = Velocity.State.calls.length;
				}

				/* Iterate through each active call. */
				for (var i = 0; i < callsLength; i++) {
					/* When a Velocity call is completed, its Velocity.State.calls entry is set to false. Continue on to the next call. */
					if (!Velocity.State.calls[i]) {
						continue;
					}

					/************************
					 Call-Wide Variables
					 ************************/

					var callContainer = Velocity.State.calls[i],
							call = callContainer[0],
							opts = callContainer[2],
							timeStart = callContainer[3],
							firstTick = !!timeStart,
							tweenDummyValue = null,
							pauseObject = callContainer[5],
							millisecondsEllapsed = callContainer[6];



					/* If timeStart is undefined, then this is the first time that this call has been processed by tick().
					 We assign timeStart now so that its value is as close to the real animation start time as possible.
					 (Conversely, had timeStart been defined when this call was added to Velocity.State.calls, the delay
					 between that time and now would cause the first few frames of the tween to be skipped since
					 percentComplete is calculated relative to timeStart.) */
					/* Further, subtract 16ms (the approximate resolution of RAF) from the current time value so that the
					 first tick iteration isn't wasted by animating at 0% tween completion, which would produce the
					 same style value as the element's current value. */
					if (!timeStart) {
						timeStart = Velocity.State.calls[i][3] = timeCurrent - 16;
					}

					/* If a pause object is present, skip processing unless it has been set to resume */
					if (pauseObject) {
						if (pauseObject.resume === true) {
							/* Update the time start to accomodate the paused completion amount */
							timeStart = callContainer[3] = Math.round(timeCurrent - millisecondsEllapsed - 16);

							/* Remove pause object after processing */
							callContainer[5] = null;
						} else {
							continue;
						}
					}

					millisecondsEllapsed = callContainer[6] = timeCurrent - timeStart;

					/* The tween's completion percentage is relative to the tween's start time, not the tween's start value
					 (which would result in unpredictable tween durations since JavaScript's timers are not particularly accurate).
					 Accordingly, we ensure that percentComplete does not exceed 1. */
					var percentComplete = Math.min((millisecondsEllapsed) / opts.duration, 1);

					/**********************
					 Element Iteration
					 **********************/

					/* For every call, iterate through each of the elements in its set. */
					for (var j = 0, callLength = call.length; j < callLength; j++) {
						var tweensContainer = call[j],
								element = tweensContainer.element;

						/* Check to see if this element has been deleted midway through the animation by checking for the
						 continued existence of its data cache. If it's gone, or the element is currently paused, skip animating this element. */
						if (!Data(element)) {
							continue;
						}

						var transformPropertyExists = false;

						/**********************************
						 Display & Visibility Toggling
						 **********************************/

						/* If the display option is set to non-"none", set it upfront so that the element can become visible before tweening begins.
						 (Otherwise, display's "none" value is set in completeCall() once the animation has completed.) */
						if (opts.display !== undefined && opts.display !== null && opts.display !== "none") {
							if (opts.display === "flex") {
								var flexValues = ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex"];

								$.each(flexValues, function(i, flexValue) {
									CSS.setPropertyValue(element, "display", flexValue);
								});
							}

							CSS.setPropertyValue(element, "display", opts.display);
						}

						/* Same goes with the visibility option, but its "none" equivalent is "hidden". */
						if (opts.visibility !== undefined && opts.visibility !== "hidden") {
							CSS.setPropertyValue(element, "visibility", opts.visibility);
						}

						/************************
						 Property Iteration
						 ************************/

						/* For every element, iterate through each property. */
						for (var property in tweensContainer) {
							/* Note: In addition to property tween data, tweensContainer contains a reference to its associated element. */
							if (tweensContainer.hasOwnProperty(property) && property !== "element") {
								var tween = tweensContainer[property],
										currentValue,
										/* Easing can either be a pre-genereated function or a string that references a pre-registered easing
										 on the Velocity.Easings object. In either case, return the appropriate easing *function*. */
										easing = Type.isString(tween.easing) ? Velocity.Easings[tween.easing] : tween.easing;

								/******************************
								 Current Value Calculation
								 ******************************/

								if (Type.isString(tween.pattern)) {
									var patternReplace = percentComplete === 1 ?
											function($0, index, round) {
												var result = tween.endValue[index];

												return round ? Math.round(result) : result;
											} :
											function($0, index, round) {
												var startValue = tween.startValue[index],
														tweenDelta = tween.endValue[index] - startValue,
														result = startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));

												return round ? Math.round(result) : result;
											};

									currentValue = tween.pattern.replace(/{(\d+)(!)?}/g, patternReplace);
								} else if (percentComplete === 1) {
									/* If this is the last tick pass (if we've reached 100% completion for this tween),
									 ensure that currentValue is explicitly set to its target endValue so that it's not subjected to any rounding. */
									currentValue = tween.endValue;
								} else {
									/* Otherwise, calculate currentValue based on the current delta from startValue. */
									var tweenDelta = tween.endValue - tween.startValue;

									currentValue = tween.startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));
									/* If no value change is occurring, don't proceed with DOM updating. */
								}
								if (!firstTick && (currentValue === tween.currentValue)) {
									continue;
								}

								tween.currentValue = currentValue;

								/* If we're tweening a fake 'tween' property in order to log transition values, update the one-per-call variable so that
								 it can be passed into the progress callback. */
								if (property === "tween") {
									tweenDummyValue = currentValue;
								} else {
									/******************
									 Hooks: Part I
									 ******************/
									var hookRoot;

									/* For hooked properties, the newly-updated rootPropertyValueCache is cached onto the element so that it can be used
									 for subsequent hooks in this call that are associated with the same root property. If we didn't cache the updated
									 rootPropertyValue, each subsequent update to the root property in this tick pass would reset the previous hook's
									 updates to rootPropertyValue prior to injection. A nice performance byproduct of rootPropertyValue caching is that
									 subsequently chained animations using the same hookRoot but a different hook can use this cached rootPropertyValue. */
									if (CSS.Hooks.registered[property]) {
										hookRoot = CSS.Hooks.getRoot(property);

										var rootPropertyValueCache = Data(element).rootPropertyValueCache[hookRoot];

										if (rootPropertyValueCache) {
											tween.rootPropertyValue = rootPropertyValueCache;
										}
									}

									/*****************
									 DOM Update
									 *****************/

									/* setPropertyValue() returns an array of the property name and property value post any normalization that may have been performed. */
									/* Note: To solve an IE<=8 positioning bug, the unit type is dropped when setting a property value of 0. */
									var adjustedSetData = CSS.setPropertyValue(element, /* SET */
											property,
											tween.currentValue + (IE < 9 && parseFloat(currentValue) === 0 ? "" : tween.unitType),
											tween.rootPropertyValue,
											tween.scrollData);

									/*******************
									 Hooks: Part II
									 *******************/

									/* Now that we have the hook's updated rootPropertyValue (the post-processed value provided by adjustedSetData), cache it onto the element. */
									if (CSS.Hooks.registered[property]) {
										/* Since adjustedSetData contains normalized data ready for DOM updating, the rootPropertyValue needs to be re-extracted from its normalized form. ?? */
										if (CSS.Normalizations.registered[hookRoot]) {
											Data(element).rootPropertyValueCache[hookRoot] = CSS.Normalizations.registered[hookRoot]("extract", null, adjustedSetData[1]);
										} else {
											Data(element).rootPropertyValueCache[hookRoot] = adjustedSetData[1];
										}
									}

									/***************
									 Transforms
									 ***************/

									/* Flag whether a transform property is being animated so that flushTransformCache() can be triggered once this tick pass is complete. */
									if (adjustedSetData[0] === "transform") {
										transformPropertyExists = true;
									}

								}
							}
						}

						/****************
						 mobileHA
						 ****************/

						/* If mobileHA is enabled, set the translate3d transform to null to force hardware acceleration.
						 It's safe to override this property since Velocity doesn't actually support its animation (hooks are used in its place). */
						if (opts.mobileHA) {
							/* Don't set the null transform hack if we've already done so. */
							if (Data(element).transformCache.translate3d === undefined) {
								/* All entries on the transformCache object are later concatenated into a single transform string via flushTransformCache(). */
								Data(element).transformCache.translate3d = "(0px, 0px, 0px)";

								transformPropertyExists = true;
							}
						}

						if (transformPropertyExists) {
							CSS.flushTransformCache(element);
						}
					}

					/* The non-"none" display value is only applied to an element once -- when its associated call is first ticked through.
					 Accordingly, it's set to false so that it isn't re-processed by this call in the next tick. */
					if (opts.display !== undefined && opts.display !== "none") {
						Velocity.State.calls[i][2].display = false;
					}
					if (opts.visibility !== undefined && opts.visibility !== "hidden") {
						Velocity.State.calls[i][2].visibility = false;
					}

					/* Pass the elements and the timing data (percentComplete, msRemaining, timeStart, tweenDummyValue) into the progress callback. */
					if (opts.progress) {
						opts.progress.call(callContainer[1],
								callContainer[1],
								percentComplete,
								Math.max(0, (timeStart + opts.duration) - timeCurrent),
								timeStart,
								tweenDummyValue);
					}

					/* If this call has finished tweening, pass its index to completeCall() to handle call cleanup. */
					if (percentComplete === 1) {
						completeCall(i);
					}
				}
			}

			/* Note: completeCall() sets the isTicking flag to false when the last call on Velocity.State.calls has completed. */
			if (Velocity.State.isTicking) {
				ticker(tick);
			}
		}

		/**********************
		 Call Completion
		 **********************/

		/* Note: Unlike tick(), which processes all active calls at once, call completion is handled on a per-call basis. */
		function completeCall(callIndex, isStopped) {
			/* Ensure the call exists. */
			if (!Velocity.State.calls[callIndex]) {
				return false;
			}

			/* Pull the metadata from the call. */
			var call = Velocity.State.calls[callIndex][0],
					elements = Velocity.State.calls[callIndex][1],
					opts = Velocity.State.calls[callIndex][2],
					resolver = Velocity.State.calls[callIndex][4];

			var remainingCallsExist = false;

			/*************************
			 Element Finalization
			 *************************/

			for (var i = 0, callLength = call.length; i < callLength; i++) {
				var element = call[i].element;

				/* If the user set display to "none" (intending to hide the element), set it now that the animation has completed. */
				/* Note: display:none isn't set when calls are manually stopped (via Velocity("stop"). */
				/* Note: Display gets ignored with "reverse" calls and infinite loops, since this behavior would be undesirable. */
				if (!isStopped && !opts.loop) {
					if (opts.display === "none") {
						CSS.setPropertyValue(element, "display", opts.display);
					}

					if (opts.visibility === "hidden") {
						CSS.setPropertyValue(element, "visibility", opts.visibility);
					}
				}

				/* If the element's queue is empty (if only the "inprogress" item is left at position 0) or if its queue is about to run
				 a non-Velocity-initiated entry, turn off the isAnimating flag. A non-Velocity-initiatied queue entry's logic might alter
				 an element's CSS values and thereby cause Velocity's cached value data to go stale. To detect if a queue entry was initiated by Velocity,
				 we check for the existence of our special Velocity.queueEntryFlag declaration, which minifiers won't rename since the flag
				 is assigned to jQuery's global $ object and thus exists out of Velocity's own scope. */
				var data = Data(element);

				if (opts.loop !== true && ($.queue(element)[1] === undefined || !/\.velocityQueueEntryFlag/i.test($.queue(element)[1]))) {
					/* The element may have been deleted. Ensure that its data cache still exists before acting on it. */
					if (data) {
						data.isAnimating = false;
						/* Clear the element's rootPropertyValueCache, which will become stale. */
						data.rootPropertyValueCache = {};

						var transformHAPropertyExists = false;
						/* If any 3D transform subproperty is at its default value (regardless of unit type), remove it. */
						$.each(CSS.Lists.transforms3D, function(i, transformName) {
							var defaultValue = /^scale/.test(transformName) ? 1 : 0,
									currentValue = data.transformCache[transformName];

							if (data.transformCache[transformName] !== undefined && new RegExp("^\\(" + defaultValue + "[^.]").test(currentValue)) {
								transformHAPropertyExists = true;

								delete data.transformCache[transformName];
							}
						});

						/* Mobile devices have hardware acceleration removed at the end of the animation in order to avoid hogging the GPU's memory. */
						if (opts.mobileHA) {
							transformHAPropertyExists = true;
							delete data.transformCache.translate3d;
						}

						/* Flush the subproperty removals to the DOM. */
						if (transformHAPropertyExists) {
							CSS.flushTransformCache(element);
						}

						/* Remove the "velocity-animating" indicator class. */
						CSS.Values.removeClass(element, "velocity-animating");
					}
				}

				/*********************
				 Option: Complete
				 *********************/

				/* Complete is fired once per call (not once per element) and is passed the full raw DOM element set as both its context and its first argument. */
				/* Note: Callbacks aren't fired when calls are manually stopped (via Velocity("stop"). */
				if (!isStopped && opts.complete && !opts.loop && (i === callLength - 1)) {
					/* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
					try {
						opts.complete.call(elements, elements);
					} catch (error) {
						setTimeout(function() {
							throw error;
						}, 1);
					}
				}

				/**********************
				 Promise Resolving
				 **********************/

				/* Note: Infinite loops don't return promises. */
				if (resolver && opts.loop !== true) {
					resolver(elements);
				}

				/****************************
				 Option: Loop (Infinite)
				 ****************************/

				if (data && opts.loop === true && !isStopped) {
					/* If a rotateX/Y/Z property is being animated by 360 deg with loop:true, swap tween start/end values to enable
					 continuous iterative rotation looping. (Otherise, the element would just rotate back and forth.) */
					$.each(data.tweensContainer, function(propertyName, tweenContainer) {
						if (/^rotate/.test(propertyName) && ((parseFloat(tweenContainer.startValue) - parseFloat(tweenContainer.endValue)) % 360 === 0)) {
							var oldStartValue = tweenContainer.startValue;

							tweenContainer.startValue = tweenContainer.endValue;
							tweenContainer.endValue = oldStartValue;
						}

						if (/^backgroundPosition/.test(propertyName) && parseFloat(tweenContainer.endValue) === 100 && tweenContainer.unitType === "%") {
							tweenContainer.endValue = 0;
							tweenContainer.startValue = 100;
						}
					});

					Velocity(element, "reverse", {loop: true, delay: opts.delay});
				}

				/***************
				 Dequeueing
				 ***************/

				/* Fire the next call in the queue so long as this call's queue wasn't set to false (to trigger a parallel animation),
				 which would have already caused the next call to fire. Note: Even if the end of the animation queue has been reached,
				 $.dequeue() must still be called in order to completely clear jQuery's animation queue. */
				if (opts.queue !== false) {
					$.dequeue(element, opts.queue);
				}
			}

			/************************
			 Calls Array Cleanup
			 ************************/

			/* Since this call is complete, set it to false so that the rAF tick skips it. This array is later compacted via compactSparseArray().
			 (For performance reasons, the call is set to false instead of being deleted from the array: http://www.html5rocks.com/en/tutorials/speed/v8/) */
			Velocity.State.calls[callIndex] = false;

			/* Iterate through the calls array to determine if this was the final in-progress animation.
			 If so, set a flag to end ticking and clear the calls array. */
			for (var j = 0, callsLength = Velocity.State.calls.length; j < callsLength; j++) {
				if (Velocity.State.calls[j] !== false) {
					remainingCallsExist = true;

					break;
				}
			}

			if (remainingCallsExist === false) {
				/* tick() will detect this flag upon its next iteration and subsequently turn itself off. */
				Velocity.State.isTicking = false;

				/* Clear the calls array so that its length is reset. */
				delete Velocity.State.calls;
				Velocity.State.calls = [];
			}
		}

		/******************
		 Frameworks
		 ******************/

		/* Both jQuery and Zepto allow their $.fn object to be extended to allow wrapped elements to be subjected to plugin calls.
		 If either framework is loaded, register a "velocity" extension pointing to Velocity's core animate() method.  Velocity
		 also registers itself onto a global container (window.jQuery || window.Zepto || window) so that certain features are
		 accessible beyond just a per-element scope. This master object contains an .animate() method, which is later assigned to $.fn
		 (if jQuery or Zepto are present). Accordingly, Velocity can both act on wrapped DOM elements and stand alone for targeting raw DOM elements. */
		global.Velocity = Velocity;

		if (global !== window) {
			/* Assign the element function to Velocity's core animate() method. */
			global.fn.velocity = animate;
			/* Assign the object function's defaults to Velocity's global defaults object. */
			global.fn.velocity.defaults = Velocity.defaults;
		}

		/***********************
		 Packaged Redirects
		 ***********************/

		/* slideUp, slideDown */
		$.each(["Down", "Up"], function(i, direction) {
			Velocity.Redirects["slide" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {
				var opts = $.extend({}, options),
						begin = opts.begin,
						complete = opts.complete,
						inlineValues = {},
						computedValues = {height: "", marginTop: "", marginBottom: "", paddingTop: "", paddingBottom: ""};

				if (opts.display === undefined) {
					/* Show the element before slideDown begins and hide the element after slideUp completes. */
					/* Note: Inline elements cannot have dimensions animated, so they're reverted to inline-block. */
					opts.display = (direction === "Down" ? (Velocity.CSS.Values.getDisplayType(element) === "inline" ? "inline-block" : "block") : "none");
				}

				opts.begin = function() {
					/* If the user passed in a begin callback, fire it now. */
					if (elementsIndex === 0 && begin) {
						begin.call(elements, elements);
					}

					/* Cache the elements' original vertical dimensional property values so that we can animate back to them. */
					for (var property in computedValues) {
						if (!computedValues.hasOwnProperty(property)) {
							continue;
						}
						inlineValues[property] = element.style[property];

						/* For slideDown, use forcefeeding to animate all vertical properties from 0. For slideUp,
						 use forcefeeding to start from computed values and animate down to 0. */
						var propertyValue = CSS.getPropertyValue(element, property);
						computedValues[property] = (direction === "Down") ? [propertyValue, 0] : [0, propertyValue];
					}

					/* Force vertical overflow content to clip so that sliding works as expected. */
					inlineValues.overflow = element.style.overflow;
					element.style.overflow = "hidden";
				};

				opts.complete = function() {
					/* Reset element to its pre-slide inline values once its slide animation is complete. */
					for (var property in inlineValues) {
						if (inlineValues.hasOwnProperty(property)) {
							element.style[property] = inlineValues[property];
						}
					}

					/* If the user passed in a complete callback, fire it now. */
					if (elementsIndex === elementsSize - 1) {
						if (complete) {
							complete.call(elements, elements);
						}
						if (promiseData) {
							promiseData.resolver(elements);
						}
					}
				};

				Velocity(element, computedValues, opts);
			};
		});

		/* fadeIn, fadeOut */
		$.each(["In", "Out"], function(i, direction) {
			Velocity.Redirects["fade" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {
				var opts = $.extend({}, options),
						complete = opts.complete,
						propertiesMap = {opacity: (direction === "In") ? 1 : 0};

				/* Since redirects are triggered individually for each element in the animated set, avoid repeatedly triggering
				 callbacks by firing them only when the final element has been reached. */
				if (elementsIndex !== 0) {
					opts.begin = null;
				}
				if (elementsIndex !== elementsSize - 1) {
					opts.complete = null;
				} else {
					opts.complete = function() {
						if (complete) {
							complete.call(elements, elements);
						}
						if (promiseData) {
							promiseData.resolver(elements);
						}
					};
				}

				/* If a display was passed in, use it. Otherwise, default to "none" for fadeOut or the element-specific default for fadeIn. */
				/* Note: We allow users to pass in "null" to skip display setting altogether. */
				if (opts.display === undefined) {
					opts.display = (direction === "In" ? "auto" : "none");
				}

				Velocity(this, propertiesMap, opts);
			};
		});

		return Velocity;
	}((__webpack_provided_window_dot_jQuery || window.Zepto || window), window, (window ? window.document : undefined));
}));

/******************
 Known Issues
 ******************/

/* The CSS spec mandates that the translateX/Y/Z transforms are %-relative to the element itself -- not its parent.
 Velocity, however, doesn't make this distinction. Thus, converting to or from the % unit with these subproperties
 will produce an inaccurate conversion value. The same issue exists with the cx/cy attributes of SVG circles and ellipses. */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(6)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(144);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 68 */,
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery) {

/*
 * debouncedresize: special jQuery event that happens once after a window resize
 *
 * latest version and complete README available on Github:
 * https://github.com/louisremi/jquery-smartresize
 *
 * Copyright 2012 @louis_remi
 * Licensed under the MIT license.
 *
 * This saved you an hour of work? 
 * Send me music http://www.amazon.co.uk/wishlist/HNTU0468LQON
 */
(function ($) {

    var $event = $.event,
        $special,
        resizeTimeout;

    $special = $event.special.debouncedresize = {
        setup: function setup() {
            $(this).on("resize", $special.handler);
        },
        teardown: function teardown() {
            $(this).off("resize", $special.handler);
        },
        handler: function handler(event, execAsap) {
            // Save the context
            var context = this,
                args = arguments,
                dispatch = function dispatch() {
                // set correct event type
                event.type = "debouncedresize";
                $event.dispatch.apply(context, args);
            };

            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }

            execAsap ? dispatch() : resizeTimeout = setTimeout(dispatch, $special.threshold);
        },
        threshold: 150
    };
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * buildInputs method uses input found in
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * resources > views > forms > components > standard-input.blade
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _selectComponent = __webpack_require__(32);

var _selectComponent2 = _interopRequireDefault(_selectComponent);

var _autosize = __webpack_require__(169);

var _autosize2 = _interopRequireDefault(_autosize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var baseClass = 'input';

var CustomInput = function () {
    function CustomInput(element) {
        var _this = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, CustomInput);

        this.activeClass = baseClass + '--is-active';
        this.filledClass = baseClass + '--is-filled';
        this.disabledClass = baseClass + '--is-disabled';
        this.errorClass = baseClass + '--has-error';

        this.handleFileChange = function (event) {
            var fileName = _this.$component.elements.field[0].files[0].name;

            _this.$component.elements.label.text(fileName);
        };

        this.handleFilterEvent = function (event) {
            var url = _this.$component.find('option:selected').val();

            if (url.length > 0) {
                window.location.href = url;
            }
        };

        this.handleInputFill = function (event) {
            if (_this.$component.elements.field.val()) {
                _this.$component.addClass(_this.filledClass);
            } else {
                _this.$component.removeClass(_this.filledClass);
            }
        };

        this.$component = (0, _selectComponent2.default)(element);
        this.$field = this.$component.elements.field;

        this.attachEvents(options);
        this.handleInputFill();

        if (!this.$component.elements.errorLabel) {
            this.createErrorLabel();
        }
    }

    _createClass(CustomInput, [{
        key: 'attachEvents',
        value: function attachEvents(options) {
            var tagName = this.$field[0].tagName.toLowerCase();

            if (this.$field.attr('type') === 'file') {
                this.$component.on('change', this.handleFileChange);

                return;
            }

            if (tagName === 'select') {
                this.options = _extends({}, options);

                if (this.$component.attr('data-action') == 'filter') {
                    this.$component.on('change', this.handleFilterEvent);
                }
            }

            if (tagName === 'textarea') {
                (0, _autosize2.default)(this.$field[0]);
            }

            this.$field.on('focus blur', this.handleInputFill);
        }
    }, {
        key: 'createErrorLabel',
        value: function createErrorLabel() {
            if (!this.$component.elements.error) {
                this.$component.prepend($('<label />', {
                    'for': this.$component.elements.field.attr('name'),
                    'class': 'input__error',
                    'data-element': 'error'
                }));

                this.$component.refresh();
            }
        }
    }, {
        key: 'disable',
        value: function disable() {
            this.$component.addClass(this.disabledClass);
            this.$field.attr('disabled', 'disabled');
        }
    }, {
        key: 'enable',
        value: function enable() {
            this.$component.removeClass(this.disabledClass);
            this.$field.removeAttr('disabled');
        }
    }, {
        key: 'focus',
        value: function focus() {
            this.$component.elements.field.focus();
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.$component.elements.field.val('');
        }
    }, {
        key: 'setError',
        value: function setError(message) {
            this.$component.addClass(this.errorClass);
            this.$component.elements.error.html(message).addClass(this.activeClass);
        }
    }, {
        key: 'removeError',
        value: function removeError() {
            this.$component.removeClass(this.errorClass);
            this.$component.elements.error.html('').removeClass(this.activeClass);
        }
    }, {
        key: 'getName',
        value: function getName() {
            return this.$component.elements.field.attr('name');
        }
    }]);

    return CustomInput;
}();

exports.default = CustomInput;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var DEFAULT = {
    name: 'Unnamed Module',
    el: 'body'
};

exports.default = {

    exists: false,

    construct: function construct(moduleDefault, args) {
        if (typeof args === 'string') {
            args = {
                el: args
            };
        }

        var settings = _extends({}, DEFAULT, moduleDefault, args);

        if ($(settings.el).length) {
            this.exists = true;
        }

        return settings;
    },
    start: function start(args) {
        if (this.exists) {
            try {
                this.action(args);
            } catch (err) {
                console.log('There was a problem with ' + DEFAULT.name + '. :(');
                console.log(err);
            }
        }
    },
    action: function action() {
        throw 'The \'action\' method must be defined in a concrete module';
    }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {!function(a){"use strict"; true?module.exports=a():"function"==typeof define&&define.amd?define(["velocity"],a):a()}(function(){"use strict";return function(a,b,c,d){var e=a.Velocity;if(!e||!e.Utilities)return void(b.console&&console.log("Velocity UI Pack: Velocity must be loaded first. Aborting."));var f=e.Utilities,g=e.version,h={major:1,minor:1,patch:0};if(function(a,b){var c=[];return!(!a||!b)&&(f.each([a,b],function(a,b){var d=[];f.each(b,function(a,b){for(;b.toString().length<5;)b="0"+b;d.push(b)}),c.push(d.join(""))}),parseFloat(c[0])>parseFloat(c[1]))}(h,g)){var i="Velocity UI Pack: You need to update Velocity (velocity.js) to a newer version. Visit http://github.com/julianshapiro/velocity.";throw alert(i),new Error(i)}e.RegisterEffect=e.RegisterUI=function(a,b){function c(a,b,c,d){var g,h=0;f.each(a.nodeType?[a]:a,function(a,b){d&&(c+=a*d),g=b.parentNode;var i=["height","paddingTop","paddingBottom","marginTop","marginBottom"];"border-box"===e.CSS.getPropertyValue(b,"boxSizing").toString().toLowerCase()&&(i=["height"]),f.each(i,function(a,c){h+=parseFloat(e.CSS.getPropertyValue(b,c))})}),e.animate(g,{height:("In"===b?"+":"-")+"="+h},{queue:!1,easing:"ease-in-out",duration:c*("In"===b?.6:1)})}return e.Redirects[a]=function(d,g,h,i,j,k,l){var m=h===i-1,n=0;l=l||b.loop,"function"==typeof b.defaultDuration?b.defaultDuration=b.defaultDuration.call(j,j):b.defaultDuration=parseFloat(b.defaultDuration);for(var o=0;o<b.calls.length;o++)"number"==typeof(t=b.calls[o][1])&&(n+=t);var p=n>=1?0:b.calls.length?(1-n)/b.calls.length:1;for(o=0;o<b.calls.length;o++){var q=b.calls[o],r=q[0],s=1e3,t=q[1],u=q[2]||{},v={};if(void 0!==g.duration?s=g.duration:void 0!==b.defaultDuration&&(s=b.defaultDuration),v.duration=s*("number"==typeof t?t:p),v.queue=g.queue||"",v.easing=u.easing||"ease",v.delay=parseFloat(u.delay)||0,v.loop=!b.loop&&u.loop,v._cacheValues=u._cacheValues||!0,0===o){if(v.delay+=parseFloat(g.delay)||0,0===h&&(v.begin=function(){g.begin&&g.begin.call(j,j);var b=a.match(/(In|Out)$/);b&&"In"===b[0]&&void 0!==r.opacity&&f.each(j.nodeType?[j]:j,function(a,b){e.CSS.setPropertyValue(b,"opacity",0)}),g.animateParentHeight&&b&&c(j,b[0],s+v.delay,g.stagger)}),null!==g.display)if(void 0!==g.display&&"none"!==g.display)v.display=g.display;else if(/In$/.test(a)){var w=e.CSS.Values.getDisplayType(d);v.display="inline"===w?"inline-block":w}g.visibility&&"hidden"!==g.visibility&&(v.visibility=g.visibility)}if(o===b.calls.length-1){var x=function(){void 0!==g.display&&"none"!==g.display||!/Out$/.test(a)||f.each(j.nodeType?[j]:j,function(a,b){e.CSS.setPropertyValue(b,"display","none")}),g.complete&&g.complete.call(j,j),k&&k.resolver(j||d)};v.complete=function(){if(l&&e.Redirects[a](d,g,h,i,j,k,l===!0||Math.max(0,l-1)),b.reset){for(var c in b.reset)if(b.reset.hasOwnProperty(c)){var f=b.reset[c];void 0!==e.CSS.Hooks.registered[c]||"string"!=typeof f&&"number"!=typeof f||(b.reset[c]=[b.reset[c],b.reset[c]])}var n={duration:0,queue:!1};m&&(n.complete=x),e.animate(d,b.reset,n)}else m&&x()},"hidden"===g.visibility&&(v.visibility=g.visibility)}e.animate(d,r,v)}},e},e.RegisterEffect.packagedEffects={"callout.bounce":{defaultDuration:550,calls:[[{translateY:-30},.25],[{translateY:0},.125],[{translateY:-15},.125],[{translateY:0},.25]]},"callout.shake":{defaultDuration:800,calls:[[{translateX:-11}],[{translateX:11}],[{translateX:-11}],[{translateX:11}],[{translateX:-11}],[{translateX:11}],[{translateX:-11}],[{translateX:0}]]},"callout.flash":{defaultDuration:1100,calls:[[{opacity:[0,"easeInOutQuad",1]}],[{opacity:[1,"easeInOutQuad"]}],[{opacity:[0,"easeInOutQuad"]}],[{opacity:[1,"easeInOutQuad"]}]]},"callout.pulse":{defaultDuration:825,calls:[[{scaleX:1.1,scaleY:1.1},.5,{easing:"easeInExpo"}],[{scaleX:1,scaleY:1},.5]]},"callout.swing":{defaultDuration:950,calls:[[{rotateZ:15}],[{rotateZ:-10}],[{rotateZ:5}],[{rotateZ:-5}],[{rotateZ:0}]]},"callout.tada":{defaultDuration:1e3,calls:[[{scaleX:.9,scaleY:.9,rotateZ:-3},.1],[{scaleX:1.1,scaleY:1.1,rotateZ:3},.1],[{scaleX:1.1,scaleY:1.1,rotateZ:-3},.1],["reverse",.125],["reverse",.125],["reverse",.125],["reverse",.125],["reverse",.125],[{scaleX:1,scaleY:1,rotateZ:0},.2]]},"transition.fadeIn":{defaultDuration:500,calls:[[{opacity:[1,0]}]]},"transition.fadeOut":{defaultDuration:500,calls:[[{opacity:[0,1]}]]},"transition.flipXIn":{defaultDuration:700,calls:[[{opacity:[1,0],transformPerspective:[800,800],rotateY:[0,-55]}]],reset:{transformPerspective:0}},"transition.flipXOut":{defaultDuration:700,calls:[[{opacity:[0,1],transformPerspective:[800,800],rotateY:55}]],reset:{transformPerspective:0,rotateY:0}},"transition.flipYIn":{defaultDuration:800,calls:[[{opacity:[1,0],transformPerspective:[800,800],rotateX:[0,-45]}]],reset:{transformPerspective:0}},"transition.flipYOut":{defaultDuration:800,calls:[[{opacity:[0,1],transformPerspective:[800,800],rotateX:25}]],reset:{transformPerspective:0,rotateX:0}},"transition.flipBounceXIn":{defaultDuration:900,calls:[[{opacity:[.725,0],transformPerspective:[400,400],rotateY:[-10,90]},.5],[{opacity:.8,rotateY:10},.25],[{opacity:1,rotateY:0},.25]],reset:{transformPerspective:0}},"transition.flipBounceXOut":{defaultDuration:800,calls:[[{opacity:[.9,1],transformPerspective:[400,400],rotateY:-10}],[{opacity:0,rotateY:90}]],reset:{transformPerspective:0,rotateY:0}},"transition.flipBounceYIn":{defaultDuration:850,calls:[[{opacity:[.725,0],transformPerspective:[400,400],rotateX:[-10,90]},.5],[{opacity:.8,rotateX:10},.25],[{opacity:1,rotateX:0},.25]],reset:{transformPerspective:0}},"transition.flipBounceYOut":{defaultDuration:800,calls:[[{opacity:[.9,1],transformPerspective:[400,400],rotateX:-15}],[{opacity:0,rotateX:90}]],reset:{transformPerspective:0,rotateX:0}},"transition.swoopIn":{defaultDuration:850,calls:[[{opacity:[1,0],transformOriginX:["100%","50%"],transformOriginY:["100%","100%"],scaleX:[1,0],scaleY:[1,0],translateX:[0,-700],translateZ:0}]],reset:{transformOriginX:"50%",transformOriginY:"50%"}},"transition.swoopOut":{defaultDuration:850,calls:[[{opacity:[0,1],transformOriginX:["50%","100%"],transformOriginY:["100%","100%"],scaleX:0,scaleY:0,translateX:-700,translateZ:0}]],reset:{transformOriginX:"50%",transformOriginY:"50%",scaleX:1,scaleY:1,translateX:0}},"transition.whirlIn":{defaultDuration:850,calls:[[{opacity:[1,0],transformOriginX:["50%","50%"],transformOriginY:["50%","50%"],scaleX:[1,0],scaleY:[1,0],rotateY:[0,160]},1,{easing:"easeInOutSine"}]]},"transition.whirlOut":{defaultDuration:750,calls:[[{opacity:[0,"easeInOutQuint",1],transformOriginX:["50%","50%"],transformOriginY:["50%","50%"],scaleX:0,scaleY:0,rotateY:160},1,{easing:"swing"}]],reset:{scaleX:1,scaleY:1,rotateY:0}},"transition.shrinkIn":{defaultDuration:750,calls:[[{opacity:[1,0],transformOriginX:["50%","50%"],transformOriginY:["50%","50%"],scaleX:[1,1.5],scaleY:[1,1.5],translateZ:0}]]},"transition.shrinkOut":{defaultDuration:600,calls:[[{opacity:[0,1],transformOriginX:["50%","50%"],transformOriginY:["50%","50%"],scaleX:1.3,scaleY:1.3,translateZ:0}]],reset:{scaleX:1,scaleY:1}},"transition.expandIn":{defaultDuration:700,calls:[[{opacity:[1,0],transformOriginX:["50%","50%"],transformOriginY:["50%","50%"],scaleX:[1,.625],scaleY:[1,.625],translateZ:0}]]},"transition.expandOut":{defaultDuration:700,calls:[[{opacity:[0,1],transformOriginX:["50%","50%"],transformOriginY:["50%","50%"],scaleX:.5,scaleY:.5,translateZ:0}]],reset:{scaleX:1,scaleY:1}},"transition.bounceIn":{defaultDuration:800,calls:[[{opacity:[1,0],scaleX:[1.05,.3],scaleY:[1.05,.3]},.35],[{scaleX:.9,scaleY:.9,translateZ:0},.2],[{scaleX:1,scaleY:1},.45]]},"transition.bounceOut":{defaultDuration:800,calls:[[{scaleX:.95,scaleY:.95},.35],[{scaleX:1.1,scaleY:1.1,translateZ:0},.35],[{opacity:[0,1],scaleX:.3,scaleY:.3},.3]],reset:{scaleX:1,scaleY:1}},"transition.bounceUpIn":{defaultDuration:800,calls:[[{opacity:[1,0],translateY:[-30,1e3]},.6,{easing:"easeOutCirc"}],[{translateY:10},.2],[{translateY:0},.2]]},"transition.bounceUpOut":{defaultDuration:1e3,calls:[[{translateY:20},.2],[{opacity:[0,"easeInCirc",1],translateY:-1e3},.8]],reset:{translateY:0}},"transition.bounceDownIn":{defaultDuration:800,calls:[[{opacity:[1,0],translateY:[30,-1e3]},.6,{easing:"easeOutCirc"}],[{translateY:-10},.2],[{translateY:0},.2]]},"transition.bounceDownOut":{defaultDuration:1e3,calls:[[{translateY:-20},.2],[{opacity:[0,"easeInCirc",1],translateY:1e3},.8]],reset:{translateY:0}},"transition.bounceLeftIn":{defaultDuration:750,calls:[[{opacity:[1,0],translateX:[30,-1250]},.6,{easing:"easeOutCirc"}],[{translateX:-10},.2],[{translateX:0},.2]]},"transition.bounceLeftOut":{defaultDuration:750,calls:[[{translateX:30},.2],[{opacity:[0,"easeInCirc",1],translateX:-1250},.8]],reset:{translateX:0}},"transition.bounceRightIn":{defaultDuration:750,calls:[[{opacity:[1,0],translateX:[-30,1250]},.6,{easing:"easeOutCirc"}],[{translateX:10},.2],[{translateX:0},.2]]},"transition.bounceRightOut":{defaultDuration:750,calls:[[{translateX:-30},.2],[{opacity:[0,"easeInCirc",1],translateX:1250},.8]],reset:{translateX:0}},"transition.slideUpIn":{defaultDuration:900,calls:[[{opacity:[1,0],translateY:[0,20],translateZ:0}]]},"transition.slideUpOut":{defaultDuration:900,calls:[[{opacity:[0,1],translateY:-20,translateZ:0}]],reset:{translateY:0}},"transition.slideDownIn":{defaultDuration:900,calls:[[{opacity:[1,0],translateY:[0,-20],translateZ:0}]]},"transition.slideDownOut":{defaultDuration:900,calls:[[{opacity:[0,1],translateY:20,translateZ:0}]],reset:{translateY:0}},"transition.slideLeftIn":{defaultDuration:1e3,calls:[[{opacity:[1,0],translateX:[0,-20],translateZ:0}]]},"transition.slideLeftOut":{defaultDuration:1050,calls:[[{opacity:[0,1],translateX:-20,translateZ:0}]],reset:{translateX:0}},"transition.slideRightIn":{defaultDuration:1e3,calls:[[{opacity:[1,0],translateX:[0,20],translateZ:0}]]},"transition.slideRightOut":{defaultDuration:1050,calls:[[{opacity:[0,1],translateX:20,translateZ:0}]],reset:{translateX:0}},"transition.slideUpBigIn":{defaultDuration:850,calls:[[{opacity:[1,0],translateY:[0,75],translateZ:0}]]},"transition.slideUpBigOut":{defaultDuration:800,calls:[[{opacity:[0,1],translateY:-75,translateZ:0}]],reset:{translateY:0}},"transition.slideDownBigIn":{defaultDuration:850,calls:[[{opacity:[1,0],translateY:[0,-75],translateZ:0}]]},"transition.slideDownBigOut":{defaultDuration:800,calls:[[{opacity:[0,1],translateY:75,translateZ:0}]],reset:{translateY:0}},"transition.slideLeftBigIn":{defaultDuration:800,calls:[[{opacity:[1,0],translateX:[0,-75],translateZ:0}]]},"transition.slideLeftBigOut":{defaultDuration:750,calls:[[{opacity:[0,1],translateX:-75,translateZ:0}]],reset:{translateX:0}},"transition.slideRightBigIn":{defaultDuration:800,calls:[[{opacity:[1,0],translateX:[0,75],translateZ:0}]]},"transition.slideRightBigOut":{defaultDuration:750,calls:[[{opacity:[0,1],translateX:75,translateZ:0}]],reset:{translateX:0}},"transition.perspectiveUpIn":{defaultDuration:800,calls:[[{opacity:[1,0],transformPerspective:[800,800],transformOriginX:[0,0],transformOriginY:["100%","100%"],rotateX:[0,-180]}]],reset:{transformPerspective:0,transformOriginX:"50%",transformOriginY:"50%"}},"transition.perspectiveUpOut":{defaultDuration:850,calls:[[{opacity:[0,1],transformPerspective:[800,800],transformOriginX:[0,0],transformOriginY:["100%","100%"],rotateX:-180}]],reset:{transformPerspective:0,transformOriginX:"50%",transformOriginY:"50%",rotateX:0}},"transition.perspectiveDownIn":{defaultDuration:800,calls:[[{opacity:[1,0],transformPerspective:[800,800],transformOriginX:[0,0],transformOriginY:[0,0],rotateX:[0,180]}]],reset:{transformPerspective:0,transformOriginX:"50%",transformOriginY:"50%"}},"transition.perspectiveDownOut":{defaultDuration:850,calls:[[{opacity:[0,1],transformPerspective:[800,800],transformOriginX:[0,0],transformOriginY:[0,0],rotateX:180}]],reset:{transformPerspective:0,transformOriginX:"50%",transformOriginY:"50%",rotateX:0}},"transition.perspectiveLeftIn":{defaultDuration:950,calls:[[{opacity:[1,0],transformPerspective:[2e3,2e3],transformOriginX:[0,0],transformOriginY:[0,0],rotateY:[0,-180]}]],reset:{transformPerspective:0,transformOriginX:"50%",transformOriginY:"50%"}},"transition.perspectiveLeftOut":{defaultDuration:950,calls:[[{opacity:[0,1],transformPerspective:[2e3,2e3],transformOriginX:[0,0],transformOriginY:[0,0],rotateY:-180}]],reset:{transformPerspective:0,transformOriginX:"50%",transformOriginY:"50%",rotateY:0}},"transition.perspectiveRightIn":{defaultDuration:950,calls:[[{opacity:[1,0],transformPerspective:[2e3,2e3],transformOriginX:["100%","100%"],transformOriginY:[0,0],rotateY:[0,180]}]],reset:{transformPerspective:0,transformOriginX:"50%",transformOriginY:"50%"}},"transition.perspectiveRightOut":{defaultDuration:950,calls:[[{opacity:[0,1],transformPerspective:[2e3,2e3],transformOriginX:["100%","100%"],transformOriginY:[0,0],rotateY:180}]],reset:{transformPerspective:0,transformOriginX:"50%",transformOriginY:"50%",rotateY:0}}};for(var j in e.RegisterEffect.packagedEffects)e.RegisterEffect.packagedEffects.hasOwnProperty(j)&&e.RegisterEffect(j,e.RegisterEffect.packagedEffects[j]);e.RunSequence=function(a){var b=f.extend(!0,[],a);b.length>1&&(f.each(b.reverse(),function(a,c){var d=b[a+1];if(d){var g=c.o||c.options,h=d.o||d.options,i=g&&g.sequenceQueue===!1?"begin":"complete",j=h&&h[i],k={};k[i]=function(){var a=d.e||d.elements,b=a.nodeType?[a]:a;j&&j.call(b,b),e(c)},d.o?d.o=f.extend({},h,k):d.options=f.extend({},h,k)}}),b.reverse()),e(b[0])}}(__webpack_provided_window_dot_jQuery||window.Zepto||window,window,window?window.document:undefined)});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var $bpMobile = exports.$bpMobile = window.matchMedia('(min-width: 480px)');
var $bpTablet = exports.$bpTablet = window.matchMedia('(min-width: 768px)');
var $bpLaptop = exports.$bpLaptop = window.matchMedia('(min-width: 1000px)');
var $bpLg = exports.$bpLg = window.matchMedia('(min-width: 1100px)');
var $bpXl = exports.$bpXl = window.matchMedia('(min-width: 1400px)');
var $bpXxl = exports.$bpXxl = window.matchMedia('(min-width: 1560px)');

/***/ }),
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(137);
__webpack_require__(181);
module.exports = __webpack_require__(182);


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

__webpack_require__(66);

__webpack_require__(138);

var _site = __webpack_require__(139);

var _site2 = _interopRequireDefault(_site);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

$(document).ready(function () {
	(0, _site2.default)().init();

	$.ajaxSetup({
		headers: {
			'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
		}
	});
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {/**********************
 Velocity UI Pack
 **********************/

/* VelocityJS.org UI Pack (5.2.0). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License. Portions copyright Daniel Eden, Christian Pucci. */

(function(factory) {
	"use strict";
	/* CommonJS module. */
	if (true) {
		module.exports = factory();
		/* AMD module. */
	} else if (typeof define === "function" && define.amd) {
		define(["velocity"], factory);
		/* Browser globals. */
	} else {
		factory();
	}
}(function() {
	"use strict";
	return function(global, window, document, undefined) {

		/*************
		 Checks
		 *************/
		var Velocity = global.Velocity;

		if (!Velocity || !Velocity.Utilities) {
			if (window.console) {
				console.log("Velocity UI Pack: Velocity must be loaded first. Aborting.");
			}
			return;
		}
		var $ = Velocity.Utilities;

		var velocityVersion = Velocity.version,
				requiredVersion = {major: 1, minor: 1, patch: 0};

		function greaterSemver(primary, secondary) {
			var versionInts = [];

			if (!primary || !secondary) {
				return false;
			}

			$.each([primary, secondary], function(i, versionObject) {
				var versionIntsComponents = [];

				$.each(versionObject, function(component, value) {
					while (value.toString().length < 5) {
						value = "0" + value;
					}
					versionIntsComponents.push(value);
				});

				versionInts.push(versionIntsComponents.join(""));
			});

			return (parseFloat(versionInts[0]) > parseFloat(versionInts[1]));
		}

		if (greaterSemver(requiredVersion, velocityVersion)) {
			var abortError = "Velocity UI Pack: You need to update Velocity (velocity.js) to a newer version. Visit http://github.com/julianshapiro/velocity.";
			alert(abortError);
			throw new Error(abortError);
		}

		/************************
		 Effect Registration
		 ************************/

		/* Note: RegisterUI is a legacy name. */
		Velocity.RegisterEffect = Velocity.RegisterUI = function(effectName, properties) {
			/* Animate the expansion/contraction of the elements' parent's height for In/Out effects. */
			function animateParentHeight(elements, direction, totalDuration, stagger) {
				var totalHeightDelta = 0,
						parentNode;

				/* Sum the total height (including padding and margin) of all targeted elements. */
				$.each(elements.nodeType ? [elements] : elements, function(i, element) {
					if (stagger) {
						/* Increase the totalDuration by the successive delay amounts produced by the stagger option. */
						totalDuration += i * stagger;
					}

					parentNode = element.parentNode;

					var propertiesToSum = ["height", "paddingTop", "paddingBottom", "marginTop", "marginBottom"];

					/* If box-sizing is border-box, the height already includes padding and margin */
					if (Velocity.CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() === "border-box") {
						propertiesToSum = ["height"];
					}

					$.each(propertiesToSum, function(i, property) {
						totalHeightDelta += parseFloat(Velocity.CSS.getPropertyValue(element, property));
					});
				});

				/* Animate the parent element's height adjustment (with a varying duration multiplier for aesthetic benefits). */
				Velocity.animate(
						parentNode,
						{height: (direction === "In" ? "+" : "-") + "=" + totalHeightDelta},
						{queue: false, easing: "ease-in-out", duration: totalDuration * (direction === "In" ? 0.6 : 1)}
				);
			}

			/* Register a custom redirect for each effect. */
			Velocity.Redirects[effectName] = function(element, redirectOptions, elementsIndex, elementsSize, elements, promiseData, loop) {
				var finalElement = (elementsIndex === elementsSize - 1),
						totalDuration = 0;

				loop = loop || properties.loop;
				if (typeof properties.defaultDuration === "function") {
					properties.defaultDuration = properties.defaultDuration.call(elements, elements);
				} else {
					properties.defaultDuration = parseFloat(properties.defaultDuration);
				}

				/* Get the total duration used, so we can share it out with everything that doesn't have a duration */
				for (var callIndex = 0; callIndex < properties.calls.length; callIndex++) {
					durationPercentage = properties.calls[callIndex][1];
					if (typeof durationPercentage === "number") {
						totalDuration += durationPercentage;
					}
				}
				var shareDuration = totalDuration >= 1 ? 0 : properties.calls.length ? (1 - totalDuration) / properties.calls.length : 1;

				/* Iterate through each effect's call array. */
				for (callIndex = 0; callIndex < properties.calls.length; callIndex++) {
					var call = properties.calls[callIndex],
							propertyMap = call[0],
							redirectDuration = 1000,
							durationPercentage = call[1],
							callOptions = call[2] || {},
							opts = {};

					if (redirectOptions.duration !== undefined) {
						redirectDuration = redirectOptions.duration;
					} else if (properties.defaultDuration !== undefined) {
						redirectDuration = properties.defaultDuration;
					}

					/* Assign the whitelisted per-call options. */
					opts.duration = redirectDuration * (typeof durationPercentage === "number" ? durationPercentage : shareDuration);
					opts.queue = redirectOptions.queue || "";
					opts.easing = callOptions.easing || "ease";
					opts.delay = parseFloat(callOptions.delay) || 0;
					opts.loop = !properties.loop && callOptions.loop;
					opts._cacheValues = callOptions._cacheValues || true;

					/* Special processing for the first effect call. */
					if (callIndex === 0) {
						/* If a delay was passed into the redirect, combine it with the first call's delay. */
						opts.delay += (parseFloat(redirectOptions.delay) || 0);

						if (elementsIndex === 0) {
							opts.begin = function() {
								/* Only trigger a begin callback on the first effect call with the first element in the set. */
								if (redirectOptions.begin) {
									redirectOptions.begin.call(elements, elements);
								}

								var direction = effectName.match(/(In|Out)$/);

								/* Make "in" transitioning elements invisible immediately so that there's no FOUC between now
								 and the first RAF tick. */
								if ((direction && direction[0] === "In") && propertyMap.opacity !== undefined) {
									$.each(elements.nodeType ? [elements] : elements, function(i, element) {
										Velocity.CSS.setPropertyValue(element, "opacity", 0);
									});
								}

								/* Only trigger animateParentHeight() if we're using an In/Out transition. */
								if (redirectOptions.animateParentHeight && direction) {
									animateParentHeight(elements, direction[0], redirectDuration + opts.delay, redirectOptions.stagger);
								}
							};
						}

						/* If the user isn't overriding the display option, default to "auto" for "In"-suffixed transitions. */
						if (redirectOptions.display !== null) {
							if (redirectOptions.display !== undefined && redirectOptions.display !== "none") {
								opts.display = redirectOptions.display;
							} else if (/In$/.test(effectName)) {
								/* Inline elements cannot be subjected to transforms, so we switch them to inline-block. */
								var defaultDisplay = Velocity.CSS.Values.getDisplayType(element);
								opts.display = (defaultDisplay === "inline") ? "inline-block" : defaultDisplay;
							}
						}

						if (redirectOptions.visibility && redirectOptions.visibility !== "hidden") {
							opts.visibility = redirectOptions.visibility;
						}
					}

					/* Special processing for the last effect call. */
					if (callIndex === properties.calls.length - 1) {
						/* Append promise resolving onto the user's redirect callback. */
						var injectFinalCallbacks = function() {
							if ((redirectOptions.display === undefined || redirectOptions.display === "none") && /Out$/.test(effectName)) {
								$.each(elements.nodeType ? [elements] : elements, function(i, element) {
									Velocity.CSS.setPropertyValue(element, "display", "none");
								});
							}
							if (redirectOptions.complete) {
								redirectOptions.complete.call(elements, elements);
							}
							if (promiseData) {
								promiseData.resolver(elements || element);
							}
						};

						opts.complete = function() {
							if (loop) {
								Velocity.Redirects[effectName](element, redirectOptions, elementsIndex, elementsSize, elements, promiseData, loop === true ? true : Math.max(0, loop - 1));
							}
							if (properties.reset) {
								for (var resetProperty in properties.reset) {
									if (!properties.reset.hasOwnProperty(resetProperty)) {
										continue;
									}
									var resetValue = properties.reset[resetProperty];

									/* Format each non-array value in the reset property map to [ value, value ] so that changes apply
									 immediately and DOM querying is avoided (via forcefeeding). */
									/* Note: Don't forcefeed hooks, otherwise their hook roots will be defaulted to their null values. */
									if (Velocity.CSS.Hooks.registered[resetProperty] === undefined && (typeof resetValue === "string" || typeof resetValue === "number")) {
										properties.reset[resetProperty] = [properties.reset[resetProperty], properties.reset[resetProperty]];
									}
								}

								/* So that the reset values are applied instantly upon the next rAF tick, use a zero duration and parallel queueing. */
								var resetOptions = {duration: 0, queue: false};

								/* Since the reset option uses up the complete callback, we trigger the user's complete callback at the end of ours. */
								if (finalElement) {
									resetOptions.complete = injectFinalCallbacks;
								}

								Velocity.animate(element, properties.reset, resetOptions);
								/* Only trigger the user's complete callback on the last effect call with the last element in the set. */
							} else if (finalElement) {
								injectFinalCallbacks();
							}
						};

						if (redirectOptions.visibility === "hidden") {
							opts.visibility = redirectOptions.visibility;
						}
					}

					Velocity.animate(element, propertyMap, opts);
				}
			};

			/* Return the Velocity object so that RegisterUI calls can be chained. */
			return Velocity;
		};

		/*********************
		 Packaged Effects
		 *********************/

		/* Externalize the packagedEffects data so that they can optionally be modified and re-registered. */
		/* Support: <=IE8: Callouts will have no effect, and transitions will simply fade in/out. IE9/Android 2.3: Most effects are fully supported, the rest fade in/out. All other browsers: full support. */
		Velocity.RegisterEffect.packagedEffects =
				{
					/* Animate.css */
					"callout.bounce": {
						defaultDuration: 550,
						calls: [
							[{translateY: -30}, 0.25],
							[{translateY: 0}, 0.125],
							[{translateY: -15}, 0.125],
							[{translateY: 0}, 0.25]
						]
					},
					/* Animate.css */
					"callout.shake": {
						defaultDuration: 800,
						calls: [
							[{translateX: -11}],
							[{translateX: 11}],
							[{translateX: -11}],
							[{translateX: 11}],
							[{translateX: -11}],
							[{translateX: 11}],
							[{translateX: -11}],
							[{translateX: 0}]
						]
					},
					/* Animate.css */
					"callout.flash": {
						defaultDuration: 1100,
						calls: [
							[{opacity: [0, "easeInOutQuad", 1]}],
							[{opacity: [1, "easeInOutQuad"]}],
							[{opacity: [0, "easeInOutQuad"]}],
							[{opacity: [1, "easeInOutQuad"]}]
						]
					},
					/* Animate.css */
					"callout.pulse": {
						defaultDuration: 825,
						calls: [
							[{scaleX: 1.1, scaleY: 1.1}, 0.50, {easing: "easeInExpo"}],
							[{scaleX: 1, scaleY: 1}, 0.50]
						]
					},
					/* Animate.css */
					"callout.swing": {
						defaultDuration: 950,
						calls: [
							[{rotateZ: 15}],
							[{rotateZ: -10}],
							[{rotateZ: 5}],
							[{rotateZ: -5}],
							[{rotateZ: 0}]
						]
					},
					/* Animate.css */
					"callout.tada": {
						defaultDuration: 1000,
						calls: [
							[{scaleX: 0.9, scaleY: 0.9, rotateZ: -3}, 0.10],
							[{scaleX: 1.1, scaleY: 1.1, rotateZ: 3}, 0.10],
							[{scaleX: 1.1, scaleY: 1.1, rotateZ: -3}, 0.10],
							["reverse", 0.125],
							["reverse", 0.125],
							["reverse", 0.125],
							["reverse", 0.125],
							["reverse", 0.125],
							[{scaleX: 1, scaleY: 1, rotateZ: 0}, 0.20]
						]
					},
					"transition.fadeIn": {
						defaultDuration: 500,
						calls: [
							[{opacity: [1, 0]}]
						]
					},
					"transition.fadeOut": {
						defaultDuration: 500,
						calls: [
							[{opacity: [0, 1]}]
						]
					},
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.flipXIn": {
						defaultDuration: 700,
						calls: [
							[{opacity: [1, 0], transformPerspective: [800, 800], rotateY: [0, -55]}]
						],
						reset: {transformPerspective: 0}
					},
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.flipXOut": {
						defaultDuration: 700,
						calls: [
							[{opacity: [0, 1], transformPerspective: [800, 800], rotateY: 55}]
						],
						reset: {transformPerspective: 0, rotateY: 0}
					},
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.flipYIn": {
						defaultDuration: 800,
						calls: [
							[{opacity: [1, 0], transformPerspective: [800, 800], rotateX: [0, -45]}]
						],
						reset: {transformPerspective: 0}
					},
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.flipYOut": {
						defaultDuration: 800,
						calls: [
							[{opacity: [0, 1], transformPerspective: [800, 800], rotateX: 25}]
						],
						reset: {transformPerspective: 0, rotateX: 0}
					},
					/* Animate.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.flipBounceXIn": {
						defaultDuration: 900,
						calls: [
							[{opacity: [0.725, 0], transformPerspective: [400, 400], rotateY: [-10, 90]}, 0.50],
							[{opacity: 0.80, rotateY: 10}, 0.25],
							[{opacity: 1, rotateY: 0}, 0.25]
						],
						reset: {transformPerspective: 0}
					},
					/* Animate.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.flipBounceXOut": {
						defaultDuration: 800,
						calls: [
							[{opacity: [0.9, 1], transformPerspective: [400, 400], rotateY: -10}],
							[{opacity: 0, rotateY: 90}]
						],
						reset: {transformPerspective: 0, rotateY: 0}
					},
					/* Animate.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.flipBounceYIn": {
						defaultDuration: 850,
						calls: [
							[{opacity: [0.725, 0], transformPerspective: [400, 400], rotateX: [-10, 90]}, 0.50],
							[{opacity: 0.80, rotateX: 10}, 0.25],
							[{opacity: 1, rotateX: 0}, 0.25]
						],
						reset: {transformPerspective: 0}
					},
					/* Animate.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.flipBounceYOut": {
						defaultDuration: 800,
						calls: [
							[{opacity: [0.9, 1], transformPerspective: [400, 400], rotateX: -15}],
							[{opacity: 0, rotateX: 90}]
						],
						reset: {transformPerspective: 0, rotateX: 0}
					},
					/* Magic.css */
					"transition.swoopIn": {
						defaultDuration: 850,
						calls: [
							[{opacity: [1, 0], transformOriginX: ["100%", "50%"], transformOriginY: ["100%", "100%"], scaleX: [1, 0], scaleY: [1, 0], translateX: [0, -700], translateZ: 0}]
						],
						reset: {transformOriginX: "50%", transformOriginY: "50%"}
					},
					/* Magic.css */
					"transition.swoopOut": {
						defaultDuration: 850,
						calls: [
							[{opacity: [0, 1], transformOriginX: ["50%", "100%"], transformOriginY: ["100%", "100%"], scaleX: 0, scaleY: 0, translateX: -700, translateZ: 0}]
						],
						reset: {transformOriginX: "50%", transformOriginY: "50%", scaleX: 1, scaleY: 1, translateX: 0}
					},
					/* Magic.css */
					/* Support: Loses rotation in IE9/Android 2.3. (Fades and scales only.) */
					"transition.whirlIn": {
						defaultDuration: 850,
						calls: [
							[{opacity: [1, 0], transformOriginX: ["50%", "50%"], transformOriginY: ["50%", "50%"], scaleX: [1, 0], scaleY: [1, 0], rotateY: [0, 160]}, 1, {easing: "easeInOutSine"}]
						]
					},
					/* Magic.css */
					/* Support: Loses rotation in IE9/Android 2.3. (Fades and scales only.) */
					"transition.whirlOut": {
						defaultDuration: 750,
						calls: [
							[{opacity: [0, "easeInOutQuint", 1], transformOriginX: ["50%", "50%"], transformOriginY: ["50%", "50%"], scaleX: 0, scaleY: 0, rotateY: 160}, 1, {easing: "swing"}]
						],
						reset: {scaleX: 1, scaleY: 1, rotateY: 0}
					},
					"transition.shrinkIn": {
						defaultDuration: 750,
						calls: [
							[{opacity: [1, 0], transformOriginX: ["50%", "50%"], transformOriginY: ["50%", "50%"], scaleX: [1, 1.5], scaleY: [1, 1.5], translateZ: 0}]
						]
					},
					"transition.shrinkOut": {
						defaultDuration: 600,
						calls: [
							[{opacity: [0, 1], transformOriginX: ["50%", "50%"], transformOriginY: ["50%", "50%"], scaleX: 1.3, scaleY: 1.3, translateZ: 0}]
						],
						reset: {scaleX: 1, scaleY: 1}
					},
					"transition.expandIn": {
						defaultDuration: 700,
						calls: [
							[{opacity: [1, 0], transformOriginX: ["50%", "50%"], transformOriginY: ["50%", "50%"], scaleX: [1, 0.625], scaleY: [1, 0.625], translateZ: 0}]
						]
					},
					"transition.expandOut": {
						defaultDuration: 700,
						calls: [
							[{opacity: [0, 1], transformOriginX: ["50%", "50%"], transformOriginY: ["50%", "50%"], scaleX: 0.5, scaleY: 0.5, translateZ: 0}]
						],
						reset: {scaleX: 1, scaleY: 1}
					},
					/* Animate.css */
					"transition.bounceIn": {
						defaultDuration: 800,
						calls: [
							[{opacity: [1, 0], scaleX: [1.05, 0.3], scaleY: [1.05, 0.3]}, 0.35],
							[{scaleX: 0.9, scaleY: 0.9, translateZ: 0}, 0.20],
							[{scaleX: 1, scaleY: 1}, 0.45]
						]
					},
					/* Animate.css */
					"transition.bounceOut": {
						defaultDuration: 800,
						calls: [
							[{scaleX: 0.95, scaleY: 0.95}, 0.35],
							[{scaleX: 1.1, scaleY: 1.1, translateZ: 0}, 0.35],
							[{opacity: [0, 1], scaleX: 0.3, scaleY: 0.3}, 0.30]
						],
						reset: {scaleX: 1, scaleY: 1}
					},
					/* Animate.css */
					"transition.bounceUpIn": {
						defaultDuration: 800,
						calls: [
							[{opacity: [1, 0], translateY: [-30, 1000]}, 0.60, {easing: "easeOutCirc"}],
							[{translateY: 10}, 0.20],
							[{translateY: 0}, 0.20]
						]
					},
					/* Animate.css */
					"transition.bounceUpOut": {
						defaultDuration: 1000,
						calls: [
							[{translateY: 20}, 0.20],
							[{opacity: [0, "easeInCirc", 1], translateY: -1000}, 0.80]
						],
						reset: {translateY: 0}
					},
					/* Animate.css */
					"transition.bounceDownIn": {
						defaultDuration: 800,
						calls: [
							[{opacity: [1, 0], translateY: [30, -1000]}, 0.60, {easing: "easeOutCirc"}],
							[{translateY: -10}, 0.20],
							[{translateY: 0}, 0.20]
						]
					},
					/* Animate.css */
					"transition.bounceDownOut": {
						defaultDuration: 1000,
						calls: [
							[{translateY: -20}, 0.20],
							[{opacity: [0, "easeInCirc", 1], translateY: 1000}, 0.80]
						],
						reset: {translateY: 0}
					},
					/* Animate.css */
					"transition.bounceLeftIn": {
						defaultDuration: 750,
						calls: [
							[{opacity: [1, 0], translateX: [30, -1250]}, 0.60, {easing: "easeOutCirc"}],
							[{translateX: -10}, 0.20],
							[{translateX: 0}, 0.20]
						]
					},
					/* Animate.css */
					"transition.bounceLeftOut": {
						defaultDuration: 750,
						calls: [
							[{translateX: 30}, 0.20],
							[{opacity: [0, "easeInCirc", 1], translateX: -1250}, 0.80]
						],
						reset: {translateX: 0}
					},
					/* Animate.css */
					"transition.bounceRightIn": {
						defaultDuration: 750,
						calls: [
							[{opacity: [1, 0], translateX: [-30, 1250]}, 0.60, {easing: "easeOutCirc"}],
							[{translateX: 10}, 0.20],
							[{translateX: 0}, 0.20]
						]
					},
					/* Animate.css */
					"transition.bounceRightOut": {
						defaultDuration: 750,
						calls: [
							[{translateX: -30}, 0.20],
							[{opacity: [0, "easeInCirc", 1], translateX: 1250}, 0.80]
						],
						reset: {translateX: 0}
					},
					"transition.slideUpIn": {
						defaultDuration: 900,
						calls: [
							[{opacity: [1, 0], translateY: [0, 20], translateZ: 0}]
						]
					},
					"transition.slideUpOut": {
						defaultDuration: 900,
						calls: [
							[{opacity: [0, 1], translateY: -20, translateZ: 0}]
						],
						reset: {translateY: 0}
					},
					"transition.slideDownIn": {
						defaultDuration: 900,
						calls: [
							[{opacity: [1, 0], translateY: [0, -20], translateZ: 0}]
						]
					},
					"transition.slideDownOut": {
						defaultDuration: 900,
						calls: [
							[{opacity: [0, 1], translateY: 20, translateZ: 0}]
						],
						reset: {translateY: 0}
					},
					"transition.slideLeftIn": {
						defaultDuration: 1000,
						calls: [
							[{opacity: [1, 0], translateX: [0, -20], translateZ: 0}]
						]
					},
					"transition.slideLeftOut": {
						defaultDuration: 1050,
						calls: [
							[{opacity: [0, 1], translateX: -20, translateZ: 0}]
						],
						reset: {translateX: 0}
					},
					"transition.slideRightIn": {
						defaultDuration: 1000,
						calls: [
							[{opacity: [1, 0], translateX: [0, 20], translateZ: 0}]
						]
					},
					"transition.slideRightOut": {
						defaultDuration: 1050,
						calls: [
							[{opacity: [0, 1], translateX: 20, translateZ: 0}]
						],
						reset: {translateX: 0}
					},
					"transition.slideUpBigIn": {
						defaultDuration: 850,
						calls: [
							[{opacity: [1, 0], translateY: [0, 75], translateZ: 0}]
						]
					},
					"transition.slideUpBigOut": {
						defaultDuration: 800,
						calls: [
							[{opacity: [0, 1], translateY: -75, translateZ: 0}]
						],
						reset: {translateY: 0}
					},
					"transition.slideDownBigIn": {
						defaultDuration: 850,
						calls: [
							[{opacity: [1, 0], translateY: [0, -75], translateZ: 0}]
						]
					},
					"transition.slideDownBigOut": {
						defaultDuration: 800,
						calls: [
							[{opacity: [0, 1], translateY: 75, translateZ: 0}]
						],
						reset: {translateY: 0}
					},
					"transition.slideLeftBigIn": {
						defaultDuration: 800,
						calls: [
							[{opacity: [1, 0], translateX: [0, -75], translateZ: 0}]
						]
					},
					"transition.slideLeftBigOut": {
						defaultDuration: 750,
						calls: [
							[{opacity: [0, 1], translateX: -75, translateZ: 0}]
						],
						reset: {translateX: 0}
					},
					"transition.slideRightBigIn": {
						defaultDuration: 800,
						calls: [
							[{opacity: [1, 0], translateX: [0, 75], translateZ: 0}]
						]
					},
					"transition.slideRightBigOut": {
						defaultDuration: 750,
						calls: [
							[{opacity: [0, 1], translateX: 75, translateZ: 0}]
						],
						reset: {translateX: 0}
					},
					/* Magic.css */
					"transition.perspectiveUpIn": {
						defaultDuration: 800,
						calls: [
							[{opacity: [1, 0], transformPerspective: [800, 800], transformOriginX: [0, 0], transformOriginY: ["100%", "100%"], rotateX: [0, -180]}]
						],
						reset: {transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%"}
					},
					/* Magic.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.perspectiveUpOut": {
						defaultDuration: 850,
						calls: [
							[{opacity: [0, 1], transformPerspective: [800, 800], transformOriginX: [0, 0], transformOriginY: ["100%", "100%"], rotateX: -180}]
						],
						reset: {transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%", rotateX: 0}
					},
					/* Magic.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.perspectiveDownIn": {
						defaultDuration: 800,
						calls: [
							[{opacity: [1, 0], transformPerspective: [800, 800], transformOriginX: [0, 0], transformOriginY: [0, 0], rotateX: [0, 180]}]
						],
						reset: {transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%"}
					},
					/* Magic.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.perspectiveDownOut": {
						defaultDuration: 850,
						calls: [
							[{opacity: [0, 1], transformPerspective: [800, 800], transformOriginX: [0, 0], transformOriginY: [0, 0], rotateX: 180}]
						],
						reset: {transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%", rotateX: 0}
					},
					/* Magic.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.perspectiveLeftIn": {
						defaultDuration: 950,
						calls: [
							[{opacity: [1, 0], transformPerspective: [2000, 2000], transformOriginX: [0, 0], transformOriginY: [0, 0], rotateY: [0, -180]}]
						],
						reset: {transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%"}
					},
					/* Magic.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.perspectiveLeftOut": {
						defaultDuration: 950,
						calls: [
							[{opacity: [0, 1], transformPerspective: [2000, 2000], transformOriginX: [0, 0], transformOriginY: [0, 0], rotateY: -180}]
						],
						reset: {transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%", rotateY: 0}
					},
					/* Magic.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.perspectiveRightIn": {
						defaultDuration: 950,
						calls: [
							[{opacity: [1, 0], transformPerspective: [2000, 2000], transformOriginX: ["100%", "100%"], transformOriginY: [0, 0], rotateY: [0, 180]}]
						],
						reset: {transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%"}
					},
					/* Magic.css */
					/* Support: Loses rotation in IE9/Android 2.3 (fades only). */
					"transition.perspectiveRightOut": {
						defaultDuration: 950,
						calls: [
							[{opacity: [0, 1], transformPerspective: [2000, 2000], transformOriginX: ["100%", "100%"], transformOriginY: [0, 0], rotateY: 180}]
						],
						reset: {transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%", rotateY: 0}
					}
				};

		/* Register the packaged effects. */
		for (var effectName in Velocity.RegisterEffect.packagedEffects) {
			if (Velocity.RegisterEffect.packagedEffects.hasOwnProperty(effectName)) {
				Velocity.RegisterEffect(effectName, Velocity.RegisterEffect.packagedEffects[effectName]);
			}
		}

		/*********************
		 Sequence Running
		 **********************/

		/* Note: Sequence calls must use Velocity's single-object arguments syntax. */
		Velocity.RunSequence = function(originalSequence) {
			var sequence = $.extend(true, [], originalSequence);

			if (sequence.length > 1) {
				$.each(sequence.reverse(), function(i, currentCall) {
					var nextCall = sequence[i + 1];

					if (nextCall) {
						/* Parallel sequence calls (indicated via sequenceQueue:false) are triggered
						 in the previous call's begin callback. Otherwise, chained calls are normally triggered
						 in the previous call's complete callback. */
						var currentCallOptions = currentCall.o || currentCall.options,
								nextCallOptions = nextCall.o || nextCall.options;

						var timing = (currentCallOptions && currentCallOptions.sequenceQueue === false) ? "begin" : "complete",
								callbackOriginal = nextCallOptions && nextCallOptions[timing],
								options = {};

						options[timing] = function() {
							var nextCallElements = nextCall.e || nextCall.elements;
							var elements = nextCallElements.nodeType ? [nextCallElements] : nextCallElements;

							if (callbackOriginal) {
								callbackOriginal.call(elements, elements);
							}
							Velocity(currentCall);
						};

						if (nextCall.o) {
							nextCall.o = $.extend({}, nextCallOptions, options);
						} else {
							nextCall.options = $.extend({}, nextCallOptions, options);
						}
					}
				});

				sequence.reverse();
			}

			Velocity(sequence[0]);
		};
	}((__webpack_provided_window_dot_jQuery || window.Zepto || window), window, (window ? window.document : undefined));
}));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = Site;

var _ajaxForm = __webpack_require__(140);

var _ajaxForm2 = _interopRequireDefault(_ajaxForm);

var _customInput = __webpack_require__(98);

var _customInput2 = _interopRequireDefault(_customInput);

var _GoogleMap = __webpack_require__(170);

var _GoogleMap2 = _interopRequireDefault(_GoogleMap);

var _modalMfp = __webpack_require__(173);

var _modalMfp2 = _interopRequireDefault(_modalMfp);

var _mainNav = __webpack_require__(175);

var _mainNav2 = _interopRequireDefault(_mainNav);

var _galleryPhotoswipe = __webpack_require__(176);

var _galleryPhotoswipe2 = _interopRequireDefault(_galleryPhotoswipe);

var _selectComponent = __webpack_require__(32);

var _selectComponent2 = _interopRequireDefault(_selectComponent);

var _Share = __webpack_require__(179);

var _Share2 = _interopRequireDefault(_Share);

var _subnav = __webpack_require__(180);

var _subnav2 = _interopRequireDefault(_subnav);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AUTO_MODULES = [_galleryPhotoswipe2.default];

function Site() {

    var init = function init() {
        startDefault();
        startCustom();
    };

    var startDefault = function startDefault() {
        $.each(AUTO_MODULES, function (key, Module) {
            var instance = Module();
            instance.start();
        });
    };

    var startCustom = function startCustom() {

        (0, _selectComponent2.default)('ajax-form').each(function (index, element) {
            return new _ajaxForm2.default(element);
        });

        var mapIcon = {
            path: 'M1152 640q0-106-75-181t-181-75-181 75-75 181 75 181 181 75 181-75 75-181zm256 0q0 109-33 179l-364 774q-16 33-47.5 52t-67.5 19-67.5-19-46.5-52l-365-774q-33-70-33-179 0-212 150-362t362-150 362 150 150 362z',
            fillColor: '#000',
            fillOpacity: 1,
            strokeOpacity: 1,
            scale: .02,
            anchor: new google.maps.Point(896, 1792)
        };

        var imageOverlays = [{
            northEast: {
                "lat": 38.2665,
                "lng": -85.6277
            },
            southWest: {
                "lat": 38.229607,
                "lng": -85.720607
            },
            image: 'http://via.placeholder.com/400x200',
            showBounds: true,
            importSVG: false
        }];

        (0, _selectComponent2.default)('locations-map').each(function (index, element) {
            return new _GoogleMap2.default(index, element, { locations: window.LOCATIONS, icon: mapIcon, imageOverlays: imageOverlays });
        });

        (0, _selectComponent2.default)('toggle-nav').each(function (index, element) {
            return new Nav(element);
        });

        (0, _selectComponent2.default)('select').each(function (index, element) {
            return new _customInput2.default(element);
        });

        (0, _selectComponent2.default)('ajax-form').each(function (index, element) {
            return new _ajaxForm2.default(element);
        });

        (0, _selectComponent2.default)('main-nav').each(function (index, element) {
            return new _mainNav2.default(element);
        });

        (0, _selectComponent2.default)('share').each(function (index, element) {
            return new _Share2.default(element);
        });
    };

    return {
        init: init
    };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _selectComponent = __webpack_require__(32);

var _selectComponent2 = _interopRequireDefault(_selectComponent);

var _customInput = __webpack_require__(98);

var _customInput2 = _interopRequireDefault(_customInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var baseClass = 'form';

var AjaxForm = function () {
    function AjaxForm(element) {
        var _this = this;

        _classCallCheck(this, AjaxForm);

        this.completeClass = baseClass + '--is-complete';
        this.disabledClass = baseClass + '--is-disabled';
        this.activeClass = baseClass + '--is-active';
        this.loadingClass = baseClass + '--is-loading';
        this.fieldsSelector = '[data-component="input"]';
        this.inputs = {};

        this.handleError = function (jqXHR, textStatus, errorThrown) {
            var errorObject = jqXHR.responseJSON ? jqXHR.responseJSON.errors : false;

            if (errorObject) {

                $.each(errorObject, function (key, value) {
                    if ($.type(value) === 'string') {
                        value = [value][0];
                    }

                    _this.inputs[key].setError(value.join('<br />'));
                });

                var $firstError = _this.$form.find('.input__error').filter('.' + _this.activeClass).first();

                if ($firstError.length) {
                    var inputName = $firstError.attr('for');

                    _this.inputs[inputName].$component.velocity('scroll', {
                        offset: -200,
                        duration: 350,
                        complete: function complete() {
                            _this.$form.find('#' + inputName).focus();
                        }
                    });
                }
            }
        };

        this.handleSuccess = function (data, textStatus, jqXHR) {
            _this.$form.addClass(_this.completeClass);

            $.each(_this.inputs, function (name, field) {
                return field.disable();
            });

            _this.$form.elements.submit.attr('disabled', 'disabled');

            _this.$form.elements.successMessage.append($('<p />', {
                'text': data.message
            }));

            _this.$form.velocity({
                opacity: .8
            }, {
                duration: 1500,
                easing: 'easeOutCubic'
            }).velocity({
                opacity: 1
            }, {
                begin: function begin() {
                    _this.$form.elements.successMessage.velocity('transition.slideUpIn');
                },
                complete: function complete() {
                    _this.$form.removeAttr('styles');
                },
                duration: 750,
                easing: [1000, 20]
            });
        };

        this.handleRequestStart = function () {
            _this.resetErrors();

            _this.$form.elements.submit.attr('disabled', 'disabled').addClass(_this.loadingClass);

            _this.$form.addClass(_this.disabledClass);
        };

        this.handleRequestEnd = function () {
            _this.$form.elements.submit.attr('disabled', false).removeClass(_this.loadingClass);

            _this.$form.removeClass(_this.disabledClass);
        };

        this.handleSubmit = function (event) {
            event.preventDefault();

            if (_this.$form.hasClass(_this.disabledClass)) {
                return;
            }

            var data = new FormData(_this.$form[0]);
            var url = _this.$form.attr('action');

            _this.handleRequestStart();

            $.ajax({
                url: url,
                type: 'POST',
                data: data,
                processData: false,
                contentType: false
            }).always(_this.handleRequestEnd).then(_this.handleSuccess).fail(_this.handleError);
        };

        this.$form = (0, _selectComponent2.default)(element);

        this.buildInputs();
        this.createSuccessElement();

        this.$form.attr('novalidate', true).on('submit', this.handleSubmit);
    }

    _createClass(AjaxForm, [{
        key: 'buildInputs',
        value: function buildInputs() {
            var _this2 = this;

            this.$form.find(this.fieldsSelector).each(function (index, element) {
                var input = new _customInput2.default(element);

                _this2.inputs[input.getName()] = input;
            });
        }
    }, {
        key: 'createSuccessElement',
        value: function createSuccessElement() {
            if (!this.$form.elements.successMessage) {
                this.$form.append($('<div />', {
                    'class': 'form__success',
                    'data-element': 'success-message'
                }));

                this.$form.refresh();
            }
        }
    }, {
        key: 'resetErrors',
        value: function resetErrors() {
            $.each(this.inputs, function (name, field) {
                return field.removeError();
            });
        }
    }]);

    return AjaxForm;
}();

exports.default = AjaxForm;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var capitalize = __webpack_require__(142),
    createCompounder = __webpack_require__(160);

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

module.exports = camelCase;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(51),
    upperFirst = __webpack_require__(153);

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

module.exports = capitalize;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(67),
    arrayMap = __webpack_require__(146),
    isArray = __webpack_require__(147),
    isSymbol = __webpack_require__(148);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(145);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(68)))

/***/ }),
/* 146 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(149),
    isObjectLike = __webpack_require__(152);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(67),
    getRawTag = __webpack_require__(150),
    objectToString = __webpack_require__(151);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(67);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 151 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var createCaseFirst = __webpack_require__(154);

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var castSlice = __webpack_require__(155),
    hasUnicode = __webpack_require__(97),
    stringToArray = __webpack_require__(157),
    toString = __webpack_require__(51);

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var baseSlice = __webpack_require__(156);

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var asciiToArray = __webpack_require__(158),
    hasUnicode = __webpack_require__(97),
    unicodeToArray = __webpack_require__(159);

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


/***/ }),
/* 158 */
/***/ (function(module, exports) {

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


/***/ }),
/* 159 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var arrayReduce = __webpack_require__(161),
    deburr = __webpack_require__(162),
    words = __webpack_require__(165);

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;


/***/ }),
/* 161 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var deburrLetter = __webpack_require__(163),
    toString = __webpack_require__(51);

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var basePropertyOf = __webpack_require__(164);

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;


/***/ }),
/* 164 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var asciiWords = __webpack_require__(166),
    hasUnicodeWord = __webpack_require__(167),
    toString = __webpack_require__(51),
    unicodeWords = __webpack_require__(168);

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),
/* 166 */
/***/ (function(module, exports) {

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;


/***/ }),
/* 167 */
/***/ (function(module, exports) {

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;


/***/ }),
/* 168 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
    rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	Autosize 3.0.21
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
		factory(exports, module);
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports, mod);
		global.autosize = mod.exports;
	}
})(this, function (exports, module) {
	'use strict';

	var map = typeof Map === "function" ? new Map() : (function () {
		var keys = [];
		var values = [];

		return {
			has: function has(key) {
				return keys.indexOf(key) > -1;
			},
			get: function get(key) {
				return values[keys.indexOf(key)];
			},
			set: function set(key, value) {
				if (keys.indexOf(key) === -1) {
					keys.push(key);
					values.push(value);
				}
			},
			'delete': function _delete(key) {
				var index = keys.indexOf(key);
				if (index > -1) {
					keys.splice(index, 1);
					values.splice(index, 1);
				}
			}
		};
	})();

	var createEvent = function createEvent(name) {
		return new Event(name, { bubbles: true });
	};
	try {
		new Event('test');
	} catch (e) {
		// IE does not support `new Event()`
		createEvent = function (name) {
			var evt = document.createEvent('Event');
			evt.initEvent(name, true, false);
			return evt;
		};
	}

	function assign(ta) {
		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

		var heightOffset = null;
		var clientWidth = ta.clientWidth;
		var cachedHeight = null;

		function init() {
			var style = window.getComputedStyle(ta, null);

			if (style.resize === 'vertical') {
				ta.style.resize = 'none';
			} else if (style.resize === 'both') {
				ta.style.resize = 'horizontal';
			}

			if (style.boxSizing === 'content-box') {
				heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
			} else {
				heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
			}
			// Fix when a textarea is not on document body and heightOffset is Not a Number
			if (isNaN(heightOffset)) {
				heightOffset = 0;
			}

			update();
		}

		function changeOverflow(value) {
			{
				// Chrome/Safari-specific fix:
				// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
				// made available by removing the scrollbar. The following forces the necessary text reflow.
				var width = ta.style.width;
				ta.style.width = '0px';
				// Force reflow:
				/* jshint ignore:start */
				ta.offsetWidth;
				/* jshint ignore:end */
				ta.style.width = width;
			}

			ta.style.overflowY = value;
		}

		function getParentOverflows(el) {
			var arr = [];

			while (el && el.parentNode && el.parentNode instanceof Element) {
				if (el.parentNode.scrollTop) {
					arr.push({
						node: el.parentNode,
						scrollTop: el.parentNode.scrollTop
					});
				}
				el = el.parentNode;
			}

			return arr;
		}

		function resize() {
			var originalHeight = ta.style.height;
			var overflows = getParentOverflows(ta);
			var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

			ta.style.height = 'auto';

			var endHeight = ta.scrollHeight + heightOffset;

			if (ta.scrollHeight === 0) {
				// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
				ta.style.height = originalHeight;
				return;
			}

			ta.style.height = endHeight + 'px';

			// used to check if an update is actually necessary on window.resize
			clientWidth = ta.clientWidth;

			// prevents scroll-position jumping
			overflows.forEach(function (el) {
				el.node.scrollTop = el.scrollTop;
			});

			if (docTop) {
				document.documentElement.scrollTop = docTop;
			}
		}

		function update() {
			resize();

			var styleHeight = Math.round(parseFloat(ta.style.height));
			var computed = window.getComputedStyle(ta, null);

			// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
			var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

			// The actual height not matching the style height (set via the resize method) indicates that
			// the max-height has been exceeded, in which case the overflow should be allowed.
			if (actualHeight !== styleHeight) {
				if (computed.overflowY === 'hidden') {
					changeOverflow('scroll');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			} else {
				// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
				if (computed.overflowY !== 'hidden') {
					changeOverflow('hidden');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			}

			if (cachedHeight !== actualHeight) {
				cachedHeight = actualHeight;
				var evt = createEvent('autosize:resized');
				try {
					ta.dispatchEvent(evt);
				} catch (err) {
					// Firefox will throw an error on dispatchEvent for a detached element
					// https://bugzilla.mozilla.org/show_bug.cgi?id=889376
				}
			}
		}

		var pageResize = function pageResize() {
			if (ta.clientWidth !== clientWidth) {
				update();
			}
		};

		var destroy = (function (style) {
			window.removeEventListener('resize', pageResize, false);
			ta.removeEventListener('input', update, false);
			ta.removeEventListener('keyup', update, false);
			ta.removeEventListener('autosize:destroy', destroy, false);
			ta.removeEventListener('autosize:update', update, false);

			Object.keys(style).forEach(function (key) {
				ta.style[key] = style[key];
			});

			map['delete'](ta);
		}).bind(ta, {
			height: ta.style.height,
			resize: ta.style.resize,
			overflowY: ta.style.overflowY,
			overflowX: ta.style.overflowX,
			wordWrap: ta.style.wordWrap
		});

		ta.addEventListener('autosize:destroy', destroy, false);

		// IE9 does not fire onpropertychange or oninput for deletions,
		// so binding to onkeyup to catch most of those events.
		// There is no way that I know of to detect something like 'cut' in IE9.
		if ('onpropertychange' in ta && 'oninput' in ta) {
			ta.addEventListener('keyup', update, false);
		}

		window.addEventListener('resize', pageResize, false);
		ta.addEventListener('input', update, false);
		ta.addEventListener('autosize:update', update, false);
		ta.style.overflowX = 'hidden';
		ta.style.wordWrap = 'break-word';

		map.set(ta, {
			destroy: destroy,
			update: update
		});

		init();
	}

	function destroy(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.destroy();
		}
	}

	function update(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.update();
		}
	}

	var autosize = null;

	// Do nothing in Node.js environment and IE8 (or lower)
	if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
		autosize = function (el) {
			return el;
		};
		autosize.destroy = function (el) {
			return el;
		};
		autosize.update = function (el) {
			return el;
		};
	} else {
		autosize = function (el, options) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], function (x) {
					return assign(x, options);
				});
			}
			return el;
		};
		autosize.destroy = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], destroy);
			}
			return el;
		};
		autosize.update = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], update);
			}
			return el;
		};
	}

	module.exports = autosize;
});

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _selectComponent = __webpack_require__(32);

var _selectComponent2 = _interopRequireDefault(_selectComponent);

var _BaseMap = __webpack_require__(171);

var _BaseMap2 = _interopRequireDefault(_BaseMap);

var _Overlay = __webpack_require__(172);

var _Overlay2 = _interopRequireDefault(_Overlay);

__webpack_require__(69);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GoogleMap = function () {

    // Optional array of object for image overlays
    // - supports SVGs or bitmap images,
    //   using importSVG to embed the SVG directly
    // - optional showBounds to provide outline to
    //   help with image placement


    function GoogleMap() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var element = arguments[1];
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, GoogleMap);

        this.infoWindowTemplate = function (location) {
            return '\n        <div class="info-window">\n            <div class="info-window__content">\n                <h4 class="info-window__location">' + location.title + '</h4>\n                ' + ((location.phone || location.fax) && '\n                    <div class="info-window__meta">\n                        ' + (location.phone && '\n                            <label class="info-window__label">Tel</label>\n                            <a href="tel:' + location.phone + '" class="info-window__phone">' + location.phone + '</a>\n                        ') + '\n                        ' + (location.fax && '\n                            <label class="info-window__label">Fax</label>\n                            <a href="tel:' + location.fax + '" class="info-window__phone">' + location.fax + '</a>\n                        ') + '\n                    </div>\n                ') + '\n                <address class="info-window__address">\n                    ' + location.address1 + '\n                    <br />\n                    ' + location.city + ', ' + location.state + ' ' + location.zip + '\n                    <br />\n                    ' + location.country + '\n                </address>\n            </div>\n        </div>\n    ';
        };

        this.$component = (0, _selectComponent2.default)(element);
        this.$map = this.$component.elements.map;
        this.icon = options.icon;
        this.locations = options.locations;
        this.index = index;
        this.imageOverlays = options.imageOverlays;

        this.mapDefaults = {
            center: {
                lat: parseFloat(this.$map.data('lat')),
                lng: parseFloat(this.$map.data('lng'))
            },
            mapTypeControl: false,
            streetViewControl: false,
            zoom: parseFloat(this.$map.data('zoom')),
            zoomControlOptions: {
                position: google.maps.ControlPosition.LEFT_BOTTOM
            }
        };

        this.mapOptions = _extends({}, this.mapDefaults, options.mapConfig);

        this.initMap();
    }

    _createClass(GoogleMap, [{
        key: 'initMap',
        value: function initMap() {
            this.googleMap = new _BaseMap2.default(this.$map[0], this.mapOptions);
            this.infoWindow = new google.maps.InfoWindow();
            this.setCenterPoint(this.$map.data('lat'), this.$map.data('lng'));

            if (this.locations && this.locations.length) {
                this.addLocations();
            }

            if (this.imageOverlays) {
                this.createOverlays();
            }

            this.bindEvents();
        }
    }, {
        key: 'bindEvents',
        value: function bindEvents() {
            var _this = this;

            if (this.$component.elements.control) {
                this.initCustomControls();
            }

            if (this.$component.elements.select) {
                this.initCustomSelects();
            }

            this.$component.on('addedOverlay', function () {
                _this.$component.refresh();
            });

            $(window).on('debouncedresize.googleMap-' + this.index, function () {
                return _this.recenterMap();
            });
        }
    }, {
        key: 'unbindEvents',
        value: function unbindEvents() {
            $(window).off('.googleMap-' + this.index);

            this.$component.off();

            if (this.$component.elements.control) {
                this.$component.elements.control.off();
            }

            if (this.$component.elements.select) {
                this.$component.elements.select.off();
            }
        }
    }, {
        key: 'destroyMap',
        value: function destroyMap() {
            // This deletes the map and unbinds its events, but does not unbind
            // Google Map API events, they'll stay in the memory until JS garbage collection
            // removes them. This is a known issue with Google Maps.

            this.unbindEvents();
            this.$component.remove();
        }
    }, {
        key: 'recenterMap',
        value: function recenterMap() {
            this.googleMap.panToLocation(this.centerPoint.lat(), this.centerPoint.lng());
            this.$map.removeAttr('style');
            this.googleMap.refresh();
        }
    }, {
        key: 'setCenterPoint',
        value: function setCenterPoint(lat, lng) {
            this.centerPoint = this.googleMap.setLatLng(parseFloat(lat), parseFloat(lng));
        }
    }, {
        key: 'addLocations',
        value: function addLocations() {
            var _this2 = this;

            this.locations.forEach(function (location) {
                _this2.googleMap.addMarker({
                    lat: location.lat,
                    lng: location.lng,
                    icon: _this2.icon,
                    infoWindowTemplate: _this2.infoWindowTemplate,
                    infoWindowFields: location
                });
            });
        }
    }, {
        key: 'createOverlays',
        value: function createOverlays() {
            var _this3 = this;

            this.imageOverlays.forEach(function (location) {
                var bounds = new google.maps.LatLngBounds(new google.maps.LatLng(location.southWest.lat, location.southWest.lng), new google.maps.LatLng(location.northEast.lat, location.northEast.lng));

                return new _Overlay2.default(bounds, location.image, _this3.googleMap, location.showBounds, location.importSVG);
            });
        }
    }, {
        key: 'initCustomSelects',
        value: function initCustomSelects() {
            var _this4 = this;

            this.$component.elements.select.each(function (index, element) {
                var $control = $(element);

                $control.on('change', function () {
                    var $option = $control.find('option:selected');
                    _this4.setMapPosition($option);
                    _this4.activeControl = $option.val().trim();
                    _this4.setActiveControls();
                    _this4.setCenterPoint($option.data('lat'), $option.data('lng'));
                });
            });
        }
    }, {
        key: 'initCustomControls',
        value: function initCustomControls() {
            var _this5 = this;

            this.$component.elements.control.each(function (index, element) {
                var $control = $(element);

                $control.on('click', function () {
                    _this5.setMapPosition($control);
                    _this5.activeControl = $control.text().trim();
                    _this5.setActiveControls();
                    _this5.setCenterPoint($control.data('lat'), $control.data('lng'));
                });
            });
        }
    }, {
        key: 'setActiveControls',
        value: function setActiveControls() {
            var _this6 = this;

            var $controls = this.$component.elements.control;
            var $selects = this.$component.elements.select;
            $controls.attr('data-status', 'off');

            if ($controls) {
                $controls.each(function (index, element) {
                    if ($(element).text().trim() == _this6.activeControl) {
                        $(element).attr('data-status', 'on');
                    }
                });
            }

            if ($selects) {
                var option = $selects.find('option:contains(' + this.activeControl + ')');
                option.parent('select').val(this.activeControl);
            }
        }
    }, {
        key: 'setMapPosition',
        value: function setMapPosition(control) {
            var $control = control;
            var controlLat = parseFloat($control.data('lat'));
            var controlLng = parseFloat($control.data('lng'));
            var controlZoom = this.mapOptions.zoom;

            if ($control.data('zoom')) {
                controlZoom = $control.data('zoom');
            }

            if (controlLat && controlLng) {
                this.googleMap.panToLocation(controlLat, controlLng);
                this.googleMap.setZoomAmount(controlZoom);
                this.$component.elements.control.attr('data-status', 'off');
                $control.attr('data-status', 'on');
            }
        }
    }]);

    return GoogleMap;
}();

exports.default = GoogleMap;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Creates JS class out of Google Map API

var BaseMap = function () {
    function BaseMap(mapElement) {
        var _this = this;

        var mapOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, BaseMap);

        this.markers = [];
        this.markerBounds = new google.maps.LatLngBounds();
        this.mapOptionsDefaults = {
            zoom: 12,
            scrollwheel: false
        };
        this.mapCenterDefaults = {
            lat: 38.232069,
            lng: -85.742059
        };

        this.map = this.initMap(mapElement, mapOptions);
        this.getMap = function () {
            return _this.map;
        };
    }

    _createClass(BaseMap, [{
        key: 'initMap',
        value: function initMap(mapElement, mapOptions) {
            if ((typeof google === 'undefined' ? 'undefined' : _typeof(google)) !== 'object') {
                throw new Error('Google Maps JavaScript API is required.');
            }

            mapOptions = _extends({}, this.mapOptionsDefaults, mapOptions);

            if (!mapOptions.hasOwnProperty('center')) {
                mapOptions.center = new google.maps.LatLng(this.mapCenterDefaults.lat, this.mapCenterDefaults.lng);
            }

            return new google.maps.Map(mapElement, mapOptions);
        }
    }, {
        key: 'setStyles',
        value: function setStyles(styles) {
            this.map.mapTypes.set('styled_map', new google.maps.StyledMapType(styles));
            this.map.setMapTypeId('styled_map');
        }

        /**
         * Adds a new location marker to the map. Custom markup for info windows should be passed in as
         * a function that returns a template literal.
         *
         * Example Usage:
         *
         * var locationFields = {
         *      title: 'Location Name',
         *      message: 'Location information'
         * }
         *
         * var locationTemplate = fields => `
         *      <h2>${fields.title}</h2>
         *      <p>${fields.message}</p>
         * `
         *
         * googleMaps.addLocation(123, 456, locationTemplate, locationFields, '/path/to/icon.png')
         *
         *
         * @param {number} lat
         * @param {number} lng
         * @param {string} (optional) infoWindowTemplate - Mustache.js formatted template for info window markup
         * @param {object} (optional) infoWindowFields - object used to fill in the template's data
         * @param {string} (optional) icon - URL path to the custom map tack icon for this location
         *
         * @return {void}
         */

    }, {
        key: 'addMarker',
        value: function addMarker(_ref) {
            var lat = _ref.lat,
                lng = _ref.lng,
                infoWindowTemplate = _ref.infoWindowTemplate,
                infoWindowFields = _ref.infoWindowFields,
                icon = _ref.icon;

            var markerCenter = new google.maps.LatLng(lat, lng);
            var map = this.map;
            var markerParams = {
                position: markerCenter,
                map: map
            };

            if (icon) {
                markerParams.icon = icon;
            }

            var marker = new google.maps.Marker(markerParams);

            // Add an info window only if infoWindowTemplate is defined
            if (infoWindowTemplate) {
                var infoWindowMarkup = infoWindowTemplate(infoWindowFields);
                var infoWindow = new google.maps.InfoWindow({
                    content: infoWindowMarkup,
                    enableEventPropagation: true,
                    disableAutoPan: false,
                    maxWidth: 150,
                    zIndex: null,
                    closeBoxURL: '/assets/images/icons/close.svg'
                });

                google.maps.event.addListener(marker, 'click', function () {
                    infoWindow.open(map, marker);
                }.bind(this));
            }

            this.markerBounds.extend(marker.position);
            this.markers.push(marker);
        }
    }, {
        key: 'fitMarkerBounds',
        value: function fitMarkerBounds() {
            this.map.fitBounds(this.markerBounds);
        }
    }, {
        key: 'panToLocation',
        value: function panToLocation(lat, lng) {
            var markerLocation = new google.maps.LatLng(lat, lng);
            this.map.panTo(markerLocation);
        }
    }, {
        key: 'setZoomAmount',
        value: function setZoomAmount(zoom) {
            this.map.setZoom(zoom);
        }

        /**
         * Fits the map bounds to a radius (in miles) around a given center point
         *
         * @param {number} lat
         * @param {number} lng
         * @param {number} distance - map bounds radius in miles
         *
         * @return {void}
         */

    }, {
        key: 'fitRadiusBounds',
        value: function fitRadiusBounds(lat, lng, distance) {
            var circle = new google.maps.Circle({
                center: new google.maps.LatLng(lat, lng),
                radius: distance * 1609.34 / 2,
                visible: false
            });

            this.map.fitBounds(circle.getBounds());
        }

        /**
         * Clears all markers from the map
         *
         * @return {void}
         */

    }, {
        key: 'clearMarkers',
        value: function clearMarkers() {
            for (var i = 0; i < this.markers.length; i++) {
                this.markers[i].setMap(null);
            }

            this.markers = [];
        }
    }, {
        key: 'geolocate',
        value: function geolocate() {
            return new Promise(function (resolve, reject) {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(function (position) {
                        resolve({
                            byIP: false,
                            coordinates: {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            }
                        });
                    }, function () {
                        resolve({ byIP: true });
                    });
                } else {
                    resolve({ byIP: true });
                }
            });
        }
    }, {
        key: 'createListener',
        value: function createListener(event, listenerFunction) {
            this.map.addListener(event, listenerFunction);
        }
    }, {
        key: 'geolocateByIP',
        value: function geolocateByIP(fallbackEndpoint) {
            return new Promise(function (resolve, reject) {
                $.ajax({
                    url: fallbackEndpoint,
                    success: function success(data) {
                        resolve({
                            coordinates: $.parseJSON(data)
                        });
                    },
                    error: function error(data) {
                        resolve({
                            coordinates: undefined
                        });
                    }
                });
            });
        }

        /**
         * Uses geo-location to find the user's lat/lng coordinates. Uses browser-based
         * location if possible, falls back to server-side geo-location using IP address.
         *
         * The method expects a callback function as the second argument to handle the
         * user's coordinates.
         *
         * Example Usage:
         *
         * googleMaps.getUserLatLng('/path/to/fallback.php', function(coords) {
         *     console.log(coords.lat) // 123
         *     console.log(coords.lng) // 456
         * })
         *
         *
         * @param {string} fallbackEndpoint   - URL path to server-side script that processes IP-based geo-location.
         *                                      NOTE: the script should return a JSON object in the format { 'lat': 123, 'lng': 456 }
         *
         * @param {function} successCallback  - callback function to handle user's coordinates. Receives a coordinate object
         *                                      in the format { lat: 123, lng: 456 }
         *
         * @return {void}
         */

    }, {
        key: 'getUserLatLng',
        value: function getUserLatLng(fallbackEndpoint, successCallback) {
            var _this2 = this;

            this.geolocate().then(function (data) {
                if (data.byIP) {
                    _this2.geolocateByIP(fallbackEndpoint).then(function (data) {
                        successCallback(data.coordinates);
                    });
                } else {
                    successCallback(data.coordinates);
                }
            });
        }

        /**
         * Retrieves lat and lng values from a given address or postal code.
         *
         * The method expects a callback function as the second argument to handle the
         * retrieved coordinates.
         *
         * Example Usage:
         *
         * googleMaps.getLatLngFromAddress('40217', function(coords) {
         *     console.log(coords.lat) // 38.2131874
         *     console.log(coords.lng) // -85.74102619999996
         * }, function() {
         *     console.log('Error finding coordinates')
         * })
         *
         *
         * @param {string} address            - Address or ZIP string that Google will use to determine coordinates
         *
         * @param {function} successCallback  - callback function to handle coordinates. Passed a coordinate object
         *                                      in the format { lat: 123, lng: 456 }
         *
         * @param {function} errorCallback    - callback function called when geocoder fails to find lat/lng values
         *
         * @return {void}
         */

    }, {
        key: 'getLatLngFromAddress',
        value: function getLatLngFromAddress(address, successCallback, errorCallback) {
            var geocoder = new google.maps.Geocoder();

            geocoder.geocode({
                address: address
            }, function (data) {
                if (data.length) {
                    var lat = data[0].geometry.location.lat();
                    var lng = data[0].geometry.location.lng();
                    successCallback({ lat: lat, lng: lng });
                } else {
                    errorCallback();
                }
            });
        }

        /**
         * Retrieves an array of addresses near a given coordinate.
         *
         *
         * Example Usage:
         *
         * googleMaps.getAddressesFromLatLng(38.2131874, -85.74102619999996, function(addresses) {
         *     console.log(addresses.length) // 10
         * }, function() {
         *     console.log('No addresses found')
         * })
         *
         *
         * @param {number} lat
         * @param {number} lng
         * @param {function} successCallback  - callback function to handle retrieved addresses. Passed an array of address data
         * @param {function} errorCallback    - callback function to handle when no addresses are found at given coordinates
         *
         * @return {void}
         */

    }, {
        key: 'getAddressesFromLatLng',
        value: function getAddressesFromLatLng(lat, lng, successCallback, errorCallback) {
            var geocoder = new google.maps.Geocoder();

            geocoder.geocode({
                location: new google.maps.LatLng(lat, lng)
            }, function (addresses) {
                if (addresses.length) {
                    successCallback(addresses);
                } else {
                    errorCallback();
                }
            });
        }
    }, {
        key: 'setPoint',
        value: function setPoint(x, y) {
            var ne = this.map.getBounds().getNorthEast();
            var sw = this.map.getBounds().getSouthWest();
            var projection = this.map.getProjection();
            var topRight = projection.fromLatLngToPoint(ne);
            var bottomLeft = projection.fromLatLngToPoint(sw);
            var scale = 1 << this.map.getZoom();

            var position = projection.fromPointToLatLng(new google.maps.Point(x / scale + bottomLeft.x, y / scale + topRight.y));

            return position;
        }
    }, {
        key: 'setLatLng',
        value: function setLatLng(lat, lng) {
            return new google.maps.LatLng(lat, lng);
        }
    }, {
        key: 'refresh',
        value: function refresh() {
            google.maps.event.trigger(this.map, 'resize');
        }
    }]);

    return BaseMap;
}();

exports.default = BaseMap;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GoogleMapOverlay = function (_google$maps$OverlayV) {
    _inherits(GoogleMapOverlay, _google$maps$OverlayV);

    function GoogleMapOverlay(bounds, image, mapObject) {
        var showBounds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var importSVG = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        _classCallCheck(this, GoogleMapOverlay);

        var _this = _possibleConstructorReturn(this, (GoogleMapOverlay.__proto__ || Object.getPrototypeOf(GoogleMapOverlay)).call(this));

        _this.bounds = bounds;
        _this.image = image;
        _this.map = mapObject.map;
        _this.container = null;
        _this.showBounds = showBounds;
        _this.containerBorder;
        _this.importSVG = importSVG;

        _this.setMap(_this.map);
        return _this;
    }

    _createClass(GoogleMapOverlay, [{
        key: 'onAdd',
        value: function onAdd() {
            var panes = this.getPanes();

            this.$imageContainer = $('<div/>').css({
                'position': 'absolute'
            }).appendTo(panes.overlayMouseTarget);

            if (this.showBounds) {
                this.addContainerBorder();
            }

            if (this.importSVG) {
                var $image = $(this.image, {}).css({
                    'width': '100%',
                    'height': '100%',
                    'position': 'absolute'
                }).appendTo(this.$imageContainer).trigger('addedOverlay');
            } else {
                var _$image = $('<img/>', {
                    src: this.image
                }).css({
                    'width': '100%',
                    'height': '100%',
                    'position': 'absolute'
                }).appendTo(this.$imageContainer);
            }
        }
    }, {
        key: 'addContainerBorder',
        value: function addContainerBorder() {
            this.$imageContainer.css({
                'border': '1px solid red'
            });
        }
    }, {
        key: 'draw',
        value: function draw() {
            var overlayProjection = this.getProjection();
            var sw = overlayProjection.fromLatLngToDivPixel(this.bounds.getSouthWest());
            var ne = overlayProjection.fromLatLngToDivPixel(this.bounds.getNorthEast());

            this.$imageContainer.css({
                'left': sw.x + 'px',
                'top': ne.y + 'px',
                'width': ne.x - sw.x + 'px',
                'height': sw.y - ne.y + 'px'
            });
        }
    }, {
        key: 'onRemove',
        value: function onRemove() {
            this.$imageContainer[0].parentNode.removeChild(this.$imageContainer[0]);
            this.$imageContainer = null;
        }
    }]);

    return GoogleMapOverlay;
}(google.maps.OverlayView);

exports.default = GoogleMapOverlay;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * Modals using Magnific Popup.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * AJAX MODALS:
                                                                                                                                                                                                                                                                   * Will create Ajax-based modals from links by default. Currently, default HTML would be:
                                                                                                                                                                                                                                                                   * <a href="/path/to/page" data-action="modal-mfp" data-fragment="#fragment">Foo</a>
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * INLINE MODALS:
                                                                                                                                                                                                                                                                   * Modals from in-page content can be created by using type: 'inline'.
                                                                                                                                                                                                                                                                   * Default HTML would be:
                                                                                                                                                                                                                                                                   * <a href="/path/to/fallback/page" data-action="modal-mfp" data-mfp-src="#id-of-content">
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * IMAGE MODALS:
                                                                                                                                                                                                                                                                   * Use type: image
                                                                                                                                                                                                                                                                   * <a href="/path/to/image" data-action="modal-mfp">Image type</a>
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * GALLERY MODAL:
                                                                                                                                                                                                                                                                   * Use type: gallery
                                                                                                                                                                                                                                                                   * <div class="gallery">
                                                                                                                                                                                                                                                                   * 	   <a data-action="modal-mfp" href="/path/to/full/image/1"><img src="/path/to/thumbnail/image/1" alt="1"></a>
                                                                                                                                                                                                                                                                   * 	   <a data-action="modal-mfp" href="/path/to/full/image/2"><img src="/path/to/thumbnail/image/2" alt="2"></a>
                                                                                                                                                                                                                                                                   * 	   <a data-action="modal-mfp" href="/path/to/full/image/3"><img src="/path/to/thumbnail/image/3" alt="3"></a>
                                                                                                                                                                                                                                                                   * 	   <a data-action="modal-mfp" href="/path/to/full/image/4"><img src="/path/to/thumbnail/image/4" alt="4"></a>
                                                                                                                                                                                                                                                                   * 	   <a data-action="modal-mfp" href="/path/to/full/image/5"><img src="/path/to/thumbnail/image/5" alt="5"></a>
                                                                                                                                                                                                                                                                   * </div>
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * For all other types, pass your custom MFP options to the module's init() function.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * @todo add beforeOpen callback so effect could be a data attribute
                                                                                                                                                                                                                                                                   * @module modal-mfp
                                                                                                                                                                                                                                                                   */

exports.default = ModalMFP;

var _base = __webpack_require__(99);

var _base2 = _interopRequireDefault(_base);

__webpack_require__(174);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ModalMFP(args) {

	/**
  * Plugin defaults / Base constructor
  * ----------------------------------------------------------- */
	var DEFAULT = {
		name: 'Modal (Magnific Popup)',
		el: '[data-action="modal-mfp"]',
		type: 'ajax'
	};

	var settings = _base2.default.construct(DEFAULT, args);

	var action = function action() {
		//console.log(settings.type);


		if (settings.type == 'ajax') {
			this.args = {
				type: 'ajax',
				src: $(this).attr('href'),
				callbacks: {
					parseAjax: function parseAjax(r) {
						//http://stackoverflow.com/questions/18265294/magnific-popup-ajax-call-for-html-fragment
						var mp = $.magnificPopup.instance,
						    $trigger = $(mp.currItem.el[0]),
						    fragment = $trigger.attr('data-fragment');

						if (fragment === undefined) {
							r.data = $(r.data);
						} else {
							r.data = $(r.data).filter(fragment);
						}
					}
				},
				removalDelay: 500,
				mainClass: 'mfp-zoom-in',
				closeBtnInside: true
			};
		}

		if (settings.type == 'inline') {
			this.args = {
				type: 'inline'
			};
		}

		if (settings.type == 'image') {
			this.args = {
				type: 'image'
			};
		}

		if (settings.type == 'gallery') {
			this.args = {
				type: 'image',
				gallery: {
					enabled: true
				}
			};
		}

		$(settings.el).magnificPopup(this.args);
	};

	/**
  * Method exporter
  * ----------------------------------------------------------- */
	var publicExports = {
		action: action
	};

	return _extends(_base2.default, publicExports);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! Magnific Popup - v1.0.0 - 2014-12-12
* http://dimsemenov.com/plugins/magnific-popup/
* Copyright (c) 2014 Dmitry Semenov; */
(function (e) {
   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? e(require("jquery")) : e(window.jQuery || window.Zepto);
})(function (e) {
  var t,
      n,
      i,
      o,
      r,
      a,
      s,
      l = "Close",
      c = "BeforeClose",
      d = "AfterClose",
      u = "BeforeAppend",
      p = "MarkupParse",
      f = "Open",
      m = "Change",
      g = "mfp",
      h = "." + g,
      v = "mfp-ready",
      C = "mfp-removing",
      y = "mfp-prevent-close",
      w = function w() {},
      b = !!__webpack_provided_window_dot_jQuery,
      I = e(window),
      x = function x(e, n) {
    t.ev.on(g + e + h, n);
  },
      k = function k(t, n, i, o) {
    var r = document.createElement("div");return r.className = "mfp-" + t, i && (r.innerHTML = i), o ? n && n.appendChild(r) : (r = e(r), n && r.appendTo(n)), r;
  },
      T = function T(n, i) {
    t.ev.triggerHandler(g + n, i), t.st.callbacks && (n = n.charAt(0).toLowerCase() + n.slice(1), t.st.callbacks[n] && t.st.callbacks[n].apply(t, e.isArray(i) ? i : [i]));
  },
      E = function E(n) {
    return n === s && t.currTemplate.closeBtn || (t.currTemplate.closeBtn = e(t.st.closeMarkup.replace("%title%", t.st.tClose)), s = n), t.currTemplate.closeBtn;
  },
      _ = function _() {
    e.magnificPopup.instance || (t = new w(), t.init(), e.magnificPopup.instance = t);
  },
      S = function S() {
    var e = document.createElement("p").style,
        t = ["ms", "O", "Moz", "Webkit"];if (void 0 !== e.transition) return !0;for (; t.length;) {
      if (t.pop() + "Transition" in e) return !0;
    }return !1;
  };w.prototype = { constructor: w, init: function init() {
      var n = navigator.appVersion;t.isIE7 = -1 !== n.indexOf("MSIE 7."), t.isIE8 = -1 !== n.indexOf("MSIE 8."), t.isLowIE = t.isIE7 || t.isIE8, t.isAndroid = /android/gi.test(n), t.isIOS = /iphone|ipad|ipod/gi.test(n), t.supportsTransition = S(), t.probablyMobile = t.isAndroid || t.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent), o = e(document), t.popupsCache = {};
    }, open: function open(n) {
      i || (i = e(document.body));var r;if (n.isObj === !1) {
        t.items = n.items.toArray(), t.index = 0;var s,
            l = n.items;for (r = 0; l.length > r; r++) {
          if (s = l[r], s.parsed && (s = s.el[0]), s === n.el[0]) {
            t.index = r;break;
          }
        }
      } else t.items = e.isArray(n.items) ? n.items : [n.items], t.index = n.index || 0;if (t.isOpen) return t.updateItemHTML(), void 0;t.types = [], a = "", t.ev = n.mainEl && n.mainEl.length ? n.mainEl.eq(0) : o, n.key ? (t.popupsCache[n.key] || (t.popupsCache[n.key] = {}), t.currTemplate = t.popupsCache[n.key]) : t.currTemplate = {}, t.st = e.extend(!0, {}, e.magnificPopup.defaults, n), t.fixedContentPos = "auto" === t.st.fixedContentPos ? !t.probablyMobile : t.st.fixedContentPos, t.st.modal && (t.st.closeOnContentClick = !1, t.st.closeOnBgClick = !1, t.st.showCloseBtn = !1, t.st.enableEscapeKey = !1), t.bgOverlay || (t.bgOverlay = k("bg").on("click" + h, function () {
        t.close();
      }), t.wrap = k("wrap").attr("tabindex", -1).on("click" + h, function (e) {
        t._checkIfClose(e.target) && t.close();
      }), t.container = k("container", t.wrap)), t.contentContainer = k("content"), t.st.preloader && (t.preloader = k("preloader", t.container, t.st.tLoading));var c = e.magnificPopup.modules;for (r = 0; c.length > r; r++) {
        var d = c[r];d = d.charAt(0).toUpperCase() + d.slice(1), t["init" + d].call(t);
      }T("BeforeOpen"), t.st.showCloseBtn && (t.st.closeBtnInside ? (x(p, function (e, t, n, i) {
        n.close_replaceWith = E(i.type);
      }), a += " mfp-close-btn-in") : t.wrap.append(E())), t.st.alignTop && (a += " mfp-align-top"), t.fixedContentPos ? t.wrap.css({ overflow: t.st.overflowY, overflowX: "hidden", overflowY: t.st.overflowY }) : t.wrap.css({ top: I.scrollTop(), position: "absolute" }), (t.st.fixedBgPos === !1 || "auto" === t.st.fixedBgPos && !t.fixedContentPos) && t.bgOverlay.css({ height: o.height(), position: "absolute" }), t.st.enableEscapeKey && o.on("keyup" + h, function (e) {
        27 === e.keyCode && t.close();
      }), I.on("resize" + h, function () {
        t.updateSize();
      }), t.st.closeOnContentClick || (a += " mfp-auto-cursor"), a && t.wrap.addClass(a);var u = t.wH = I.height(),
          m = {};if (t.fixedContentPos && t._hasScrollBar(u)) {
        var g = t._getScrollbarSize();g && (m.marginRight = g);
      }t.fixedContentPos && (t.isIE7 ? e("body, html").css("overflow", "hidden") : m.overflow = "hidden");var C = t.st.mainClass;return t.isIE7 && (C += " mfp-ie7"), C && t._addClassToMFP(C), t.updateItemHTML(), T("BuildControls"), e("html").css(m), t.bgOverlay.add(t.wrap).prependTo(t.st.prependTo || i), t._lastFocusedEl = document.activeElement, setTimeout(function () {
        t.content ? (t._addClassToMFP(v), t._setFocus()) : t.bgOverlay.addClass(v), o.on("focusin" + h, t._onFocusIn);
      }, 16), t.isOpen = !0, t.updateSize(u), T(f), n;
    }, close: function close() {
      t.isOpen && (T(c), t.isOpen = !1, t.st.removalDelay && !t.isLowIE && t.supportsTransition ? (t._addClassToMFP(C), setTimeout(function () {
        t._close();
      }, t.st.removalDelay)) : t._close());
    }, _close: function _close() {
      T(l);var n = C + " " + v + " ";if (t.bgOverlay.detach(), t.wrap.detach(), t.container.empty(), t.st.mainClass && (n += t.st.mainClass + " "), t._removeClassFromMFP(n), t.fixedContentPos) {
        var i = { marginRight: "" };t.isIE7 ? e("body, html").css("overflow", "") : i.overflow = "", e("html").css(i);
      }o.off("keyup" + h + " focusin" + h), t.ev.off(h), t.wrap.attr("class", "mfp-wrap").removeAttr("style"), t.bgOverlay.attr("class", "mfp-bg"), t.container.attr("class", "mfp-container"), !t.st.showCloseBtn || t.st.closeBtnInside && t.currTemplate[t.currItem.type] !== !0 || t.currTemplate.closeBtn && t.currTemplate.closeBtn.detach(), t._lastFocusedEl && e(t._lastFocusedEl).focus(), t.currItem = null, t.content = null, t.currTemplate = null, t.prevHeight = 0, T(d);
    }, updateSize: function updateSize(e) {
      if (t.isIOS) {
        var n = document.documentElement.clientWidth / window.innerWidth,
            i = window.innerHeight * n;t.wrap.css("height", i), t.wH = i;
      } else t.wH = e || I.height();t.fixedContentPos || t.wrap.css("height", t.wH), T("Resize");
    }, updateItemHTML: function updateItemHTML() {
      var n = t.items[t.index];t.contentContainer.detach(), t.content && t.content.detach(), n.parsed || (n = t.parseEl(t.index));var i = n.type;if (T("BeforeChange", [t.currItem ? t.currItem.type : "", i]), t.currItem = n, !t.currTemplate[i]) {
        var o = t.st[i] ? t.st[i].markup : !1;T("FirstMarkupParse", o), t.currTemplate[i] = o ? e(o) : !0;
      }r && r !== n.type && t.container.removeClass("mfp-" + r + "-holder");var a = t["get" + i.charAt(0).toUpperCase() + i.slice(1)](n, t.currTemplate[i]);t.appendContent(a, i), n.preloaded = !0, T(m, n), r = n.type, t.container.prepend(t.contentContainer), T("AfterChange");
    }, appendContent: function appendContent(e, n) {
      t.content = e, e ? t.st.showCloseBtn && t.st.closeBtnInside && t.currTemplate[n] === !0 ? t.content.find(".mfp-close").length || t.content.append(E()) : t.content = e : t.content = "", T(u), t.container.addClass("mfp-" + n + "-holder"), t.contentContainer.append(t.content);
    }, parseEl: function parseEl(n) {
      var i,
          o = t.items[n];if (o.tagName ? o = { el: e(o) } : (i = o.type, o = { data: o, src: o.src }), o.el) {
        for (var r = t.types, a = 0; r.length > a; a++) {
          if (o.el.hasClass("mfp-" + r[a])) {
            i = r[a];break;
          }
        }o.src = o.el.attr("data-mfp-src"), o.src || (o.src = o.el.attr("href"));
      }return o.type = i || t.st.type || "inline", o.index = n, o.parsed = !0, t.items[n] = o, T("ElementParse", o), t.items[n];
    }, addGroup: function addGroup(e, n) {
      var i = function i(_i) {
        _i.mfpEl = this, t._openClick(_i, e, n);
      };n || (n = {});var o = "click.magnificPopup";n.mainEl = e, n.items ? (n.isObj = !0, e.off(o).on(o, i)) : (n.isObj = !1, n.delegate ? e.off(o).on(o, n.delegate, i) : (n.items = e, e.off(o).on(o, i)));
    }, _openClick: function _openClick(n, i, o) {
      var r = void 0 !== o.midClick ? o.midClick : e.magnificPopup.defaults.midClick;if (r || 2 !== n.which && !n.ctrlKey && !n.metaKey) {
        var a = void 0 !== o.disableOn ? o.disableOn : e.magnificPopup.defaults.disableOn;if (a) if (e.isFunction(a)) {
          if (!a.call(t)) return !0;
        } else if (a > I.width()) return !0;n.type && (n.preventDefault(), t.isOpen && n.stopPropagation()), o.el = e(n.mfpEl), o.delegate && (o.items = i.find(o.delegate)), t.open(o);
      }
    }, updateStatus: function updateStatus(e, i) {
      if (t.preloader) {
        n !== e && t.container.removeClass("mfp-s-" + n), i || "loading" !== e || (i = t.st.tLoading);var o = { status: e, text: i };T("UpdateStatus", o), e = o.status, i = o.text, t.preloader.html(i), t.preloader.find("a").on("click", function (e) {
          e.stopImmediatePropagation();
        }), t.container.addClass("mfp-s-" + e), n = e;
      }
    }, _checkIfClose: function _checkIfClose(n) {
      if (!e(n).hasClass(y)) {
        var i = t.st.closeOnContentClick,
            o = t.st.closeOnBgClick;if (i && o) return !0;if (!t.content || e(n).hasClass("mfp-close") || t.preloader && n === t.preloader[0]) return !0;if (n === t.content[0] || e.contains(t.content[0], n)) {
          if (i) return !0;
        } else if (o && e.contains(document, n)) return !0;return !1;
      }
    }, _addClassToMFP: function _addClassToMFP(e) {
      t.bgOverlay.addClass(e), t.wrap.addClass(e);
    }, _removeClassFromMFP: function _removeClassFromMFP(e) {
      this.bgOverlay.removeClass(e), t.wrap.removeClass(e);
    }, _hasScrollBar: function _hasScrollBar(e) {
      return (t.isIE7 ? o.height() : document.body.scrollHeight) > (e || I.height());
    }, _setFocus: function _setFocus() {
      (t.st.focus ? t.content.find(t.st.focus).eq(0) : t.wrap).focus();
    }, _onFocusIn: function _onFocusIn(n) {
      return n.target === t.wrap[0] || e.contains(t.wrap[0], n.target) ? void 0 : (t._setFocus(), !1);
    }, _parseMarkup: function _parseMarkup(t, n, i) {
      var o;i.data && (n = e.extend(i.data, n)), T(p, [t, n, i]), e.each(n, function (e, n) {
        if (void 0 === n || n === !1) return !0;if (o = e.split("_"), o.length > 1) {
          var i = t.find(h + "-" + o[0]);if (i.length > 0) {
            var r = o[1];"replaceWith" === r ? i[0] !== n[0] && i.replaceWith(n) : "img" === r ? i.is("img") ? i.attr("src", n) : i.replaceWith('<img src="' + n + '" class="' + i.attr("class") + '" />') : i.attr(o[1], n);
          }
        } else t.find(h + "-" + e).html(n);
      });
    }, _getScrollbarSize: function _getScrollbarSize() {
      if (void 0 === t.scrollbarSize) {
        var e = document.createElement("div");e.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;", document.body.appendChild(e), t.scrollbarSize = e.offsetWidth - e.clientWidth, document.body.removeChild(e);
      }return t.scrollbarSize;
    } }, e.magnificPopup = { instance: null, proto: w.prototype, modules: [], open: function open(t, n) {
      return _(), t = t ? e.extend(!0, {}, t) : {}, t.isObj = !0, t.index = n || 0, this.instance.open(t);
    }, close: function close() {
      return e.magnificPopup.instance && e.magnificPopup.instance.close();
    }, registerModule: function registerModule(t, n) {
      n.options && (e.magnificPopup.defaults[t] = n.options), e.extend(this.proto, n.proto), this.modules.push(t);
    }, defaults: { disableOn: 0, key: null, midClick: !1, mainClass: "", preloader: !0, focus: "", closeOnContentClick: !1, closeOnBgClick: !0, closeBtnInside: !0, showCloseBtn: !0, enableEscapeKey: !0, modal: !1, alignTop: !1, removalDelay: 0, prependTo: null, fixedContentPos: "auto", fixedBgPos: "auto", overflowY: "auto", closeMarkup: '<button title="%title%" type="button" class="mfp-close">&times;</button>', tClose: "Close (Esc)", tLoading: "Loading..." } }, e.fn.magnificPopup = function (n) {
    _();var i = e(this);if ("string" == typeof n) {
      if ("open" === n) {
        var o,
            r = b ? i.data("magnificPopup") : i[0].magnificPopup,
            a = parseInt(arguments[1], 10) || 0;r.items ? o = r.items[a] : (o = i, r.delegate && (o = o.find(r.delegate)), o = o.eq(a)), t._openClick({ mfpEl: o }, i, r);
      } else t.isOpen && t[n].apply(t, Array.prototype.slice.call(arguments, 1));
    } else n = e.extend(!0, {}, n), b ? i.data("magnificPopup", n) : i[0].magnificPopup = n, t.addGroup(i, n);return i;
  };var P,
      O,
      z,
      M = "inline",
      B = function B() {
    z && (O.after(z.addClass(P)).detach(), z = null);
  };e.magnificPopup.registerModule(M, { options: { hiddenClass: "hide", markup: "", tNotFound: "Content not found" }, proto: { initInline: function initInline() {
        t.types.push(M), x(l + "." + M, function () {
          B();
        });
      }, getInline: function getInline(n, i) {
        if (B(), n.src) {
          var o = t.st.inline,
              r = e(n.src);if (r.length) {
            var a = r[0].parentNode;a && a.tagName && (O || (P = o.hiddenClass, O = k(P), P = "mfp-" + P), z = r.after(O).detach().removeClass(P)), t.updateStatus("ready");
          } else t.updateStatus("error", o.tNotFound), r = e("<div>");return n.inlineElement = r, r;
        }return t.updateStatus("ready"), t._parseMarkup(i, {}, n), i;
      } } });var F,
      H = "ajax",
      L = function L() {
    F && i.removeClass(F);
  },
      A = function A() {
    L(), t.req && t.req.abort();
  };e.magnificPopup.registerModule(H, { options: { settings: null, cursor: "mfp-ajax-cur", tError: '<a href="%url%">The content</a> could not be loaded.' }, proto: { initAjax: function initAjax() {
        t.types.push(H), F = t.st.ajax.cursor, x(l + "." + H, A), x("BeforeChange." + H, A);
      }, getAjax: function getAjax(n) {
        F && i.addClass(F), t.updateStatus("loading");var o = e.extend({ url: n.src, success: function success(i, o, r) {
            var a = { data: i, xhr: r };T("ParseAjax", a), t.appendContent(e(a.data), H), n.finished = !0, L(), t._setFocus(), setTimeout(function () {
              t.wrap.addClass(v);
            }, 16), t.updateStatus("ready"), T("AjaxContentAdded");
          }, error: function error() {
            L(), n.finished = n.loadError = !0, t.updateStatus("error", t.st.ajax.tError.replace("%url%", n.src));
          } }, t.st.ajax.settings);return t.req = e.ajax(o), "";
      } } });var j,
      N = function N(n) {
    if (n.data && void 0 !== n.data.title) return n.data.title;var i = t.st.image.titleSrc;if (i) {
      if (e.isFunction(i)) return i.call(t, n);if (n.el) return n.el.attr(i) || "";
    }return "";
  };e.magnificPopup.registerModule("image", { options: { markup: '<div class="mfp-figure"><div class="mfp-close"></div><figure><div class="mfp-img"></div><figcaption><div class="mfp-bottom-bar"><div class="mfp-title"></div><div class="mfp-counter"></div></div></figcaption></figure></div>', cursor: "mfp-zoom-out-cur", titleSrc: "title", verticalFit: !0, tError: '<a href="%url%">The image</a> could not be loaded.' }, proto: { initImage: function initImage() {
        var e = t.st.image,
            n = ".image";t.types.push("image"), x(f + n, function () {
          "image" === t.currItem.type && e.cursor && i.addClass(e.cursor);
        }), x(l + n, function () {
          e.cursor && i.removeClass(e.cursor), I.off("resize" + h);
        }), x("Resize" + n, t.resizeImage), t.isLowIE && x("AfterChange", t.resizeImage);
      }, resizeImage: function resizeImage() {
        var e = t.currItem;if (e && e.img && t.st.image.verticalFit) {
          var n = 0;t.isLowIE && (n = parseInt(e.img.css("padding-top"), 10) + parseInt(e.img.css("padding-bottom"), 10)), e.img.css("max-height", t.wH - n);
        }
      }, _onImageHasSize: function _onImageHasSize(e) {
        e.img && (e.hasSize = !0, j && clearInterval(j), e.isCheckingImgSize = !1, T("ImageHasSize", e), e.imgHidden && (t.content && t.content.removeClass("mfp-loading"), e.imgHidden = !1));
      }, findImageSize: function findImageSize(e) {
        var n = 0,
            i = e.img[0],
            o = function o(r) {
          j && clearInterval(j), j = setInterval(function () {
            return i.naturalWidth > 0 ? (t._onImageHasSize(e), void 0) : (n > 200 && clearInterval(j), n++, 3 === n ? o(10) : 40 === n ? o(50) : 100 === n && o(500), void 0);
          }, r);
        };o(1);
      }, getImage: function getImage(n, i) {
        var o = 0,
            r = function r() {
          n && (n.img[0].complete ? (n.img.off(".mfploader"), n === t.currItem && (t._onImageHasSize(n), t.updateStatus("ready")), n.hasSize = !0, n.loaded = !0, T("ImageLoadComplete")) : (o++, 200 > o ? setTimeout(r, 100) : a()));
        },
            a = function a() {
          n && (n.img.off(".mfploader"), n === t.currItem && (t._onImageHasSize(n), t.updateStatus("error", s.tError.replace("%url%", n.src))), n.hasSize = !0, n.loaded = !0, n.loadError = !0);
        },
            s = t.st.image,
            l = i.find(".mfp-img");if (l.length) {
          var c = document.createElement("img");c.className = "mfp-img", n.el && n.el.find("img").length && (c.alt = n.el.find("img").attr("alt")), n.img = e(c).on("load.mfploader", r).on("error.mfploader", a), c.src = n.src, l.is("img") && (n.img = n.img.clone()), c = n.img[0], c.naturalWidth > 0 ? n.hasSize = !0 : c.width || (n.hasSize = !1);
        }return t._parseMarkup(i, { title: N(n), img_replaceWith: n.img }, n), t.resizeImage(), n.hasSize ? (j && clearInterval(j), n.loadError ? (i.addClass("mfp-loading"), t.updateStatus("error", s.tError.replace("%url%", n.src))) : (i.removeClass("mfp-loading"), t.updateStatus("ready")), i) : (t.updateStatus("loading"), n.loading = !0, n.hasSize || (n.imgHidden = !0, i.addClass("mfp-loading"), t.findImageSize(n)), i);
      } } });var W,
      R = function R() {
    return void 0 === W && (W = void 0 !== document.createElement("p").style.MozTransform), W;
  };e.magnificPopup.registerModule("zoom", { options: { enabled: !1, easing: "ease-in-out", duration: 300, opener: function opener(e) {
        return e.is("img") ? e : e.find("img");
      } }, proto: { initZoom: function initZoom() {
        var e,
            n = t.st.zoom,
            i = ".zoom";if (n.enabled && t.supportsTransition) {
          var o,
              r,
              a = n.duration,
              s = function s(e) {
            var t = e.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image"),
                i = "all " + n.duration / 1e3 + "s " + n.easing,
                o = { position: "fixed", zIndex: 9999, left: 0, top: 0, "-webkit-backface-visibility": "hidden" },
                r = "transition";return o["-webkit-" + r] = o["-moz-" + r] = o["-o-" + r] = o[r] = i, t.css(o), t;
          },
              d = function d() {
            t.content.css("visibility", "visible");
          };x("BuildControls" + i, function () {
            if (t._allowZoom()) {
              if (clearTimeout(o), t.content.css("visibility", "hidden"), e = t._getItemToZoom(), !e) return d(), void 0;r = s(e), r.css(t._getOffset()), t.wrap.append(r), o = setTimeout(function () {
                r.css(t._getOffset(!0)), o = setTimeout(function () {
                  d(), setTimeout(function () {
                    r.remove(), e = r = null, T("ZoomAnimationEnded");
                  }, 16);
                }, a);
              }, 16);
            }
          }), x(c + i, function () {
            if (t._allowZoom()) {
              if (clearTimeout(o), t.st.removalDelay = a, !e) {
                if (e = t._getItemToZoom(), !e) return;r = s(e);
              }r.css(t._getOffset(!0)), t.wrap.append(r), t.content.css("visibility", "hidden"), setTimeout(function () {
                r.css(t._getOffset());
              }, 16);
            }
          }), x(l + i, function () {
            t._allowZoom() && (d(), r && r.remove(), e = null);
          });
        }
      }, _allowZoom: function _allowZoom() {
        return "image" === t.currItem.type;
      }, _getItemToZoom: function _getItemToZoom() {
        return t.currItem.hasSize ? t.currItem.img : !1;
      }, _getOffset: function _getOffset(n) {
        var i;i = n ? t.currItem.img : t.st.zoom.opener(t.currItem.el || t.currItem);var o = i.offset(),
            r = parseInt(i.css("padding-top"), 10),
            a = parseInt(i.css("padding-bottom"), 10);o.top -= e(window).scrollTop() - r;var s = { width: i.width(), height: (b ? i.innerHeight() : i[0].offsetHeight) - a - r };return R() ? s["-moz-transform"] = s.transform = "translate(" + o.left + "px," + o.top + "px)" : (s.left = o.left, s.top = o.top), s;
      } } });var Z = "iframe",
      q = "//about:blank",
      D = function D(e) {
    if (t.currTemplate[Z]) {
      var n = t.currTemplate[Z].find("iframe");n.length && (e || (n[0].src = q), t.isIE8 && n.css("display", e ? "block" : "none"));
    }
  };e.magnificPopup.registerModule(Z, { options: { markup: '<div class="mfp-iframe-scaler"><div class="mfp-close"></div><iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe></div>', srcAction: "iframe_src", patterns: { youtube: { index: "youtube.com", id: "v=", src: "//www.youtube.com/embed/%id%?autoplay=1" }, vimeo: { index: "vimeo.com/", id: "/", src: "//player.vimeo.com/video/%id%?autoplay=1" }, gmaps: { index: "//maps.google.", src: "%id%&output=embed" } } }, proto: { initIframe: function initIframe() {
        t.types.push(Z), x("BeforeChange", function (e, t, n) {
          t !== n && (t === Z ? D() : n === Z && D(!0));
        }), x(l + "." + Z, function () {
          D();
        });
      }, getIframe: function getIframe(n, i) {
        var o = n.src,
            r = t.st.iframe;e.each(r.patterns, function () {
          return o.indexOf(this.index) > -1 ? (this.id && (o = "string" == typeof this.id ? o.substr(o.lastIndexOf(this.id) + this.id.length, o.length) : this.id.call(this, o)), o = this.src.replace("%id%", o), !1) : void 0;
        });var a = {};return r.srcAction && (a[r.srcAction] = o), t._parseMarkup(i, a, n), t.updateStatus("ready"), i;
      } } });var K = function K(e) {
    var n = t.items.length;return e > n - 1 ? e - n : 0 > e ? n + e : e;
  },
      Y = function Y(e, t, n) {
    return e.replace(/%curr%/gi, t + 1).replace(/%total%/gi, n);
  };e.magnificPopup.registerModule("gallery", { options: { enabled: !1, arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>', preload: [0, 2], navigateByImgClick: !0, arrows: !0, tPrev: "Previous (Left arrow key)", tNext: "Next (Right arrow key)", tCounter: "%curr% of %total%" }, proto: { initGallery: function initGallery() {
        var n = t.st.gallery,
            i = ".mfp-gallery",
            r = Boolean(e.fn.mfpFastClick);return t.direction = !0, n && n.enabled ? (a += " mfp-gallery", x(f + i, function () {
          n.navigateByImgClick && t.wrap.on("click" + i, ".mfp-img", function () {
            return t.items.length > 1 ? (t.next(), !1) : void 0;
          }), o.on("keydown" + i, function (e) {
            37 === e.keyCode ? t.prev() : 39 === e.keyCode && t.next();
          });
        }), x("UpdateStatus" + i, function (e, n) {
          n.text && (n.text = Y(n.text, t.currItem.index, t.items.length));
        }), x(p + i, function (e, i, o, r) {
          var a = t.items.length;o.counter = a > 1 ? Y(n.tCounter, r.index, a) : "";
        }), x("BuildControls" + i, function () {
          if (t.items.length > 1 && n.arrows && !t.arrowLeft) {
            var i = n.arrowMarkup,
                o = t.arrowLeft = e(i.replace(/%title%/gi, n.tPrev).replace(/%dir%/gi, "left")).addClass(y),
                a = t.arrowRight = e(i.replace(/%title%/gi, n.tNext).replace(/%dir%/gi, "right")).addClass(y),
                s = r ? "mfpFastClick" : "click";o[s](function () {
              t.prev();
            }), a[s](function () {
              t.next();
            }), t.isIE7 && (k("b", o[0], !1, !0), k("a", o[0], !1, !0), k("b", a[0], !1, !0), k("a", a[0], !1, !0)), t.container.append(o.add(a));
          }
        }), x(m + i, function () {
          t._preloadTimeout && clearTimeout(t._preloadTimeout), t._preloadTimeout = setTimeout(function () {
            t.preloadNearbyImages(), t._preloadTimeout = null;
          }, 16);
        }), x(l + i, function () {
          o.off(i), t.wrap.off("click" + i), t.arrowLeft && r && t.arrowLeft.add(t.arrowRight).destroyMfpFastClick(), t.arrowRight = t.arrowLeft = null;
        }), void 0) : !1;
      }, next: function next() {
        t.direction = !0, t.index = K(t.index + 1), t.updateItemHTML();
      }, prev: function prev() {
        t.direction = !1, t.index = K(t.index - 1), t.updateItemHTML();
      }, goTo: function goTo(e) {
        t.direction = e >= t.index, t.index = e, t.updateItemHTML();
      }, preloadNearbyImages: function preloadNearbyImages() {
        var e,
            n = t.st.gallery.preload,
            i = Math.min(n[0], t.items.length),
            o = Math.min(n[1], t.items.length);for (e = 1; (t.direction ? o : i) >= e; e++) {
          t._preloadItem(t.index + e);
        }for (e = 1; (t.direction ? i : o) >= e; e++) {
          t._preloadItem(t.index - e);
        }
      }, _preloadItem: function _preloadItem(n) {
        if (n = K(n), !t.items[n].preloaded) {
          var i = t.items[n];i.parsed || (i = t.parseEl(n)), T("LazyLoad", i), "image" === i.type && (i.img = e('<img class="mfp-img" />').on("load.mfploader", function () {
            i.hasSize = !0;
          }).on("error.mfploader", function () {
            i.hasSize = !0, i.loadError = !0, T("LazyLoadError", i);
          }).attr("src", i.src)), i.preloaded = !0;
        }
      } } });var U = "retina";e.magnificPopup.registerModule(U, { options: { replaceSrc: function replaceSrc(e) {
        return e.src.replace(/\.\w+$/, function (e) {
          return "@2x" + e;
        });
      }, ratio: 1 }, proto: { initRetina: function initRetina() {
        if (window.devicePixelRatio > 1) {
          var e = t.st.retina,
              n = e.ratio;n = isNaN(n) ? n() : n, n > 1 && (x("ImageHasSize." + U, function (e, t) {
            t.img.css({ "max-width": t.img[0].naturalWidth / n, width: "100%" });
          }), x("ElementParse." + U, function (t, i) {
            i.src = e.replaceSrc(i, n);
          }));
        }
      } } }), function () {
    var t = 1e3,
        n = "ontouchstart" in window,
        i = function i() {
      I.off("touchmove" + r + " touchend" + r);
    },
        o = "mfpFastClick",
        r = "." + o;e.fn.mfpFastClick = function (o) {
      return e(this).each(function () {
        var a,
            s = e(this);if (n) {
          var l, c, d, u, p, f;s.on("touchstart" + r, function (e) {
            u = !1, f = 1, p = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0], c = p.clientX, d = p.clientY, I.on("touchmove" + r, function (e) {
              p = e.originalEvent ? e.originalEvent.touches : e.touches, f = p.length, p = p[0], (Math.abs(p.clientX - c) > 10 || Math.abs(p.clientY - d) > 10) && (u = !0, i());
            }).on("touchend" + r, function (e) {
              i(), u || f > 1 || (a = !0, e.preventDefault(), clearTimeout(l), l = setTimeout(function () {
                a = !1;
              }, t), o());
            });
          });
        }s.on("click" + r, function () {
          a || o();
        });
      });
    }, e.fn.destroyMfpFastClick = function () {
      e(this).off("touchstart" + r + " click" + r), n && I.off("touchmove" + r + " touchend" + r);
    };
  }(), _();
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(66);

__webpack_require__(100);

var _selectComponent = __webpack_require__(32);

var _selectComponent2 = _interopRequireDefault(_selectComponent);

var _gridSettings = __webpack_require__(101);

__webpack_require__(69);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MainNav = function () {
    function MainNav(element) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, MainNav);

        this.bodyOpenClass = '-nav-open';
        this.mobileToggleActiveClass = 'is-active';

        this.$component = (0, _selectComponent2.default)(element);
        this.$nav = this.$component.elements.list;
        this.$toggle = this.$component.elements.toggle;
        this.attachEvents();
    }

    _createClass(MainNav, [{
        key: 'attachEvents',
        value: function attachEvents() {
            var _this = this;

            this.checkToggle();

            $(window).on('debouncedresize', function () {
                _this.checkToggle();
            });
        }
    }, {
        key: 'checkToggle',
        value: function checkToggle() {
            this.stopToggle();

            if (!_gridSettings.$bpLg.matches) {
                this.startToggle();
            }
        }
    }, {
        key: 'startToggle',
        value: function startToggle() {
            var _this2 = this;

            this.$toggle.on('click', function () {
                if (_this2.$toggle.attr('data-property') == 'open') {
                    _this2.$toggle.attr('data-property', 'closed');
                    _this2.closeNav();
                    _this2.$toggle.removeClass(_this2.mobileToggleActiveClass);
                    $('body').removeClass(_this2.bodyOpenClass);
                } else {
                    _this2.$toggle.attr('data-property', 'open');
                    _this2.openNav();
                    _this2.$toggle.addClass(_this2.mobileToggleActiveClass);
                    $('body').addClass(_this2.bodyOpenClass);
                }
            });
        }
    }, {
        key: 'stopToggle',
        value: function stopToggle() {
            this.$toggle.off();
        }
    }, {
        key: 'openNav',
        value: function openNav() {
            var _this3 = this;

            this.$nav.velocity('slideDown', {
                duration: 400,
                complete: function complete() {
                    _this3.$nav.removeAttr('style');
                    _this3.$nav.attr('data-property', 'open');
                }
            });
        }
    }, {
        key: 'closeNav',
        value: function closeNav() {
            var _this4 = this;

            this.$nav.velocity('slideUp', {
                duration: 500,
                complete: function complete() {
                    _this4.$nav.removeAttr('style');
                    _this4.$nav.attr('data-property', 'closed');
                }
            });
        }
    }]);

    return MainNav;
}();

exports.default = MainNav;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * Gallery - Photoswipe
                                                                                                                                                                                                                                                                   * ================================
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * Description:  An image gallery implemented with the Photoswipe javascript library.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * Instructions: Gallery container element must be the parent node of <a> elements
                                                                                                                                                                                                                                                                   *               that link to the full-size version of the thumbnail image. The anchor contains
                                                                                                                                                                                                                                                                   *               a child <img> tag. Markup to be used for the full-size image caption should be a child
                                                                                                                                                                                                                                                                   *               element of the <a> tag and include the selector specified in settings.titleEl. The <a>
                                                                                                                                                                                                                                                                   *               element must contain a data-size attribute with the width and height of the full size image.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   *               Example:
                                                                                                                                                                                                                                                                   *                        <div data-element="gallery-photoswipe">
                                                                                                                                                                                                                                                                   *                            <a href="/path/to/full/image.jpg" data-size="640x480">
                                                                                                                                                                                                                                                                   *                               <img src="/path/to/thumb.jpg" alt="Thumnail Image">
                                                                                                                                                                                                                                                                   *                               <div data-element="title">Image Caption</div>
                                                                                                                                                                                                                                                                   *                            </a>
                                                                                                                                                                                                                                                                   *                            [...]
                                                                                                                                                                                                                                                                   *                        </div>
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   *               The template for the photoswipe full-image UI is in /Templates/includes/photoswipe-element.php
                                                                                                                                                                                                                                                                   *               and must be included on the same page as the gallery.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * Parameters:
                                                                                                                                                                                                                                                                   *               el:       [data-action="gallery-photoswipe"]         // Anchor elements that trigger scroll when clicked
                                                                                                                                                                                                                                                                   *               titleEl:  [data-element="title"]                     // Markup to be used in full-size caption
                                                                                                                                                                                                                                                                   **/


exports.default = GalleryPhotoSwipeFactory;

var _base = __webpack_require__(99);

var _base2 = _interopRequireDefault(_base);

var _photoswipe = __webpack_require__(177);

var _photoswipe2 = _interopRequireDefault(_photoswipe);

var _photoswipeUiDefault = __webpack_require__(178);

var _photoswipeUiDefault2 = _interopRequireDefault(_photoswipeUiDefault);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GalleryPhotoSwipeFactory(args) {
    /**
         * Plugin defaults / Base constructor
         * ----------------------------------------------------------- */
    var DEFAULT = {
        name: 'Gallery - Photoswipe',
        el: '[data-action="gallery-photoswipe"]',
        titleEl: '[data-element="title"]'
    };

    var settings = _base2.default.construct(DEFAULT, args);

    /**
     * Private and public methods
     * ----------------------------------------------------------- */
    var action = function action() {

        var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {

            // parse slide data (url, title, size ...) from DOM elements (links)
            var parseThumbnailElements = function parseThumbnailElements(el) {
                var thumbElements = el.childNodes,
                    numNodes = thumbElements.length,
                    items = [],
                    childElements = void 0,
                    thumbnailEl = void 0,
                    size = void 0,
                    item = void 0;

                for (var i = 0; i < numNodes; i++) {
                    el = thumbElements[i];

                    // include only element nodes
                    if (el.nodeType !== 1) {
                        continue;
                    }

                    var linkEl = void 0;

                    if (el.children[0].tagName.toUpperCase() == 'A') {
                        linkEl = el.children[0];
                    } else {
                        linkEl = el;
                    }

                    childElements = linkEl.children;

                    size = linkEl.getAttribute('data-size').split('x');

                    // create slide object
                    item = {
                        src: linkEl.getAttribute('href'),
                        w: parseInt(size[0], 10),
                        h: parseInt(size[1], 10)
                    };

                    if (el.children.length > 1) {
                        // <figcaption> content
                        item.title = el.children[1].innerHTML;
                    }

                    if (linkEl.children.length > 0) {
                        // <img> thumbnail element, retrieving thumbnail url
                        item.msrc = linkEl.children[0].getAttribute('src');
                    }

                    item.el = linkEl; // save link to element for getThumbBoundsFn

                    items.push(item);
                }

                return items;
            };

            // find nearest parent element
            var closest = function closest(el, fn) {
                return el && (fn(el) ? el : closest(el.parentNode, fn));
            };

            // triggers when user clicks on thumbnail
            var onThumbnailsClick = function onThumbnailsClick(e) {
                e = e || window.event;
                e.preventDefault ? e.preventDefault() : e.returnValue = false;

                var eTarget = e.target || e.srcElement;

                var clickedListItem = closest(eTarget, function (el) {
                    return el.tagName && el.tagName.toUpperCase() === 'FIGURE';
                });

                if (!clickedListItem) {
                    return;
                }

                var clickedGallery = clickedListItem.parentNode;

                var childNodes = clickedListItem.parentNode.childNodes,
                    numChildNodes = childNodes.length,
                    nodeIndex = 0,
                    index = void 0;

                for (var i = 0; i < numChildNodes; i++) {
                    if (childNodes[i].nodeType !== 1) {
                        continue;
                    }

                    if (childNodes[i] === clickedListItem) {
                        index = nodeIndex;
                        break;
                    }

                    nodeIndex++;
                }

                if (index >= 0) {
                    openPhotoSwipe(index, clickedGallery);
                }

                return false;
            };

            // parse picture index and gallery index from URL (#&pid=1&gid=2)
            var photoswipeParseHash = function photoswipeParseHash() {
                var hash = window.location.hash.substring(1),
                    params = {};

                if (hash.length < 5) {
                    return params;
                }

                var vars = hash.split('&');
                for (var i = 0; i < vars.length; i++) {
                    if (!vars[i]) {
                        continue;
                    }

                    var pair = vars[i].split('=');
                    if (pair.length < 2) {
                        continue;
                    }

                    params[pair[0]] = pair[1];
                }

                if (params.gid) {
                    params.gid = parseInt(params.gid, 10);
                }

                return params;
            };

            var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {
                var pswpElement = document.querySelectorAll('.pswp')[0],
                    gallery = void 0,
                    options = void 0,
                    items = void 0;

                items = parseThumbnailElements(galleryElement);

                // define options (if needed)
                options = {
                    index: index,
                    fullscreenEl: false,
                    shareEl: false,

                    // define gallery index (for URL)
                    galleryUID: galleryElement.getAttribute('data-pswp-uid'),

                    getThumbBoundsFn: function getThumbBoundsFn(index) {
                        // See Options -> getThumbBoundsFn section of docs for more info

                        var thumbnail = items[index].el.children[0],
                            pageYScroll = window.pageYOffset || document.documentElement.scrollTop,
                            rect = thumbnail.getBoundingClientRect();

                        return { x: rect.left, y: rect.top + pageYScroll, w: rect.width };
                    }

                };

                if (fromURL) {
                    if (options.galleryPIDs) {
                        // parse real index when custom PIDs are used 
                        // http://photoswipe.com/documentation/faq.html#custom-pid-in-url
                        for (var j = 0; j < items.length; j++) {
                            if (items[j].pid == index) {
                                options.index = j;
                                break;
                            }
                        }
                    } else {
                        // in URL indexes start from 1
                        options.index = parseInt(index, 10) - 1;
                    }
                } else {
                    options.index = parseInt(index, 10);
                }

                if (isNaN(options.index)) {
                    return;
                }

                if (disableAnimation) {
                    options.showAnimationDuration = 0;
                }

                // Pass data to PhotoSwipe and initialize it
                gallery = new _photoswipe2.default(pswpElement, _photoswipeUiDefault2.default, items, options);
                gallery.init();
            };

            // loop through all gallery elements and bind events
            var galleryElements = document.querySelectorAll(gallerySelector);
            for (var i = 0, l = galleryElements.length; i < l; i++) {
                galleryElements[i].setAttribute('data-pswp-uid', i + 1);
                galleryElements[i].onclick = onThumbnailsClick;
            }

            // Parse URL and open gallery if it contains #&pid=3&gid=1
            var hashData = photoswipeParseHash();
            if (hashData.pid && hashData.gid) {
                openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);
            }
        };

        // execute above function
        initPhotoSwipeFromDOM(settings.el);
    };

    /**
     * Method exporter
     * ----------------------------------------------------------- */
    var publicExports = {
        action: action
    };

    return _extends(_base2.default, publicExports);
};

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! PhotoSwipe - v4.1.1 - 2015-12-24
* http://photoswipe.com
* Copyright (c) 2015 Dmitry Semenov; */
(function (root, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        module.exports = factory();
    } else {
        root.PhotoSwipe = factory();
    }
})(undefined, function () {

    'use strict';

    var PhotoSwipe = function PhotoSwipe(template, UiClass, items, options) {

        /*>>framework-bridge*/
        /**
         *
         * Set of generic functions used by gallery.
         * 
         * You're free to modify anything here as long as functionality is kept.
         * 
         */
        var framework = {
            features: null,
            bind: function bind(target, type, listener, unbind) {
                var methodName = (unbind ? 'remove' : 'add') + 'EventListener';
                type = type.split(' ');
                for (var i = 0; i < type.length; i++) {
                    if (type[i]) {
                        target[methodName](type[i], listener, false);
                    }
                }
            },
            isArray: function isArray(obj) {
                return obj instanceof Array;
            },
            createEl: function createEl(classes, tag) {
                var el = document.createElement(tag || 'div');
                if (classes) {
                    el.className = classes;
                }
                return el;
            },
            getScrollY: function getScrollY() {
                var yOffset = window.pageYOffset;
                return yOffset !== undefined ? yOffset : document.documentElement.scrollTop;
            },
            unbind: function unbind(target, type, listener) {
                framework.bind(target, type, listener, true);
            },
            removeClass: function removeClass(el, className) {
                var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
                el.className = el.className.replace(reg, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
            },
            addClass: function addClass(el, className) {
                if (!framework.hasClass(el, className)) {
                    el.className += (el.className ? ' ' : '') + className;
                }
            },
            hasClass: function hasClass(el, className) {
                return el.className && new RegExp('(^|\\s)' + className + '(\\s|$)').test(el.className);
            },
            getChildByClass: function getChildByClass(parentEl, childClassName) {
                var node = parentEl.firstChild;
                while (node) {
                    if (framework.hasClass(node, childClassName)) {
                        return node;
                    }
                    node = node.nextSibling;
                }
            },
            arraySearch: function arraySearch(array, value, key) {
                var i = array.length;
                while (i--) {
                    if (array[i][key] === value) {
                        return i;
                    }
                }
                return -1;
            },
            extend: function extend(o1, o2, preventOverwrite) {
                for (var prop in o2) {
                    if (o2.hasOwnProperty(prop)) {
                        if (preventOverwrite && o1.hasOwnProperty(prop)) {
                            continue;
                        }
                        o1[prop] = o2[prop];
                    }
                }
            },
            easing: {
                sine: {
                    out: function out(k) {
                        return Math.sin(k * (Math.PI / 2));
                    },
                    inOut: function inOut(k) {
                        return -(Math.cos(Math.PI * k) - 1) / 2;
                    }
                },
                cubic: {
                    out: function out(k) {
                        return --k * k * k + 1;
                    }
                    /*
                        elastic: {
                            out: function ( k ) {
                                 var s, a = 0.1, p = 0.4;
                                if ( k === 0 ) return 0;
                                if ( k === 1 ) return 1;
                                if ( !a || a < 1 ) { a = 1; s = p / 4; }
                                else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
                                return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );
                             },
                        },
                        back: {
                            out: function ( k ) {
                                var s = 1.70158;
                                return --k * k * ( ( s + 1 ) * k + s ) + 1;
                            }
                        }
                    */
                } },

            /**
             * 
             * @return {object}
             * 
             * {
             *  raf : request animation frame function
             *  caf : cancel animation frame function
             *  transfrom : transform property key (with vendor), or null if not supported
             *  oldIE : IE8 or below
             * }
             * 
             */
            detectFeatures: function detectFeatures() {
                if (framework.features) {
                    return framework.features;
                }
                var helperEl = framework.createEl(),
                    helperStyle = helperEl.style,
                    vendor = '',
                    features = {};

                // IE8 and below
                features.oldIE = document.all && !document.addEventListener;

                features.touch = 'ontouchstart' in window;

                if (window.requestAnimationFrame) {
                    features.raf = window.requestAnimationFrame;
                    features.caf = window.cancelAnimationFrame;
                }

                features.pointerEvent = navigator.pointerEnabled || navigator.msPointerEnabled;

                // fix false-positive detection of old Android in new IE
                // (IE11 ua string contains "Android 4.0")

                if (!features.pointerEvent) {

                    var ua = navigator.userAgent;

                    // Detect if device is iPhone or iPod and if it's older than iOS 8
                    // http://stackoverflow.com/a/14223920
                    // 
                    // This detection is made because of buggy top/bottom toolbars
                    // that don't trigger window.resize event.
                    // For more info refer to _isFixedPosition variable in core.js

                    if (/iP(hone|od)/.test(navigator.platform)) {
                        var v = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
                        if (v && v.length > 0) {
                            v = parseInt(v[1], 10);
                            if (v >= 1 && v < 8) {
                                features.isOldIOSPhone = true;
                            }
                        }
                    }

                    // Detect old Android (before KitKat)
                    // due to bugs related to position:fixed
                    // http://stackoverflow.com/questions/7184573/pick-up-the-android-version-in-the-browser-by-javascript

                    var match = ua.match(/Android\s([0-9\.]*)/);
                    var androidversion = match ? match[1] : 0;
                    androidversion = parseFloat(androidversion);
                    if (androidversion >= 1) {
                        if (androidversion < 4.4) {
                            features.isOldAndroid = true; // for fixed position bug & performance
                        }
                        features.androidVersion = androidversion; // for touchend bug
                    }
                    features.isMobileOpera = /opera mini|opera mobi/i.test(ua);

                    // p.s. yes, yes, UA sniffing is bad, propose your solution for above bugs.
                }

                var styleChecks = ['transform', 'perspective', 'animationName'],
                    vendors = ['', 'webkit', 'Moz', 'ms', 'O'],
                    styleCheckItem,
                    styleName;

                for (var i = 0; i < 4; i++) {
                    vendor = vendors[i];

                    for (var a = 0; a < 3; a++) {
                        styleCheckItem = styleChecks[a];

                        // uppercase first letter of property name, if vendor is present
                        styleName = vendor + (vendor ? styleCheckItem.charAt(0).toUpperCase() + styleCheckItem.slice(1) : styleCheckItem);

                        if (!features[styleCheckItem] && styleName in helperStyle) {
                            features[styleCheckItem] = styleName;
                        }
                    }

                    if (vendor && !features.raf) {
                        vendor = vendor.toLowerCase();
                        features.raf = window[vendor + 'RequestAnimationFrame'];
                        if (features.raf) {
                            features.caf = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
                        }
                    }
                }

                if (!features.raf) {
                    var lastTime = 0;
                    features.raf = function (fn) {
                        var currTime = new Date().getTime();
                        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                        var id = window.setTimeout(function () {
                            fn(currTime + timeToCall);
                        }, timeToCall);
                        lastTime = currTime + timeToCall;
                        return id;
                    };
                    features.caf = function (id) {
                        clearTimeout(id);
                    };
                }

                // Detect SVG support
                features.svg = !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;

                framework.features = features;

                return features;
            }
        };

        framework.detectFeatures();

        // Override addEventListener for old versions of IE
        if (framework.features.oldIE) {

            framework.bind = function (target, type, listener, unbind) {

                type = type.split(' ');

                var methodName = (unbind ? 'detach' : 'attach') + 'Event',
                    evName,
                    _handleEv = function _handleEv() {
                    listener.handleEvent.call(listener);
                };

                for (var i = 0; i < type.length; i++) {
                    evName = type[i];
                    if (evName) {

                        if ((typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object' && listener.handleEvent) {
                            if (!unbind) {
                                listener['oldIE' + evName] = _handleEv;
                            } else {
                                if (!listener['oldIE' + evName]) {
                                    return false;
                                }
                            }

                            target[methodName]('on' + evName, listener['oldIE' + evName]);
                        } else {
                            target[methodName]('on' + evName, listener);
                        }
                    }
                }
            };
        }

        /*>>framework-bridge*/

        /*>>core*/
        //function(template, UiClass, items, options)

        var self = this;

        /**
         * Static vars, don't change unless you know what you're doing.
         */
        var DOUBLE_TAP_RADIUS = 25,
            NUM_HOLDERS = 3;

        /**
         * Options
         */
        var _options = {
            allowPanToNext: true,
            spacing: 0.12,
            bgOpacity: 1,
            mouseUsed: false,
            loop: true,
            pinchToClose: true,
            closeOnScroll: true,
            closeOnVerticalDrag: true,
            verticalDragRange: 0.75,
            hideAnimationDuration: 333,
            showAnimationDuration: 333,
            showHideOpacity: false,
            focus: true,
            escKey: true,
            arrowKeys: true,
            mainScrollEndFriction: 0.35,
            panEndFriction: 0.35,
            isClickableElement: function isClickableElement(el) {
                return el.tagName === 'A';
            },
            getDoubleTapZoom: function getDoubleTapZoom(isMouseClick, item) {
                if (isMouseClick) {
                    return 1;
                } else {
                    return item.initialZoomLevel < 0.7 ? 1 : 1.33;
                }
            },
            maxSpreadZoom: 1.33,
            modal: true,

            // not fully implemented yet
            scaleMode: 'fit' // TODO
        };
        framework.extend(_options, options);

        /**
         * Private helper variables & functions
         */

        var _getEmptyPoint = function _getEmptyPoint() {
            return { x: 0, y: 0 };
        };

        var _isOpen,
            _isDestroying,
            _closedByScroll,
            _currentItemIndex,
            _containerStyle,
            _containerShiftIndex,
            _currPanDist = _getEmptyPoint(),
            _startPanOffset = _getEmptyPoint(),
            _panOffset = _getEmptyPoint(),
            _upMoveEvents,
            // drag move, drag end & drag cancel events array
        _downEvents,
            // drag start events array
        _globalEventHandlers,
            _viewportSize = {},
            _currZoomLevel,
            _startZoomLevel,
            _translatePrefix,
            _translateSufix,
            _updateSizeInterval,
            _itemsNeedUpdate,
            _currPositionIndex = 0,
            _offset = {},
            _slideSize = _getEmptyPoint(),
            // size of slide area, including spacing
        _itemHolders,
            _prevItemIndex,
            _indexDiff = 0,
            // difference of indexes since last content update
        _dragStartEvent,
            _dragMoveEvent,
            _dragEndEvent,
            _dragCancelEvent,
            _transformKey,
            _pointerEventEnabled,
            _isFixedPosition = true,
            _likelyTouchDevice,
            _modules = [],
            _requestAF,
            _cancelAF,
            _initalClassName,
            _initalWindowScrollY,
            _oldIE,
            _currentWindowScrollY,
            _features,
            _windowVisibleSize = {},
            _renderMaxResolution = false,


        // Registers PhotoSWipe module (History, Controller ...)
        _registerModule = function _registerModule(name, module) {
            framework.extend(self, module.publicMethods);
            _modules.push(name);
        },
            _getLoopedId = function _getLoopedId(index) {
            var numSlides = _getNumItems();
            if (index > numSlides - 1) {
                return index - numSlides;
            } else if (index < 0) {
                return numSlides + index;
            }
            return index;
        },


        // Micro bind/trigger
        _listeners = {},
            _listen = function _listen(name, fn) {
            if (!_listeners[name]) {
                _listeners[name] = [];
            }
            return _listeners[name].push(fn);
        },
            _shout = function _shout(name) {
            var listeners = _listeners[name];

            if (listeners) {
                var args = Array.prototype.slice.call(arguments);
                args.shift();

                for (var i = 0; i < listeners.length; i++) {
                    listeners[i].apply(self, args);
                }
            }
        },
            _getCurrentTime = function _getCurrentTime() {
            return new Date().getTime();
        },
            _applyBgOpacity = function _applyBgOpacity(opacity) {
            _bgOpacity = opacity;
            self.bg.style.opacity = opacity * _options.bgOpacity;
        },
            _applyZoomTransform = function _applyZoomTransform(styleObj, x, y, zoom, item) {
            if (!_renderMaxResolution || item && item !== self.currItem) {
                zoom = zoom / (item ? item.fitRatio : self.currItem.fitRatio);
            }

            styleObj[_transformKey] = _translatePrefix + x + 'px, ' + y + 'px' + _translateSufix + ' scale(' + zoom + ')';
        },
            _applyCurrentZoomPan = function _applyCurrentZoomPan(allowRenderResolution) {
            if (_currZoomElementStyle) {

                if (allowRenderResolution) {
                    if (_currZoomLevel > self.currItem.fitRatio) {
                        if (!_renderMaxResolution) {
                            _setImageSize(self.currItem, false, true);
                            _renderMaxResolution = true;
                        }
                    } else {
                        if (_renderMaxResolution) {
                            _setImageSize(self.currItem);
                            _renderMaxResolution = false;
                        }
                    }
                }

                _applyZoomTransform(_currZoomElementStyle, _panOffset.x, _panOffset.y, _currZoomLevel);
            }
        },
            _applyZoomPanToItem = function _applyZoomPanToItem(item) {
            if (item.container) {

                _applyZoomTransform(item.container.style, item.initialPosition.x, item.initialPosition.y, item.initialZoomLevel, item);
            }
        },
            _setTranslateX = function _setTranslateX(x, elStyle) {
            elStyle[_transformKey] = _translatePrefix + x + 'px, 0px' + _translateSufix;
        },
            _moveMainScroll = function _moveMainScroll(x, dragging) {

            if (!_options.loop && dragging) {
                var newSlideIndexOffset = _currentItemIndex + (_slideSize.x * _currPositionIndex - x) / _slideSize.x,
                    delta = Math.round(x - _mainScrollPos.x);

                if (newSlideIndexOffset < 0 && delta > 0 || newSlideIndexOffset >= _getNumItems() - 1 && delta < 0) {
                    x = _mainScrollPos.x + delta * _options.mainScrollEndFriction;
                }
            }

            _mainScrollPos.x = x;
            _setTranslateX(x, _containerStyle);
        },
            _calculatePanOffset = function _calculatePanOffset(axis, zoomLevel) {
            var m = _midZoomPoint[axis] - _offset[axis];
            return _startPanOffset[axis] + _currPanDist[axis] + m - m * (zoomLevel / _startZoomLevel);
        },
            _equalizePoints = function _equalizePoints(p1, p2) {
            p1.x = p2.x;
            p1.y = p2.y;
            if (p2.id) {
                p1.id = p2.id;
            }
        },
            _roundPoint = function _roundPoint(p) {
            p.x = Math.round(p.x);
            p.y = Math.round(p.y);
        },
            _mouseMoveTimeout = null,
            _onFirstMouseMove = function _onFirstMouseMove() {
            // Wait until mouse move event is fired at least twice during 100ms
            // We do this, because some mobile browsers trigger it on touchstart
            if (_mouseMoveTimeout) {
                framework.unbind(document, 'mousemove', _onFirstMouseMove);
                framework.addClass(template, 'pswp--has_mouse');
                _options.mouseUsed = true;
                _shout('mouseUsed');
            }
            _mouseMoveTimeout = setTimeout(function () {
                _mouseMoveTimeout = null;
            }, 100);
        },
            _bindEvents = function _bindEvents() {
            framework.bind(document, 'keydown', self);

            if (_features.transform) {
                // don't bind click event in browsers that don't support transform (mostly IE8)
                framework.bind(self.scrollWrap, 'click', self);
            }

            if (!_options.mouseUsed) {
                framework.bind(document, 'mousemove', _onFirstMouseMove);
            }

            framework.bind(window, 'resize scroll', self);

            _shout('bindEvents');
        },
            _unbindEvents = function _unbindEvents() {
            framework.unbind(window, 'resize', self);
            framework.unbind(window, 'scroll', _globalEventHandlers.scroll);
            framework.unbind(document, 'keydown', self);
            framework.unbind(document, 'mousemove', _onFirstMouseMove);

            if (_features.transform) {
                framework.unbind(self.scrollWrap, 'click', self);
            }

            if (_isDragging) {
                framework.unbind(window, _upMoveEvents, self);
            }

            _shout('unbindEvents');
        },
            _calculatePanBounds = function _calculatePanBounds(zoomLevel, update) {
            var bounds = _calculateItemSize(self.currItem, _viewportSize, zoomLevel);
            if (update) {
                _currPanBounds = bounds;
            }
            return bounds;
        },
            _getMinZoomLevel = function _getMinZoomLevel(item) {
            if (!item) {
                item = self.currItem;
            }
            return item.initialZoomLevel;
        },
            _getMaxZoomLevel = function _getMaxZoomLevel(item) {
            if (!item) {
                item = self.currItem;
            }
            return item.w > 0 ? _options.maxSpreadZoom : 1;
        },


        // Return true if offset is out of the bounds
        _modifyDestPanOffset = function _modifyDestPanOffset(axis, destPanBounds, destPanOffset, destZoomLevel) {
            if (destZoomLevel === self.currItem.initialZoomLevel) {
                destPanOffset[axis] = self.currItem.initialPosition[axis];
                return true;
            } else {
                destPanOffset[axis] = _calculatePanOffset(axis, destZoomLevel);

                if (destPanOffset[axis] > destPanBounds.min[axis]) {
                    destPanOffset[axis] = destPanBounds.min[axis];
                    return true;
                } else if (destPanOffset[axis] < destPanBounds.max[axis]) {
                    destPanOffset[axis] = destPanBounds.max[axis];
                    return true;
                }
            }
            return false;
        },
            _setupTransforms = function _setupTransforms() {

            if (_transformKey) {
                // setup 3d transforms
                var allow3dTransform = _features.perspective && !_likelyTouchDevice;
                _translatePrefix = 'translate' + (allow3dTransform ? '3d(' : '(');
                _translateSufix = _features.perspective ? ', 0px)' : ')';
                return;
            }

            // Override zoom/pan/move functions in case old browser is used (most likely IE)
            // (so they use left/top/width/height, instead of CSS transform)

            _transformKey = 'left';
            framework.addClass(template, 'pswp--ie');

            _setTranslateX = function _setTranslateX(x, elStyle) {
                elStyle.left = x + 'px';
            };
            _applyZoomPanToItem = function _applyZoomPanToItem(item) {

                var zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,
                    s = item.container.style,
                    w = zoomRatio * item.w,
                    h = zoomRatio * item.h;

                s.width = w + 'px';
                s.height = h + 'px';
                s.left = item.initialPosition.x + 'px';
                s.top = item.initialPosition.y + 'px';
            };
            _applyCurrentZoomPan = function _applyCurrentZoomPan() {
                if (_currZoomElementStyle) {

                    var s = _currZoomElementStyle,
                        item = self.currItem,
                        zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,
                        w = zoomRatio * item.w,
                        h = zoomRatio * item.h;

                    s.width = w + 'px';
                    s.height = h + 'px';

                    s.left = _panOffset.x + 'px';
                    s.top = _panOffset.y + 'px';
                }
            };
        },
            _onKeyDown = function _onKeyDown(e) {
            var keydownAction = '';
            if (_options.escKey && e.keyCode === 27) {
                keydownAction = 'close';
            } else if (_options.arrowKeys) {
                if (e.keyCode === 37) {
                    keydownAction = 'prev';
                } else if (e.keyCode === 39) {
                    keydownAction = 'next';
                }
            }

            if (keydownAction) {
                // don't do anything if special key pressed to prevent from overriding default browser actions
                // e.g. in Chrome on Mac cmd+arrow-left returns to previous page
                if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey) {
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }
                    self[keydownAction]();
                }
            }
        },
            _onGlobalClick = function _onGlobalClick(e) {
            if (!e) {
                return;
            }

            // don't allow click event to pass through when triggering after drag or some other gesture
            if (_moved || _zoomStarted || _mainScrollAnimating || _verticalDragInitiated) {
                e.preventDefault();
                e.stopPropagation();
            }
        },
            _updatePageScrollOffset = function _updatePageScrollOffset() {
            self.setScrollOffset(0, framework.getScrollY());
        };

        // Micro animation engine
        var _animations = {},
            _numAnimations = 0,
            _stopAnimation = function _stopAnimation(name) {
            if (_animations[name]) {
                if (_animations[name].raf) {
                    _cancelAF(_animations[name].raf);
                }
                _numAnimations--;
                delete _animations[name];
            }
        },
            _registerStartAnimation = function _registerStartAnimation(name) {
            if (_animations[name]) {
                _stopAnimation(name);
            }
            if (!_animations[name]) {
                _numAnimations++;
                _animations[name] = {};
            }
        },
            _stopAllAnimations = function _stopAllAnimations() {
            for (var prop in _animations) {

                if (_animations.hasOwnProperty(prop)) {
                    _stopAnimation(prop);
                }
            }
        },
            _animateProp = function _animateProp(name, b, endProp, d, easingFn, onUpdate, onComplete) {
            var startAnimTime = _getCurrentTime(),
                t;
            _registerStartAnimation(name);

            var animloop = function animloop() {
                if (_animations[name]) {

                    t = _getCurrentTime() - startAnimTime; // time diff
                    //b - beginning (start prop)
                    //d - anim duration

                    if (t >= d) {
                        _stopAnimation(name);
                        onUpdate(endProp);
                        if (onComplete) {
                            onComplete();
                        }
                        return;
                    }
                    onUpdate((endProp - b) * easingFn(t / d) + b);

                    _animations[name].raf = _requestAF(animloop);
                }
            };
            animloop();
        };

        var publicMethods = {

            // make a few local variables and functions public
            shout: _shout,
            listen: _listen,
            viewportSize: _viewportSize,
            options: _options,

            isMainScrollAnimating: function isMainScrollAnimating() {
                return _mainScrollAnimating;
            },
            getZoomLevel: function getZoomLevel() {
                return _currZoomLevel;
            },
            getCurrentIndex: function getCurrentIndex() {
                return _currentItemIndex;
            },
            isDragging: function isDragging() {
                return _isDragging;
            },
            isZooming: function isZooming() {
                return _isZooming;
            },
            setScrollOffset: function setScrollOffset(x, y) {
                _offset.x = x;
                _currentWindowScrollY = _offset.y = y;
                _shout('updateScrollOffset', _offset);
            },
            applyZoomPan: function applyZoomPan(zoomLevel, panX, panY, allowRenderResolution) {
                _panOffset.x = panX;
                _panOffset.y = panY;
                _currZoomLevel = zoomLevel;
                _applyCurrentZoomPan(allowRenderResolution);
            },

            init: function init() {

                if (_isOpen || _isDestroying) {
                    return;
                }

                var i;

                self.framework = framework; // basic functionality
                self.template = template; // root DOM element of PhotoSwipe
                self.bg = framework.getChildByClass(template, 'pswp__bg');

                _initalClassName = template.className;
                _isOpen = true;

                _features = framework.detectFeatures();
                _requestAF = _features.raf;
                _cancelAF = _features.caf;
                _transformKey = _features.transform;
                _oldIE = _features.oldIE;

                self.scrollWrap = framework.getChildByClass(template, 'pswp__scroll-wrap');
                self.container = framework.getChildByClass(self.scrollWrap, 'pswp__container');

                _containerStyle = self.container.style; // for fast access

                // Objects that hold slides (there are only 3 in DOM)
                self.itemHolders = _itemHolders = [{ el: self.container.children[0], wrap: 0, index: -1 }, { el: self.container.children[1], wrap: 0, index: -1 }, { el: self.container.children[2], wrap: 0, index: -1 }];

                // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)
                _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'none';

                _setupTransforms();

                // Setup global events
                _globalEventHandlers = {
                    resize: self.updateSize,
                    scroll: _updatePageScrollOffset,
                    keydown: _onKeyDown,
                    click: _onGlobalClick
                };

                // disable show/hide effects on old browsers that don't support CSS animations or transforms, 
                // old IOS, Android and Opera mobile. Blackberry seems to work fine, even older models.
                var oldPhone = _features.isOldIOSPhone || _features.isOldAndroid || _features.isMobileOpera;
                if (!_features.animationName || !_features.transform || oldPhone) {
                    _options.showAnimationDuration = _options.hideAnimationDuration = 0;
                }

                // init modules
                for (i = 0; i < _modules.length; i++) {
                    self['init' + _modules[i]]();
                }

                // init
                if (UiClass) {
                    var ui = self.ui = new UiClass(self, framework);
                    ui.init();
                }

                _shout('firstUpdate');
                _currentItemIndex = _currentItemIndex || _options.index || 0;
                // validate index
                if (isNaN(_currentItemIndex) || _currentItemIndex < 0 || _currentItemIndex >= _getNumItems()) {
                    _currentItemIndex = 0;
                }
                self.currItem = _getItemAt(_currentItemIndex);

                if (_features.isOldIOSPhone || _features.isOldAndroid) {
                    _isFixedPosition = false;
                }

                template.setAttribute('aria-hidden', 'false');
                if (_options.modal) {
                    if (!_isFixedPosition) {
                        template.style.position = 'absolute';
                        template.style.top = framework.getScrollY() + 'px';
                    } else {
                        template.style.position = 'fixed';
                    }
                }

                if (_currentWindowScrollY === undefined) {
                    _shout('initialLayout');
                    _currentWindowScrollY = _initalWindowScrollY = framework.getScrollY();
                }

                // add classes to root element of PhotoSwipe
                var rootClasses = 'pswp--open ';
                if (_options.mainClass) {
                    rootClasses += _options.mainClass + ' ';
                }
                if (_options.showHideOpacity) {
                    rootClasses += 'pswp--animate_opacity ';
                }
                rootClasses += _likelyTouchDevice ? 'pswp--touch' : 'pswp--notouch';
                rootClasses += _features.animationName ? ' pswp--css_animation' : '';
                rootClasses += _features.svg ? ' pswp--svg' : '';
                framework.addClass(template, rootClasses);

                self.updateSize();

                // initial update
                _containerShiftIndex = -1;
                _indexDiff = null;
                for (i = 0; i < NUM_HOLDERS; i++) {
                    _setTranslateX((i + _containerShiftIndex) * _slideSize.x, _itemHolders[i].el.style);
                }

                if (!_oldIE) {
                    framework.bind(self.scrollWrap, _downEvents, self); // no dragging for old IE
                }

                _listen('initialZoomInEnd', function () {
                    self.setContent(_itemHolders[0], _currentItemIndex - 1);
                    self.setContent(_itemHolders[2], _currentItemIndex + 1);

                    _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'block';

                    if (_options.focus) {
                        // focus causes layout, 
                        // which causes lag during the animation, 
                        // that's why we delay it untill the initial zoom transition ends
                        template.focus();
                    }

                    _bindEvents();
                });

                // set content for center slide (first time)
                self.setContent(_itemHolders[1], _currentItemIndex);

                self.updateCurrItem();

                _shout('afterInit');

                if (!_isFixedPosition) {

                    // On all versions of iOS lower than 8.0, we check size of viewport every second.
                    // 
                    // This is done to detect when Safari top & bottom bars appear, 
                    // as this action doesn't trigger any events (like resize). 
                    // 
                    // On iOS8 they fixed this.
                    // 
                    // 10 Nov 2014: iOS 7 usage ~40%. iOS 8 usage 56%.

                    _updateSizeInterval = setInterval(function () {
                        if (!_numAnimations && !_isDragging && !_isZooming && _currZoomLevel === self.currItem.initialZoomLevel) {
                            self.updateSize();
                        }
                    }, 1000);
                }

                framework.addClass(template, 'pswp--visible');
            },

            // Close the gallery, then destroy it
            close: function close() {
                if (!_isOpen) {
                    return;
                }

                _isOpen = false;
                _isDestroying = true;
                _shout('close');
                _unbindEvents();

                _showOrHide(self.currItem, null, true, self.destroy);
            },

            // destroys the gallery (unbinds events, cleans up intervals and timeouts to avoid memory leaks)
            destroy: function destroy() {
                _shout('destroy');

                if (_showOrHideTimeout) {
                    clearTimeout(_showOrHideTimeout);
                }

                template.setAttribute('aria-hidden', 'true');
                template.className = _initalClassName;

                if (_updateSizeInterval) {
                    clearInterval(_updateSizeInterval);
                }

                framework.unbind(self.scrollWrap, _downEvents, self);

                // we unbind scroll event at the end, as closing animation may depend on it
                framework.unbind(window, 'scroll', self);

                _stopDragUpdateLoop();

                _stopAllAnimations();

                _listeners = null;
            },

            /**
             * Pan image to position
             * @param {Number} x     
             * @param {Number} y     
             * @param {Boolean} force Will ignore bounds if set to true.
             */
            panTo: function panTo(x, y, force) {
                if (!force) {
                    if (x > _currPanBounds.min.x) {
                        x = _currPanBounds.min.x;
                    } else if (x < _currPanBounds.max.x) {
                        x = _currPanBounds.max.x;
                    }

                    if (y > _currPanBounds.min.y) {
                        y = _currPanBounds.min.y;
                    } else if (y < _currPanBounds.max.y) {
                        y = _currPanBounds.max.y;
                    }
                }

                _panOffset.x = x;
                _panOffset.y = y;
                _applyCurrentZoomPan();
            },

            handleEvent: function handleEvent(e) {
                e = e || window.event;
                if (_globalEventHandlers[e.type]) {
                    _globalEventHandlers[e.type](e);
                }
            },

            goTo: function goTo(index) {

                index = _getLoopedId(index);

                var diff = index - _currentItemIndex;
                _indexDiff = diff;

                _currentItemIndex = index;
                self.currItem = _getItemAt(_currentItemIndex);
                _currPositionIndex -= diff;

                _moveMainScroll(_slideSize.x * _currPositionIndex);

                _stopAllAnimations();
                _mainScrollAnimating = false;

                self.updateCurrItem();
            },
            next: function next() {
                self.goTo(_currentItemIndex + 1);
            },
            prev: function prev() {
                self.goTo(_currentItemIndex - 1);
            },

            // update current zoom/pan objects
            updateCurrZoomItem: function updateCurrZoomItem(emulateSetContent) {
                if (emulateSetContent) {
                    _shout('beforeChange', 0);
                }

                // itemHolder[1] is middle (current) item
                if (_itemHolders[1].el.children.length) {
                    var zoomElement = _itemHolders[1].el.children[0];
                    if (framework.hasClass(zoomElement, 'pswp__zoom-wrap')) {
                        _currZoomElementStyle = zoomElement.style;
                    } else {
                        _currZoomElementStyle = null;
                    }
                } else {
                    _currZoomElementStyle = null;
                }

                _currPanBounds = self.currItem.bounds;
                _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;

                _panOffset.x = _currPanBounds.center.x;
                _panOffset.y = _currPanBounds.center.y;

                if (emulateSetContent) {
                    _shout('afterChange');
                }
            },

            invalidateCurrItems: function invalidateCurrItems() {
                _itemsNeedUpdate = true;
                for (var i = 0; i < NUM_HOLDERS; i++) {
                    if (_itemHolders[i].item) {
                        _itemHolders[i].item.needsUpdate = true;
                    }
                }
            },

            updateCurrItem: function updateCurrItem(beforeAnimation) {

                if (_indexDiff === 0) {
                    return;
                }

                var diffAbs = Math.abs(_indexDiff),
                    tempHolder;

                if (beforeAnimation && diffAbs < 2) {
                    return;
                }

                self.currItem = _getItemAt(_currentItemIndex);
                _renderMaxResolution = false;

                _shout('beforeChange', _indexDiff);

                if (diffAbs >= NUM_HOLDERS) {
                    _containerShiftIndex += _indexDiff + (_indexDiff > 0 ? -NUM_HOLDERS : NUM_HOLDERS);
                    diffAbs = NUM_HOLDERS;
                }
                for (var i = 0; i < diffAbs; i++) {
                    if (_indexDiff > 0) {
                        tempHolder = _itemHolders.shift();
                        _itemHolders[NUM_HOLDERS - 1] = tempHolder; // move first to last

                        _containerShiftIndex++;
                        _setTranslateX((_containerShiftIndex + 2) * _slideSize.x, tempHolder.el.style);
                        self.setContent(tempHolder, _currentItemIndex - diffAbs + i + 1 + 1);
                    } else {
                        tempHolder = _itemHolders.pop();
                        _itemHolders.unshift(tempHolder); // move last to first

                        _containerShiftIndex--;
                        _setTranslateX(_containerShiftIndex * _slideSize.x, tempHolder.el.style);
                        self.setContent(tempHolder, _currentItemIndex + diffAbs - i - 1 - 1);
                    }
                }

                // reset zoom/pan on previous item
                if (_currZoomElementStyle && Math.abs(_indexDiff) === 1) {

                    var prevItem = _getItemAt(_prevItemIndex);
                    if (prevItem.initialZoomLevel !== _currZoomLevel) {
                        _calculateItemSize(prevItem, _viewportSize);
                        _setImageSize(prevItem);
                        _applyZoomPanToItem(prevItem);
                    }
                }

                // reset diff after update
                _indexDiff = 0;

                self.updateCurrZoomItem();

                _prevItemIndex = _currentItemIndex;

                _shout('afterChange');
            },

            updateSize: function updateSize(force) {

                if (!_isFixedPosition && _options.modal) {
                    var windowScrollY = framework.getScrollY();
                    if (_currentWindowScrollY !== windowScrollY) {
                        template.style.top = windowScrollY + 'px';
                        _currentWindowScrollY = windowScrollY;
                    }
                    if (!force && _windowVisibleSize.x === window.innerWidth && _windowVisibleSize.y === window.innerHeight) {
                        return;
                    }
                    _windowVisibleSize.x = window.innerWidth;
                    _windowVisibleSize.y = window.innerHeight;

                    //template.style.width = _windowVisibleSize.x + 'px';
                    template.style.height = _windowVisibleSize.y + 'px';
                }

                _viewportSize.x = self.scrollWrap.clientWidth;
                _viewportSize.y = self.scrollWrap.clientHeight;

                _updatePageScrollOffset();

                _slideSize.x = _viewportSize.x + Math.round(_viewportSize.x * _options.spacing);
                _slideSize.y = _viewportSize.y;

                _moveMainScroll(_slideSize.x * _currPositionIndex);

                _shout('beforeResize'); // even may be used for example to switch image sources


                // don't re-calculate size on inital size update
                if (_containerShiftIndex !== undefined) {

                    var holder, item, hIndex;

                    for (var i = 0; i < NUM_HOLDERS; i++) {
                        holder = _itemHolders[i];
                        _setTranslateX((i + _containerShiftIndex) * _slideSize.x, holder.el.style);

                        hIndex = _currentItemIndex + i - 1;

                        if (_options.loop && _getNumItems() > 2) {
                            hIndex = _getLoopedId(hIndex);
                        }

                        // update zoom level on items and refresh source (if needsUpdate)
                        item = _getItemAt(hIndex);

                        // re-render gallery item if `needsUpdate`,
                        // or doesn't have `bounds` (entirely new slide object)
                        if (item && (_itemsNeedUpdate || item.needsUpdate || !item.bounds)) {

                            self.cleanSlide(item);

                            self.setContent(holder, hIndex);

                            // if "center" slide
                            if (i === 1) {
                                self.currItem = item;
                                self.updateCurrZoomItem(true);
                            }

                            item.needsUpdate = false;
                        } else if (holder.index === -1 && hIndex >= 0) {
                            // add content first time
                            self.setContent(holder, hIndex);
                        }
                        if (item && item.container) {
                            _calculateItemSize(item, _viewportSize);
                            _setImageSize(item);
                            _applyZoomPanToItem(item);
                        }
                    }
                    _itemsNeedUpdate = false;
                }

                _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;
                _currPanBounds = self.currItem.bounds;

                if (_currPanBounds) {
                    _panOffset.x = _currPanBounds.center.x;
                    _panOffset.y = _currPanBounds.center.y;
                    _applyCurrentZoomPan(true);
                }

                _shout('resize');
            },

            // Zoom current item to
            zoomTo: function zoomTo(destZoomLevel, centerPoint, speed, easingFn, updateFn) {
                /*
                    if(destZoomLevel === 'fit') {
                        destZoomLevel = self.currItem.fitRatio;
                    } else if(destZoomLevel === 'fill') {
                        destZoomLevel = self.currItem.fillRatio;
                    }
                */

                if (centerPoint) {
                    _startZoomLevel = _currZoomLevel;
                    _midZoomPoint.x = Math.abs(centerPoint.x) - _panOffset.x;
                    _midZoomPoint.y = Math.abs(centerPoint.y) - _panOffset.y;
                    _equalizePoints(_startPanOffset, _panOffset);
                }

                var destPanBounds = _calculatePanBounds(destZoomLevel, false),
                    destPanOffset = {};

                _modifyDestPanOffset('x', destPanBounds, destPanOffset, destZoomLevel);
                _modifyDestPanOffset('y', destPanBounds, destPanOffset, destZoomLevel);

                var initialZoomLevel = _currZoomLevel;
                var initialPanOffset = {
                    x: _panOffset.x,
                    y: _panOffset.y
                };

                _roundPoint(destPanOffset);

                var onUpdate = function onUpdate(now) {
                    if (now === 1) {
                        _currZoomLevel = destZoomLevel;
                        _panOffset.x = destPanOffset.x;
                        _panOffset.y = destPanOffset.y;
                    } else {
                        _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;
                        _panOffset.x = (destPanOffset.x - initialPanOffset.x) * now + initialPanOffset.x;
                        _panOffset.y = (destPanOffset.y - initialPanOffset.y) * now + initialPanOffset.y;
                    }

                    if (updateFn) {
                        updateFn(now);
                    }

                    _applyCurrentZoomPan(now === 1);
                };

                if (speed) {
                    _animateProp('customZoomTo', 0, 1, speed, easingFn || framework.easing.sine.inOut, onUpdate);
                } else {
                    onUpdate(1);
                }
            }

        };

        /*>>core*/

        /*>>gestures*/
        /**
         * Mouse/touch/pointer event handlers.
         * 
         * separated from @core.js for readability
         */

        var MIN_SWIPE_DISTANCE = 30,
            DIRECTION_CHECK_OFFSET = 10; // amount of pixels to drag to determine direction of swipe

        var _gestureStartTime,
            _gestureCheckSpeedTime,


        // pool of objects that are used during dragging of zooming
        p = {},
            // first point
        p2 = {},
            // second point (for zoom gesture)
        delta = {},
            _currPoint = {},
            _startPoint = {},
            _currPointers = [],
            _startMainScrollPos = {},
            _releaseAnimData,
            _posPoints = [],
            // array of points during dragging, used to determine type of gesture
        _tempPoint = {},
            _isZoomingIn,
            _verticalDragInitiated,
            _oldAndroidTouchEndTimeout,
            _currZoomedItemIndex = 0,
            _centerPoint = _getEmptyPoint(),
            _lastReleaseTime = 0,
            _isDragging,
            // at least one pointer is down
        _isMultitouch,
            // at least two _pointers are down
        _zoomStarted,
            // zoom level changed during zoom gesture
        _moved,
            _dragAnimFrame,
            _mainScrollShifted,
            _currentPoints,
            // array of current touch points
        _isZooming,
            _currPointsDistance,
            _startPointsDistance,
            _currPanBounds,
            _mainScrollPos = _getEmptyPoint(),
            _currZoomElementStyle,
            _mainScrollAnimating,
            // true, if animation after swipe gesture is running
        _midZoomPoint = _getEmptyPoint(),
            _currCenterPoint = _getEmptyPoint(),
            _direction,
            _isFirstMove,
            _opacityChanged,
            _bgOpacity,
            _wasOverInitialZoom,
            _isEqualPoints = function _isEqualPoints(p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
        },
            _isNearbyPoints = function _isNearbyPoints(touch0, touch1) {
            return Math.abs(touch0.x - touch1.x) < DOUBLE_TAP_RADIUS && Math.abs(touch0.y - touch1.y) < DOUBLE_TAP_RADIUS;
        },
            _calculatePointsDistance = function _calculatePointsDistance(p1, p2) {
            _tempPoint.x = Math.abs(p1.x - p2.x);
            _tempPoint.y = Math.abs(p1.y - p2.y);
            return Math.sqrt(_tempPoint.x * _tempPoint.x + _tempPoint.y * _tempPoint.y);
        },
            _stopDragUpdateLoop = function _stopDragUpdateLoop() {
            if (_dragAnimFrame) {
                _cancelAF(_dragAnimFrame);
                _dragAnimFrame = null;
            }
        },
            _dragUpdateLoop = function _dragUpdateLoop() {
            if (_isDragging) {
                _dragAnimFrame = _requestAF(_dragUpdateLoop);
                _renderMovement();
            }
        },
            _canPan = function _canPan() {
            return !(_options.scaleMode === 'fit' && _currZoomLevel === self.currItem.initialZoomLevel);
        },


        // find the closest parent DOM element
        _closestElement = function _closestElement(el, fn) {
            if (!el || el === document) {
                return false;
            }

            // don't search elements above pswp__scroll-wrap
            if (el.getAttribute('class') && el.getAttribute('class').indexOf('pswp__scroll-wrap') > -1) {
                return false;
            }

            if (fn(el)) {
                return el;
            }

            return _closestElement(el.parentNode, fn);
        },
            _preventObj = {},
            _preventDefaultEventBehaviour = function _preventDefaultEventBehaviour(e, isDown) {
            _preventObj.prevent = !_closestElement(e.target, _options.isClickableElement);

            _shout('preventDragEvent', e, isDown, _preventObj);
            return _preventObj.prevent;
        },
            _convertTouchToPoint = function _convertTouchToPoint(touch, p) {
            p.x = touch.pageX;
            p.y = touch.pageY;
            p.id = touch.identifier;
            return p;
        },
            _findCenterOfPoints = function _findCenterOfPoints(p1, p2, pCenter) {
            pCenter.x = (p1.x + p2.x) * 0.5;
            pCenter.y = (p1.y + p2.y) * 0.5;
        },
            _pushPosPoint = function _pushPosPoint(time, x, y) {
            if (time - _gestureCheckSpeedTime > 50) {
                var o = _posPoints.length > 2 ? _posPoints.shift() : {};
                o.x = x;
                o.y = y;
                _posPoints.push(o);
                _gestureCheckSpeedTime = time;
            }
        },
            _calculateVerticalDragOpacityRatio = function _calculateVerticalDragOpacityRatio() {
            var yOffset = _panOffset.y - self.currItem.initialPosition.y; // difference between initial and current position
            return 1 - Math.abs(yOffset / (_viewportSize.y / 2));
        },


        // points pool, reused during touch events
        _ePoint1 = {},
            _ePoint2 = {},
            _tempPointsArr = [],
            _tempCounter,
            _getTouchPoints = function _getTouchPoints(e) {
            // clean up previous points, without recreating array
            while (_tempPointsArr.length > 0) {
                _tempPointsArr.pop();
            }

            if (!_pointerEventEnabled) {
                if (e.type.indexOf('touch') > -1) {

                    if (e.touches && e.touches.length > 0) {
                        _tempPointsArr[0] = _convertTouchToPoint(e.touches[0], _ePoint1);
                        if (e.touches.length > 1) {
                            _tempPointsArr[1] = _convertTouchToPoint(e.touches[1], _ePoint2);
                        }
                    }
                } else {
                    _ePoint1.x = e.pageX;
                    _ePoint1.y = e.pageY;
                    _ePoint1.id = '';
                    _tempPointsArr[0] = _ePoint1; //_ePoint1;
                }
            } else {
                _tempCounter = 0;
                // we can use forEach, as pointer events are supported only in modern browsers
                _currPointers.forEach(function (p) {
                    if (_tempCounter === 0) {
                        _tempPointsArr[0] = p;
                    } else if (_tempCounter === 1) {
                        _tempPointsArr[1] = p;
                    }
                    _tempCounter++;
                });
            }
            return _tempPointsArr;
        },
            _panOrMoveMainScroll = function _panOrMoveMainScroll(axis, delta) {

            var panFriction,
                overDiff = 0,
                newOffset = _panOffset[axis] + delta[axis],
                startOverDiff,
                dir = delta[axis] > 0,
                newMainScrollPosition = _mainScrollPos.x + delta.x,
                mainScrollDiff = _mainScrollPos.x - _startMainScrollPos.x,
                newPanPos,
                newMainScrollPos;

            // calculate fdistance over the bounds and friction
            if (newOffset > _currPanBounds.min[axis] || newOffset < _currPanBounds.max[axis]) {
                panFriction = _options.panEndFriction;
                // Linear increasing of friction, so at 1/4 of viewport it's at max value. 
                // Looks not as nice as was expected. Left for history.
                // panFriction = (1 - (_panOffset[axis] + delta[axis] + panBounds.min[axis]) / (_viewportSize[axis] / 4) );
            } else {
                panFriction = 1;
            }

            newOffset = _panOffset[axis] + delta[axis] * panFriction;

            // move main scroll or start panning
            if (_options.allowPanToNext || _currZoomLevel === self.currItem.initialZoomLevel) {

                if (!_currZoomElementStyle) {

                    newMainScrollPos = newMainScrollPosition;
                } else if (_direction === 'h' && axis === 'x' && !_zoomStarted) {

                    if (dir) {
                        if (newOffset > _currPanBounds.min[axis]) {
                            panFriction = _options.panEndFriction;
                            overDiff = _currPanBounds.min[axis] - newOffset;
                            startOverDiff = _currPanBounds.min[axis] - _startPanOffset[axis];
                        }

                        // drag right
                        if ((startOverDiff <= 0 || mainScrollDiff < 0) && _getNumItems() > 1) {
                            newMainScrollPos = newMainScrollPosition;
                            if (mainScrollDiff < 0 && newMainScrollPosition > _startMainScrollPos.x) {
                                newMainScrollPos = _startMainScrollPos.x;
                            }
                        } else {
                            if (_currPanBounds.min.x !== _currPanBounds.max.x) {
                                newPanPos = newOffset;
                            }
                        }
                    } else {

                        if (newOffset < _currPanBounds.max[axis]) {
                            panFriction = _options.panEndFriction;
                            overDiff = newOffset - _currPanBounds.max[axis];
                            startOverDiff = _startPanOffset[axis] - _currPanBounds.max[axis];
                        }

                        if ((startOverDiff <= 0 || mainScrollDiff > 0) && _getNumItems() > 1) {
                            newMainScrollPos = newMainScrollPosition;

                            if (mainScrollDiff > 0 && newMainScrollPosition < _startMainScrollPos.x) {
                                newMainScrollPos = _startMainScrollPos.x;
                            }
                        } else {
                            if (_currPanBounds.min.x !== _currPanBounds.max.x) {
                                newPanPos = newOffset;
                            }
                        }
                    }

                    //
                }

                if (axis === 'x') {

                    if (newMainScrollPos !== undefined) {
                        _moveMainScroll(newMainScrollPos, true);
                        if (newMainScrollPos === _startMainScrollPos.x) {
                            _mainScrollShifted = false;
                        } else {
                            _mainScrollShifted = true;
                        }
                    }

                    if (_currPanBounds.min.x !== _currPanBounds.max.x) {
                        if (newPanPos !== undefined) {
                            _panOffset.x = newPanPos;
                        } else if (!_mainScrollShifted) {
                            _panOffset.x += delta.x * panFriction;
                        }
                    }

                    return newMainScrollPos !== undefined;
                }
            }

            if (!_mainScrollAnimating) {

                if (!_mainScrollShifted) {
                    if (_currZoomLevel > self.currItem.fitRatio) {
                        _panOffset[axis] += delta[axis] * panFriction;
                    }
                }
            }
        },


        // Pointerdown/touchstart/mousedown handler
        _onDragStart = function _onDragStart(e) {

            // Allow dragging only via left mouse button.
            // As this handler is not added in IE8 - we ignore e.which
            // 
            // http://www.quirksmode.org/js/events_properties.html
            // https://developer.mozilla.org/en-US/docs/Web/API/event.button
            if (e.type === 'mousedown' && e.button > 0) {
                return;
            }

            if (_initialZoomRunning) {
                e.preventDefault();
                return;
            }

            if (_oldAndroidTouchEndTimeout && e.type === 'mousedown') {
                return;
            }

            if (_preventDefaultEventBehaviour(e, true)) {
                e.preventDefault();
            }

            _shout('pointerDown');

            if (_pointerEventEnabled) {
                var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');
                if (pointerIndex < 0) {
                    pointerIndex = _currPointers.length;
                }
                _currPointers[pointerIndex] = { x: e.pageX, y: e.pageY, id: e.pointerId };
            }

            var startPointsList = _getTouchPoints(e),
                numPoints = startPointsList.length;

            _currentPoints = null;

            _stopAllAnimations();

            // init drag
            if (!_isDragging || numPoints === 1) {

                _isDragging = _isFirstMove = true;
                framework.bind(window, _upMoveEvents, self);

                _isZoomingIn = _wasOverInitialZoom = _opacityChanged = _verticalDragInitiated = _mainScrollShifted = _moved = _isMultitouch = _zoomStarted = false;

                _direction = null;

                _shout('firstTouchStart', startPointsList);

                _equalizePoints(_startPanOffset, _panOffset);

                _currPanDist.x = _currPanDist.y = 0;
                _equalizePoints(_currPoint, startPointsList[0]);
                _equalizePoints(_startPoint, _currPoint);

                //_equalizePoints(_startMainScrollPos, _mainScrollPos);
                _startMainScrollPos.x = _slideSize.x * _currPositionIndex;

                _posPoints = [{
                    x: _currPoint.x,
                    y: _currPoint.y
                }];

                _gestureCheckSpeedTime = _gestureStartTime = _getCurrentTime();

                //_mainScrollAnimationEnd(true);
                _calculatePanBounds(_currZoomLevel, true);

                // Start rendering
                _stopDragUpdateLoop();
                _dragUpdateLoop();
            }

            // init zoom
            if (!_isZooming && numPoints > 1 && !_mainScrollAnimating && !_mainScrollShifted) {
                _startZoomLevel = _currZoomLevel;
                _zoomStarted = false; // true if zoom changed at least once

                _isZooming = _isMultitouch = true;
                _currPanDist.y = _currPanDist.x = 0;

                _equalizePoints(_startPanOffset, _panOffset);

                _equalizePoints(p, startPointsList[0]);
                _equalizePoints(p2, startPointsList[1]);

                _findCenterOfPoints(p, p2, _currCenterPoint);

                _midZoomPoint.x = Math.abs(_currCenterPoint.x) - _panOffset.x;
                _midZoomPoint.y = Math.abs(_currCenterPoint.y) - _panOffset.y;
                _currPointsDistance = _startPointsDistance = _calculatePointsDistance(p, p2);
            }
        },


        // Pointermove/touchmove/mousemove handler
        _onDragMove = function _onDragMove(e) {

            e.preventDefault();

            if (_pointerEventEnabled) {
                var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');
                if (pointerIndex > -1) {
                    var p = _currPointers[pointerIndex];
                    p.x = e.pageX;
                    p.y = e.pageY;
                }
            }

            if (_isDragging) {
                var touchesList = _getTouchPoints(e);
                if (!_direction && !_moved && !_isZooming) {

                    if (_mainScrollPos.x !== _slideSize.x * _currPositionIndex) {
                        // if main scroll position is shifted  direction is always horizontal
                        _direction = 'h';
                    } else {
                        var diff = Math.abs(touchesList[0].x - _currPoint.x) - Math.abs(touchesList[0].y - _currPoint.y);
                        // check the direction of movement
                        if (Math.abs(diff) >= DIRECTION_CHECK_OFFSET) {
                            _direction = diff > 0 ? 'h' : 'v';
                            _currentPoints = touchesList;
                        }
                    }
                } else {
                    _currentPoints = touchesList;
                }
            }
        },

        // 
        _renderMovement = function _renderMovement() {

            if (!_currentPoints) {
                return;
            }

            var numPoints = _currentPoints.length;

            if (numPoints === 0) {
                return;
            }

            _equalizePoints(p, _currentPoints[0]);

            delta.x = p.x - _currPoint.x;
            delta.y = p.y - _currPoint.y;

            if (_isZooming && numPoints > 1) {
                // Handle behaviour for more than 1 point

                _currPoint.x = p.x;
                _currPoint.y = p.y;

                // check if one of two points changed
                if (!delta.x && !delta.y && _isEqualPoints(_currentPoints[1], p2)) {
                    return;
                }

                _equalizePoints(p2, _currentPoints[1]);

                if (!_zoomStarted) {
                    _zoomStarted = true;
                    _shout('zoomGestureStarted');
                }

                // Distance between two points
                var pointsDistance = _calculatePointsDistance(p, p2);

                var zoomLevel = _calculateZoomLevel(pointsDistance);

                // slightly over the of initial zoom level
                if (zoomLevel > self.currItem.initialZoomLevel + self.currItem.initialZoomLevel / 15) {
                    _wasOverInitialZoom = true;
                }

                // Apply the friction if zoom level is out of the bounds
                var zoomFriction = 1,
                    minZoomLevel = _getMinZoomLevel(),
                    maxZoomLevel = _getMaxZoomLevel();

                if (zoomLevel < minZoomLevel) {

                    if (_options.pinchToClose && !_wasOverInitialZoom && _startZoomLevel <= self.currItem.initialZoomLevel) {
                        // fade out background if zooming out
                        var minusDiff = minZoomLevel - zoomLevel;
                        var percent = 1 - minusDiff / (minZoomLevel / 1.2);

                        _applyBgOpacity(percent);
                        _shout('onPinchClose', percent);
                        _opacityChanged = true;
                    } else {
                        zoomFriction = (minZoomLevel - zoomLevel) / minZoomLevel;
                        if (zoomFriction > 1) {
                            zoomFriction = 1;
                        }
                        zoomLevel = minZoomLevel - zoomFriction * (minZoomLevel / 3);
                    }
                } else if (zoomLevel > maxZoomLevel) {
                    // 1.5 - extra zoom level above the max. E.g. if max is x6, real max 6 + 1.5 = 7.5
                    zoomFriction = (zoomLevel - maxZoomLevel) / (minZoomLevel * 6);
                    if (zoomFriction > 1) {
                        zoomFriction = 1;
                    }
                    zoomLevel = maxZoomLevel + zoomFriction * minZoomLevel;
                }

                if (zoomFriction < 0) {
                    zoomFriction = 0;
                }

                // distance between touch points after friction is applied
                _currPointsDistance = pointsDistance;

                // _centerPoint - The point in the middle of two pointers
                _findCenterOfPoints(p, p2, _centerPoint);

                // paning with two pointers pressed
                _currPanDist.x += _centerPoint.x - _currCenterPoint.x;
                _currPanDist.y += _centerPoint.y - _currCenterPoint.y;
                _equalizePoints(_currCenterPoint, _centerPoint);

                _panOffset.x = _calculatePanOffset('x', zoomLevel);
                _panOffset.y = _calculatePanOffset('y', zoomLevel);

                _isZoomingIn = zoomLevel > _currZoomLevel;
                _currZoomLevel = zoomLevel;
                _applyCurrentZoomPan();
            } else {

                // handle behaviour for one point (dragging or panning)

                if (!_direction) {
                    return;
                }

                if (_isFirstMove) {
                    _isFirstMove = false;

                    // subtract drag distance that was used during the detection direction  

                    if (Math.abs(delta.x) >= DIRECTION_CHECK_OFFSET) {
                        delta.x -= _currentPoints[0].x - _startPoint.x;
                    }

                    if (Math.abs(delta.y) >= DIRECTION_CHECK_OFFSET) {
                        delta.y -= _currentPoints[0].y - _startPoint.y;
                    }
                }

                _currPoint.x = p.x;
                _currPoint.y = p.y;

                // do nothing if pointers position hasn't changed
                if (delta.x === 0 && delta.y === 0) {
                    return;
                }

                if (_direction === 'v' && _options.closeOnVerticalDrag) {
                    if (!_canPan()) {
                        _currPanDist.y += delta.y;
                        _panOffset.y += delta.y;

                        var opacityRatio = _calculateVerticalDragOpacityRatio();

                        _verticalDragInitiated = true;
                        _shout('onVerticalDrag', opacityRatio);

                        _applyBgOpacity(opacityRatio);
                        _applyCurrentZoomPan();
                        return;
                    }
                }

                _pushPosPoint(_getCurrentTime(), p.x, p.y);

                _moved = true;
                _currPanBounds = self.currItem.bounds;

                var mainScrollChanged = _panOrMoveMainScroll('x', delta);
                if (!mainScrollChanged) {
                    _panOrMoveMainScroll('y', delta);

                    _roundPoint(_panOffset);
                    _applyCurrentZoomPan();
                }
            }
        },


        // Pointerup/pointercancel/touchend/touchcancel/mouseup event handler
        _onDragRelease = function _onDragRelease(e) {

            if (_features.isOldAndroid) {

                if (_oldAndroidTouchEndTimeout && e.type === 'mouseup') {
                    return;
                }

                // on Android (v4.1, 4.2, 4.3 & possibly older) 
                // ghost mousedown/up event isn't preventable via e.preventDefault,
                // which causes fake mousedown event
                // so we block mousedown/up for 600ms
                if (e.type.indexOf('touch') > -1) {
                    clearTimeout(_oldAndroidTouchEndTimeout);
                    _oldAndroidTouchEndTimeout = setTimeout(function () {
                        _oldAndroidTouchEndTimeout = 0;
                    }, 600);
                }
            }

            _shout('pointerUp');

            if (_preventDefaultEventBehaviour(e, false)) {
                e.preventDefault();
            }

            var releasePoint;

            if (_pointerEventEnabled) {
                var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');

                if (pointerIndex > -1) {
                    releasePoint = _currPointers.splice(pointerIndex, 1)[0];

                    if (navigator.pointerEnabled) {
                        releasePoint.type = e.pointerType || 'mouse';
                    } else {
                        var MSPOINTER_TYPES = {
                            4: 'mouse', // event.MSPOINTER_TYPE_MOUSE
                            2: 'touch', // event.MSPOINTER_TYPE_TOUCH 
                            3: 'pen' // event.MSPOINTER_TYPE_PEN
                        };
                        releasePoint.type = MSPOINTER_TYPES[e.pointerType];

                        if (!releasePoint.type) {
                            releasePoint.type = e.pointerType || 'mouse';
                        }
                    }
                }
            }

            var touchList = _getTouchPoints(e),
                gestureType,
                numPoints = touchList.length;

            if (e.type === 'mouseup') {
                numPoints = 0;
            }

            // Do nothing if there were 3 touch points or more
            if (numPoints === 2) {
                _currentPoints = null;
                return true;
            }

            // if second pointer released
            if (numPoints === 1) {
                _equalizePoints(_startPoint, touchList[0]);
            }

            // pointer hasn't moved, send "tap release" point
            if (numPoints === 0 && !_direction && !_mainScrollAnimating) {
                if (!releasePoint) {
                    if (e.type === 'mouseup') {
                        releasePoint = { x: e.pageX, y: e.pageY, type: 'mouse' };
                    } else if (e.changedTouches && e.changedTouches[0]) {
                        releasePoint = { x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY, type: 'touch' };
                    }
                }

                _shout('touchRelease', e, releasePoint);
            }

            // Difference in time between releasing of two last touch points (zoom gesture)
            var releaseTimeDiff = -1;

            // Gesture completed, no pointers left
            if (numPoints === 0) {
                _isDragging = false;
                framework.unbind(window, _upMoveEvents, self);

                _stopDragUpdateLoop();

                if (_isZooming) {
                    // Two points released at the same time
                    releaseTimeDiff = 0;
                } else if (_lastReleaseTime !== -1) {
                    releaseTimeDiff = _getCurrentTime() - _lastReleaseTime;
                }
            }
            _lastReleaseTime = numPoints === 1 ? _getCurrentTime() : -1;

            if (releaseTimeDiff !== -1 && releaseTimeDiff < 150) {
                gestureType = 'zoom';
            } else {
                gestureType = 'swipe';
            }

            if (_isZooming && numPoints < 2) {
                _isZooming = false;

                // Only second point released
                if (numPoints === 1) {
                    gestureType = 'zoomPointerUp';
                }
                _shout('zoomGestureEnded');
            }

            _currentPoints = null;
            if (!_moved && !_zoomStarted && !_mainScrollAnimating && !_verticalDragInitiated) {
                // nothing to animate
                return;
            }

            _stopAllAnimations();

            if (!_releaseAnimData) {
                _releaseAnimData = _initDragReleaseAnimationData();
            }

            _releaseAnimData.calculateSwipeSpeed('x');

            if (_verticalDragInitiated) {

                var opacityRatio = _calculateVerticalDragOpacityRatio();

                if (opacityRatio < _options.verticalDragRange) {
                    self.close();
                } else {
                    var initalPanY = _panOffset.y,
                        initialBgOpacity = _bgOpacity;

                    _animateProp('verticalDrag', 0, 1, 300, framework.easing.cubic.out, function (now) {

                        _panOffset.y = (self.currItem.initialPosition.y - initalPanY) * now + initalPanY;

                        _applyBgOpacity((1 - initialBgOpacity) * now + initialBgOpacity);
                        _applyCurrentZoomPan();
                    });

                    _shout('onVerticalDrag', 1);
                }

                return;
            }

            // main scroll 
            if ((_mainScrollShifted || _mainScrollAnimating) && numPoints === 0) {
                var itemChanged = _finishSwipeMainScrollGesture(gestureType, _releaseAnimData);
                if (itemChanged) {
                    return;
                }
                gestureType = 'zoomPointerUp';
            }

            // prevent zoom/pan animation when main scroll animation runs
            if (_mainScrollAnimating) {
                return;
            }

            // Complete simple zoom gesture (reset zoom level if it's out of the bounds)  
            if (gestureType !== 'swipe') {
                _completeZoomGesture();
                return;
            }

            // Complete pan gesture if main scroll is not shifted, and it's possible to pan current image
            if (!_mainScrollShifted && _currZoomLevel > self.currItem.fitRatio) {
                _completePanGesture(_releaseAnimData);
            }
        },


        // Returns object with data about gesture
        // It's created only once and then reused
        _initDragReleaseAnimationData = function _initDragReleaseAnimationData() {
            // temp local vars
            var lastFlickDuration, tempReleasePos;

            // s = this
            var s = {
                lastFlickOffset: {},
                lastFlickDist: {},
                lastFlickSpeed: {},
                slowDownRatio: {},
                slowDownRatioReverse: {},
                speedDecelerationRatio: {},
                speedDecelerationRatioAbs: {},
                distanceOffset: {},
                backAnimDestination: {},
                backAnimStarted: {},
                calculateSwipeSpeed: function calculateSwipeSpeed(axis) {

                    if (_posPoints.length > 1) {
                        lastFlickDuration = _getCurrentTime() - _gestureCheckSpeedTime + 50;
                        tempReleasePos = _posPoints[_posPoints.length - 2][axis];
                    } else {
                        lastFlickDuration = _getCurrentTime() - _gestureStartTime; // total gesture duration
                        tempReleasePos = _startPoint[axis];
                    }
                    s.lastFlickOffset[axis] = _currPoint[axis] - tempReleasePos;
                    s.lastFlickDist[axis] = Math.abs(s.lastFlickOffset[axis]);
                    if (s.lastFlickDist[axis] > 20) {
                        s.lastFlickSpeed[axis] = s.lastFlickOffset[axis] / lastFlickDuration;
                    } else {
                        s.lastFlickSpeed[axis] = 0;
                    }
                    if (Math.abs(s.lastFlickSpeed[axis]) < 0.1) {
                        s.lastFlickSpeed[axis] = 0;
                    }

                    s.slowDownRatio[axis] = 0.95;
                    s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];
                    s.speedDecelerationRatio[axis] = 1;
                },

                calculateOverBoundsAnimOffset: function calculateOverBoundsAnimOffset(axis, speed) {
                    if (!s.backAnimStarted[axis]) {

                        if (_panOffset[axis] > _currPanBounds.min[axis]) {
                            s.backAnimDestination[axis] = _currPanBounds.min[axis];
                        } else if (_panOffset[axis] < _currPanBounds.max[axis]) {
                            s.backAnimDestination[axis] = _currPanBounds.max[axis];
                        }

                        if (s.backAnimDestination[axis] !== undefined) {
                            s.slowDownRatio[axis] = 0.7;
                            s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];
                            if (s.speedDecelerationRatioAbs[axis] < 0.05) {

                                s.lastFlickSpeed[axis] = 0;
                                s.backAnimStarted[axis] = true;

                                _animateProp('bounceZoomPan' + axis, _panOffset[axis], s.backAnimDestination[axis], speed || 300, framework.easing.sine.out, function (pos) {
                                    _panOffset[axis] = pos;
                                    _applyCurrentZoomPan();
                                });
                            }
                        }
                    }
                },

                // Reduces the speed by slowDownRatio (per 10ms)
                calculateAnimOffset: function calculateAnimOffset(axis) {
                    if (!s.backAnimStarted[axis]) {
                        s.speedDecelerationRatio[axis] = s.speedDecelerationRatio[axis] * (s.slowDownRatio[axis] + s.slowDownRatioReverse[axis] - s.slowDownRatioReverse[axis] * s.timeDiff / 10);

                        s.speedDecelerationRatioAbs[axis] = Math.abs(s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis]);
                        s.distanceOffset[axis] = s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis] * s.timeDiff;
                        _panOffset[axis] += s.distanceOffset[axis];
                    }
                },

                panAnimLoop: function panAnimLoop() {
                    if (_animations.zoomPan) {
                        _animations.zoomPan.raf = _requestAF(s.panAnimLoop);

                        s.now = _getCurrentTime();
                        s.timeDiff = s.now - s.lastNow;
                        s.lastNow = s.now;

                        s.calculateAnimOffset('x');
                        s.calculateAnimOffset('y');

                        _applyCurrentZoomPan();

                        s.calculateOverBoundsAnimOffset('x');
                        s.calculateOverBoundsAnimOffset('y');

                        if (s.speedDecelerationRatioAbs.x < 0.05 && s.speedDecelerationRatioAbs.y < 0.05) {

                            // round pan position
                            _panOffset.x = Math.round(_panOffset.x);
                            _panOffset.y = Math.round(_panOffset.y);
                            _applyCurrentZoomPan();

                            _stopAnimation('zoomPan');
                            return;
                        }
                    }
                }
            };
            return s;
        },
            _completePanGesture = function _completePanGesture(animData) {
            // calculate swipe speed for Y axis (paanning)
            animData.calculateSwipeSpeed('y');

            _currPanBounds = self.currItem.bounds;

            animData.backAnimDestination = {};
            animData.backAnimStarted = {};

            // Avoid acceleration animation if speed is too low
            if (Math.abs(animData.lastFlickSpeed.x) <= 0.05 && Math.abs(animData.lastFlickSpeed.y) <= 0.05) {
                animData.speedDecelerationRatioAbs.x = animData.speedDecelerationRatioAbs.y = 0;

                // Run pan drag release animation. E.g. if you drag image and release finger without momentum.
                animData.calculateOverBoundsAnimOffset('x');
                animData.calculateOverBoundsAnimOffset('y');
                return true;
            }

            // Animation loop that controls the acceleration after pan gesture ends
            _registerStartAnimation('zoomPan');
            animData.lastNow = _getCurrentTime();
            animData.panAnimLoop();
        },
            _finishSwipeMainScrollGesture = function _finishSwipeMainScrollGesture(gestureType, _releaseAnimData) {
            var itemChanged;
            if (!_mainScrollAnimating) {
                _currZoomedItemIndex = _currentItemIndex;
            }

            var itemsDiff;

            if (gestureType === 'swipe') {
                var totalShiftDist = _currPoint.x - _startPoint.x,
                    isFastLastFlick = _releaseAnimData.lastFlickDist.x < 10;

                // if container is shifted for more than MIN_SWIPE_DISTANCE, 
                // and last flick gesture was in right direction
                if (totalShiftDist > MIN_SWIPE_DISTANCE && (isFastLastFlick || _releaseAnimData.lastFlickOffset.x > 20)) {
                    // go to prev item
                    itemsDiff = -1;
                } else if (totalShiftDist < -MIN_SWIPE_DISTANCE && (isFastLastFlick || _releaseAnimData.lastFlickOffset.x < -20)) {
                    // go to next item
                    itemsDiff = 1;
                }
            }

            var nextCircle;

            if (itemsDiff) {

                _currentItemIndex += itemsDiff;

                if (_currentItemIndex < 0) {
                    _currentItemIndex = _options.loop ? _getNumItems() - 1 : 0;
                    nextCircle = true;
                } else if (_currentItemIndex >= _getNumItems()) {
                    _currentItemIndex = _options.loop ? 0 : _getNumItems() - 1;
                    nextCircle = true;
                }

                if (!nextCircle || _options.loop) {
                    _indexDiff += itemsDiff;
                    _currPositionIndex -= itemsDiff;
                    itemChanged = true;
                }
            }

            var animateToX = _slideSize.x * _currPositionIndex;
            var animateToDist = Math.abs(animateToX - _mainScrollPos.x);
            var finishAnimDuration;

            if (!itemChanged && animateToX > _mainScrollPos.x !== _releaseAnimData.lastFlickSpeed.x > 0) {
                // "return to current" duration, e.g. when dragging from slide 0 to -1
                finishAnimDuration = 333;
            } else {
                finishAnimDuration = Math.abs(_releaseAnimData.lastFlickSpeed.x) > 0 ? animateToDist / Math.abs(_releaseAnimData.lastFlickSpeed.x) : 333;

                finishAnimDuration = Math.min(finishAnimDuration, 400);
                finishAnimDuration = Math.max(finishAnimDuration, 250);
            }

            if (_currZoomedItemIndex === _currentItemIndex) {
                itemChanged = false;
            }

            _mainScrollAnimating = true;

            _shout('mainScrollAnimStart');

            _animateProp('mainScroll', _mainScrollPos.x, animateToX, finishAnimDuration, framework.easing.cubic.out, _moveMainScroll, function () {
                _stopAllAnimations();
                _mainScrollAnimating = false;
                _currZoomedItemIndex = -1;

                if (itemChanged || _currZoomedItemIndex !== _currentItemIndex) {
                    self.updateCurrItem();
                }

                _shout('mainScrollAnimComplete');
            });

            if (itemChanged) {
                self.updateCurrItem(true);
            }

            return itemChanged;
        },
            _calculateZoomLevel = function _calculateZoomLevel(touchesDistance) {
            return 1 / _startPointsDistance * touchesDistance * _startZoomLevel;
        },


        // Resets zoom if it's out of bounds
        _completeZoomGesture = function _completeZoomGesture() {
            var destZoomLevel = _currZoomLevel,
                minZoomLevel = _getMinZoomLevel(),
                maxZoomLevel = _getMaxZoomLevel();

            if (_currZoomLevel < minZoomLevel) {
                destZoomLevel = minZoomLevel;
            } else if (_currZoomLevel > maxZoomLevel) {
                destZoomLevel = maxZoomLevel;
            }

            var destOpacity = 1,
                onUpdate,
                initialOpacity = _bgOpacity;

            if (_opacityChanged && !_isZoomingIn && !_wasOverInitialZoom && _currZoomLevel < minZoomLevel) {
                //_closedByScroll = true;
                self.close();
                return true;
            }

            if (_opacityChanged) {
                onUpdate = function onUpdate(now) {
                    _applyBgOpacity((destOpacity - initialOpacity) * now + initialOpacity);
                };
            }

            self.zoomTo(destZoomLevel, 0, 200, framework.easing.cubic.out, onUpdate);
            return true;
        };

        _registerModule('Gestures', {
            publicMethods: {

                initGestures: function initGestures() {

                    // helper function that builds touch/pointer/mouse events
                    var addEventNames = function addEventNames(pref, down, move, up, cancel) {
                        _dragStartEvent = pref + down;
                        _dragMoveEvent = pref + move;
                        _dragEndEvent = pref + up;
                        if (cancel) {
                            _dragCancelEvent = pref + cancel;
                        } else {
                            _dragCancelEvent = '';
                        }
                    };

                    _pointerEventEnabled = _features.pointerEvent;
                    if (_pointerEventEnabled && _features.touch) {
                        // we don't need touch events, if browser supports pointer events
                        _features.touch = false;
                    }

                    if (_pointerEventEnabled) {
                        if (navigator.pointerEnabled) {
                            addEventNames('pointer', 'down', 'move', 'up', 'cancel');
                        } else {
                            // IE10 pointer events are case-sensitive
                            addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
                        }
                    } else if (_features.touch) {
                        addEventNames('touch', 'start', 'move', 'end', 'cancel');
                        _likelyTouchDevice = true;
                    } else {
                        addEventNames('mouse', 'down', 'move', 'up');
                    }

                    _upMoveEvents = _dragMoveEvent + ' ' + _dragEndEvent + ' ' + _dragCancelEvent;
                    _downEvents = _dragStartEvent;

                    if (_pointerEventEnabled && !_likelyTouchDevice) {
                        _likelyTouchDevice = navigator.maxTouchPoints > 1 || navigator.msMaxTouchPoints > 1;
                    }
                    // make variable public
                    self.likelyTouchDevice = _likelyTouchDevice;

                    _globalEventHandlers[_dragStartEvent] = _onDragStart;
                    _globalEventHandlers[_dragMoveEvent] = _onDragMove;
                    _globalEventHandlers[_dragEndEvent] = _onDragRelease; // the Kraken

                    if (_dragCancelEvent) {
                        _globalEventHandlers[_dragCancelEvent] = _globalEventHandlers[_dragEndEvent];
                    }

                    // Bind mouse events on device with detected hardware touch support, in case it supports multiple types of input.
                    if (_features.touch) {
                        _downEvents += ' mousedown';
                        _upMoveEvents += ' mousemove mouseup';
                        _globalEventHandlers.mousedown = _globalEventHandlers[_dragStartEvent];
                        _globalEventHandlers.mousemove = _globalEventHandlers[_dragMoveEvent];
                        _globalEventHandlers.mouseup = _globalEventHandlers[_dragEndEvent];
                    }

                    if (!_likelyTouchDevice) {
                        // don't allow pan to next slide from zoomed state on Desktop
                        _options.allowPanToNext = false;
                    }
                }

            }
        });

        /*>>gestures*/

        /*>>show-hide-transition*/
        /**
         * show-hide-transition.js:
         *
         * Manages initial opening or closing transition.
         *
         * If you're not planning to use transition for gallery at all,
         * you may set options hideAnimationDuration and showAnimationDuration to 0,
         * and just delete startAnimation function.
         * 
         */

        var _showOrHideTimeout,
            _showOrHide = function _showOrHide(item, img, out, completeFn) {

            if (_showOrHideTimeout) {
                clearTimeout(_showOrHideTimeout);
            }

            _initialZoomRunning = true;
            _initialContentSet = true;

            // dimensions of small thumbnail {x:,y:,w:}.
            // Height is optional, as calculated based on large image.
            var thumbBounds;
            if (item.initialLayout) {
                thumbBounds = item.initialLayout;
                item.initialLayout = null;
            } else {
                thumbBounds = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);
            }

            var duration = out ? _options.hideAnimationDuration : _options.showAnimationDuration;

            var onComplete = function onComplete() {
                _stopAnimation('initialZoom');
                if (!out) {
                    _applyBgOpacity(1);
                    if (img) {
                        img.style.display = 'block';
                    }
                    framework.addClass(template, 'pswp--animated-in');
                    _shout('initialZoom' + (out ? 'OutEnd' : 'InEnd'));
                } else {
                    self.template.removeAttribute('style');
                    self.bg.removeAttribute('style');
                }

                if (completeFn) {
                    completeFn();
                }
                _initialZoomRunning = false;
            };

            // if bounds aren't provided, just open gallery without animation
            if (!duration || !thumbBounds || thumbBounds.x === undefined) {

                _shout('initialZoom' + (out ? 'Out' : 'In'));

                _currZoomLevel = item.initialZoomLevel;
                _equalizePoints(_panOffset, item.initialPosition);
                _applyCurrentZoomPan();

                template.style.opacity = out ? 0 : 1;
                _applyBgOpacity(1);

                if (duration) {
                    setTimeout(function () {
                        onComplete();
                    }, duration);
                } else {
                    onComplete();
                }

                return;
            }

            var startAnimation = function startAnimation() {
                var closeWithRaf = _closedByScroll,
                    fadeEverything = !self.currItem.src || self.currItem.loadError || _options.showHideOpacity;

                // apply hw-acceleration to image
                if (item.miniImg) {
                    item.miniImg.style.webkitBackfaceVisibility = 'hidden';
                }

                if (!out) {
                    _currZoomLevel = thumbBounds.w / item.w;
                    _panOffset.x = thumbBounds.x;
                    _panOffset.y = thumbBounds.y - _initalWindowScrollY;

                    self[fadeEverything ? 'template' : 'bg'].style.opacity = 0.001;
                    _applyCurrentZoomPan();
                }

                _registerStartAnimation('initialZoom');

                if (out && !closeWithRaf) {
                    framework.removeClass(template, 'pswp--animated-in');
                }

                if (fadeEverything) {
                    if (out) {
                        framework[(closeWithRaf ? 'remove' : 'add') + 'Class'](template, 'pswp--animate_opacity');
                    } else {
                        setTimeout(function () {
                            framework.addClass(template, 'pswp--animate_opacity');
                        }, 30);
                    }
                }

                _showOrHideTimeout = setTimeout(function () {

                    _shout('initialZoom' + (out ? 'Out' : 'In'));

                    if (!out) {

                        // "in" animation always uses CSS transitions (instead of rAF).
                        // CSS transition work faster here, 
                        // as developer may also want to animate other things, 
                        // like ui on top of sliding area, which can be animated just via CSS

                        _currZoomLevel = item.initialZoomLevel;
                        _equalizePoints(_panOffset, item.initialPosition);
                        _applyCurrentZoomPan();
                        _applyBgOpacity(1);

                        if (fadeEverything) {
                            template.style.opacity = 1;
                        } else {
                            _applyBgOpacity(1);
                        }

                        _showOrHideTimeout = setTimeout(onComplete, duration + 20);
                    } else {

                        // "out" animation uses rAF only when PhotoSwipe is closed by browser scroll, to recalculate position
                        var destZoomLevel = thumbBounds.w / item.w,
                            initialPanOffset = {
                            x: _panOffset.x,
                            y: _panOffset.y
                        },
                            initialZoomLevel = _currZoomLevel,
                            initalBgOpacity = _bgOpacity,
                            onUpdate = function onUpdate(now) {

                            if (now === 1) {
                                _currZoomLevel = destZoomLevel;
                                _panOffset.x = thumbBounds.x;
                                _panOffset.y = thumbBounds.y - _currentWindowScrollY;
                            } else {
                                _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;
                                _panOffset.x = (thumbBounds.x - initialPanOffset.x) * now + initialPanOffset.x;
                                _panOffset.y = (thumbBounds.y - _currentWindowScrollY - initialPanOffset.y) * now + initialPanOffset.y;
                            }

                            _applyCurrentZoomPan();
                            if (fadeEverything) {
                                template.style.opacity = 1 - now;
                            } else {
                                _applyBgOpacity(initalBgOpacity - now * initalBgOpacity);
                            }
                        };

                        if (closeWithRaf) {
                            _animateProp('initialZoom', 0, 1, duration, framework.easing.cubic.out, onUpdate, onComplete);
                        } else {
                            onUpdate(1);
                            _showOrHideTimeout = setTimeout(onComplete, duration + 20);
                        }
                    }
                }, out ? 25 : 90); // Main purpose of this delay is to give browser time to paint and
                // create composite layers of PhotoSwipe UI parts (background, controls, caption, arrows).
                // Which avoids lag at the beginning of scale transition.
            };
            startAnimation();
        };

        /*>>show-hide-transition*/

        /*>>items-controller*/
        /**
        *
        * Controller manages gallery items, their dimensions, and their content.
        * 
        */

        var _items,
            _tempPanAreaSize = {},
            _imagesToAppendPool = [],
            _initialContentSet,
            _initialZoomRunning,
            _controllerDefaultOptions = {
            index: 0,
            errorMsg: '<div class="pswp__error-msg"><a href="%url%" target="_blank">The image</a> could not be loaded.</div>',
            forceProgressiveLoading: false, // TODO
            preload: [1, 1],
            getNumItemsFn: function getNumItemsFn() {
                return _items.length;
            }
        };

        var _getItemAt,
            _getNumItems,
            _initialIsLoop,
            _getZeroBounds = function _getZeroBounds() {
            return {
                center: { x: 0, y: 0 },
                max: { x: 0, y: 0 },
                min: { x: 0, y: 0 }
            };
        },
            _calculateSingleItemPanBounds = function _calculateSingleItemPanBounds(item, realPanElementW, realPanElementH) {
            var bounds = item.bounds;

            // position of element when it's centered
            bounds.center.x = Math.round((_tempPanAreaSize.x - realPanElementW) / 2);
            bounds.center.y = Math.round((_tempPanAreaSize.y - realPanElementH) / 2) + item.vGap.top;

            // maximum pan position
            bounds.max.x = realPanElementW > _tempPanAreaSize.x ? Math.round(_tempPanAreaSize.x - realPanElementW) : bounds.center.x;

            bounds.max.y = realPanElementH > _tempPanAreaSize.y ? Math.round(_tempPanAreaSize.y - realPanElementH) + item.vGap.top : bounds.center.y;

            // minimum pan position
            bounds.min.x = realPanElementW > _tempPanAreaSize.x ? 0 : bounds.center.x;
            bounds.min.y = realPanElementH > _tempPanAreaSize.y ? item.vGap.top : bounds.center.y;
        },
            _calculateItemSize = function _calculateItemSize(item, viewportSize, zoomLevel) {

            if (item.src && !item.loadError) {
                var isInitial = !zoomLevel;

                if (isInitial) {
                    if (!item.vGap) {
                        item.vGap = { top: 0, bottom: 0 };
                    }
                    // allows overriding vertical margin for individual items
                    _shout('parseVerticalMargin', item);
                }

                _tempPanAreaSize.x = viewportSize.x;
                _tempPanAreaSize.y = viewportSize.y - item.vGap.top - item.vGap.bottom;

                if (isInitial) {
                    var hRatio = _tempPanAreaSize.x / item.w;
                    var vRatio = _tempPanAreaSize.y / item.h;

                    item.fitRatio = hRatio < vRatio ? hRatio : vRatio;
                    //item.fillRatio = hRatio > vRatio ? hRatio : vRatio;

                    var scaleMode = _options.scaleMode;

                    if (scaleMode === 'orig') {
                        zoomLevel = 1;
                    } else if (scaleMode === 'fit') {
                        zoomLevel = item.fitRatio;
                    }

                    if (zoomLevel > 1) {
                        zoomLevel = 1;
                    }

                    item.initialZoomLevel = zoomLevel;

                    if (!item.bounds) {
                        // reuse bounds object
                        item.bounds = _getZeroBounds();
                    }
                }

                if (!zoomLevel) {
                    return;
                }

                _calculateSingleItemPanBounds(item, item.w * zoomLevel, item.h * zoomLevel);

                if (isInitial && zoomLevel === item.initialZoomLevel) {
                    item.initialPosition = item.bounds.center;
                }

                return item.bounds;
            } else {
                item.w = item.h = 0;
                item.initialZoomLevel = item.fitRatio = 1;
                item.bounds = _getZeroBounds();
                item.initialPosition = item.bounds.center;

                // if it's not image, we return zero bounds (content is not zoomable)
                return item.bounds;
            }
        },
            _appendImage = function _appendImage(index, item, baseDiv, img, preventAnimation, keepPlaceholder) {

            if (item.loadError) {
                return;
            }

            if (img) {

                item.imageAppended = true;
                _setImageSize(item, img, item === self.currItem && _renderMaxResolution);

                baseDiv.appendChild(img);

                if (keepPlaceholder) {
                    setTimeout(function () {
                        if (item && item.loaded && item.placeholder) {
                            item.placeholder.style.display = 'none';
                            item.placeholder = null;
                        }
                    }, 500);
                }
            }
        },
            _preloadImage = function _preloadImage(item) {
            item.loading = true;
            item.loaded = false;
            var img = item.img = framework.createEl('pswp__img', 'img');
            var onComplete = function onComplete() {
                item.loading = false;
                item.loaded = true;

                if (item.loadComplete) {
                    item.loadComplete(item);
                } else {
                    item.img = null; // no need to store image object
                }
                img.onload = img.onerror = null;
                img = null;
            };
            img.onload = onComplete;
            img.onerror = function () {
                item.loadError = true;
                onComplete();
            };

            img.src = item.src; // + '?a=' + Math.random();

            return img;
        },
            _checkForError = function _checkForError(item, cleanUp) {
            if (item.src && item.loadError && item.container) {

                if (cleanUp) {
                    item.container.innerHTML = '';
                }

                item.container.innerHTML = _options.errorMsg.replace('%url%', item.src);
                return true;
            }
        },
            _setImageSize = function _setImageSize(item, img, maxRes) {
            if (!item.src) {
                return;
            }

            if (!img) {
                img = item.container.lastChild;
            }

            var w = maxRes ? item.w : Math.round(item.w * item.fitRatio),
                h = maxRes ? item.h : Math.round(item.h * item.fitRatio);

            if (item.placeholder && !item.loaded) {
                item.placeholder.style.width = w + 'px';
                item.placeholder.style.height = h + 'px';
            }

            img.style.width = w + 'px';
            img.style.height = h + 'px';
        },
            _appendImagesPool = function _appendImagesPool() {

            if (_imagesToAppendPool.length) {
                var poolItem;

                for (var i = 0; i < _imagesToAppendPool.length; i++) {
                    poolItem = _imagesToAppendPool[i];
                    if (poolItem.holder.index === poolItem.index) {
                        _appendImage(poolItem.index, poolItem.item, poolItem.baseDiv, poolItem.img, false, poolItem.clearPlaceholder);
                    }
                }
                _imagesToAppendPool = [];
            }
        };

        _registerModule('Controller', {

            publicMethods: {

                lazyLoadItem: function lazyLoadItem(index) {
                    index = _getLoopedId(index);
                    var item = _getItemAt(index);

                    if (!item || (item.loaded || item.loading) && !_itemsNeedUpdate) {
                        return;
                    }

                    _shout('gettingData', index, item);

                    if (!item.src) {
                        return;
                    }

                    _preloadImage(item);
                },
                initController: function initController() {
                    framework.extend(_options, _controllerDefaultOptions, true);
                    self.items = _items = items;
                    _getItemAt = self.getItemAt;
                    _getNumItems = _options.getNumItemsFn; //self.getNumItems;


                    _initialIsLoop = _options.loop;
                    if (_getNumItems() < 3) {
                        _options.loop = false; // disable loop if less then 3 items
                    }

                    _listen('beforeChange', function (diff) {

                        var p = _options.preload,
                            isNext = diff === null ? true : diff >= 0,
                            preloadBefore = Math.min(p[0], _getNumItems()),
                            preloadAfter = Math.min(p[1], _getNumItems()),
                            i;

                        for (i = 1; i <= (isNext ? preloadAfter : preloadBefore); i++) {
                            self.lazyLoadItem(_currentItemIndex + i);
                        }
                        for (i = 1; i <= (isNext ? preloadBefore : preloadAfter); i++) {
                            self.lazyLoadItem(_currentItemIndex - i);
                        }
                    });

                    _listen('initialLayout', function () {
                        self.currItem.initialLayout = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);
                    });

                    _listen('mainScrollAnimComplete', _appendImagesPool);
                    _listen('initialZoomInEnd', _appendImagesPool);

                    _listen('destroy', function () {
                        var item;
                        for (var i = 0; i < _items.length; i++) {
                            item = _items[i];
                            // remove reference to DOM elements, for GC
                            if (item.container) {
                                item.container = null;
                            }
                            if (item.placeholder) {
                                item.placeholder = null;
                            }
                            if (item.img) {
                                item.img = null;
                            }
                            if (item.preloader) {
                                item.preloader = null;
                            }
                            if (item.loadError) {
                                item.loaded = item.loadError = false;
                            }
                        }
                        _imagesToAppendPool = null;
                    });
                },

                getItemAt: function getItemAt(index) {
                    if (index >= 0) {
                        return _items[index] !== undefined ? _items[index] : false;
                    }
                    return false;
                },

                allowProgressiveImg: function allowProgressiveImg() {
                    // 1. Progressive image loading isn't working on webkit/blink 
                    //    when hw-acceleration (e.g. translateZ) is applied to IMG element.
                    //    That's why in PhotoSwipe parent element gets zoom transform, not image itself.
                    //    
                    // 2. Progressive image loading sometimes blinks in webkit/blink when applying animation to parent element.
                    //    That's why it's disabled on touch devices (mainly because of swipe transition)
                    //    
                    // 3. Progressive image loading sometimes doesn't work in IE (up to 11).

                    // Don't allow progressive loading on non-large touch devices
                    return _options.forceProgressiveLoading || !_likelyTouchDevice || _options.mouseUsed || screen.width > 1200;
                    // 1200 - to eliminate touch devices with large screen (like Chromebook Pixel)
                },

                setContent: function setContent(holder, index) {

                    if (_options.loop) {
                        index = _getLoopedId(index);
                    }

                    var prevItem = self.getItemAt(holder.index);
                    if (prevItem) {
                        prevItem.container = null;
                    }

                    var item = self.getItemAt(index),
                        img;

                    if (!item) {
                        holder.el.innerHTML = '';
                        return;
                    }

                    // allow to override data
                    _shout('gettingData', index, item);

                    holder.index = index;
                    holder.item = item;

                    // base container DIV is created only once for each of 3 holders
                    var baseDiv = item.container = framework.createEl('pswp__zoom-wrap');

                    if (!item.src && item.html) {
                        if (item.html.tagName) {
                            baseDiv.appendChild(item.html);
                        } else {
                            baseDiv.innerHTML = item.html;
                        }
                    }

                    _checkForError(item);

                    _calculateItemSize(item, _viewportSize);

                    if (item.src && !item.loadError && !item.loaded) {

                        item.loadComplete = function (item) {

                            // gallery closed before image finished loading
                            if (!_isOpen) {
                                return;
                            }

                            // check if holder hasn't changed while image was loading
                            if (holder && holder.index === index) {
                                if (_checkForError(item, true)) {
                                    item.loadComplete = item.img = null;
                                    _calculateItemSize(item, _viewportSize);
                                    _applyZoomPanToItem(item);

                                    if (holder.index === _currentItemIndex) {
                                        // recalculate dimensions
                                        self.updateCurrZoomItem();
                                    }
                                    return;
                                }
                                if (!item.imageAppended) {
                                    if (_features.transform && (_mainScrollAnimating || _initialZoomRunning)) {
                                        _imagesToAppendPool.push({
                                            item: item,
                                            baseDiv: baseDiv,
                                            img: item.img,
                                            index: index,
                                            holder: holder,
                                            clearPlaceholder: true
                                        });
                                    } else {
                                        _appendImage(index, item, baseDiv, item.img, _mainScrollAnimating || _initialZoomRunning, true);
                                    }
                                } else {
                                    // remove preloader & mini-img
                                    if (!_initialZoomRunning && item.placeholder) {
                                        item.placeholder.style.display = 'none';
                                        item.placeholder = null;
                                    }
                                }
                            }

                            item.loadComplete = null;
                            item.img = null; // no need to store image element after it's added

                            _shout('imageLoadComplete', index, item);
                        };

                        if (framework.features.transform) {

                            var placeholderClassName = 'pswp__img pswp__img--placeholder';
                            placeholderClassName += item.msrc ? '' : ' pswp__img--placeholder--blank';

                            var placeholder = framework.createEl(placeholderClassName, item.msrc ? 'img' : '');
                            if (item.msrc) {
                                placeholder.src = item.msrc;
                            }

                            _setImageSize(item, placeholder);

                            baseDiv.appendChild(placeholder);
                            item.placeholder = placeholder;
                        }

                        if (!item.loading) {
                            _preloadImage(item);
                        }

                        if (self.allowProgressiveImg()) {
                            // just append image
                            if (!_initialContentSet && _features.transform) {
                                _imagesToAppendPool.push({
                                    item: item,
                                    baseDiv: baseDiv,
                                    img: item.img,
                                    index: index,
                                    holder: holder
                                });
                            } else {
                                _appendImage(index, item, baseDiv, item.img, true, true);
                            }
                        }
                    } else if (item.src && !item.loadError) {
                        // image object is created every time, due to bugs of image loading & delay when switching images
                        img = framework.createEl('pswp__img', 'img');
                        img.style.opacity = 1;
                        img.src = item.src;
                        _setImageSize(item, img);
                        _appendImage(index, item, baseDiv, img, true);
                    }

                    if (!_initialContentSet && index === _currentItemIndex) {
                        _currZoomElementStyle = baseDiv.style;
                        _showOrHide(item, img || item.img);
                    } else {
                        _applyZoomPanToItem(item);
                    }

                    holder.el.innerHTML = '';
                    holder.el.appendChild(baseDiv);
                },

                cleanSlide: function cleanSlide(item) {
                    if (item.img) {
                        item.img.onload = item.img.onerror = null;
                    }
                    item.loaded = item.loading = item.img = item.imageAppended = false;
                }

            }
        });

        /*>>items-controller*/

        /*>>tap*/
        /**
         * tap.js:
         *
         * Displatches tap and double-tap events.
         * 
         */

        var tapTimer,
            tapReleasePoint = {},
            _dispatchTapEvent = function _dispatchTapEvent(origEvent, releasePoint, pointerType) {
            var e = document.createEvent('CustomEvent'),
                eDetail = {
                origEvent: origEvent,
                target: origEvent.target,
                releasePoint: releasePoint,
                pointerType: pointerType || 'touch'
            };

            e.initCustomEvent('pswpTap', true, true, eDetail);
            origEvent.target.dispatchEvent(e);
        };

        _registerModule('Tap', {
            publicMethods: {
                initTap: function initTap() {
                    _listen('firstTouchStart', self.onTapStart);
                    _listen('touchRelease', self.onTapRelease);
                    _listen('destroy', function () {
                        tapReleasePoint = {};
                        tapTimer = null;
                    });
                },
                onTapStart: function onTapStart(touchList) {
                    if (touchList.length > 1) {
                        clearTimeout(tapTimer);
                        tapTimer = null;
                    }
                },
                onTapRelease: function onTapRelease(e, releasePoint) {
                    if (!releasePoint) {
                        return;
                    }

                    if (!_moved && !_isMultitouch && !_numAnimations) {
                        var p0 = releasePoint;
                        if (tapTimer) {
                            clearTimeout(tapTimer);
                            tapTimer = null;

                            // Check if taped on the same place
                            if (_isNearbyPoints(p0, tapReleasePoint)) {
                                _shout('doubleTap', p0);
                                return;
                            }
                        }

                        if (releasePoint.type === 'mouse') {
                            _dispatchTapEvent(e, releasePoint, 'mouse');
                            return;
                        }

                        var clickedTagName = e.target.tagName.toUpperCase();
                        // avoid double tap delay on buttons and elements that have class pswp__single-tap
                        if (clickedTagName === 'BUTTON' || framework.hasClass(e.target, 'pswp__single-tap')) {
                            _dispatchTapEvent(e, releasePoint);
                            return;
                        }

                        _equalizePoints(tapReleasePoint, p0);

                        tapTimer = setTimeout(function () {
                            _dispatchTapEvent(e, releasePoint);
                            tapTimer = null;
                        }, 300);
                    }
                }
            }
        });

        /*>>tap*/

        /*>>desktop-zoom*/
        /**
         *
         * desktop-zoom.js:
         *
         * - Binds mousewheel event for paning zoomed image.
         * - Manages "dragging", "zoomed-in", "zoom-out" classes.
         *   (which are used for cursors and zoom icon)
         * - Adds toggleDesktopZoom function.
         * 
         */

        var _wheelDelta;

        _registerModule('DesktopZoom', {

            publicMethods: {

                initDesktopZoom: function initDesktopZoom() {

                    if (_oldIE) {
                        // no zoom for old IE (<=8)
                        return;
                    }

                    if (_likelyTouchDevice) {
                        // if detected hardware touch support, we wait until mouse is used,
                        // and only then apply desktop-zoom features
                        _listen('mouseUsed', function () {
                            self.setupDesktopZoom();
                        });
                    } else {
                        self.setupDesktopZoom(true);
                    }
                },

                setupDesktopZoom: function setupDesktopZoom(onInit) {

                    _wheelDelta = {};

                    var events = 'wheel mousewheel DOMMouseScroll';

                    _listen('bindEvents', function () {
                        framework.bind(template, events, self.handleMouseWheel);
                    });

                    _listen('unbindEvents', function () {
                        if (_wheelDelta) {
                            framework.unbind(template, events, self.handleMouseWheel);
                        }
                    });

                    self.mouseZoomedIn = false;

                    var hasDraggingClass,
                        updateZoomable = function updateZoomable() {
                        if (self.mouseZoomedIn) {
                            framework.removeClass(template, 'pswp--zoomed-in');
                            self.mouseZoomedIn = false;
                        }
                        if (_currZoomLevel < 1) {
                            framework.addClass(template, 'pswp--zoom-allowed');
                        } else {
                            framework.removeClass(template, 'pswp--zoom-allowed');
                        }
                        removeDraggingClass();
                    },
                        removeDraggingClass = function removeDraggingClass() {
                        if (hasDraggingClass) {
                            framework.removeClass(template, 'pswp--dragging');
                            hasDraggingClass = false;
                        }
                    };

                    _listen('resize', updateZoomable);
                    _listen('afterChange', updateZoomable);
                    _listen('pointerDown', function () {
                        if (self.mouseZoomedIn) {
                            hasDraggingClass = true;
                            framework.addClass(template, 'pswp--dragging');
                        }
                    });
                    _listen('pointerUp', removeDraggingClass);

                    if (!onInit) {
                        updateZoomable();
                    }
                },

                handleMouseWheel: function handleMouseWheel(e) {

                    if (_currZoomLevel <= self.currItem.fitRatio) {
                        if (_options.modal) {

                            if (!_options.closeOnScroll || _numAnimations || _isDragging) {
                                e.preventDefault();
                            } else if (_transformKey && Math.abs(e.deltaY) > 2) {
                                // close PhotoSwipe
                                // if browser supports transforms & scroll changed enough
                                _closedByScroll = true;
                                self.close();
                            }
                        }
                        return true;
                    }

                    // allow just one event to fire
                    e.stopPropagation();

                    // https://developer.mozilla.org/en-US/docs/Web/Events/wheel
                    _wheelDelta.x = 0;

                    if ('deltaX' in e) {
                        if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {
                                // 18 - average line height
                                _wheelDelta.x = e.deltaX * 18;
                                _wheelDelta.y = e.deltaY * 18;
                            } else {
                            _wheelDelta.x = e.deltaX;
                            _wheelDelta.y = e.deltaY;
                        }
                    } else if ('wheelDelta' in e) {
                        if (e.wheelDeltaX) {
                            _wheelDelta.x = -0.16 * e.wheelDeltaX;
                        }
                        if (e.wheelDeltaY) {
                            _wheelDelta.y = -0.16 * e.wheelDeltaY;
                        } else {
                            _wheelDelta.y = -0.16 * e.wheelDelta;
                        }
                    } else if ('detail' in e) {
                        _wheelDelta.y = e.detail;
                    } else {
                        return;
                    }

                    _calculatePanBounds(_currZoomLevel, true);

                    var newPanX = _panOffset.x - _wheelDelta.x,
                        newPanY = _panOffset.y - _wheelDelta.y;

                    // only prevent scrolling in nonmodal mode when not at edges
                    if (_options.modal || newPanX <= _currPanBounds.min.x && newPanX >= _currPanBounds.max.x && newPanY <= _currPanBounds.min.y && newPanY >= _currPanBounds.max.y) {
                        e.preventDefault();
                    }

                    // TODO: use rAF instead of mousewheel?
                    self.panTo(newPanX, newPanY);
                },

                toggleDesktopZoom: function toggleDesktopZoom(centerPoint) {
                    centerPoint = centerPoint || { x: _viewportSize.x / 2 + _offset.x, y: _viewportSize.y / 2 + _offset.y };

                    var doubleTapZoomLevel = _options.getDoubleTapZoom(true, self.currItem);
                    var zoomOut = _currZoomLevel === doubleTapZoomLevel;

                    self.mouseZoomedIn = !zoomOut;

                    self.zoomTo(zoomOut ? self.currItem.initialZoomLevel : doubleTapZoomLevel, centerPoint, 333);
                    framework[(!zoomOut ? 'add' : 'remove') + 'Class'](template, 'pswp--zoomed-in');
                }

            }
        });

        /*>>desktop-zoom*/

        /*>>history*/
        /**
         *
         * history.js:
         *
         * - Back button to close gallery.
         * 
         * - Unique URL for each slide: example.com/&pid=1&gid=3
         *   (where PID is picture index, and GID and gallery index)
         *   
         * - Switch URL when slides change.
         * 
         */

        var _historyDefaultOptions = {
            history: true,
            galleryUID: 1
        };

        var _historyUpdateTimeout,
            _hashChangeTimeout,
            _hashAnimCheckTimeout,
            _hashChangedByScript,
            _hashChangedByHistory,
            _hashReseted,
            _initialHash,
            _historyChanged,
            _closedFromURL,
            _urlChangedOnce,
            _windowLoc,
            _supportsPushState,
            _getHash = function _getHash() {
            return _windowLoc.hash.substring(1);
        },
            _cleanHistoryTimeouts = function _cleanHistoryTimeouts() {

            if (_historyUpdateTimeout) {
                clearTimeout(_historyUpdateTimeout);
            }

            if (_hashAnimCheckTimeout) {
                clearTimeout(_hashAnimCheckTimeout);
            }
        },


        // pid - Picture index
        // gid - Gallery index
        _parseItemIndexFromURL = function _parseItemIndexFromURL() {
            var hash = _getHash(),
                params = {};

            if (hash.length < 5) {
                // pid=1
                return params;
            }

            var i,
                vars = hash.split('&');
            for (i = 0; i < vars.length; i++) {
                if (!vars[i]) {
                    continue;
                }
                var pair = vars[i].split('=');
                if (pair.length < 2) {
                    continue;
                }
                params[pair[0]] = pair[1];
            }
            if (_options.galleryPIDs) {
                // detect custom pid in hash and search for it among the items collection
                var searchfor = params.pid;
                params.pid = 0; // if custom pid cannot be found, fallback to the first item
                for (i = 0; i < _items.length; i++) {
                    if (_items[i].pid === searchfor) {
                        params.pid = i;
                        break;
                    }
                }
            } else {
                params.pid = parseInt(params.pid, 10) - 1;
            }
            if (params.pid < 0) {
                params.pid = 0;
            }
            return params;
        },
            _updateHash = function _updateHash() {

            if (_hashAnimCheckTimeout) {
                clearTimeout(_hashAnimCheckTimeout);
            }

            if (_numAnimations || _isDragging) {
                // changing browser URL forces layout/paint in some browsers, which causes noticable lag during animation
                // that's why we update hash only when no animations running
                _hashAnimCheckTimeout = setTimeout(_updateHash, 500);
                return;
            }

            if (_hashChangedByScript) {
                clearTimeout(_hashChangeTimeout);
            } else {
                _hashChangedByScript = true;
            }

            var pid = _currentItemIndex + 1;
            var item = _getItemAt(_currentItemIndex);
            if (item.hasOwnProperty('pid')) {
                // carry forward any custom pid assigned to the item
                pid = item.pid;
            }
            var newHash = _initialHash + '&' + 'gid=' + _options.galleryUID + '&' + 'pid=' + pid;

            if (!_historyChanged) {
                if (_windowLoc.hash.indexOf(newHash) === -1) {
                    _urlChangedOnce = true;
                }
                // first time - add new hisory record, then just replace
            }

            var newURL = _windowLoc.href.split('#')[0] + '#' + newHash;

            if (_supportsPushState) {

                if ('#' + newHash !== window.location.hash) {
                    history[_historyChanged ? 'replaceState' : 'pushState']('', document.title, newURL);
                }
            } else {
                if (_historyChanged) {
                    _windowLoc.replace(newURL);
                } else {
                    _windowLoc.hash = newHash;
                }
            }

            _historyChanged = true;
            _hashChangeTimeout = setTimeout(function () {
                _hashChangedByScript = false;
            }, 60);
        };

        _registerModule('History', {

            publicMethods: {
                initHistory: function initHistory() {

                    framework.extend(_options, _historyDefaultOptions, true);

                    if (!_options.history) {
                        return;
                    }

                    _windowLoc = window.location;
                    _urlChangedOnce = false;
                    _closedFromURL = false;
                    _historyChanged = false;
                    _initialHash = _getHash();
                    _supportsPushState = 'pushState' in history;

                    if (_initialHash.indexOf('gid=') > -1) {
                        _initialHash = _initialHash.split('&gid=')[0];
                        _initialHash = _initialHash.split('?gid=')[0];
                    }

                    _listen('afterChange', self.updateURL);
                    _listen('unbindEvents', function () {
                        framework.unbind(window, 'hashchange', self.onHashChange);
                    });

                    var returnToOriginal = function returnToOriginal() {
                        _hashReseted = true;
                        if (!_closedFromURL) {

                            if (_urlChangedOnce) {
                                history.back();
                            } else {

                                if (_initialHash) {
                                    _windowLoc.hash = _initialHash;
                                } else {
                                    if (_supportsPushState) {

                                        // remove hash from url without refreshing it or scrolling to top
                                        history.pushState('', document.title, _windowLoc.pathname + _windowLoc.search);
                                    } else {
                                        _windowLoc.hash = '';
                                    }
                                }
                            }
                        }

                        _cleanHistoryTimeouts();
                    };

                    _listen('unbindEvents', function () {
                        if (_closedByScroll) {
                            // if PhotoSwipe is closed by scroll, we go "back" before the closing animation starts
                            // this is done to keep the scroll position
                            returnToOriginal();
                        }
                    });
                    _listen('destroy', function () {
                        if (!_hashReseted) {
                            returnToOriginal();
                        }
                    });
                    _listen('firstUpdate', function () {
                        _currentItemIndex = _parseItemIndexFromURL().pid;
                    });

                    var index = _initialHash.indexOf('pid=');
                    if (index > -1) {
                        _initialHash = _initialHash.substring(0, index);
                        if (_initialHash.slice(-1) === '&') {
                            _initialHash = _initialHash.slice(0, -1);
                        }
                    }

                    setTimeout(function () {
                        if (_isOpen) {
                            // hasn't destroyed yet
                            framework.bind(window, 'hashchange', self.onHashChange);
                        }
                    }, 40);
                },
                onHashChange: function onHashChange() {

                    if (_getHash() === _initialHash) {

                        _closedFromURL = true;
                        self.close();
                        return;
                    }
                    if (!_hashChangedByScript) {

                        _hashChangedByHistory = true;
                        self.goTo(_parseItemIndexFromURL().pid);
                        _hashChangedByHistory = false;
                    }
                },
                updateURL: function updateURL() {

                    // Delay the update of URL, to avoid lag during transition, 
                    // and to not to trigger actions like "refresh page sound" or "blinking favicon" to often

                    _cleanHistoryTimeouts();

                    if (_hashChangedByHistory) {
                        return;
                    }

                    if (!_historyChanged) {
                        _updateHash(); // first time
                    } else {
                        _historyUpdateTimeout = setTimeout(_updateHash, 800);
                    }
                }

            }
        });

        /*>>history*/
        framework.extend(self, publicMethods);
    };
    return PhotoSwipe;
});

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! PhotoSwipe - v4.1.1 - 2015-12-24
* http://photoswipe.com
* Copyright (c) 2015 Dmitry Semenov; */
(function (root, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        module.exports = factory();
    } else {
        root.PhotoSwipe = factory();
    }
})(undefined, function () {

    'use strict';

    var PhotoSwipe = function PhotoSwipe(template, UiClass, items, options) {

        /*>>framework-bridge*/
        /**
         *
         * Set of generic functions used by gallery.
         * 
         * You're free to modify anything here as long as functionality is kept.
         * 
         */
        var framework = {
            features: null,
            bind: function bind(target, type, listener, unbind) {
                var methodName = (unbind ? 'remove' : 'add') + 'EventListener';
                type = type.split(' ');
                for (var i = 0; i < type.length; i++) {
                    if (type[i]) {
                        target[methodName](type[i], listener, false);
                    }
                }
            },
            isArray: function isArray(obj) {
                return obj instanceof Array;
            },
            createEl: function createEl(classes, tag) {
                var el = document.createElement(tag || 'div');
                if (classes) {
                    el.className = classes;
                }
                return el;
            },
            getScrollY: function getScrollY() {
                var yOffset = window.pageYOffset;
                return yOffset !== undefined ? yOffset : document.documentElement.scrollTop;
            },
            unbind: function unbind(target, type, listener) {
                framework.bind(target, type, listener, true);
            },
            removeClass: function removeClass(el, className) {
                var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
                el.className = el.className.replace(reg, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
            },
            addClass: function addClass(el, className) {
                if (!framework.hasClass(el, className)) {
                    el.className += (el.className ? ' ' : '') + className;
                }
            },
            hasClass: function hasClass(el, className) {
                return el.className && new RegExp('(^|\\s)' + className + '(\\s|$)').test(el.className);
            },
            getChildByClass: function getChildByClass(parentEl, childClassName) {
                var node = parentEl.firstChild;
                while (node) {
                    if (framework.hasClass(node, childClassName)) {
                        return node;
                    }
                    node = node.nextSibling;
                }
            },
            arraySearch: function arraySearch(array, value, key) {
                var i = array.length;
                while (i--) {
                    if (array[i][key] === value) {
                        return i;
                    }
                }
                return -1;
            },
            extend: function extend(o1, o2, preventOverwrite) {
                for (var prop in o2) {
                    if (o2.hasOwnProperty(prop)) {
                        if (preventOverwrite && o1.hasOwnProperty(prop)) {
                            continue;
                        }
                        o1[prop] = o2[prop];
                    }
                }
            },
            easing: {
                sine: {
                    out: function out(k) {
                        return Math.sin(k * (Math.PI / 2));
                    },
                    inOut: function inOut(k) {
                        return -(Math.cos(Math.PI * k) - 1) / 2;
                    }
                },
                cubic: {
                    out: function out(k) {
                        return --k * k * k + 1;
                    }
                    /*
                        elastic: {
                            out: function ( k ) {
                                 var s, a = 0.1, p = 0.4;
                                if ( k === 0 ) return 0;
                                if ( k === 1 ) return 1;
                                if ( !a || a < 1 ) { a = 1; s = p / 4; }
                                else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
                                return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );
                             },
                        },
                        back: {
                            out: function ( k ) {
                                var s = 1.70158;
                                return --k * k * ( ( s + 1 ) * k + s ) + 1;
                            }
                        }
                    */
                } },

            /**
             * 
             * @return {object}
             * 
             * {
             *  raf : request animation frame function
             *  caf : cancel animation frame function
             *  transfrom : transform property key (with vendor), or null if not supported
             *  oldIE : IE8 or below
             * }
             * 
             */
            detectFeatures: function detectFeatures() {
                if (framework.features) {
                    return framework.features;
                }
                var helperEl = framework.createEl(),
                    helperStyle = helperEl.style,
                    vendor = '',
                    features = {};

                // IE8 and below
                features.oldIE = document.all && !document.addEventListener;

                features.touch = 'ontouchstart' in window;

                if (window.requestAnimationFrame) {
                    features.raf = window.requestAnimationFrame;
                    features.caf = window.cancelAnimationFrame;
                }

                features.pointerEvent = navigator.pointerEnabled || navigator.msPointerEnabled;

                // fix false-positive detection of old Android in new IE
                // (IE11 ua string contains "Android 4.0")

                if (!features.pointerEvent) {

                    var ua = navigator.userAgent;

                    // Detect if device is iPhone or iPod and if it's older than iOS 8
                    // http://stackoverflow.com/a/14223920
                    // 
                    // This detection is made because of buggy top/bottom toolbars
                    // that don't trigger window.resize event.
                    // For more info refer to _isFixedPosition variable in core.js

                    if (/iP(hone|od)/.test(navigator.platform)) {
                        var v = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
                        if (v && v.length > 0) {
                            v = parseInt(v[1], 10);
                            if (v >= 1 && v < 8) {
                                features.isOldIOSPhone = true;
                            }
                        }
                    }

                    // Detect old Android (before KitKat)
                    // due to bugs related to position:fixed
                    // http://stackoverflow.com/questions/7184573/pick-up-the-android-version-in-the-browser-by-javascript

                    var match = ua.match(/Android\s([0-9\.]*)/);
                    var androidversion = match ? match[1] : 0;
                    androidversion = parseFloat(androidversion);
                    if (androidversion >= 1) {
                        if (androidversion < 4.4) {
                            features.isOldAndroid = true; // for fixed position bug & performance
                        }
                        features.androidVersion = androidversion; // for touchend bug
                    }
                    features.isMobileOpera = /opera mini|opera mobi/i.test(ua);

                    // p.s. yes, yes, UA sniffing is bad, propose your solution for above bugs.
                }

                var styleChecks = ['transform', 'perspective', 'animationName'],
                    vendors = ['', 'webkit', 'Moz', 'ms', 'O'],
                    styleCheckItem,
                    styleName;

                for (var i = 0; i < 4; i++) {
                    vendor = vendors[i];

                    for (var a = 0; a < 3; a++) {
                        styleCheckItem = styleChecks[a];

                        // uppercase first letter of property name, if vendor is present
                        styleName = vendor + (vendor ? styleCheckItem.charAt(0).toUpperCase() + styleCheckItem.slice(1) : styleCheckItem);

                        if (!features[styleCheckItem] && styleName in helperStyle) {
                            features[styleCheckItem] = styleName;
                        }
                    }

                    if (vendor && !features.raf) {
                        vendor = vendor.toLowerCase();
                        features.raf = window[vendor + 'RequestAnimationFrame'];
                        if (features.raf) {
                            features.caf = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
                        }
                    }
                }

                if (!features.raf) {
                    var lastTime = 0;
                    features.raf = function (fn) {
                        var currTime = new Date().getTime();
                        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                        var id = window.setTimeout(function () {
                            fn(currTime + timeToCall);
                        }, timeToCall);
                        lastTime = currTime + timeToCall;
                        return id;
                    };
                    features.caf = function (id) {
                        clearTimeout(id);
                    };
                }

                // Detect SVG support
                features.svg = !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;

                framework.features = features;

                return features;
            }
        };

        framework.detectFeatures();

        // Override addEventListener for old versions of IE
        if (framework.features.oldIE) {

            framework.bind = function (target, type, listener, unbind) {

                type = type.split(' ');

                var methodName = (unbind ? 'detach' : 'attach') + 'Event',
                    evName,
                    _handleEv = function _handleEv() {
                    listener.handleEvent.call(listener);
                };

                for (var i = 0; i < type.length; i++) {
                    evName = type[i];
                    if (evName) {

                        if ((typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object' && listener.handleEvent) {
                            if (!unbind) {
                                listener['oldIE' + evName] = _handleEv;
                            } else {
                                if (!listener['oldIE' + evName]) {
                                    return false;
                                }
                            }

                            target[methodName]('on' + evName, listener['oldIE' + evName]);
                        } else {
                            target[methodName]('on' + evName, listener);
                        }
                    }
                }
            };
        }

        /*>>framework-bridge*/

        /*>>core*/
        //function(template, UiClass, items, options)

        var self = this;

        /**
         * Static vars, don't change unless you know what you're doing.
         */
        var DOUBLE_TAP_RADIUS = 25,
            NUM_HOLDERS = 3;

        /**
         * Options
         */
        var _options = {
            allowPanToNext: true,
            spacing: 0.12,
            bgOpacity: 1,
            mouseUsed: false,
            loop: true,
            pinchToClose: true,
            closeOnScroll: true,
            closeOnVerticalDrag: true,
            verticalDragRange: 0.75,
            hideAnimationDuration: 333,
            showAnimationDuration: 333,
            showHideOpacity: false,
            focus: true,
            escKey: true,
            arrowKeys: true,
            mainScrollEndFriction: 0.35,
            panEndFriction: 0.35,
            isClickableElement: function isClickableElement(el) {
                return el.tagName === 'A';
            },
            getDoubleTapZoom: function getDoubleTapZoom(isMouseClick, item) {
                if (isMouseClick) {
                    return 1;
                } else {
                    return item.initialZoomLevel < 0.7 ? 1 : 1.33;
                }
            },
            maxSpreadZoom: 1.33,
            modal: true,

            // not fully implemented yet
            scaleMode: 'fit' // TODO
        };
        framework.extend(_options, options);

        /**
         * Private helper variables & functions
         */

        var _getEmptyPoint = function _getEmptyPoint() {
            return { x: 0, y: 0 };
        };

        var _isOpen,
            _isDestroying,
            _closedByScroll,
            _currentItemIndex,
            _containerStyle,
            _containerShiftIndex,
            _currPanDist = _getEmptyPoint(),
            _startPanOffset = _getEmptyPoint(),
            _panOffset = _getEmptyPoint(),
            _upMoveEvents,
            // drag move, drag end & drag cancel events array
        _downEvents,
            // drag start events array
        _globalEventHandlers,
            _viewportSize = {},
            _currZoomLevel,
            _startZoomLevel,
            _translatePrefix,
            _translateSufix,
            _updateSizeInterval,
            _itemsNeedUpdate,
            _currPositionIndex = 0,
            _offset = {},
            _slideSize = _getEmptyPoint(),
            // size of slide area, including spacing
        _itemHolders,
            _prevItemIndex,
            _indexDiff = 0,
            // difference of indexes since last content update
        _dragStartEvent,
            _dragMoveEvent,
            _dragEndEvent,
            _dragCancelEvent,
            _transformKey,
            _pointerEventEnabled,
            _isFixedPosition = true,
            _likelyTouchDevice,
            _modules = [],
            _requestAF,
            _cancelAF,
            _initalClassName,
            _initalWindowScrollY,
            _oldIE,
            _currentWindowScrollY,
            _features,
            _windowVisibleSize = {},
            _renderMaxResolution = false,


        // Registers PhotoSWipe module (History, Controller ...)
        _registerModule = function _registerModule(name, module) {
            framework.extend(self, module.publicMethods);
            _modules.push(name);
        },
            _getLoopedId = function _getLoopedId(index) {
            var numSlides = _getNumItems();
            if (index > numSlides - 1) {
                return index - numSlides;
            } else if (index < 0) {
                return numSlides + index;
            }
            return index;
        },


        // Micro bind/trigger
        _listeners = {},
            _listen = function _listen(name, fn) {
            if (!_listeners[name]) {
                _listeners[name] = [];
            }
            return _listeners[name].push(fn);
        },
            _shout = function _shout(name) {
            var listeners = _listeners[name];

            if (listeners) {
                var args = Array.prototype.slice.call(arguments);
                args.shift();

                for (var i = 0; i < listeners.length; i++) {
                    listeners[i].apply(self, args);
                }
            }
        },
            _getCurrentTime = function _getCurrentTime() {
            return new Date().getTime();
        },
            _applyBgOpacity = function _applyBgOpacity(opacity) {
            _bgOpacity = opacity;
            self.bg.style.opacity = opacity * _options.bgOpacity;
        },
            _applyZoomTransform = function _applyZoomTransform(styleObj, x, y, zoom, item) {
            if (!_renderMaxResolution || item && item !== self.currItem) {
                zoom = zoom / (item ? item.fitRatio : self.currItem.fitRatio);
            }

            styleObj[_transformKey] = _translatePrefix + x + 'px, ' + y + 'px' + _translateSufix + ' scale(' + zoom + ')';
        },
            _applyCurrentZoomPan = function _applyCurrentZoomPan(allowRenderResolution) {
            if (_currZoomElementStyle) {

                if (allowRenderResolution) {
                    if (_currZoomLevel > self.currItem.fitRatio) {
                        if (!_renderMaxResolution) {
                            _setImageSize(self.currItem, false, true);
                            _renderMaxResolution = true;
                        }
                    } else {
                        if (_renderMaxResolution) {
                            _setImageSize(self.currItem);
                            _renderMaxResolution = false;
                        }
                    }
                }

                _applyZoomTransform(_currZoomElementStyle, _panOffset.x, _panOffset.y, _currZoomLevel);
            }
        },
            _applyZoomPanToItem = function _applyZoomPanToItem(item) {
            if (item.container) {

                _applyZoomTransform(item.container.style, item.initialPosition.x, item.initialPosition.y, item.initialZoomLevel, item);
            }
        },
            _setTranslateX = function _setTranslateX(x, elStyle) {
            elStyle[_transformKey] = _translatePrefix + x + 'px, 0px' + _translateSufix;
        },
            _moveMainScroll = function _moveMainScroll(x, dragging) {

            if (!_options.loop && dragging) {
                var newSlideIndexOffset = _currentItemIndex + (_slideSize.x * _currPositionIndex - x) / _slideSize.x,
                    delta = Math.round(x - _mainScrollPos.x);

                if (newSlideIndexOffset < 0 && delta > 0 || newSlideIndexOffset >= _getNumItems() - 1 && delta < 0) {
                    x = _mainScrollPos.x + delta * _options.mainScrollEndFriction;
                }
            }

            _mainScrollPos.x = x;
            _setTranslateX(x, _containerStyle);
        },
            _calculatePanOffset = function _calculatePanOffset(axis, zoomLevel) {
            var m = _midZoomPoint[axis] - _offset[axis];
            return _startPanOffset[axis] + _currPanDist[axis] + m - m * (zoomLevel / _startZoomLevel);
        },
            _equalizePoints = function _equalizePoints(p1, p2) {
            p1.x = p2.x;
            p1.y = p2.y;
            if (p2.id) {
                p1.id = p2.id;
            }
        },
            _roundPoint = function _roundPoint(p) {
            p.x = Math.round(p.x);
            p.y = Math.round(p.y);
        },
            _mouseMoveTimeout = null,
            _onFirstMouseMove = function _onFirstMouseMove() {
            // Wait until mouse move event is fired at least twice during 100ms
            // We do this, because some mobile browsers trigger it on touchstart
            if (_mouseMoveTimeout) {
                framework.unbind(document, 'mousemove', _onFirstMouseMove);
                framework.addClass(template, 'pswp--has_mouse');
                _options.mouseUsed = true;
                _shout('mouseUsed');
            }
            _mouseMoveTimeout = setTimeout(function () {
                _mouseMoveTimeout = null;
            }, 100);
        },
            _bindEvents = function _bindEvents() {
            framework.bind(document, 'keydown', self);

            if (_features.transform) {
                // don't bind click event in browsers that don't support transform (mostly IE8)
                framework.bind(self.scrollWrap, 'click', self);
            }

            if (!_options.mouseUsed) {
                framework.bind(document, 'mousemove', _onFirstMouseMove);
            }

            framework.bind(window, 'resize scroll', self);

            _shout('bindEvents');
        },
            _unbindEvents = function _unbindEvents() {
            framework.unbind(window, 'resize', self);
            framework.unbind(window, 'scroll', _globalEventHandlers.scroll);
            framework.unbind(document, 'keydown', self);
            framework.unbind(document, 'mousemove', _onFirstMouseMove);

            if (_features.transform) {
                framework.unbind(self.scrollWrap, 'click', self);
            }

            if (_isDragging) {
                framework.unbind(window, _upMoveEvents, self);
            }

            _shout('unbindEvents');
        },
            _calculatePanBounds = function _calculatePanBounds(zoomLevel, update) {
            var bounds = _calculateItemSize(self.currItem, _viewportSize, zoomLevel);
            if (update) {
                _currPanBounds = bounds;
            }
            return bounds;
        },
            _getMinZoomLevel = function _getMinZoomLevel(item) {
            if (!item) {
                item = self.currItem;
            }
            return item.initialZoomLevel;
        },
            _getMaxZoomLevel = function _getMaxZoomLevel(item) {
            if (!item) {
                item = self.currItem;
            }
            return item.w > 0 ? _options.maxSpreadZoom : 1;
        },


        // Return true if offset is out of the bounds
        _modifyDestPanOffset = function _modifyDestPanOffset(axis, destPanBounds, destPanOffset, destZoomLevel) {
            if (destZoomLevel === self.currItem.initialZoomLevel) {
                destPanOffset[axis] = self.currItem.initialPosition[axis];
                return true;
            } else {
                destPanOffset[axis] = _calculatePanOffset(axis, destZoomLevel);

                if (destPanOffset[axis] > destPanBounds.min[axis]) {
                    destPanOffset[axis] = destPanBounds.min[axis];
                    return true;
                } else if (destPanOffset[axis] < destPanBounds.max[axis]) {
                    destPanOffset[axis] = destPanBounds.max[axis];
                    return true;
                }
            }
            return false;
        },
            _setupTransforms = function _setupTransforms() {

            if (_transformKey) {
                // setup 3d transforms
                var allow3dTransform = _features.perspective && !_likelyTouchDevice;
                _translatePrefix = 'translate' + (allow3dTransform ? '3d(' : '(');
                _translateSufix = _features.perspective ? ', 0px)' : ')';
                return;
            }

            // Override zoom/pan/move functions in case old browser is used (most likely IE)
            // (so they use left/top/width/height, instead of CSS transform)

            _transformKey = 'left';
            framework.addClass(template, 'pswp--ie');

            _setTranslateX = function _setTranslateX(x, elStyle) {
                elStyle.left = x + 'px';
            };
            _applyZoomPanToItem = function _applyZoomPanToItem(item) {

                var zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,
                    s = item.container.style,
                    w = zoomRatio * item.w,
                    h = zoomRatio * item.h;

                s.width = w + 'px';
                s.height = h + 'px';
                s.left = item.initialPosition.x + 'px';
                s.top = item.initialPosition.y + 'px';
            };
            _applyCurrentZoomPan = function _applyCurrentZoomPan() {
                if (_currZoomElementStyle) {

                    var s = _currZoomElementStyle,
                        item = self.currItem,
                        zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,
                        w = zoomRatio * item.w,
                        h = zoomRatio * item.h;

                    s.width = w + 'px';
                    s.height = h + 'px';

                    s.left = _panOffset.x + 'px';
                    s.top = _panOffset.y + 'px';
                }
            };
        },
            _onKeyDown = function _onKeyDown(e) {
            var keydownAction = '';
            if (_options.escKey && e.keyCode === 27) {
                keydownAction = 'close';
            } else if (_options.arrowKeys) {
                if (e.keyCode === 37) {
                    keydownAction = 'prev';
                } else if (e.keyCode === 39) {
                    keydownAction = 'next';
                }
            }

            if (keydownAction) {
                // don't do anything if special key pressed to prevent from overriding default browser actions
                // e.g. in Chrome on Mac cmd+arrow-left returns to previous page
                if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey) {
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }
                    self[keydownAction]();
                }
            }
        },
            _onGlobalClick = function _onGlobalClick(e) {
            if (!e) {
                return;
            }

            // don't allow click event to pass through when triggering after drag or some other gesture
            if (_moved || _zoomStarted || _mainScrollAnimating || _verticalDragInitiated) {
                e.preventDefault();
                e.stopPropagation();
            }
        },
            _updatePageScrollOffset = function _updatePageScrollOffset() {
            self.setScrollOffset(0, framework.getScrollY());
        };

        // Micro animation engine
        var _animations = {},
            _numAnimations = 0,
            _stopAnimation = function _stopAnimation(name) {
            if (_animations[name]) {
                if (_animations[name].raf) {
                    _cancelAF(_animations[name].raf);
                }
                _numAnimations--;
                delete _animations[name];
            }
        },
            _registerStartAnimation = function _registerStartAnimation(name) {
            if (_animations[name]) {
                _stopAnimation(name);
            }
            if (!_animations[name]) {
                _numAnimations++;
                _animations[name] = {};
            }
        },
            _stopAllAnimations = function _stopAllAnimations() {
            for (var prop in _animations) {

                if (_animations.hasOwnProperty(prop)) {
                    _stopAnimation(prop);
                }
            }
        },
            _animateProp = function _animateProp(name, b, endProp, d, easingFn, onUpdate, onComplete) {
            var startAnimTime = _getCurrentTime(),
                t;
            _registerStartAnimation(name);

            var animloop = function animloop() {
                if (_animations[name]) {

                    t = _getCurrentTime() - startAnimTime; // time diff
                    //b - beginning (start prop)
                    //d - anim duration

                    if (t >= d) {
                        _stopAnimation(name);
                        onUpdate(endProp);
                        if (onComplete) {
                            onComplete();
                        }
                        return;
                    }
                    onUpdate((endProp - b) * easingFn(t / d) + b);

                    _animations[name].raf = _requestAF(animloop);
                }
            };
            animloop();
        };

        var publicMethods = {

            // make a few local variables and functions public
            shout: _shout,
            listen: _listen,
            viewportSize: _viewportSize,
            options: _options,

            isMainScrollAnimating: function isMainScrollAnimating() {
                return _mainScrollAnimating;
            },
            getZoomLevel: function getZoomLevel() {
                return _currZoomLevel;
            },
            getCurrentIndex: function getCurrentIndex() {
                return _currentItemIndex;
            },
            isDragging: function isDragging() {
                return _isDragging;
            },
            isZooming: function isZooming() {
                return _isZooming;
            },
            setScrollOffset: function setScrollOffset(x, y) {
                _offset.x = x;
                _currentWindowScrollY = _offset.y = y;
                _shout('updateScrollOffset', _offset);
            },
            applyZoomPan: function applyZoomPan(zoomLevel, panX, panY, allowRenderResolution) {
                _panOffset.x = panX;
                _panOffset.y = panY;
                _currZoomLevel = zoomLevel;
                _applyCurrentZoomPan(allowRenderResolution);
            },

            init: function init() {

                if (_isOpen || _isDestroying) {
                    return;
                }

                var i;

                self.framework = framework; // basic functionality
                self.template = template; // root DOM element of PhotoSwipe
                self.bg = framework.getChildByClass(template, 'pswp__bg');

                _initalClassName = template.className;
                _isOpen = true;

                _features = framework.detectFeatures();
                _requestAF = _features.raf;
                _cancelAF = _features.caf;
                _transformKey = _features.transform;
                _oldIE = _features.oldIE;

                self.scrollWrap = framework.getChildByClass(template, 'pswp__scroll-wrap');
                self.container = framework.getChildByClass(self.scrollWrap, 'pswp__container');

                _containerStyle = self.container.style; // for fast access

                // Objects that hold slides (there are only 3 in DOM)
                self.itemHolders = _itemHolders = [{ el: self.container.children[0], wrap: 0, index: -1 }, { el: self.container.children[1], wrap: 0, index: -1 }, { el: self.container.children[2], wrap: 0, index: -1 }];

                // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)
                _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'none';

                _setupTransforms();

                // Setup global events
                _globalEventHandlers = {
                    resize: self.updateSize,
                    scroll: _updatePageScrollOffset,
                    keydown: _onKeyDown,
                    click: _onGlobalClick
                };

                // disable show/hide effects on old browsers that don't support CSS animations or transforms, 
                // old IOS, Android and Opera mobile. Blackberry seems to work fine, even older models.
                var oldPhone = _features.isOldIOSPhone || _features.isOldAndroid || _features.isMobileOpera;
                if (!_features.animationName || !_features.transform || oldPhone) {
                    _options.showAnimationDuration = _options.hideAnimationDuration = 0;
                }

                // init modules
                for (i = 0; i < _modules.length; i++) {
                    self['init' + _modules[i]]();
                }

                // init
                if (UiClass) {
                    var ui = self.ui = new UiClass(self, framework);
                    ui.init();
                }

                _shout('firstUpdate');
                _currentItemIndex = _currentItemIndex || _options.index || 0;
                // validate index
                if (isNaN(_currentItemIndex) || _currentItemIndex < 0 || _currentItemIndex >= _getNumItems()) {
                    _currentItemIndex = 0;
                }
                self.currItem = _getItemAt(_currentItemIndex);

                if (_features.isOldIOSPhone || _features.isOldAndroid) {
                    _isFixedPosition = false;
                }

                template.setAttribute('aria-hidden', 'false');
                if (_options.modal) {
                    if (!_isFixedPosition) {
                        template.style.position = 'absolute';
                        template.style.top = framework.getScrollY() + 'px';
                    } else {
                        template.style.position = 'fixed';
                    }
                }

                if (_currentWindowScrollY === undefined) {
                    _shout('initialLayout');
                    _currentWindowScrollY = _initalWindowScrollY = framework.getScrollY();
                }

                // add classes to root element of PhotoSwipe
                var rootClasses = 'pswp--open ';
                if (_options.mainClass) {
                    rootClasses += _options.mainClass + ' ';
                }
                if (_options.showHideOpacity) {
                    rootClasses += 'pswp--animate_opacity ';
                }
                rootClasses += _likelyTouchDevice ? 'pswp--touch' : 'pswp--notouch';
                rootClasses += _features.animationName ? ' pswp--css_animation' : '';
                rootClasses += _features.svg ? ' pswp--svg' : '';
                framework.addClass(template, rootClasses);

                self.updateSize();

                // initial update
                _containerShiftIndex = -1;
                _indexDiff = null;
                for (i = 0; i < NUM_HOLDERS; i++) {
                    _setTranslateX((i + _containerShiftIndex) * _slideSize.x, _itemHolders[i].el.style);
                }

                if (!_oldIE) {
                    framework.bind(self.scrollWrap, _downEvents, self); // no dragging for old IE
                }

                _listen('initialZoomInEnd', function () {
                    self.setContent(_itemHolders[0], _currentItemIndex - 1);
                    self.setContent(_itemHolders[2], _currentItemIndex + 1);

                    _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'block';

                    if (_options.focus) {
                        // focus causes layout, 
                        // which causes lag during the animation, 
                        // that's why we delay it untill the initial zoom transition ends
                        template.focus();
                    }

                    _bindEvents();
                });

                // set content for center slide (first time)
                self.setContent(_itemHolders[1], _currentItemIndex);

                self.updateCurrItem();

                _shout('afterInit');

                if (!_isFixedPosition) {

                    // On all versions of iOS lower than 8.0, we check size of viewport every second.
                    // 
                    // This is done to detect when Safari top & bottom bars appear, 
                    // as this action doesn't trigger any events (like resize). 
                    // 
                    // On iOS8 they fixed this.
                    // 
                    // 10 Nov 2014: iOS 7 usage ~40%. iOS 8 usage 56%.

                    _updateSizeInterval = setInterval(function () {
                        if (!_numAnimations && !_isDragging && !_isZooming && _currZoomLevel === self.currItem.initialZoomLevel) {
                            self.updateSize();
                        }
                    }, 1000);
                }

                framework.addClass(template, 'pswp--visible');
            },

            // Close the gallery, then destroy it
            close: function close() {
                if (!_isOpen) {
                    return;
                }

                _isOpen = false;
                _isDestroying = true;
                _shout('close');
                _unbindEvents();

                _showOrHide(self.currItem, null, true, self.destroy);
            },

            // destroys the gallery (unbinds events, cleans up intervals and timeouts to avoid memory leaks)
            destroy: function destroy() {
                _shout('destroy');

                if (_showOrHideTimeout) {
                    clearTimeout(_showOrHideTimeout);
                }

                template.setAttribute('aria-hidden', 'true');
                template.className = _initalClassName;

                if (_updateSizeInterval) {
                    clearInterval(_updateSizeInterval);
                }

                framework.unbind(self.scrollWrap, _downEvents, self);

                // we unbind scroll event at the end, as closing animation may depend on it
                framework.unbind(window, 'scroll', self);

                _stopDragUpdateLoop();

                _stopAllAnimations();

                _listeners = null;
            },

            /**
             * Pan image to position
             * @param {Number} x     
             * @param {Number} y     
             * @param {Boolean} force Will ignore bounds if set to true.
             */
            panTo: function panTo(x, y, force) {
                if (!force) {
                    if (x > _currPanBounds.min.x) {
                        x = _currPanBounds.min.x;
                    } else if (x < _currPanBounds.max.x) {
                        x = _currPanBounds.max.x;
                    }

                    if (y > _currPanBounds.min.y) {
                        y = _currPanBounds.min.y;
                    } else if (y < _currPanBounds.max.y) {
                        y = _currPanBounds.max.y;
                    }
                }

                _panOffset.x = x;
                _panOffset.y = y;
                _applyCurrentZoomPan();
            },

            handleEvent: function handleEvent(e) {
                e = e || window.event;
                if (_globalEventHandlers[e.type]) {
                    _globalEventHandlers[e.type](e);
                }
            },

            goTo: function goTo(index) {

                index = _getLoopedId(index);

                var diff = index - _currentItemIndex;
                _indexDiff = diff;

                _currentItemIndex = index;
                self.currItem = _getItemAt(_currentItemIndex);
                _currPositionIndex -= diff;

                _moveMainScroll(_slideSize.x * _currPositionIndex);

                _stopAllAnimations();
                _mainScrollAnimating = false;

                self.updateCurrItem();
            },
            next: function next() {
                self.goTo(_currentItemIndex + 1);
            },
            prev: function prev() {
                self.goTo(_currentItemIndex - 1);
            },

            // update current zoom/pan objects
            updateCurrZoomItem: function updateCurrZoomItem(emulateSetContent) {
                if (emulateSetContent) {
                    _shout('beforeChange', 0);
                }

                // itemHolder[1] is middle (current) item
                if (_itemHolders[1].el.children.length) {
                    var zoomElement = _itemHolders[1].el.children[0];
                    if (framework.hasClass(zoomElement, 'pswp__zoom-wrap')) {
                        _currZoomElementStyle = zoomElement.style;
                    } else {
                        _currZoomElementStyle = null;
                    }
                } else {
                    _currZoomElementStyle = null;
                }

                _currPanBounds = self.currItem.bounds;
                _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;

                _panOffset.x = _currPanBounds.center.x;
                _panOffset.y = _currPanBounds.center.y;

                if (emulateSetContent) {
                    _shout('afterChange');
                }
            },

            invalidateCurrItems: function invalidateCurrItems() {
                _itemsNeedUpdate = true;
                for (var i = 0; i < NUM_HOLDERS; i++) {
                    if (_itemHolders[i].item) {
                        _itemHolders[i].item.needsUpdate = true;
                    }
                }
            },

            updateCurrItem: function updateCurrItem(beforeAnimation) {

                if (_indexDiff === 0) {
                    return;
                }

                var diffAbs = Math.abs(_indexDiff),
                    tempHolder;

                if (beforeAnimation && diffAbs < 2) {
                    return;
                }

                self.currItem = _getItemAt(_currentItemIndex);
                _renderMaxResolution = false;

                _shout('beforeChange', _indexDiff);

                if (diffAbs >= NUM_HOLDERS) {
                    _containerShiftIndex += _indexDiff + (_indexDiff > 0 ? -NUM_HOLDERS : NUM_HOLDERS);
                    diffAbs = NUM_HOLDERS;
                }
                for (var i = 0; i < diffAbs; i++) {
                    if (_indexDiff > 0) {
                        tempHolder = _itemHolders.shift();
                        _itemHolders[NUM_HOLDERS - 1] = tempHolder; // move first to last

                        _containerShiftIndex++;
                        _setTranslateX((_containerShiftIndex + 2) * _slideSize.x, tempHolder.el.style);
                        self.setContent(tempHolder, _currentItemIndex - diffAbs + i + 1 + 1);
                    } else {
                        tempHolder = _itemHolders.pop();
                        _itemHolders.unshift(tempHolder); // move last to first

                        _containerShiftIndex--;
                        _setTranslateX(_containerShiftIndex * _slideSize.x, tempHolder.el.style);
                        self.setContent(tempHolder, _currentItemIndex + diffAbs - i - 1 - 1);
                    }
                }

                // reset zoom/pan on previous item
                if (_currZoomElementStyle && Math.abs(_indexDiff) === 1) {

                    var prevItem = _getItemAt(_prevItemIndex);
                    if (prevItem.initialZoomLevel !== _currZoomLevel) {
                        _calculateItemSize(prevItem, _viewportSize);
                        _setImageSize(prevItem);
                        _applyZoomPanToItem(prevItem);
                    }
                }

                // reset diff after update
                _indexDiff = 0;

                self.updateCurrZoomItem();

                _prevItemIndex = _currentItemIndex;

                _shout('afterChange');
            },

            updateSize: function updateSize(force) {

                if (!_isFixedPosition && _options.modal) {
                    var windowScrollY = framework.getScrollY();
                    if (_currentWindowScrollY !== windowScrollY) {
                        template.style.top = windowScrollY + 'px';
                        _currentWindowScrollY = windowScrollY;
                    }
                    if (!force && _windowVisibleSize.x === window.innerWidth && _windowVisibleSize.y === window.innerHeight) {
                        return;
                    }
                    _windowVisibleSize.x = window.innerWidth;
                    _windowVisibleSize.y = window.innerHeight;

                    //template.style.width = _windowVisibleSize.x + 'px';
                    template.style.height = _windowVisibleSize.y + 'px';
                }

                _viewportSize.x = self.scrollWrap.clientWidth;
                _viewportSize.y = self.scrollWrap.clientHeight;

                _updatePageScrollOffset();

                _slideSize.x = _viewportSize.x + Math.round(_viewportSize.x * _options.spacing);
                _slideSize.y = _viewportSize.y;

                _moveMainScroll(_slideSize.x * _currPositionIndex);

                _shout('beforeResize'); // even may be used for example to switch image sources


                // don't re-calculate size on inital size update
                if (_containerShiftIndex !== undefined) {

                    var holder, item, hIndex;

                    for (var i = 0; i < NUM_HOLDERS; i++) {
                        holder = _itemHolders[i];
                        _setTranslateX((i + _containerShiftIndex) * _slideSize.x, holder.el.style);

                        hIndex = _currentItemIndex + i - 1;

                        if (_options.loop && _getNumItems() > 2) {
                            hIndex = _getLoopedId(hIndex);
                        }

                        // update zoom level on items and refresh source (if needsUpdate)
                        item = _getItemAt(hIndex);

                        // re-render gallery item if `needsUpdate`,
                        // or doesn't have `bounds` (entirely new slide object)
                        if (item && (_itemsNeedUpdate || item.needsUpdate || !item.bounds)) {

                            self.cleanSlide(item);

                            self.setContent(holder, hIndex);

                            // if "center" slide
                            if (i === 1) {
                                self.currItem = item;
                                self.updateCurrZoomItem(true);
                            }

                            item.needsUpdate = false;
                        } else if (holder.index === -1 && hIndex >= 0) {
                            // add content first time
                            self.setContent(holder, hIndex);
                        }
                        if (item && item.container) {
                            _calculateItemSize(item, _viewportSize);
                            _setImageSize(item);
                            _applyZoomPanToItem(item);
                        }
                    }
                    _itemsNeedUpdate = false;
                }

                _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;
                _currPanBounds = self.currItem.bounds;

                if (_currPanBounds) {
                    _panOffset.x = _currPanBounds.center.x;
                    _panOffset.y = _currPanBounds.center.y;
                    _applyCurrentZoomPan(true);
                }

                _shout('resize');
            },

            // Zoom current item to
            zoomTo: function zoomTo(destZoomLevel, centerPoint, speed, easingFn, updateFn) {
                /*
                    if(destZoomLevel === 'fit') {
                        destZoomLevel = self.currItem.fitRatio;
                    } else if(destZoomLevel === 'fill') {
                        destZoomLevel = self.currItem.fillRatio;
                    }
                */

                if (centerPoint) {
                    _startZoomLevel = _currZoomLevel;
                    _midZoomPoint.x = Math.abs(centerPoint.x) - _panOffset.x;
                    _midZoomPoint.y = Math.abs(centerPoint.y) - _panOffset.y;
                    _equalizePoints(_startPanOffset, _panOffset);
                }

                var destPanBounds = _calculatePanBounds(destZoomLevel, false),
                    destPanOffset = {};

                _modifyDestPanOffset('x', destPanBounds, destPanOffset, destZoomLevel);
                _modifyDestPanOffset('y', destPanBounds, destPanOffset, destZoomLevel);

                var initialZoomLevel = _currZoomLevel;
                var initialPanOffset = {
                    x: _panOffset.x,
                    y: _panOffset.y
                };

                _roundPoint(destPanOffset);

                var onUpdate = function onUpdate(now) {
                    if (now === 1) {
                        _currZoomLevel = destZoomLevel;
                        _panOffset.x = destPanOffset.x;
                        _panOffset.y = destPanOffset.y;
                    } else {
                        _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;
                        _panOffset.x = (destPanOffset.x - initialPanOffset.x) * now + initialPanOffset.x;
                        _panOffset.y = (destPanOffset.y - initialPanOffset.y) * now + initialPanOffset.y;
                    }

                    if (updateFn) {
                        updateFn(now);
                    }

                    _applyCurrentZoomPan(now === 1);
                };

                if (speed) {
                    _animateProp('customZoomTo', 0, 1, speed, easingFn || framework.easing.sine.inOut, onUpdate);
                } else {
                    onUpdate(1);
                }
            }

        };

        /*>>core*/

        /*>>gestures*/
        /**
         * Mouse/touch/pointer event handlers.
         * 
         * separated from @core.js for readability
         */

        var MIN_SWIPE_DISTANCE = 30,
            DIRECTION_CHECK_OFFSET = 10; // amount of pixels to drag to determine direction of swipe

        var _gestureStartTime,
            _gestureCheckSpeedTime,


        // pool of objects that are used during dragging of zooming
        p = {},
            // first point
        p2 = {},
            // second point (for zoom gesture)
        delta = {},
            _currPoint = {},
            _startPoint = {},
            _currPointers = [],
            _startMainScrollPos = {},
            _releaseAnimData,
            _posPoints = [],
            // array of points during dragging, used to determine type of gesture
        _tempPoint = {},
            _isZoomingIn,
            _verticalDragInitiated,
            _oldAndroidTouchEndTimeout,
            _currZoomedItemIndex = 0,
            _centerPoint = _getEmptyPoint(),
            _lastReleaseTime = 0,
            _isDragging,
            // at least one pointer is down
        _isMultitouch,
            // at least two _pointers are down
        _zoomStarted,
            // zoom level changed during zoom gesture
        _moved,
            _dragAnimFrame,
            _mainScrollShifted,
            _currentPoints,
            // array of current touch points
        _isZooming,
            _currPointsDistance,
            _startPointsDistance,
            _currPanBounds,
            _mainScrollPos = _getEmptyPoint(),
            _currZoomElementStyle,
            _mainScrollAnimating,
            // true, if animation after swipe gesture is running
        _midZoomPoint = _getEmptyPoint(),
            _currCenterPoint = _getEmptyPoint(),
            _direction,
            _isFirstMove,
            _opacityChanged,
            _bgOpacity,
            _wasOverInitialZoom,
            _isEqualPoints = function _isEqualPoints(p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
        },
            _isNearbyPoints = function _isNearbyPoints(touch0, touch1) {
            return Math.abs(touch0.x - touch1.x) < DOUBLE_TAP_RADIUS && Math.abs(touch0.y - touch1.y) < DOUBLE_TAP_RADIUS;
        },
            _calculatePointsDistance = function _calculatePointsDistance(p1, p2) {
            _tempPoint.x = Math.abs(p1.x - p2.x);
            _tempPoint.y = Math.abs(p1.y - p2.y);
            return Math.sqrt(_tempPoint.x * _tempPoint.x + _tempPoint.y * _tempPoint.y);
        },
            _stopDragUpdateLoop = function _stopDragUpdateLoop() {
            if (_dragAnimFrame) {
                _cancelAF(_dragAnimFrame);
                _dragAnimFrame = null;
            }
        },
            _dragUpdateLoop = function _dragUpdateLoop() {
            if (_isDragging) {
                _dragAnimFrame = _requestAF(_dragUpdateLoop);
                _renderMovement();
            }
        },
            _canPan = function _canPan() {
            return !(_options.scaleMode === 'fit' && _currZoomLevel === self.currItem.initialZoomLevel);
        },


        // find the closest parent DOM element
        _closestElement = function _closestElement(el, fn) {
            if (!el || el === document) {
                return false;
            }

            // don't search elements above pswp__scroll-wrap
            if (el.getAttribute('class') && el.getAttribute('class').indexOf('pswp__scroll-wrap') > -1) {
                return false;
            }

            if (fn(el)) {
                return el;
            }

            return _closestElement(el.parentNode, fn);
        },
            _preventObj = {},
            _preventDefaultEventBehaviour = function _preventDefaultEventBehaviour(e, isDown) {
            _preventObj.prevent = !_closestElement(e.target, _options.isClickableElement);

            _shout('preventDragEvent', e, isDown, _preventObj);
            return _preventObj.prevent;
        },
            _convertTouchToPoint = function _convertTouchToPoint(touch, p) {
            p.x = touch.pageX;
            p.y = touch.pageY;
            p.id = touch.identifier;
            return p;
        },
            _findCenterOfPoints = function _findCenterOfPoints(p1, p2, pCenter) {
            pCenter.x = (p1.x + p2.x) * 0.5;
            pCenter.y = (p1.y + p2.y) * 0.5;
        },
            _pushPosPoint = function _pushPosPoint(time, x, y) {
            if (time - _gestureCheckSpeedTime > 50) {
                var o = _posPoints.length > 2 ? _posPoints.shift() : {};
                o.x = x;
                o.y = y;
                _posPoints.push(o);
                _gestureCheckSpeedTime = time;
            }
        },
            _calculateVerticalDragOpacityRatio = function _calculateVerticalDragOpacityRatio() {
            var yOffset = _panOffset.y - self.currItem.initialPosition.y; // difference between initial and current position
            return 1 - Math.abs(yOffset / (_viewportSize.y / 2));
        },


        // points pool, reused during touch events
        _ePoint1 = {},
            _ePoint2 = {},
            _tempPointsArr = [],
            _tempCounter,
            _getTouchPoints = function _getTouchPoints(e) {
            // clean up previous points, without recreating array
            while (_tempPointsArr.length > 0) {
                _tempPointsArr.pop();
            }

            if (!_pointerEventEnabled) {
                if (e.type.indexOf('touch') > -1) {

                    if (e.touches && e.touches.length > 0) {
                        _tempPointsArr[0] = _convertTouchToPoint(e.touches[0], _ePoint1);
                        if (e.touches.length > 1) {
                            _tempPointsArr[1] = _convertTouchToPoint(e.touches[1], _ePoint2);
                        }
                    }
                } else {
                    _ePoint1.x = e.pageX;
                    _ePoint1.y = e.pageY;
                    _ePoint1.id = '';
                    _tempPointsArr[0] = _ePoint1; //_ePoint1;
                }
            } else {
                _tempCounter = 0;
                // we can use forEach, as pointer events are supported only in modern browsers
                _currPointers.forEach(function (p) {
                    if (_tempCounter === 0) {
                        _tempPointsArr[0] = p;
                    } else if (_tempCounter === 1) {
                        _tempPointsArr[1] = p;
                    }
                    _tempCounter++;
                });
            }
            return _tempPointsArr;
        },
            _panOrMoveMainScroll = function _panOrMoveMainScroll(axis, delta) {

            var panFriction,
                overDiff = 0,
                newOffset = _panOffset[axis] + delta[axis],
                startOverDiff,
                dir = delta[axis] > 0,
                newMainScrollPosition = _mainScrollPos.x + delta.x,
                mainScrollDiff = _mainScrollPos.x - _startMainScrollPos.x,
                newPanPos,
                newMainScrollPos;

            // calculate fdistance over the bounds and friction
            if (newOffset > _currPanBounds.min[axis] || newOffset < _currPanBounds.max[axis]) {
                panFriction = _options.panEndFriction;
                // Linear increasing of friction, so at 1/4 of viewport it's at max value. 
                // Looks not as nice as was expected. Left for history.
                // panFriction = (1 - (_panOffset[axis] + delta[axis] + panBounds.min[axis]) / (_viewportSize[axis] / 4) );
            } else {
                panFriction = 1;
            }

            newOffset = _panOffset[axis] + delta[axis] * panFriction;

            // move main scroll or start panning
            if (_options.allowPanToNext || _currZoomLevel === self.currItem.initialZoomLevel) {

                if (!_currZoomElementStyle) {

                    newMainScrollPos = newMainScrollPosition;
                } else if (_direction === 'h' && axis === 'x' && !_zoomStarted) {

                    if (dir) {
                        if (newOffset > _currPanBounds.min[axis]) {
                            panFriction = _options.panEndFriction;
                            overDiff = _currPanBounds.min[axis] - newOffset;
                            startOverDiff = _currPanBounds.min[axis] - _startPanOffset[axis];
                        }

                        // drag right
                        if ((startOverDiff <= 0 || mainScrollDiff < 0) && _getNumItems() > 1) {
                            newMainScrollPos = newMainScrollPosition;
                            if (mainScrollDiff < 0 && newMainScrollPosition > _startMainScrollPos.x) {
                                newMainScrollPos = _startMainScrollPos.x;
                            }
                        } else {
                            if (_currPanBounds.min.x !== _currPanBounds.max.x) {
                                newPanPos = newOffset;
                            }
                        }
                    } else {

                        if (newOffset < _currPanBounds.max[axis]) {
                            panFriction = _options.panEndFriction;
                            overDiff = newOffset - _currPanBounds.max[axis];
                            startOverDiff = _startPanOffset[axis] - _currPanBounds.max[axis];
                        }

                        if ((startOverDiff <= 0 || mainScrollDiff > 0) && _getNumItems() > 1) {
                            newMainScrollPos = newMainScrollPosition;

                            if (mainScrollDiff > 0 && newMainScrollPosition < _startMainScrollPos.x) {
                                newMainScrollPos = _startMainScrollPos.x;
                            }
                        } else {
                            if (_currPanBounds.min.x !== _currPanBounds.max.x) {
                                newPanPos = newOffset;
                            }
                        }
                    }

                    //
                }

                if (axis === 'x') {

                    if (newMainScrollPos !== undefined) {
                        _moveMainScroll(newMainScrollPos, true);
                        if (newMainScrollPos === _startMainScrollPos.x) {
                            _mainScrollShifted = false;
                        } else {
                            _mainScrollShifted = true;
                        }
                    }

                    if (_currPanBounds.min.x !== _currPanBounds.max.x) {
                        if (newPanPos !== undefined) {
                            _panOffset.x = newPanPos;
                        } else if (!_mainScrollShifted) {
                            _panOffset.x += delta.x * panFriction;
                        }
                    }

                    return newMainScrollPos !== undefined;
                }
            }

            if (!_mainScrollAnimating) {

                if (!_mainScrollShifted) {
                    if (_currZoomLevel > self.currItem.fitRatio) {
                        _panOffset[axis] += delta[axis] * panFriction;
                    }
                }
            }
        },


        // Pointerdown/touchstart/mousedown handler
        _onDragStart = function _onDragStart(e) {

            // Allow dragging only via left mouse button.
            // As this handler is not added in IE8 - we ignore e.which
            // 
            // http://www.quirksmode.org/js/events_properties.html
            // https://developer.mozilla.org/en-US/docs/Web/API/event.button
            if (e.type === 'mousedown' && e.button > 0) {
                return;
            }

            if (_initialZoomRunning) {
                e.preventDefault();
                return;
            }

            if (_oldAndroidTouchEndTimeout && e.type === 'mousedown') {
                return;
            }

            if (_preventDefaultEventBehaviour(e, true)) {
                e.preventDefault();
            }

            _shout('pointerDown');

            if (_pointerEventEnabled) {
                var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');
                if (pointerIndex < 0) {
                    pointerIndex = _currPointers.length;
                }
                _currPointers[pointerIndex] = { x: e.pageX, y: e.pageY, id: e.pointerId };
            }

            var startPointsList = _getTouchPoints(e),
                numPoints = startPointsList.length;

            _currentPoints = null;

            _stopAllAnimations();

            // init drag
            if (!_isDragging || numPoints === 1) {

                _isDragging = _isFirstMove = true;
                framework.bind(window, _upMoveEvents, self);

                _isZoomingIn = _wasOverInitialZoom = _opacityChanged = _verticalDragInitiated = _mainScrollShifted = _moved = _isMultitouch = _zoomStarted = false;

                _direction = null;

                _shout('firstTouchStart', startPointsList);

                _equalizePoints(_startPanOffset, _panOffset);

                _currPanDist.x = _currPanDist.y = 0;
                _equalizePoints(_currPoint, startPointsList[0]);
                _equalizePoints(_startPoint, _currPoint);

                //_equalizePoints(_startMainScrollPos, _mainScrollPos);
                _startMainScrollPos.x = _slideSize.x * _currPositionIndex;

                _posPoints = [{
                    x: _currPoint.x,
                    y: _currPoint.y
                }];

                _gestureCheckSpeedTime = _gestureStartTime = _getCurrentTime();

                //_mainScrollAnimationEnd(true);
                _calculatePanBounds(_currZoomLevel, true);

                // Start rendering
                _stopDragUpdateLoop();
                _dragUpdateLoop();
            }

            // init zoom
            if (!_isZooming && numPoints > 1 && !_mainScrollAnimating && !_mainScrollShifted) {
                _startZoomLevel = _currZoomLevel;
                _zoomStarted = false; // true if zoom changed at least once

                _isZooming = _isMultitouch = true;
                _currPanDist.y = _currPanDist.x = 0;

                _equalizePoints(_startPanOffset, _panOffset);

                _equalizePoints(p, startPointsList[0]);
                _equalizePoints(p2, startPointsList[1]);

                _findCenterOfPoints(p, p2, _currCenterPoint);

                _midZoomPoint.x = Math.abs(_currCenterPoint.x) - _panOffset.x;
                _midZoomPoint.y = Math.abs(_currCenterPoint.y) - _panOffset.y;
                _currPointsDistance = _startPointsDistance = _calculatePointsDistance(p, p2);
            }
        },


        // Pointermove/touchmove/mousemove handler
        _onDragMove = function _onDragMove(e) {

            e.preventDefault();

            if (_pointerEventEnabled) {
                var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');
                if (pointerIndex > -1) {
                    var p = _currPointers[pointerIndex];
                    p.x = e.pageX;
                    p.y = e.pageY;
                }
            }

            if (_isDragging) {
                var touchesList = _getTouchPoints(e);
                if (!_direction && !_moved && !_isZooming) {

                    if (_mainScrollPos.x !== _slideSize.x * _currPositionIndex) {
                        // if main scroll position is shifted  direction is always horizontal
                        _direction = 'h';
                    } else {
                        var diff = Math.abs(touchesList[0].x - _currPoint.x) - Math.abs(touchesList[0].y - _currPoint.y);
                        // check the direction of movement
                        if (Math.abs(diff) >= DIRECTION_CHECK_OFFSET) {
                            _direction = diff > 0 ? 'h' : 'v';
                            _currentPoints = touchesList;
                        }
                    }
                } else {
                    _currentPoints = touchesList;
                }
            }
        },

        // 
        _renderMovement = function _renderMovement() {

            if (!_currentPoints) {
                return;
            }

            var numPoints = _currentPoints.length;

            if (numPoints === 0) {
                return;
            }

            _equalizePoints(p, _currentPoints[0]);

            delta.x = p.x - _currPoint.x;
            delta.y = p.y - _currPoint.y;

            if (_isZooming && numPoints > 1) {
                // Handle behaviour for more than 1 point

                _currPoint.x = p.x;
                _currPoint.y = p.y;

                // check if one of two points changed
                if (!delta.x && !delta.y && _isEqualPoints(_currentPoints[1], p2)) {
                    return;
                }

                _equalizePoints(p2, _currentPoints[1]);

                if (!_zoomStarted) {
                    _zoomStarted = true;
                    _shout('zoomGestureStarted');
                }

                // Distance between two points
                var pointsDistance = _calculatePointsDistance(p, p2);

                var zoomLevel = _calculateZoomLevel(pointsDistance);

                // slightly over the of initial zoom level
                if (zoomLevel > self.currItem.initialZoomLevel + self.currItem.initialZoomLevel / 15) {
                    _wasOverInitialZoom = true;
                }

                // Apply the friction if zoom level is out of the bounds
                var zoomFriction = 1,
                    minZoomLevel = _getMinZoomLevel(),
                    maxZoomLevel = _getMaxZoomLevel();

                if (zoomLevel < minZoomLevel) {

                    if (_options.pinchToClose && !_wasOverInitialZoom && _startZoomLevel <= self.currItem.initialZoomLevel) {
                        // fade out background if zooming out
                        var minusDiff = minZoomLevel - zoomLevel;
                        var percent = 1 - minusDiff / (minZoomLevel / 1.2);

                        _applyBgOpacity(percent);
                        _shout('onPinchClose', percent);
                        _opacityChanged = true;
                    } else {
                        zoomFriction = (minZoomLevel - zoomLevel) / minZoomLevel;
                        if (zoomFriction > 1) {
                            zoomFriction = 1;
                        }
                        zoomLevel = minZoomLevel - zoomFriction * (minZoomLevel / 3);
                    }
                } else if (zoomLevel > maxZoomLevel) {
                    // 1.5 - extra zoom level above the max. E.g. if max is x6, real max 6 + 1.5 = 7.5
                    zoomFriction = (zoomLevel - maxZoomLevel) / (minZoomLevel * 6);
                    if (zoomFriction > 1) {
                        zoomFriction = 1;
                    }
                    zoomLevel = maxZoomLevel + zoomFriction * minZoomLevel;
                }

                if (zoomFriction < 0) {
                    zoomFriction = 0;
                }

                // distance between touch points after friction is applied
                _currPointsDistance = pointsDistance;

                // _centerPoint - The point in the middle of two pointers
                _findCenterOfPoints(p, p2, _centerPoint);

                // paning with two pointers pressed
                _currPanDist.x += _centerPoint.x - _currCenterPoint.x;
                _currPanDist.y += _centerPoint.y - _currCenterPoint.y;
                _equalizePoints(_currCenterPoint, _centerPoint);

                _panOffset.x = _calculatePanOffset('x', zoomLevel);
                _panOffset.y = _calculatePanOffset('y', zoomLevel);

                _isZoomingIn = zoomLevel > _currZoomLevel;
                _currZoomLevel = zoomLevel;
                _applyCurrentZoomPan();
            } else {

                // handle behaviour for one point (dragging or panning)

                if (!_direction) {
                    return;
                }

                if (_isFirstMove) {
                    _isFirstMove = false;

                    // subtract drag distance that was used during the detection direction  

                    if (Math.abs(delta.x) >= DIRECTION_CHECK_OFFSET) {
                        delta.x -= _currentPoints[0].x - _startPoint.x;
                    }

                    if (Math.abs(delta.y) >= DIRECTION_CHECK_OFFSET) {
                        delta.y -= _currentPoints[0].y - _startPoint.y;
                    }
                }

                _currPoint.x = p.x;
                _currPoint.y = p.y;

                // do nothing if pointers position hasn't changed
                if (delta.x === 0 && delta.y === 0) {
                    return;
                }

                if (_direction === 'v' && _options.closeOnVerticalDrag) {
                    if (!_canPan()) {
                        _currPanDist.y += delta.y;
                        _panOffset.y += delta.y;

                        var opacityRatio = _calculateVerticalDragOpacityRatio();

                        _verticalDragInitiated = true;
                        _shout('onVerticalDrag', opacityRatio);

                        _applyBgOpacity(opacityRatio);
                        _applyCurrentZoomPan();
                        return;
                    }
                }

                _pushPosPoint(_getCurrentTime(), p.x, p.y);

                _moved = true;
                _currPanBounds = self.currItem.bounds;

                var mainScrollChanged = _panOrMoveMainScroll('x', delta);
                if (!mainScrollChanged) {
                    _panOrMoveMainScroll('y', delta);

                    _roundPoint(_panOffset);
                    _applyCurrentZoomPan();
                }
            }
        },


        // Pointerup/pointercancel/touchend/touchcancel/mouseup event handler
        _onDragRelease = function _onDragRelease(e) {

            if (_features.isOldAndroid) {

                if (_oldAndroidTouchEndTimeout && e.type === 'mouseup') {
                    return;
                }

                // on Android (v4.1, 4.2, 4.3 & possibly older) 
                // ghost mousedown/up event isn't preventable via e.preventDefault,
                // which causes fake mousedown event
                // so we block mousedown/up for 600ms
                if (e.type.indexOf('touch') > -1) {
                    clearTimeout(_oldAndroidTouchEndTimeout);
                    _oldAndroidTouchEndTimeout = setTimeout(function () {
                        _oldAndroidTouchEndTimeout = 0;
                    }, 600);
                }
            }

            _shout('pointerUp');

            if (_preventDefaultEventBehaviour(e, false)) {
                e.preventDefault();
            }

            var releasePoint;

            if (_pointerEventEnabled) {
                var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');

                if (pointerIndex > -1) {
                    releasePoint = _currPointers.splice(pointerIndex, 1)[0];

                    if (navigator.pointerEnabled) {
                        releasePoint.type = e.pointerType || 'mouse';
                    } else {
                        var MSPOINTER_TYPES = {
                            4: 'mouse', // event.MSPOINTER_TYPE_MOUSE
                            2: 'touch', // event.MSPOINTER_TYPE_TOUCH 
                            3: 'pen' // event.MSPOINTER_TYPE_PEN
                        };
                        releasePoint.type = MSPOINTER_TYPES[e.pointerType];

                        if (!releasePoint.type) {
                            releasePoint.type = e.pointerType || 'mouse';
                        }
                    }
                }
            }

            var touchList = _getTouchPoints(e),
                gestureType,
                numPoints = touchList.length;

            if (e.type === 'mouseup') {
                numPoints = 0;
            }

            // Do nothing if there were 3 touch points or more
            if (numPoints === 2) {
                _currentPoints = null;
                return true;
            }

            // if second pointer released
            if (numPoints === 1) {
                _equalizePoints(_startPoint, touchList[0]);
            }

            // pointer hasn't moved, send "tap release" point
            if (numPoints === 0 && !_direction && !_mainScrollAnimating) {
                if (!releasePoint) {
                    if (e.type === 'mouseup') {
                        releasePoint = { x: e.pageX, y: e.pageY, type: 'mouse' };
                    } else if (e.changedTouches && e.changedTouches[0]) {
                        releasePoint = { x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY, type: 'touch' };
                    }
                }

                _shout('touchRelease', e, releasePoint);
            }

            // Difference in time between releasing of two last touch points (zoom gesture)
            var releaseTimeDiff = -1;

            // Gesture completed, no pointers left
            if (numPoints === 0) {
                _isDragging = false;
                framework.unbind(window, _upMoveEvents, self);

                _stopDragUpdateLoop();

                if (_isZooming) {
                    // Two points released at the same time
                    releaseTimeDiff = 0;
                } else if (_lastReleaseTime !== -1) {
                    releaseTimeDiff = _getCurrentTime() - _lastReleaseTime;
                }
            }
            _lastReleaseTime = numPoints === 1 ? _getCurrentTime() : -1;

            if (releaseTimeDiff !== -1 && releaseTimeDiff < 150) {
                gestureType = 'zoom';
            } else {
                gestureType = 'swipe';
            }

            if (_isZooming && numPoints < 2) {
                _isZooming = false;

                // Only second point released
                if (numPoints === 1) {
                    gestureType = 'zoomPointerUp';
                }
                _shout('zoomGestureEnded');
            }

            _currentPoints = null;
            if (!_moved && !_zoomStarted && !_mainScrollAnimating && !_verticalDragInitiated) {
                // nothing to animate
                return;
            }

            _stopAllAnimations();

            if (!_releaseAnimData) {
                _releaseAnimData = _initDragReleaseAnimationData();
            }

            _releaseAnimData.calculateSwipeSpeed('x');

            if (_verticalDragInitiated) {

                var opacityRatio = _calculateVerticalDragOpacityRatio();

                if (opacityRatio < _options.verticalDragRange) {
                    self.close();
                } else {
                    var initalPanY = _panOffset.y,
                        initialBgOpacity = _bgOpacity;

                    _animateProp('verticalDrag', 0, 1, 300, framework.easing.cubic.out, function (now) {

                        _panOffset.y = (self.currItem.initialPosition.y - initalPanY) * now + initalPanY;

                        _applyBgOpacity((1 - initialBgOpacity) * now + initialBgOpacity);
                        _applyCurrentZoomPan();
                    });

                    _shout('onVerticalDrag', 1);
                }

                return;
            }

            // main scroll 
            if ((_mainScrollShifted || _mainScrollAnimating) && numPoints === 0) {
                var itemChanged = _finishSwipeMainScrollGesture(gestureType, _releaseAnimData);
                if (itemChanged) {
                    return;
                }
                gestureType = 'zoomPointerUp';
            }

            // prevent zoom/pan animation when main scroll animation runs
            if (_mainScrollAnimating) {
                return;
            }

            // Complete simple zoom gesture (reset zoom level if it's out of the bounds)  
            if (gestureType !== 'swipe') {
                _completeZoomGesture();
                return;
            }

            // Complete pan gesture if main scroll is not shifted, and it's possible to pan current image
            if (!_mainScrollShifted && _currZoomLevel > self.currItem.fitRatio) {
                _completePanGesture(_releaseAnimData);
            }
        },


        // Returns object with data about gesture
        // It's created only once and then reused
        _initDragReleaseAnimationData = function _initDragReleaseAnimationData() {
            // temp local vars
            var lastFlickDuration, tempReleasePos;

            // s = this
            var s = {
                lastFlickOffset: {},
                lastFlickDist: {},
                lastFlickSpeed: {},
                slowDownRatio: {},
                slowDownRatioReverse: {},
                speedDecelerationRatio: {},
                speedDecelerationRatioAbs: {},
                distanceOffset: {},
                backAnimDestination: {},
                backAnimStarted: {},
                calculateSwipeSpeed: function calculateSwipeSpeed(axis) {

                    if (_posPoints.length > 1) {
                        lastFlickDuration = _getCurrentTime() - _gestureCheckSpeedTime + 50;
                        tempReleasePos = _posPoints[_posPoints.length - 2][axis];
                    } else {
                        lastFlickDuration = _getCurrentTime() - _gestureStartTime; // total gesture duration
                        tempReleasePos = _startPoint[axis];
                    }
                    s.lastFlickOffset[axis] = _currPoint[axis] - tempReleasePos;
                    s.lastFlickDist[axis] = Math.abs(s.lastFlickOffset[axis]);
                    if (s.lastFlickDist[axis] > 20) {
                        s.lastFlickSpeed[axis] = s.lastFlickOffset[axis] / lastFlickDuration;
                    } else {
                        s.lastFlickSpeed[axis] = 0;
                    }
                    if (Math.abs(s.lastFlickSpeed[axis]) < 0.1) {
                        s.lastFlickSpeed[axis] = 0;
                    }

                    s.slowDownRatio[axis] = 0.95;
                    s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];
                    s.speedDecelerationRatio[axis] = 1;
                },

                calculateOverBoundsAnimOffset: function calculateOverBoundsAnimOffset(axis, speed) {
                    if (!s.backAnimStarted[axis]) {

                        if (_panOffset[axis] > _currPanBounds.min[axis]) {
                            s.backAnimDestination[axis] = _currPanBounds.min[axis];
                        } else if (_panOffset[axis] < _currPanBounds.max[axis]) {
                            s.backAnimDestination[axis] = _currPanBounds.max[axis];
                        }

                        if (s.backAnimDestination[axis] !== undefined) {
                            s.slowDownRatio[axis] = 0.7;
                            s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];
                            if (s.speedDecelerationRatioAbs[axis] < 0.05) {

                                s.lastFlickSpeed[axis] = 0;
                                s.backAnimStarted[axis] = true;

                                _animateProp('bounceZoomPan' + axis, _panOffset[axis], s.backAnimDestination[axis], speed || 300, framework.easing.sine.out, function (pos) {
                                    _panOffset[axis] = pos;
                                    _applyCurrentZoomPan();
                                });
                            }
                        }
                    }
                },

                // Reduces the speed by slowDownRatio (per 10ms)
                calculateAnimOffset: function calculateAnimOffset(axis) {
                    if (!s.backAnimStarted[axis]) {
                        s.speedDecelerationRatio[axis] = s.speedDecelerationRatio[axis] * (s.slowDownRatio[axis] + s.slowDownRatioReverse[axis] - s.slowDownRatioReverse[axis] * s.timeDiff / 10);

                        s.speedDecelerationRatioAbs[axis] = Math.abs(s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis]);
                        s.distanceOffset[axis] = s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis] * s.timeDiff;
                        _panOffset[axis] += s.distanceOffset[axis];
                    }
                },

                panAnimLoop: function panAnimLoop() {
                    if (_animations.zoomPan) {
                        _animations.zoomPan.raf = _requestAF(s.panAnimLoop);

                        s.now = _getCurrentTime();
                        s.timeDiff = s.now - s.lastNow;
                        s.lastNow = s.now;

                        s.calculateAnimOffset('x');
                        s.calculateAnimOffset('y');

                        _applyCurrentZoomPan();

                        s.calculateOverBoundsAnimOffset('x');
                        s.calculateOverBoundsAnimOffset('y');

                        if (s.speedDecelerationRatioAbs.x < 0.05 && s.speedDecelerationRatioAbs.y < 0.05) {

                            // round pan position
                            _panOffset.x = Math.round(_panOffset.x);
                            _panOffset.y = Math.round(_panOffset.y);
                            _applyCurrentZoomPan();

                            _stopAnimation('zoomPan');
                            return;
                        }
                    }
                }
            };
            return s;
        },
            _completePanGesture = function _completePanGesture(animData) {
            // calculate swipe speed for Y axis (paanning)
            animData.calculateSwipeSpeed('y');

            _currPanBounds = self.currItem.bounds;

            animData.backAnimDestination = {};
            animData.backAnimStarted = {};

            // Avoid acceleration animation if speed is too low
            if (Math.abs(animData.lastFlickSpeed.x) <= 0.05 && Math.abs(animData.lastFlickSpeed.y) <= 0.05) {
                animData.speedDecelerationRatioAbs.x = animData.speedDecelerationRatioAbs.y = 0;

                // Run pan drag release animation. E.g. if you drag image and release finger without momentum.
                animData.calculateOverBoundsAnimOffset('x');
                animData.calculateOverBoundsAnimOffset('y');
                return true;
            }

            // Animation loop that controls the acceleration after pan gesture ends
            _registerStartAnimation('zoomPan');
            animData.lastNow = _getCurrentTime();
            animData.panAnimLoop();
        },
            _finishSwipeMainScrollGesture = function _finishSwipeMainScrollGesture(gestureType, _releaseAnimData) {
            var itemChanged;
            if (!_mainScrollAnimating) {
                _currZoomedItemIndex = _currentItemIndex;
            }

            var itemsDiff;

            if (gestureType === 'swipe') {
                var totalShiftDist = _currPoint.x - _startPoint.x,
                    isFastLastFlick = _releaseAnimData.lastFlickDist.x < 10;

                // if container is shifted for more than MIN_SWIPE_DISTANCE, 
                // and last flick gesture was in right direction
                if (totalShiftDist > MIN_SWIPE_DISTANCE && (isFastLastFlick || _releaseAnimData.lastFlickOffset.x > 20)) {
                    // go to prev item
                    itemsDiff = -1;
                } else if (totalShiftDist < -MIN_SWIPE_DISTANCE && (isFastLastFlick || _releaseAnimData.lastFlickOffset.x < -20)) {
                    // go to next item
                    itemsDiff = 1;
                }
            }

            var nextCircle;

            if (itemsDiff) {

                _currentItemIndex += itemsDiff;

                if (_currentItemIndex < 0) {
                    _currentItemIndex = _options.loop ? _getNumItems() - 1 : 0;
                    nextCircle = true;
                } else if (_currentItemIndex >= _getNumItems()) {
                    _currentItemIndex = _options.loop ? 0 : _getNumItems() - 1;
                    nextCircle = true;
                }

                if (!nextCircle || _options.loop) {
                    _indexDiff += itemsDiff;
                    _currPositionIndex -= itemsDiff;
                    itemChanged = true;
                }
            }

            var animateToX = _slideSize.x * _currPositionIndex;
            var animateToDist = Math.abs(animateToX - _mainScrollPos.x);
            var finishAnimDuration;

            if (!itemChanged && animateToX > _mainScrollPos.x !== _releaseAnimData.lastFlickSpeed.x > 0) {
                // "return to current" duration, e.g. when dragging from slide 0 to -1
                finishAnimDuration = 333;
            } else {
                finishAnimDuration = Math.abs(_releaseAnimData.lastFlickSpeed.x) > 0 ? animateToDist / Math.abs(_releaseAnimData.lastFlickSpeed.x) : 333;

                finishAnimDuration = Math.min(finishAnimDuration, 400);
                finishAnimDuration = Math.max(finishAnimDuration, 250);
            }

            if (_currZoomedItemIndex === _currentItemIndex) {
                itemChanged = false;
            }

            _mainScrollAnimating = true;

            _shout('mainScrollAnimStart');

            _animateProp('mainScroll', _mainScrollPos.x, animateToX, finishAnimDuration, framework.easing.cubic.out, _moveMainScroll, function () {
                _stopAllAnimations();
                _mainScrollAnimating = false;
                _currZoomedItemIndex = -1;

                if (itemChanged || _currZoomedItemIndex !== _currentItemIndex) {
                    self.updateCurrItem();
                }

                _shout('mainScrollAnimComplete');
            });

            if (itemChanged) {
                self.updateCurrItem(true);
            }

            return itemChanged;
        },
            _calculateZoomLevel = function _calculateZoomLevel(touchesDistance) {
            return 1 / _startPointsDistance * touchesDistance * _startZoomLevel;
        },


        // Resets zoom if it's out of bounds
        _completeZoomGesture = function _completeZoomGesture() {
            var destZoomLevel = _currZoomLevel,
                minZoomLevel = _getMinZoomLevel(),
                maxZoomLevel = _getMaxZoomLevel();

            if (_currZoomLevel < minZoomLevel) {
                destZoomLevel = minZoomLevel;
            } else if (_currZoomLevel > maxZoomLevel) {
                destZoomLevel = maxZoomLevel;
            }

            var destOpacity = 1,
                onUpdate,
                initialOpacity = _bgOpacity;

            if (_opacityChanged && !_isZoomingIn && !_wasOverInitialZoom && _currZoomLevel < minZoomLevel) {
                //_closedByScroll = true;
                self.close();
                return true;
            }

            if (_opacityChanged) {
                onUpdate = function onUpdate(now) {
                    _applyBgOpacity((destOpacity - initialOpacity) * now + initialOpacity);
                };
            }

            self.zoomTo(destZoomLevel, 0, 200, framework.easing.cubic.out, onUpdate);
            return true;
        };

        _registerModule('Gestures', {
            publicMethods: {

                initGestures: function initGestures() {

                    // helper function that builds touch/pointer/mouse events
                    var addEventNames = function addEventNames(pref, down, move, up, cancel) {
                        _dragStartEvent = pref + down;
                        _dragMoveEvent = pref + move;
                        _dragEndEvent = pref + up;
                        if (cancel) {
                            _dragCancelEvent = pref + cancel;
                        } else {
                            _dragCancelEvent = '';
                        }
                    };

                    _pointerEventEnabled = _features.pointerEvent;
                    if (_pointerEventEnabled && _features.touch) {
                        // we don't need touch events, if browser supports pointer events
                        _features.touch = false;
                    }

                    if (_pointerEventEnabled) {
                        if (navigator.pointerEnabled) {
                            addEventNames('pointer', 'down', 'move', 'up', 'cancel');
                        } else {
                            // IE10 pointer events are case-sensitive
                            addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
                        }
                    } else if (_features.touch) {
                        addEventNames('touch', 'start', 'move', 'end', 'cancel');
                        _likelyTouchDevice = true;
                    } else {
                        addEventNames('mouse', 'down', 'move', 'up');
                    }

                    _upMoveEvents = _dragMoveEvent + ' ' + _dragEndEvent + ' ' + _dragCancelEvent;
                    _downEvents = _dragStartEvent;

                    if (_pointerEventEnabled && !_likelyTouchDevice) {
                        _likelyTouchDevice = navigator.maxTouchPoints > 1 || navigator.msMaxTouchPoints > 1;
                    }
                    // make variable public
                    self.likelyTouchDevice = _likelyTouchDevice;

                    _globalEventHandlers[_dragStartEvent] = _onDragStart;
                    _globalEventHandlers[_dragMoveEvent] = _onDragMove;
                    _globalEventHandlers[_dragEndEvent] = _onDragRelease; // the Kraken

                    if (_dragCancelEvent) {
                        _globalEventHandlers[_dragCancelEvent] = _globalEventHandlers[_dragEndEvent];
                    }

                    // Bind mouse events on device with detected hardware touch support, in case it supports multiple types of input.
                    if (_features.touch) {
                        _downEvents += ' mousedown';
                        _upMoveEvents += ' mousemove mouseup';
                        _globalEventHandlers.mousedown = _globalEventHandlers[_dragStartEvent];
                        _globalEventHandlers.mousemove = _globalEventHandlers[_dragMoveEvent];
                        _globalEventHandlers.mouseup = _globalEventHandlers[_dragEndEvent];
                    }

                    if (!_likelyTouchDevice) {
                        // don't allow pan to next slide from zoomed state on Desktop
                        _options.allowPanToNext = false;
                    }
                }

            }
        });

        /*>>gestures*/

        /*>>show-hide-transition*/
        /**
         * show-hide-transition.js:
         *
         * Manages initial opening or closing transition.
         *
         * If you're not planning to use transition for gallery at all,
         * you may set options hideAnimationDuration and showAnimationDuration to 0,
         * and just delete startAnimation function.
         * 
         */

        var _showOrHideTimeout,
            _showOrHide = function _showOrHide(item, img, out, completeFn) {

            if (_showOrHideTimeout) {
                clearTimeout(_showOrHideTimeout);
            }

            _initialZoomRunning = true;
            _initialContentSet = true;

            // dimensions of small thumbnail {x:,y:,w:}.
            // Height is optional, as calculated based on large image.
            var thumbBounds;
            if (item.initialLayout) {
                thumbBounds = item.initialLayout;
                item.initialLayout = null;
            } else {
                thumbBounds = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);
            }

            var duration = out ? _options.hideAnimationDuration : _options.showAnimationDuration;

            var onComplete = function onComplete() {
                _stopAnimation('initialZoom');
                if (!out) {
                    _applyBgOpacity(1);
                    if (img) {
                        img.style.display = 'block';
                    }
                    framework.addClass(template, 'pswp--animated-in');
                    _shout('initialZoom' + (out ? 'OutEnd' : 'InEnd'));
                } else {
                    self.template.removeAttribute('style');
                    self.bg.removeAttribute('style');
                }

                if (completeFn) {
                    completeFn();
                }
                _initialZoomRunning = false;
            };

            // if bounds aren't provided, just open gallery without animation
            if (!duration || !thumbBounds || thumbBounds.x === undefined) {

                _shout('initialZoom' + (out ? 'Out' : 'In'));

                _currZoomLevel = item.initialZoomLevel;
                _equalizePoints(_panOffset, item.initialPosition);
                _applyCurrentZoomPan();

                template.style.opacity = out ? 0 : 1;
                _applyBgOpacity(1);

                if (duration) {
                    setTimeout(function () {
                        onComplete();
                    }, duration);
                } else {
                    onComplete();
                }

                return;
            }

            var startAnimation = function startAnimation() {
                var closeWithRaf = _closedByScroll,
                    fadeEverything = !self.currItem.src || self.currItem.loadError || _options.showHideOpacity;

                // apply hw-acceleration to image
                if (item.miniImg) {
                    item.miniImg.style.webkitBackfaceVisibility = 'hidden';
                }

                if (!out) {
                    _currZoomLevel = thumbBounds.w / item.w;
                    _panOffset.x = thumbBounds.x;
                    _panOffset.y = thumbBounds.y - _initalWindowScrollY;

                    self[fadeEverything ? 'template' : 'bg'].style.opacity = 0.001;
                    _applyCurrentZoomPan();
                }

                _registerStartAnimation('initialZoom');

                if (out && !closeWithRaf) {
                    framework.removeClass(template, 'pswp--animated-in');
                }

                if (fadeEverything) {
                    if (out) {
                        framework[(closeWithRaf ? 'remove' : 'add') + 'Class'](template, 'pswp--animate_opacity');
                    } else {
                        setTimeout(function () {
                            framework.addClass(template, 'pswp--animate_opacity');
                        }, 30);
                    }
                }

                _showOrHideTimeout = setTimeout(function () {

                    _shout('initialZoom' + (out ? 'Out' : 'In'));

                    if (!out) {

                        // "in" animation always uses CSS transitions (instead of rAF).
                        // CSS transition work faster here, 
                        // as developer may also want to animate other things, 
                        // like ui on top of sliding area, which can be animated just via CSS

                        _currZoomLevel = item.initialZoomLevel;
                        _equalizePoints(_panOffset, item.initialPosition);
                        _applyCurrentZoomPan();
                        _applyBgOpacity(1);

                        if (fadeEverything) {
                            template.style.opacity = 1;
                        } else {
                            _applyBgOpacity(1);
                        }

                        _showOrHideTimeout = setTimeout(onComplete, duration + 20);
                    } else {

                        // "out" animation uses rAF only when PhotoSwipe is closed by browser scroll, to recalculate position
                        var destZoomLevel = thumbBounds.w / item.w,
                            initialPanOffset = {
                            x: _panOffset.x,
                            y: _panOffset.y
                        },
                            initialZoomLevel = _currZoomLevel,
                            initalBgOpacity = _bgOpacity,
                            onUpdate = function onUpdate(now) {

                            if (now === 1) {
                                _currZoomLevel = destZoomLevel;
                                _panOffset.x = thumbBounds.x;
                                _panOffset.y = thumbBounds.y - _currentWindowScrollY;
                            } else {
                                _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;
                                _panOffset.x = (thumbBounds.x - initialPanOffset.x) * now + initialPanOffset.x;
                                _panOffset.y = (thumbBounds.y - _currentWindowScrollY - initialPanOffset.y) * now + initialPanOffset.y;
                            }

                            _applyCurrentZoomPan();
                            if (fadeEverything) {
                                template.style.opacity = 1 - now;
                            } else {
                                _applyBgOpacity(initalBgOpacity - now * initalBgOpacity);
                            }
                        };

                        if (closeWithRaf) {
                            _animateProp('initialZoom', 0, 1, duration, framework.easing.cubic.out, onUpdate, onComplete);
                        } else {
                            onUpdate(1);
                            _showOrHideTimeout = setTimeout(onComplete, duration + 20);
                        }
                    }
                }, out ? 25 : 90); // Main purpose of this delay is to give browser time to paint and
                // create composite layers of PhotoSwipe UI parts (background, controls, caption, arrows).
                // Which avoids lag at the beginning of scale transition.
            };
            startAnimation();
        };

        /*>>show-hide-transition*/

        /*>>items-controller*/
        /**
        *
        * Controller manages gallery items, their dimensions, and their content.
        * 
        */

        var _items,
            _tempPanAreaSize = {},
            _imagesToAppendPool = [],
            _initialContentSet,
            _initialZoomRunning,
            _controllerDefaultOptions = {
            index: 0,
            errorMsg: '<div class="pswp__error-msg"><a href="%url%" target="_blank">The image</a> could not be loaded.</div>',
            forceProgressiveLoading: false, // TODO
            preload: [1, 1],
            getNumItemsFn: function getNumItemsFn() {
                return _items.length;
            }
        };

        var _getItemAt,
            _getNumItems,
            _initialIsLoop,
            _getZeroBounds = function _getZeroBounds() {
            return {
                center: { x: 0, y: 0 },
                max: { x: 0, y: 0 },
                min: { x: 0, y: 0 }
            };
        },
            _calculateSingleItemPanBounds = function _calculateSingleItemPanBounds(item, realPanElementW, realPanElementH) {
            var bounds = item.bounds;

            // position of element when it's centered
            bounds.center.x = Math.round((_tempPanAreaSize.x - realPanElementW) / 2);
            bounds.center.y = Math.round((_tempPanAreaSize.y - realPanElementH) / 2) + item.vGap.top;

            // maximum pan position
            bounds.max.x = realPanElementW > _tempPanAreaSize.x ? Math.round(_tempPanAreaSize.x - realPanElementW) : bounds.center.x;

            bounds.max.y = realPanElementH > _tempPanAreaSize.y ? Math.round(_tempPanAreaSize.y - realPanElementH) + item.vGap.top : bounds.center.y;

            // minimum pan position
            bounds.min.x = realPanElementW > _tempPanAreaSize.x ? 0 : bounds.center.x;
            bounds.min.y = realPanElementH > _tempPanAreaSize.y ? item.vGap.top : bounds.center.y;
        },
            _calculateItemSize = function _calculateItemSize(item, viewportSize, zoomLevel) {

            if (item.src && !item.loadError) {
                var isInitial = !zoomLevel;

                if (isInitial) {
                    if (!item.vGap) {
                        item.vGap = { top: 0, bottom: 0 };
                    }
                    // allows overriding vertical margin for individual items
                    _shout('parseVerticalMargin', item);
                }

                _tempPanAreaSize.x = viewportSize.x;
                _tempPanAreaSize.y = viewportSize.y - item.vGap.top - item.vGap.bottom;

                if (isInitial) {
                    var hRatio = _tempPanAreaSize.x / item.w;
                    var vRatio = _tempPanAreaSize.y / item.h;

                    item.fitRatio = hRatio < vRatio ? hRatio : vRatio;
                    //item.fillRatio = hRatio > vRatio ? hRatio : vRatio;

                    var scaleMode = _options.scaleMode;

                    if (scaleMode === 'orig') {
                        zoomLevel = 1;
                    } else if (scaleMode === 'fit') {
                        zoomLevel = item.fitRatio;
                    }

                    if (zoomLevel > 1) {
                        zoomLevel = 1;
                    }

                    item.initialZoomLevel = zoomLevel;

                    if (!item.bounds) {
                        // reuse bounds object
                        item.bounds = _getZeroBounds();
                    }
                }

                if (!zoomLevel) {
                    return;
                }

                _calculateSingleItemPanBounds(item, item.w * zoomLevel, item.h * zoomLevel);

                if (isInitial && zoomLevel === item.initialZoomLevel) {
                    item.initialPosition = item.bounds.center;
                }

                return item.bounds;
            } else {
                item.w = item.h = 0;
                item.initialZoomLevel = item.fitRatio = 1;
                item.bounds = _getZeroBounds();
                item.initialPosition = item.bounds.center;

                // if it's not image, we return zero bounds (content is not zoomable)
                return item.bounds;
            }
        },
            _appendImage = function _appendImage(index, item, baseDiv, img, preventAnimation, keepPlaceholder) {

            if (item.loadError) {
                return;
            }

            if (img) {

                item.imageAppended = true;
                _setImageSize(item, img, item === self.currItem && _renderMaxResolution);

                baseDiv.appendChild(img);

                if (keepPlaceholder) {
                    setTimeout(function () {
                        if (item && item.loaded && item.placeholder) {
                            item.placeholder.style.display = 'none';
                            item.placeholder = null;
                        }
                    }, 500);
                }
            }
        },
            _preloadImage = function _preloadImage(item) {
            item.loading = true;
            item.loaded = false;
            var img = item.img = framework.createEl('pswp__img', 'img');
            var onComplete = function onComplete() {
                item.loading = false;
                item.loaded = true;

                if (item.loadComplete) {
                    item.loadComplete(item);
                } else {
                    item.img = null; // no need to store image object
                }
                img.onload = img.onerror = null;
                img = null;
            };
            img.onload = onComplete;
            img.onerror = function () {
                item.loadError = true;
                onComplete();
            };

            img.src = item.src; // + '?a=' + Math.random();

            return img;
        },
            _checkForError = function _checkForError(item, cleanUp) {
            if (item.src && item.loadError && item.container) {

                if (cleanUp) {
                    item.container.innerHTML = '';
                }

                item.container.innerHTML = _options.errorMsg.replace('%url%', item.src);
                return true;
            }
        },
            _setImageSize = function _setImageSize(item, img, maxRes) {
            if (!item.src) {
                return;
            }

            if (!img) {
                img = item.container.lastChild;
            }

            var w = maxRes ? item.w : Math.round(item.w * item.fitRatio),
                h = maxRes ? item.h : Math.round(item.h * item.fitRatio);

            if (item.placeholder && !item.loaded) {
                item.placeholder.style.width = w + 'px';
                item.placeholder.style.height = h + 'px';
            }

            img.style.width = w + 'px';
            img.style.height = h + 'px';
        },
            _appendImagesPool = function _appendImagesPool() {

            if (_imagesToAppendPool.length) {
                var poolItem;

                for (var i = 0; i < _imagesToAppendPool.length; i++) {
                    poolItem = _imagesToAppendPool[i];
                    if (poolItem.holder.index === poolItem.index) {
                        _appendImage(poolItem.index, poolItem.item, poolItem.baseDiv, poolItem.img, false, poolItem.clearPlaceholder);
                    }
                }
                _imagesToAppendPool = [];
            }
        };

        _registerModule('Controller', {

            publicMethods: {

                lazyLoadItem: function lazyLoadItem(index) {
                    index = _getLoopedId(index);
                    var item = _getItemAt(index);

                    if (!item || (item.loaded || item.loading) && !_itemsNeedUpdate) {
                        return;
                    }

                    _shout('gettingData', index, item);

                    if (!item.src) {
                        return;
                    }

                    _preloadImage(item);
                },
                initController: function initController() {
                    framework.extend(_options, _controllerDefaultOptions, true);
                    self.items = _items = items;
                    _getItemAt = self.getItemAt;
                    _getNumItems = _options.getNumItemsFn; //self.getNumItems;


                    _initialIsLoop = _options.loop;
                    if (_getNumItems() < 3) {
                        _options.loop = false; // disable loop if less then 3 items
                    }

                    _listen('beforeChange', function (diff) {

                        var p = _options.preload,
                            isNext = diff === null ? true : diff >= 0,
                            preloadBefore = Math.min(p[0], _getNumItems()),
                            preloadAfter = Math.min(p[1], _getNumItems()),
                            i;

                        for (i = 1; i <= (isNext ? preloadAfter : preloadBefore); i++) {
                            self.lazyLoadItem(_currentItemIndex + i);
                        }
                        for (i = 1; i <= (isNext ? preloadBefore : preloadAfter); i++) {
                            self.lazyLoadItem(_currentItemIndex - i);
                        }
                    });

                    _listen('initialLayout', function () {
                        self.currItem.initialLayout = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);
                    });

                    _listen('mainScrollAnimComplete', _appendImagesPool);
                    _listen('initialZoomInEnd', _appendImagesPool);

                    _listen('destroy', function () {
                        var item;
                        for (var i = 0; i < _items.length; i++) {
                            item = _items[i];
                            // remove reference to DOM elements, for GC
                            if (item.container) {
                                item.container = null;
                            }
                            if (item.placeholder) {
                                item.placeholder = null;
                            }
                            if (item.img) {
                                item.img = null;
                            }
                            if (item.preloader) {
                                item.preloader = null;
                            }
                            if (item.loadError) {
                                item.loaded = item.loadError = false;
                            }
                        }
                        _imagesToAppendPool = null;
                    });
                },

                getItemAt: function getItemAt(index) {
                    if (index >= 0) {
                        return _items[index] !== undefined ? _items[index] : false;
                    }
                    return false;
                },

                allowProgressiveImg: function allowProgressiveImg() {
                    // 1. Progressive image loading isn't working on webkit/blink 
                    //    when hw-acceleration (e.g. translateZ) is applied to IMG element.
                    //    That's why in PhotoSwipe parent element gets zoom transform, not image itself.
                    //    
                    // 2. Progressive image loading sometimes blinks in webkit/blink when applying animation to parent element.
                    //    That's why it's disabled on touch devices (mainly because of swipe transition)
                    //    
                    // 3. Progressive image loading sometimes doesn't work in IE (up to 11).

                    // Don't allow progressive loading on non-large touch devices
                    return _options.forceProgressiveLoading || !_likelyTouchDevice || _options.mouseUsed || screen.width > 1200;
                    // 1200 - to eliminate touch devices with large screen (like Chromebook Pixel)
                },

                setContent: function setContent(holder, index) {

                    if (_options.loop) {
                        index = _getLoopedId(index);
                    }

                    var prevItem = self.getItemAt(holder.index);
                    if (prevItem) {
                        prevItem.container = null;
                    }

                    var item = self.getItemAt(index),
                        img;

                    if (!item) {
                        holder.el.innerHTML = '';
                        return;
                    }

                    // allow to override data
                    _shout('gettingData', index, item);

                    holder.index = index;
                    holder.item = item;

                    // base container DIV is created only once for each of 3 holders
                    var baseDiv = item.container = framework.createEl('pswp__zoom-wrap');

                    if (!item.src && item.html) {
                        if (item.html.tagName) {
                            baseDiv.appendChild(item.html);
                        } else {
                            baseDiv.innerHTML = item.html;
                        }
                    }

                    _checkForError(item);

                    _calculateItemSize(item, _viewportSize);

                    if (item.src && !item.loadError && !item.loaded) {

                        item.loadComplete = function (item) {

                            // gallery closed before image finished loading
                            if (!_isOpen) {
                                return;
                            }

                            // check if holder hasn't changed while image was loading
                            if (holder && holder.index === index) {
                                if (_checkForError(item, true)) {
                                    item.loadComplete = item.img = null;
                                    _calculateItemSize(item, _viewportSize);
                                    _applyZoomPanToItem(item);

                                    if (holder.index === _currentItemIndex) {
                                        // recalculate dimensions
                                        self.updateCurrZoomItem();
                                    }
                                    return;
                                }
                                if (!item.imageAppended) {
                                    if (_features.transform && (_mainScrollAnimating || _initialZoomRunning)) {
                                        _imagesToAppendPool.push({
                                            item: item,
                                            baseDiv: baseDiv,
                                            img: item.img,
                                            index: index,
                                            holder: holder,
                                            clearPlaceholder: true
                                        });
                                    } else {
                                        _appendImage(index, item, baseDiv, item.img, _mainScrollAnimating || _initialZoomRunning, true);
                                    }
                                } else {
                                    // remove preloader & mini-img
                                    if (!_initialZoomRunning && item.placeholder) {
                                        item.placeholder.style.display = 'none';
                                        item.placeholder = null;
                                    }
                                }
                            }

                            item.loadComplete = null;
                            item.img = null; // no need to store image element after it's added

                            _shout('imageLoadComplete', index, item);
                        };

                        if (framework.features.transform) {

                            var placeholderClassName = 'pswp__img pswp__img--placeholder';
                            placeholderClassName += item.msrc ? '' : ' pswp__img--placeholder--blank';

                            var placeholder = framework.createEl(placeholderClassName, item.msrc ? 'img' : '');
                            if (item.msrc) {
                                placeholder.src = item.msrc;
                            }

                            _setImageSize(item, placeholder);

                            baseDiv.appendChild(placeholder);
                            item.placeholder = placeholder;
                        }

                        if (!item.loading) {
                            _preloadImage(item);
                        }

                        if (self.allowProgressiveImg()) {
                            // just append image
                            if (!_initialContentSet && _features.transform) {
                                _imagesToAppendPool.push({
                                    item: item,
                                    baseDiv: baseDiv,
                                    img: item.img,
                                    index: index,
                                    holder: holder
                                });
                            } else {
                                _appendImage(index, item, baseDiv, item.img, true, true);
                            }
                        }
                    } else if (item.src && !item.loadError) {
                        // image object is created every time, due to bugs of image loading & delay when switching images
                        img = framework.createEl('pswp__img', 'img');
                        img.style.opacity = 1;
                        img.src = item.src;
                        _setImageSize(item, img);
                        _appendImage(index, item, baseDiv, img, true);
                    }

                    if (!_initialContentSet && index === _currentItemIndex) {
                        _currZoomElementStyle = baseDiv.style;
                        _showOrHide(item, img || item.img);
                    } else {
                        _applyZoomPanToItem(item);
                    }

                    holder.el.innerHTML = '';
                    holder.el.appendChild(baseDiv);
                },

                cleanSlide: function cleanSlide(item) {
                    if (item.img) {
                        item.img.onload = item.img.onerror = null;
                    }
                    item.loaded = item.loading = item.img = item.imageAppended = false;
                }

            }
        });

        /*>>items-controller*/

        /*>>tap*/
        /**
         * tap.js:
         *
         * Displatches tap and double-tap events.
         * 
         */

        var tapTimer,
            tapReleasePoint = {},
            _dispatchTapEvent = function _dispatchTapEvent(origEvent, releasePoint, pointerType) {
            var e = document.createEvent('CustomEvent'),
                eDetail = {
                origEvent: origEvent,
                target: origEvent.target,
                releasePoint: releasePoint,
                pointerType: pointerType || 'touch'
            };

            e.initCustomEvent('pswpTap', true, true, eDetail);
            origEvent.target.dispatchEvent(e);
        };

        _registerModule('Tap', {
            publicMethods: {
                initTap: function initTap() {
                    _listen('firstTouchStart', self.onTapStart);
                    _listen('touchRelease', self.onTapRelease);
                    _listen('destroy', function () {
                        tapReleasePoint = {};
                        tapTimer = null;
                    });
                },
                onTapStart: function onTapStart(touchList) {
                    if (touchList.length > 1) {
                        clearTimeout(tapTimer);
                        tapTimer = null;
                    }
                },
                onTapRelease: function onTapRelease(e, releasePoint) {
                    if (!releasePoint) {
                        return;
                    }

                    if (!_moved && !_isMultitouch && !_numAnimations) {
                        var p0 = releasePoint;
                        if (tapTimer) {
                            clearTimeout(tapTimer);
                            tapTimer = null;

                            // Check if taped on the same place
                            if (_isNearbyPoints(p0, tapReleasePoint)) {
                                _shout('doubleTap', p0);
                                return;
                            }
                        }

                        if (releasePoint.type === 'mouse') {
                            _dispatchTapEvent(e, releasePoint, 'mouse');
                            return;
                        }

                        var clickedTagName = e.target.tagName.toUpperCase();
                        // avoid double tap delay on buttons and elements that have class pswp__single-tap
                        if (clickedTagName === 'BUTTON' || framework.hasClass(e.target, 'pswp__single-tap')) {
                            _dispatchTapEvent(e, releasePoint);
                            return;
                        }

                        _equalizePoints(tapReleasePoint, p0);

                        tapTimer = setTimeout(function () {
                            _dispatchTapEvent(e, releasePoint);
                            tapTimer = null;
                        }, 300);
                    }
                }
            }
        });

        /*>>tap*/

        /*>>desktop-zoom*/
        /**
         *
         * desktop-zoom.js:
         *
         * - Binds mousewheel event for paning zoomed image.
         * - Manages "dragging", "zoomed-in", "zoom-out" classes.
         *   (which are used for cursors and zoom icon)
         * - Adds toggleDesktopZoom function.
         * 
         */

        var _wheelDelta;

        _registerModule('DesktopZoom', {

            publicMethods: {

                initDesktopZoom: function initDesktopZoom() {

                    if (_oldIE) {
                        // no zoom for old IE (<=8)
                        return;
                    }

                    if (_likelyTouchDevice) {
                        // if detected hardware touch support, we wait until mouse is used,
                        // and only then apply desktop-zoom features
                        _listen('mouseUsed', function () {
                            self.setupDesktopZoom();
                        });
                    } else {
                        self.setupDesktopZoom(true);
                    }
                },

                setupDesktopZoom: function setupDesktopZoom(onInit) {

                    _wheelDelta = {};

                    var events = 'wheel mousewheel DOMMouseScroll';

                    _listen('bindEvents', function () {
                        framework.bind(template, events, self.handleMouseWheel);
                    });

                    _listen('unbindEvents', function () {
                        if (_wheelDelta) {
                            framework.unbind(template, events, self.handleMouseWheel);
                        }
                    });

                    self.mouseZoomedIn = false;

                    var hasDraggingClass,
                        updateZoomable = function updateZoomable() {
                        if (self.mouseZoomedIn) {
                            framework.removeClass(template, 'pswp--zoomed-in');
                            self.mouseZoomedIn = false;
                        }
                        if (_currZoomLevel < 1) {
                            framework.addClass(template, 'pswp--zoom-allowed');
                        } else {
                            framework.removeClass(template, 'pswp--zoom-allowed');
                        }
                        removeDraggingClass();
                    },
                        removeDraggingClass = function removeDraggingClass() {
                        if (hasDraggingClass) {
                            framework.removeClass(template, 'pswp--dragging');
                            hasDraggingClass = false;
                        }
                    };

                    _listen('resize', updateZoomable);
                    _listen('afterChange', updateZoomable);
                    _listen('pointerDown', function () {
                        if (self.mouseZoomedIn) {
                            hasDraggingClass = true;
                            framework.addClass(template, 'pswp--dragging');
                        }
                    });
                    _listen('pointerUp', removeDraggingClass);

                    if (!onInit) {
                        updateZoomable();
                    }
                },

                handleMouseWheel: function handleMouseWheel(e) {

                    if (_currZoomLevel <= self.currItem.fitRatio) {
                        if (_options.modal) {

                            if (!_options.closeOnScroll || _numAnimations || _isDragging) {
                                e.preventDefault();
                            } else if (_transformKey && Math.abs(e.deltaY) > 2) {
                                // close PhotoSwipe
                                // if browser supports transforms & scroll changed enough
                                _closedByScroll = true;
                                self.close();
                            }
                        }
                        return true;
                    }

                    // allow just one event to fire
                    e.stopPropagation();

                    // https://developer.mozilla.org/en-US/docs/Web/Events/wheel
                    _wheelDelta.x = 0;

                    if ('deltaX' in e) {
                        if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {
                                // 18 - average line height
                                _wheelDelta.x = e.deltaX * 18;
                                _wheelDelta.y = e.deltaY * 18;
                            } else {
                            _wheelDelta.x = e.deltaX;
                            _wheelDelta.y = e.deltaY;
                        }
                    } else if ('wheelDelta' in e) {
                        if (e.wheelDeltaX) {
                            _wheelDelta.x = -0.16 * e.wheelDeltaX;
                        }
                        if (e.wheelDeltaY) {
                            _wheelDelta.y = -0.16 * e.wheelDeltaY;
                        } else {
                            _wheelDelta.y = -0.16 * e.wheelDelta;
                        }
                    } else if ('detail' in e) {
                        _wheelDelta.y = e.detail;
                    } else {
                        return;
                    }

                    _calculatePanBounds(_currZoomLevel, true);

                    var newPanX = _panOffset.x - _wheelDelta.x,
                        newPanY = _panOffset.y - _wheelDelta.y;

                    // only prevent scrolling in nonmodal mode when not at edges
                    if (_options.modal || newPanX <= _currPanBounds.min.x && newPanX >= _currPanBounds.max.x && newPanY <= _currPanBounds.min.y && newPanY >= _currPanBounds.max.y) {
                        e.preventDefault();
                    }

                    // TODO: use rAF instead of mousewheel?
                    self.panTo(newPanX, newPanY);
                },

                toggleDesktopZoom: function toggleDesktopZoom(centerPoint) {
                    centerPoint = centerPoint || { x: _viewportSize.x / 2 + _offset.x, y: _viewportSize.y / 2 + _offset.y };

                    var doubleTapZoomLevel = _options.getDoubleTapZoom(true, self.currItem);
                    var zoomOut = _currZoomLevel === doubleTapZoomLevel;

                    self.mouseZoomedIn = !zoomOut;

                    self.zoomTo(zoomOut ? self.currItem.initialZoomLevel : doubleTapZoomLevel, centerPoint, 333);
                    framework[(!zoomOut ? 'add' : 'remove') + 'Class'](template, 'pswp--zoomed-in');
                }

            }
        });

        /*>>desktop-zoom*/

        /*>>history*/
        /**
         *
         * history.js:
         *
         * - Back button to close gallery.
         * 
         * - Unique URL for each slide: example.com/&pid=1&gid=3
         *   (where PID is picture index, and GID and gallery index)
         *   
         * - Switch URL when slides change.
         * 
         */

        var _historyDefaultOptions = {
            history: true,
            galleryUID: 1
        };

        var _historyUpdateTimeout,
            _hashChangeTimeout,
            _hashAnimCheckTimeout,
            _hashChangedByScript,
            _hashChangedByHistory,
            _hashReseted,
            _initialHash,
            _historyChanged,
            _closedFromURL,
            _urlChangedOnce,
            _windowLoc,
            _supportsPushState,
            _getHash = function _getHash() {
            return _windowLoc.hash.substring(1);
        },
            _cleanHistoryTimeouts = function _cleanHistoryTimeouts() {

            if (_historyUpdateTimeout) {
                clearTimeout(_historyUpdateTimeout);
            }

            if (_hashAnimCheckTimeout) {
                clearTimeout(_hashAnimCheckTimeout);
            }
        },


        // pid - Picture index
        // gid - Gallery index
        _parseItemIndexFromURL = function _parseItemIndexFromURL() {
            var hash = _getHash(),
                params = {};

            if (hash.length < 5) {
                // pid=1
                return params;
            }

            var i,
                vars = hash.split('&');
            for (i = 0; i < vars.length; i++) {
                if (!vars[i]) {
                    continue;
                }
                var pair = vars[i].split('=');
                if (pair.length < 2) {
                    continue;
                }
                params[pair[0]] = pair[1];
            }
            if (_options.galleryPIDs) {
                // detect custom pid in hash and search for it among the items collection
                var searchfor = params.pid;
                params.pid = 0; // if custom pid cannot be found, fallback to the first item
                for (i = 0; i < _items.length; i++) {
                    if (_items[i].pid === searchfor) {
                        params.pid = i;
                        break;
                    }
                }
            } else {
                params.pid = parseInt(params.pid, 10) - 1;
            }
            if (params.pid < 0) {
                params.pid = 0;
            }
            return params;
        },
            _updateHash = function _updateHash() {

            if (_hashAnimCheckTimeout) {
                clearTimeout(_hashAnimCheckTimeout);
            }

            if (_numAnimations || _isDragging) {
                // changing browser URL forces layout/paint in some browsers, which causes noticable lag during animation
                // that's why we update hash only when no animations running
                _hashAnimCheckTimeout = setTimeout(_updateHash, 500);
                return;
            }

            if (_hashChangedByScript) {
                clearTimeout(_hashChangeTimeout);
            } else {
                _hashChangedByScript = true;
            }

            var pid = _currentItemIndex + 1;
            var item = _getItemAt(_currentItemIndex);
            if (item.hasOwnProperty('pid')) {
                // carry forward any custom pid assigned to the item
                pid = item.pid;
            }
            var newHash = _initialHash + '&' + 'gid=' + _options.galleryUID + '&' + 'pid=' + pid;

            if (!_historyChanged) {
                if (_windowLoc.hash.indexOf(newHash) === -1) {
                    _urlChangedOnce = true;
                }
                // first time - add new hisory record, then just replace
            }

            var newURL = _windowLoc.href.split('#')[0] + '#' + newHash;

            if (_supportsPushState) {

                if ('#' + newHash !== window.location.hash) {
                    history[_historyChanged ? 'replaceState' : 'pushState']('', document.title, newURL);
                }
            } else {
                if (_historyChanged) {
                    _windowLoc.replace(newURL);
                } else {
                    _windowLoc.hash = newHash;
                }
            }

            _historyChanged = true;
            _hashChangeTimeout = setTimeout(function () {
                _hashChangedByScript = false;
            }, 60);
        };

        _registerModule('History', {

            publicMethods: {
                initHistory: function initHistory() {

                    framework.extend(_options, _historyDefaultOptions, true);

                    if (!_options.history) {
                        return;
                    }

                    _windowLoc = window.location;
                    _urlChangedOnce = false;
                    _closedFromURL = false;
                    _historyChanged = false;
                    _initialHash = _getHash();
                    _supportsPushState = 'pushState' in history;

                    if (_initialHash.indexOf('gid=') > -1) {
                        _initialHash = _initialHash.split('&gid=')[0];
                        _initialHash = _initialHash.split('?gid=')[0];
                    }

                    _listen('afterChange', self.updateURL);
                    _listen('unbindEvents', function () {
                        framework.unbind(window, 'hashchange', self.onHashChange);
                    });

                    var returnToOriginal = function returnToOriginal() {
                        _hashReseted = true;
                        if (!_closedFromURL) {

                            if (_urlChangedOnce) {
                                history.back();
                            } else {

                                if (_initialHash) {
                                    _windowLoc.hash = _initialHash;
                                } else {
                                    if (_supportsPushState) {

                                        // remove hash from url without refreshing it or scrolling to top
                                        history.pushState('', document.title, _windowLoc.pathname + _windowLoc.search);
                                    } else {
                                        _windowLoc.hash = '';
                                    }
                                }
                            }
                        }

                        _cleanHistoryTimeouts();
                    };

                    _listen('unbindEvents', function () {
                        if (_closedByScroll) {
                            // if PhotoSwipe is closed by scroll, we go "back" before the closing animation starts
                            // this is done to keep the scroll position
                            returnToOriginal();
                        }
                    });
                    _listen('destroy', function () {
                        if (!_hashReseted) {
                            returnToOriginal();
                        }
                    });
                    _listen('firstUpdate', function () {
                        _currentItemIndex = _parseItemIndexFromURL().pid;
                    });

                    var index = _initialHash.indexOf('pid=');
                    if (index > -1) {
                        _initialHash = _initialHash.substring(0, index);
                        if (_initialHash.slice(-1) === '&') {
                            _initialHash = _initialHash.slice(0, -1);
                        }
                    }

                    setTimeout(function () {
                        if (_isOpen) {
                            // hasn't destroyed yet
                            framework.bind(window, 'hashchange', self.onHashChange);
                        }
                    }, 40);
                },
                onHashChange: function onHashChange() {

                    if (_getHash() === _initialHash) {

                        _closedFromURL = true;
                        self.close();
                        return;
                    }
                    if (!_hashChangedByScript) {

                        _hashChangedByHistory = true;
                        self.goTo(_parseItemIndexFromURL().pid);
                        _hashChangedByHistory = false;
                    }
                },
                updateURL: function updateURL() {

                    // Delay the update of URL, to avoid lag during transition, 
                    // and to not to trigger actions like "refresh page sound" or "blinking favicon" to often

                    _cleanHistoryTimeouts();

                    if (_hashChangedByHistory) {
                        return;
                    }

                    if (!_historyChanged) {
                        _updateHash(); // first time
                    } else {
                        _historyUpdateTimeout = setTimeout(_updateHash, 800);
                    }
                }

            }
        });

        /*>>history*/
        framework.extend(self, publicMethods);
    };
    return PhotoSwipe;
});

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _selectComponent = __webpack_require__(32);

var _selectComponent2 = _interopRequireDefault(_selectComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Share = function () {
    function Share(element) {
        var _this = this;

        _classCallCheck(this, Share);

        this.animatingClass = 'velocity-animating';
        this.velocityConfig = {
            duration: 250
        };

        this.handeButtonClick = function (event) {
            _this.toggleList();
        };

        this.$component = (0, _selectComponent2.default)(element);
        this.$list = this.$component.elements.list;
        this.$button = this.$component.elements.button;

        $.Velocity.hook(this.$list, 'translateX', '-50%');

        this.$button.on('click', function (event) {
            event.stopPropagation();
            _this.toggleList();
        });

        this.$list.on('click', function (event) {
            return event.stopPropagation();
        });

        $(window).on('click', function () {
            if (_this.$list.is(':visible') && !_this.$list.hasClass(_this.animatingClass)) {
                _this.hideList();
            }
        });
    }

    _createClass(Share, [{
        key: 'showList',
        value: function showList() {
            if (!this.$list.hasClass(this.animatingClass)) {
                this.$list.velocity('transition.slideDownIn', this.velocityConfig);
            }
        }
    }, {
        key: 'hideList',
        value: function hideList() {
            var _this2 = this;

            if (!this.$list.hasClass(this.animatingClass)) {
                this.$list.velocity('transition.slideUpOut', _extends({}, this.velocityConfig, {
                    complete: function complete() {
                        _this2.$list.css('display', '');
                    }
                }));
            }
        }
    }, {
        key: 'toggleList',
        value: function toggleList() {
            if (this.$list.is(':visible')) {
                this.hideList();
            } else {
                this.showList();
            }
        }
    }]);

    return Share;
}();

exports.default = Share;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(66);

__webpack_require__(100);

var _selectComponent = __webpack_require__(32);

var _selectComponent2 = _interopRequireDefault(_selectComponent);

__webpack_require__(69);

var _gridSettings = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SubNav = function () {
    function SubNav(element) {
        var _this = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, SubNav);

        this.$component = (0, _selectComponent2.default)(element);
        this.$nav = this.$component.elements.subnavContents;
        this.setTransition();
        $(window).on('debouncedresize', function () {
            _this.setTransition();
        });
    }

    _createClass(SubNav, [{
        key: 'setTransition',
        value: function setTransition() {
            this.stopToggle();
            if (_gridSettings.$bpLaptop.matches) {
                this.transitionIn = 'transition.slideDownIn';
                this.transitionOut = 'transition.slideUpOut';
            } else {
                this.transitionIn = 'slideDown';
                this.transitionOut = 'slideUp';
            }

            this.startToggle();
        }
    }, {
        key: 'startToggle',
        value: function startToggle() {
            var _this2 = this;

            $('body').on('click', function () {
                if (_this2.$component.elements.toggle.attr('data-property') == 'open') {
                    _this2.$component.elements.toggle.attr('data-property', 'closed');
                    _this2.closeNav();
                }
            });

            this.$component.elements.toggle.on('click', function (event) {
                event.stopPropagation();

                if (_this2.$component.elements.toggle.attr('data-property') == 'open') {
                    _this2.$component.elements.toggle.attr('data-property', 'closed');
                    _this2.closeNav();
                } else {
                    _this2.$component.elements.toggle.attr('data-property', 'open');
                    _this2.openNav();
                }
            });

            this.$component.on('click', function (event) {
                event.stopPropagation();
            });
        }
    }, {
        key: 'stopToggle',
        value: function stopToggle() {
            this.$component.elements.toggle.off();
            $('body').off();
        }
    }, {
        key: 'openNav',
        value: function openNav() {
            var _this3 = this;

            this.$nav.velocity(this.transitionIn, {
                duration: 400,
                complete: function complete() {
                    _this3.$nav.removeAttr('style');
                    _this3.$nav.attr('data-property', 'open');
                }
            });
        }
    }, {
        key: 'closeNav',
        value: function closeNav() {
            var _this4 = this;

            this.$nav.velocity(this.transitionOut, {
                duration: 500,
                complete: function complete() {
                    _this4.$nav.removeAttr('style');
                    _this4.$nav.attr('data-property', 'closed');
                }
            });
        }
    }]);

    return SubNav;
}();

exports.default = SubNav;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 181 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 182 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
]),[136]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3V0aWxpdGllcy9zZWxlY3QtY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZlbG9jaXR5LWFuaW1hdGUvdmVsb2NpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL2pxdWVyeS5kZWJvdW5jZWRyZXNpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudC9jdXN0b20taW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnQvYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmVsb2NpdHktYW5pbWF0ZS92ZWxvY2l0eS51aS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy91dGlsaXRpZXMvZ3JpZC1zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZlbG9jaXR5LWFuaW1hdGUvdmVsb2NpdHkudWkuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9zaXRlLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50L2FqYXgtZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NhbWVsQ2FzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NhcGl0YWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3VwcGVyRmlyc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ2FzZUZpcnN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RTbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdW5pY29kZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ29tcG91bmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYnVyci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWJ1cnJMZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5T2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC93b3Jkcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVdvcmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1VuaWNvZGVXb3JkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVXb3Jkcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXV0b3NpemUvZGlzdC9hdXRvc2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudC9Hb29nbGVNYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnQvR29vZ2xlTWFwL0Jhc2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnQvR29vZ2xlTWFwL092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnQvbW9kYWwtbWZwLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL21hZ25pZmljLXBvcHVwL2pxdWVyeS5tYWduaWZpYy1wb3B1cC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnQvbWFpbi1uYXYuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnQvZ2FsbGVyeS1waG90b3N3aXBlLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL3Bob3Rvc3dpcGUuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92ZW5kb3IvcGhvdG9zd2lwZS11aS1kZWZhdWx0LmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50L1NoYXJlLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50L3N1Ym5hdi5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3Nhc3Mvc3R5bGUuc2Nzcz84YTc1Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvc2Fzcy93eXNpd3lnLXN0eWxlcy5zY3NzPzI4MTgiXSwibmFtZXMiOlsic2VsZWN0Q29tcG9uZW50IiwiY29tcG9uZW50U2VsZWN0b3JUZW1wbGF0ZSIsIm5hbWUiLCJlbGVtZW50U2VsZWN0b3IiLCJjb21wb25lbnRTZWxlY3RvciIsInRhcmdldCIsImRlYnVnIiwic2VsZWN0b3IiLCIkIiwidHlwZSIsIiRjb21wb25lbnQiLCJlbGVtZW50cyIsImluaXQiLCJqUXVlcnkiLCJidWlsZEVsZW1lbnRzIiwicmVmcmVzaCIsImVsZW1lbnRNYXAiLCIkZWxlbWVudHMiLCJjb21wb25lbnQiLCJmaW5kIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsIiRleGNsdWRlZEVsZW1lbnRzIiwiZmlsdGVyIiwiaW5kZXgiLCJlbGVtZW50IiwicGFyZW50c1VudGlsIiwibm90IiwiZWFjaCIsIiRlbGVtZW50IiwiZWxlbWVudE5hbWUiLCJkYXRhIiwiaGFzT3duUHJvcGVydHkiLCJhZGQiLCJkZWJ1Z1NldHRpbmciLCIkZXZlbnQiLCJldmVudCIsIiRzcGVjaWFsIiwicmVzaXplVGltZW91dCIsInNwZWNpYWwiLCJkZWJvdW5jZWRyZXNpemUiLCJzZXR1cCIsIm9uIiwiaGFuZGxlciIsInRlYXJkb3duIiwib2ZmIiwiZXhlY0FzYXAiLCJjb250ZXh0IiwiYXJncyIsImFyZ3VtZW50cyIsImRpc3BhdGNoIiwiYXBwbHkiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwidGhyZXNob2xkIiwiYmFzZUNsYXNzIiwiQ3VzdG9tSW5wdXQiLCJvcHRpb25zIiwiYWN0aXZlQ2xhc3MiLCJmaWxsZWRDbGFzcyIsImRpc2FibGVkQ2xhc3MiLCJlcnJvckNsYXNzIiwiaGFuZGxlRmlsZUNoYW5nZSIsImZpbGVOYW1lIiwiZmllbGQiLCJmaWxlcyIsImxhYmVsIiwidGV4dCIsImhhbmRsZUZpbHRlckV2ZW50IiwidXJsIiwidmFsIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiaGFuZGxlSW5wdXRGaWxsIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsIiRmaWVsZCIsImF0dGFjaEV2ZW50cyIsImVycm9yTGFiZWwiLCJjcmVhdGVFcnJvckxhYmVsIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwiYXR0ciIsImVycm9yIiwicHJlcGVuZCIsInJlbW92ZUF0dHIiLCJmb2N1cyIsIm1lc3NhZ2UiLCJodG1sIiwiREVGQVVMVCIsImVsIiwiZXhpc3RzIiwiY29uc3RydWN0IiwibW9kdWxlRGVmYXVsdCIsInNldHRpbmdzIiwic3RhcnQiLCJhY3Rpb24iLCJlcnIiLCIkYnBNb2JpbGUiLCJtYXRjaE1lZGlhIiwiJGJwVGFibGV0IiwiJGJwTGFwdG9wIiwiJGJwTGciLCIkYnBYbCIsIiRicFh4bCIsImRvY3VtZW50IiwicmVhZHkiLCJhamF4U2V0dXAiLCJoZWFkZXJzIiwiU2l0ZSIsIkFVVE9fTU9EVUxFUyIsInN0YXJ0RGVmYXVsdCIsInN0YXJ0Q3VzdG9tIiwia2V5IiwiTW9kdWxlIiwiaW5zdGFuY2UiLCJtYXBJY29uIiwicGF0aCIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5Iiwic3Ryb2tlT3BhY2l0eSIsInNjYWxlIiwiYW5jaG9yIiwiZ29vZ2xlIiwibWFwcyIsIlBvaW50IiwiaW1hZ2VPdmVybGF5cyIsIm5vcnRoRWFzdCIsInNvdXRoV2VzdCIsImltYWdlIiwic2hvd0JvdW5kcyIsImltcG9ydFNWRyIsImxvY2F0aW9ucyIsIkxPQ0FUSU9OUyIsImljb24iLCJOYXYiLCJBamF4Rm9ybSIsImNvbXBsZXRlQ2xhc3MiLCJsb2FkaW5nQ2xhc3MiLCJmaWVsZHNTZWxlY3RvciIsImlucHV0cyIsImhhbmRsZUVycm9yIiwianFYSFIiLCJ0ZXh0U3RhdHVzIiwiZXJyb3JUaHJvd24iLCJlcnJvck9iamVjdCIsInJlc3BvbnNlSlNPTiIsImVycm9ycyIsInZhbHVlIiwic2V0RXJyb3IiLCJqb2luIiwiJGZpcnN0RXJyb3IiLCIkZm9ybSIsImZpcnN0IiwiaW5wdXROYW1lIiwidmVsb2NpdHkiLCJvZmZzZXQiLCJkdXJhdGlvbiIsImNvbXBsZXRlIiwiaGFuZGxlU3VjY2VzcyIsImRpc2FibGUiLCJzdWJtaXQiLCJzdWNjZXNzTWVzc2FnZSIsImFwcGVuZCIsIm9wYWNpdHkiLCJlYXNpbmciLCJiZWdpbiIsImhhbmRsZVJlcXVlc3RTdGFydCIsInJlc2V0RXJyb3JzIiwiaGFuZGxlUmVxdWVzdEVuZCIsImhhbmRsZVN1Ym1pdCIsInByZXZlbnREZWZhdWx0IiwiaGFzQ2xhc3MiLCJGb3JtRGF0YSIsImFqYXgiLCJwcm9jZXNzRGF0YSIsImNvbnRlbnRUeXBlIiwiYWx3YXlzIiwidGhlbiIsImZhaWwiLCJidWlsZElucHV0cyIsImNyZWF0ZVN1Y2Nlc3NFbGVtZW50IiwiaW5wdXQiLCJnZXROYW1lIiwicmVtb3ZlRXJyb3IiLCJHb29nbGVNYXAiLCJpbmZvV2luZG93VGVtcGxhdGUiLCJ0aXRsZSIsInBob25lIiwiZmF4IiwiYWRkcmVzczEiLCJjaXR5Iiwic3RhdGUiLCJ6aXAiLCJjb3VudHJ5IiwiJG1hcCIsIm1hcCIsIm1hcERlZmF1bHRzIiwiY2VudGVyIiwibGF0IiwicGFyc2VGbG9hdCIsImxuZyIsIm1hcFR5cGVDb250cm9sIiwic3RyZWV0Vmlld0NvbnRyb2wiLCJ6b29tIiwiem9vbUNvbnRyb2xPcHRpb25zIiwicG9zaXRpb24iLCJDb250cm9sUG9zaXRpb24iLCJMRUZUX0JPVFRPTSIsIm1hcE9wdGlvbnMiLCJtYXBDb25maWciLCJpbml0TWFwIiwiZ29vZ2xlTWFwIiwiaW5mb1dpbmRvdyIsIkluZm9XaW5kb3ciLCJzZXRDZW50ZXJQb2ludCIsImFkZExvY2F0aW9ucyIsImNyZWF0ZU92ZXJsYXlzIiwiYmluZEV2ZW50cyIsImNvbnRyb2wiLCJpbml0Q3VzdG9tQ29udHJvbHMiLCJzZWxlY3QiLCJpbml0Q3VzdG9tU2VsZWN0cyIsInJlY2VudGVyTWFwIiwidW5iaW5kRXZlbnRzIiwicmVtb3ZlIiwicGFuVG9Mb2NhdGlvbiIsImNlbnRlclBvaW50Iiwic2V0TGF0TG5nIiwiZm9yRWFjaCIsImFkZE1hcmtlciIsImluZm9XaW5kb3dGaWVsZHMiLCJib3VuZHMiLCJMYXRMbmdCb3VuZHMiLCJMYXRMbmciLCIkY29udHJvbCIsIiRvcHRpb24iLCJzZXRNYXBQb3NpdGlvbiIsImFjdGl2ZUNvbnRyb2wiLCJ0cmltIiwic2V0QWN0aXZlQ29udHJvbHMiLCIkY29udHJvbHMiLCIkc2VsZWN0cyIsIm9wdGlvbiIsInBhcmVudCIsImNvbnRyb2xMYXQiLCJjb250cm9sTG5nIiwiY29udHJvbFpvb20iLCJzZXRab29tQW1vdW50IiwiQmFzZU1hcCIsIm1hcEVsZW1lbnQiLCJtYXJrZXJzIiwibWFya2VyQm91bmRzIiwibWFwT3B0aW9uc0RlZmF1bHRzIiwic2Nyb2xsd2hlZWwiLCJtYXBDZW50ZXJEZWZhdWx0cyIsImdldE1hcCIsIkVycm9yIiwiTWFwIiwic3R5bGVzIiwibWFwVHlwZXMiLCJzZXQiLCJTdHlsZWRNYXBUeXBlIiwic2V0TWFwVHlwZUlkIiwibWFya2VyQ2VudGVyIiwibWFya2VyUGFyYW1zIiwibWFya2VyIiwiTWFya2VyIiwiaW5mb1dpbmRvd01hcmt1cCIsImNvbnRlbnQiLCJlbmFibGVFdmVudFByb3BhZ2F0aW9uIiwiZGlzYWJsZUF1dG9QYW4iLCJtYXhXaWR0aCIsInpJbmRleCIsImNsb3NlQm94VVJMIiwiYWRkTGlzdGVuZXIiLCJvcGVuIiwiYmluZCIsImV4dGVuZCIsInB1c2giLCJmaXRCb3VuZHMiLCJtYXJrZXJMb2NhdGlvbiIsInBhblRvIiwic2V0Wm9vbSIsImRpc3RhbmNlIiwiY2lyY2xlIiwiQ2lyY2xlIiwicmFkaXVzIiwidmlzaWJsZSIsImdldEJvdW5kcyIsImkiLCJzZXRNYXAiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm5hdmlnYXRvciIsImdlb2xvY2F0aW9uIiwiZ2V0Q3VycmVudFBvc2l0aW9uIiwiYnlJUCIsImNvb3JkaW5hdGVzIiwiY29vcmRzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJsaXN0ZW5lckZ1bmN0aW9uIiwiZmFsbGJhY2tFbmRwb2ludCIsInN1Y2Nlc3MiLCJwYXJzZUpTT04iLCJ1bmRlZmluZWQiLCJzdWNjZXNzQ2FsbGJhY2siLCJnZW9sb2NhdGUiLCJnZW9sb2NhdGVCeUlQIiwiYWRkcmVzcyIsImVycm9yQ2FsbGJhY2siLCJnZW9jb2RlciIsIkdlb2NvZGVyIiwiZ2VvY29kZSIsImdlb21ldHJ5IiwiYWRkcmVzc2VzIiwieCIsInkiLCJuZSIsImdldE5vcnRoRWFzdCIsInN3IiwiZ2V0U291dGhXZXN0IiwicHJvamVjdGlvbiIsImdldFByb2plY3Rpb24iLCJ0b3BSaWdodCIsImZyb21MYXRMbmdUb1BvaW50IiwiYm90dG9tTGVmdCIsImdldFpvb20iLCJmcm9tUG9pbnRUb0xhdExuZyIsInRyaWdnZXIiLCJHb29nbGVNYXBPdmVybGF5IiwibWFwT2JqZWN0IiwiY29udGFpbmVyIiwiY29udGFpbmVyQm9yZGVyIiwicGFuZXMiLCJnZXRQYW5lcyIsIiRpbWFnZUNvbnRhaW5lciIsImNzcyIsImFwcGVuZFRvIiwib3ZlcmxheU1vdXNlVGFyZ2V0IiwiYWRkQ29udGFpbmVyQm9yZGVyIiwiJGltYWdlIiwic3JjIiwib3ZlcmxheVByb2plY3Rpb24iLCJmcm9tTGF0TG5nVG9EaXZQaXhlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIk92ZXJsYXlWaWV3IiwiTW9kYWxNRlAiLCJjYWxsYmFja3MiLCJwYXJzZUFqYXgiLCJyIiwibXAiLCJtYWduaWZpY1BvcHVwIiwiJHRyaWdnZXIiLCJjdXJySXRlbSIsImZyYWdtZW50IiwicmVtb3ZhbERlbGF5IiwibWFpbkNsYXNzIiwiY2xvc2VCdG5JbnNpZGUiLCJnYWxsZXJ5IiwiZW5hYmxlZCIsInB1YmxpY0V4cG9ydHMiLCJlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJaZXB0byIsInQiLCJuIiwibyIsImEiLCJzIiwibCIsImMiLCJkIiwidSIsInAiLCJmIiwibSIsImciLCJoIiwidiIsIkMiLCJ3IiwiYiIsIkkiLCJldiIsImsiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiaW5uZXJIVE1MIiwiYXBwZW5kQ2hpbGQiLCJUIiwidHJpZ2dlckhhbmRsZXIiLCJzdCIsImNoYXJBdCIsInNsaWNlIiwiaXNBcnJheSIsIkUiLCJjdXJyVGVtcGxhdGUiLCJjbG9zZUJ0biIsImNsb3NlTWFya3VwIiwicmVwbGFjZSIsInRDbG9zZSIsIl8iLCJTIiwic3R5bGUiLCJ0cmFuc2l0aW9uIiwicG9wIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJhcHBWZXJzaW9uIiwiaXNJRTciLCJpbmRleE9mIiwiaXNJRTgiLCJpc0xvd0lFIiwiaXNBbmRyb2lkIiwidGVzdCIsImlzSU9TIiwic3VwcG9ydHNUcmFuc2l0aW9uIiwicHJvYmFibHlNb2JpbGUiLCJ1c2VyQWdlbnQiLCJwb3B1cHNDYWNoZSIsImJvZHkiLCJpc09iaiIsIml0ZW1zIiwidG9BcnJheSIsInBhcnNlZCIsImlzT3BlbiIsInVwZGF0ZUl0ZW1IVE1MIiwidHlwZXMiLCJtYWluRWwiLCJlcSIsImRlZmF1bHRzIiwiZml4ZWRDb250ZW50UG9zIiwibW9kYWwiLCJjbG9zZU9uQ29udGVudENsaWNrIiwiY2xvc2VPbkJnQ2xpY2siLCJzaG93Q2xvc2VCdG4iLCJlbmFibGVFc2NhcGVLZXkiLCJiZ092ZXJsYXkiLCJjbG9zZSIsIndyYXAiLCJfY2hlY2tJZkNsb3NlIiwiY29udGVudENvbnRhaW5lciIsInByZWxvYWRlciIsInRMb2FkaW5nIiwibW9kdWxlcyIsInRvVXBwZXJDYXNlIiwiY2FsbCIsImNsb3NlX3JlcGxhY2VXaXRoIiwiYWxpZ25Ub3AiLCJvdmVyZmxvdyIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsInRvcCIsInNjcm9sbFRvcCIsImZpeGVkQmdQb3MiLCJoZWlnaHQiLCJrZXlDb2RlIiwidXBkYXRlU2l6ZSIsIndIIiwiX2hhc1Njcm9sbEJhciIsIl9nZXRTY3JvbGxiYXJTaXplIiwibWFyZ2luUmlnaHQiLCJfYWRkQ2xhc3NUb01GUCIsInByZXBlbmRUbyIsIl9sYXN0Rm9jdXNlZEVsIiwiYWN0aXZlRWxlbWVudCIsIl9zZXRGb2N1cyIsIl9vbkZvY3VzSW4iLCJfY2xvc2UiLCJkZXRhY2giLCJlbXB0eSIsIl9yZW1vdmVDbGFzc0Zyb21NRlAiLCJwcmV2SGVpZ2h0IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJwYXJzZUVsIiwibWFya3VwIiwiYXBwZW5kQ29udGVudCIsInByZWxvYWRlZCIsImFkZEdyb3VwIiwibWZwRWwiLCJfb3BlbkNsaWNrIiwiZGVsZWdhdGUiLCJtaWRDbGljayIsIndoaWNoIiwiY3RybEtleSIsIm1ldGFLZXkiLCJkaXNhYmxlT24iLCJpc0Z1bmN0aW9uIiwid2lkdGgiLCJzdG9wUHJvcGFnYXRpb24iLCJ1cGRhdGVTdGF0dXMiLCJzdGF0dXMiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJjb250YWlucyIsInNjcm9sbEhlaWdodCIsIl9wYXJzZU1hcmt1cCIsInNwbGl0IiwicmVwbGFjZVdpdGgiLCJpcyIsInNjcm9sbGJhclNpemUiLCJjc3NUZXh0Iiwib2Zmc2V0V2lkdGgiLCJwcm90byIsInJlZ2lzdGVyTW9kdWxlIiwiZm4iLCJwYXJzZUludCIsIkFycmF5IiwiUCIsIk8iLCJ6IiwiTSIsIkIiLCJhZnRlciIsImhpZGRlbkNsYXNzIiwidE5vdEZvdW5kIiwiaW5pdElubGluZSIsImdldElubGluZSIsImlubGluZSIsImlubGluZUVsZW1lbnQiLCJGIiwiSCIsIkwiLCJBIiwicmVxIiwiYWJvcnQiLCJjdXJzb3IiLCJ0RXJyb3IiLCJpbml0QWpheCIsImdldEFqYXgiLCJ4aHIiLCJmaW5pc2hlZCIsImxvYWRFcnJvciIsImoiLCJOIiwidGl0bGVTcmMiLCJ2ZXJ0aWNhbEZpdCIsImluaXRJbWFnZSIsInJlc2l6ZUltYWdlIiwiaW1nIiwiX29uSW1hZ2VIYXNTaXplIiwiaGFzU2l6ZSIsImNsZWFySW50ZXJ2YWwiLCJpc0NoZWNraW5nSW1nU2l6ZSIsImltZ0hpZGRlbiIsImZpbmRJbWFnZVNpemUiLCJzZXRJbnRlcnZhbCIsIm5hdHVyYWxXaWR0aCIsImdldEltYWdlIiwibG9hZGVkIiwiYWx0IiwiY2xvbmUiLCJpbWdfcmVwbGFjZVdpdGgiLCJsb2FkaW5nIiwiVyIsIlIiLCJNb3pUcmFuc2Zvcm0iLCJvcGVuZXIiLCJpbml0Wm9vbSIsImxlZnQiLCJfYWxsb3dab29tIiwiX2dldEl0ZW1Ub1pvb20iLCJfZ2V0T2Zmc2V0Iiwib2Zmc2V0SGVpZ2h0IiwidHJhbnNmb3JtIiwiWiIsInEiLCJEIiwic3JjQWN0aW9uIiwicGF0dGVybnMiLCJ5b3V0dWJlIiwiaWQiLCJ2aW1lbyIsImdtYXBzIiwiaW5pdElmcmFtZSIsImdldElmcmFtZSIsImlmcmFtZSIsInN1YnN0ciIsImxhc3RJbmRleE9mIiwiSyIsIlkiLCJhcnJvd01hcmt1cCIsInByZWxvYWQiLCJuYXZpZ2F0ZUJ5SW1nQ2xpY2siLCJhcnJvd3MiLCJ0UHJldiIsInROZXh0IiwidENvdW50ZXIiLCJpbml0R2FsbGVyeSIsIkJvb2xlYW4iLCJtZnBGYXN0Q2xpY2siLCJkaXJlY3Rpb24iLCJuZXh0IiwicHJldiIsImNvdW50ZXIiLCJhcnJvd0xlZnQiLCJhcnJvd1JpZ2h0IiwiX3ByZWxvYWRUaW1lb3V0IiwicHJlbG9hZE5lYXJieUltYWdlcyIsImRlc3Ryb3lNZnBGYXN0Q2xpY2siLCJnb1RvIiwiTWF0aCIsIm1pbiIsIl9wcmVsb2FkSXRlbSIsIlUiLCJyZXBsYWNlU3JjIiwicmF0aW8iLCJpbml0UmV0aW5hIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInJldGluYSIsImlzTmFOIiwib3JpZ2luYWxFdmVudCIsInRvdWNoZXMiLCJjbGllbnRYIiwiY2xpZW50WSIsImFicyIsIk1haW5OYXYiLCJib2R5T3BlbkNsYXNzIiwibW9iaWxlVG9nZ2xlQWN0aXZlQ2xhc3MiLCIkbmF2IiwibGlzdCIsIiR0b2dnbGUiLCJ0b2dnbGUiLCJjaGVja1RvZ2dsZSIsInN0b3BUb2dnbGUiLCJtYXRjaGVzIiwic3RhcnRUb2dnbGUiLCJjbG9zZU5hdiIsIm9wZW5OYXYiLCJHYWxsZXJ5UGhvdG9Td2lwZUZhY3RvcnkiLCJ0aXRsZUVsIiwiaW5pdFBob3RvU3dpcGVGcm9tRE9NIiwiZ2FsbGVyeVNlbGVjdG9yIiwicGFyc2VUaHVtYm5haWxFbGVtZW50cyIsInRodW1iRWxlbWVudHMiLCJjaGlsZE5vZGVzIiwibnVtTm9kZXMiLCJjaGlsZEVsZW1lbnRzIiwidGh1bWJuYWlsRWwiLCJzaXplIiwiaXRlbSIsIm5vZGVUeXBlIiwibGlua0VsIiwiY2hpbGRyZW4iLCJnZXRBdHRyaWJ1dGUiLCJtc3JjIiwiY2xvc2VzdCIsIm9uVGh1bWJuYWlsc0NsaWNrIiwicmV0dXJuVmFsdWUiLCJlVGFyZ2V0Iiwic3JjRWxlbWVudCIsImNsaWNrZWRMaXN0SXRlbSIsImNsaWNrZWRHYWxsZXJ5IiwibnVtQ2hpbGROb2RlcyIsIm5vZGVJbmRleCIsIm9wZW5QaG90b1N3aXBlIiwicGhvdG9zd2lwZVBhcnNlSGFzaCIsImhhc2giLCJzdWJzdHJpbmciLCJwYXJhbXMiLCJ2YXJzIiwicGFpciIsImdpZCIsImdhbGxlcnlFbGVtZW50IiwiZGlzYWJsZUFuaW1hdGlvbiIsImZyb21VUkwiLCJwc3dwRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmdWxsc2NyZWVuRWwiLCJzaGFyZUVsIiwiZ2FsbGVyeVVJRCIsImdldFRodW1iQm91bmRzRm4iLCJ0aHVtYm5haWwiLCJwYWdlWVNjcm9sbCIsInBhZ2VZT2Zmc2V0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdhbGxlcnlQSURzIiwicGlkIiwic2hvd0FuaW1hdGlvbkR1cmF0aW9uIiwiZ2FsbGVyeUVsZW1lbnRzIiwic2V0QXR0cmlidXRlIiwib25jbGljayIsImhhc2hEYXRhIiwicm9vdCIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJQaG90b1N3aXBlIiwidGVtcGxhdGUiLCJVaUNsYXNzIiwiZnJhbWV3b3JrIiwiZmVhdHVyZXMiLCJsaXN0ZW5lciIsInVuYmluZCIsIm1ldGhvZE5hbWUiLCJvYmoiLCJjcmVhdGVFbCIsImNsYXNzZXMiLCJ0YWciLCJnZXRTY3JvbGxZIiwieU9mZnNldCIsInJlZyIsIlJlZ0V4cCIsImdldENoaWxkQnlDbGFzcyIsInBhcmVudEVsIiwiY2hpbGRDbGFzc05hbWUiLCJub2RlIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwiYXJyYXlTZWFyY2giLCJhcnJheSIsIm8xIiwibzIiLCJwcmV2ZW50T3ZlcndyaXRlIiwicHJvcCIsInNpbmUiLCJvdXQiLCJzaW4iLCJQSSIsImluT3V0IiwiY29zIiwiY3ViaWMiLCJkZXRlY3RGZWF0dXJlcyIsImhlbHBlckVsIiwiaGVscGVyU3R5bGUiLCJ2ZW5kb3IiLCJvbGRJRSIsImFsbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0b3VjaCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJhZiIsImNhZiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicG9pbnRlckV2ZW50IiwicG9pbnRlckVuYWJsZWQiLCJtc1BvaW50ZXJFbmFibGVkIiwidWEiLCJwbGF0Zm9ybSIsIm1hdGNoIiwiaXNPbGRJT1NQaG9uZSIsImFuZHJvaWR2ZXJzaW9uIiwiaXNPbGRBbmRyb2lkIiwiYW5kcm9pZFZlcnNpb24iLCJpc01vYmlsZU9wZXJhIiwic3R5bGVDaGVja3MiLCJ2ZW5kb3JzIiwic3R5bGVDaGVja0l0ZW0iLCJzdHlsZU5hbWUiLCJsYXN0VGltZSIsImN1cnJUaW1lIiwiRGF0ZSIsImdldFRpbWUiLCJ0aW1lVG9DYWxsIiwibWF4Iiwic3ZnIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlU1ZHUmVjdCIsImV2TmFtZSIsIl9oYW5kbGVFdiIsImhhbmRsZUV2ZW50Iiwic2VsZiIsIkRPVUJMRV9UQVBfUkFESVVTIiwiTlVNX0hPTERFUlMiLCJfb3B0aW9ucyIsImFsbG93UGFuVG9OZXh0Iiwic3BhY2luZyIsImJnT3BhY2l0eSIsIm1vdXNlVXNlZCIsImxvb3AiLCJwaW5jaFRvQ2xvc2UiLCJjbG9zZU9uU2Nyb2xsIiwiY2xvc2VPblZlcnRpY2FsRHJhZyIsInZlcnRpY2FsRHJhZ1JhbmdlIiwiaGlkZUFuaW1hdGlvbkR1cmF0aW9uIiwic2hvd0hpZGVPcGFjaXR5IiwiZXNjS2V5IiwiYXJyb3dLZXlzIiwibWFpblNjcm9sbEVuZEZyaWN0aW9uIiwicGFuRW5kRnJpY3Rpb24iLCJpc0NsaWNrYWJsZUVsZW1lbnQiLCJnZXREb3VibGVUYXBab29tIiwiaXNNb3VzZUNsaWNrIiwiaW5pdGlhbFpvb21MZXZlbCIsIm1heFNwcmVhZFpvb20iLCJzY2FsZU1vZGUiLCJfZ2V0RW1wdHlQb2ludCIsIl9pc09wZW4iLCJfaXNEZXN0cm95aW5nIiwiX2Nsb3NlZEJ5U2Nyb2xsIiwiX2N1cnJlbnRJdGVtSW5kZXgiLCJfY29udGFpbmVyU3R5bGUiLCJfY29udGFpbmVyU2hpZnRJbmRleCIsIl9jdXJyUGFuRGlzdCIsIl9zdGFydFBhbk9mZnNldCIsIl9wYW5PZmZzZXQiLCJfdXBNb3ZlRXZlbnRzIiwiX2Rvd25FdmVudHMiLCJfZ2xvYmFsRXZlbnRIYW5kbGVycyIsIl92aWV3cG9ydFNpemUiLCJfY3Vyclpvb21MZXZlbCIsIl9zdGFydFpvb21MZXZlbCIsIl90cmFuc2xhdGVQcmVmaXgiLCJfdHJhbnNsYXRlU3VmaXgiLCJfdXBkYXRlU2l6ZUludGVydmFsIiwiX2l0ZW1zTmVlZFVwZGF0ZSIsIl9jdXJyUG9zaXRpb25JbmRleCIsIl9vZmZzZXQiLCJfc2xpZGVTaXplIiwiX2l0ZW1Ib2xkZXJzIiwiX3ByZXZJdGVtSW5kZXgiLCJfaW5kZXhEaWZmIiwiX2RyYWdTdGFydEV2ZW50IiwiX2RyYWdNb3ZlRXZlbnQiLCJfZHJhZ0VuZEV2ZW50IiwiX2RyYWdDYW5jZWxFdmVudCIsIl90cmFuc2Zvcm1LZXkiLCJfcG9pbnRlckV2ZW50RW5hYmxlZCIsIl9pc0ZpeGVkUG9zaXRpb24iLCJfbGlrZWx5VG91Y2hEZXZpY2UiLCJfbW9kdWxlcyIsIl9yZXF1ZXN0QUYiLCJfY2FuY2VsQUYiLCJfaW5pdGFsQ2xhc3NOYW1lIiwiX2luaXRhbFdpbmRvd1Njcm9sbFkiLCJfb2xkSUUiLCJfY3VycmVudFdpbmRvd1Njcm9sbFkiLCJfZmVhdHVyZXMiLCJfd2luZG93VmlzaWJsZVNpemUiLCJfcmVuZGVyTWF4UmVzb2x1dGlvbiIsIl9yZWdpc3Rlck1vZHVsZSIsInB1YmxpY01ldGhvZHMiLCJfZ2V0TG9vcGVkSWQiLCJudW1TbGlkZXMiLCJfZ2V0TnVtSXRlbXMiLCJfbGlzdGVuZXJzIiwiX2xpc3RlbiIsIl9zaG91dCIsImxpc3RlbmVycyIsInNoaWZ0IiwiX2dldEN1cnJlbnRUaW1lIiwiX2FwcGx5QmdPcGFjaXR5IiwiX2JnT3BhY2l0eSIsImJnIiwiX2FwcGx5Wm9vbVRyYW5zZm9ybSIsInN0eWxlT2JqIiwiZml0UmF0aW8iLCJfYXBwbHlDdXJyZW50Wm9vbVBhbiIsImFsbG93UmVuZGVyUmVzb2x1dGlvbiIsIl9jdXJyWm9vbUVsZW1lbnRTdHlsZSIsIl9zZXRJbWFnZVNpemUiLCJfYXBwbHlab29tUGFuVG9JdGVtIiwiaW5pdGlhbFBvc2l0aW9uIiwiX3NldFRyYW5zbGF0ZVgiLCJlbFN0eWxlIiwiX21vdmVNYWluU2Nyb2xsIiwiZHJhZ2dpbmciLCJuZXdTbGlkZUluZGV4T2Zmc2V0IiwiZGVsdGEiLCJyb3VuZCIsIl9tYWluU2Nyb2xsUG9zIiwiX2NhbGN1bGF0ZVBhbk9mZnNldCIsImF4aXMiLCJ6b29tTGV2ZWwiLCJfbWlkWm9vbVBvaW50IiwiX2VxdWFsaXplUG9pbnRzIiwicDEiLCJwMiIsIl9yb3VuZFBvaW50IiwiX21vdXNlTW92ZVRpbWVvdXQiLCJfb25GaXJzdE1vdXNlTW92ZSIsIl9iaW5kRXZlbnRzIiwic2Nyb2xsV3JhcCIsIl91bmJpbmRFdmVudHMiLCJzY3JvbGwiLCJfaXNEcmFnZ2luZyIsIl9jYWxjdWxhdGVQYW5Cb3VuZHMiLCJ1cGRhdGUiLCJfY2FsY3VsYXRlSXRlbVNpemUiLCJfY3VyclBhbkJvdW5kcyIsIl9nZXRNaW5ab29tTGV2ZWwiLCJfZ2V0TWF4Wm9vbUxldmVsIiwiX21vZGlmeURlc3RQYW5PZmZzZXQiLCJkZXN0UGFuQm91bmRzIiwiZGVzdFBhbk9mZnNldCIsImRlc3Rab29tTGV2ZWwiLCJfc2V0dXBUcmFuc2Zvcm1zIiwiYWxsb3czZFRyYW5zZm9ybSIsInBlcnNwZWN0aXZlIiwiem9vbVJhdGlvIiwiX29uS2V5RG93biIsImtleWRvd25BY3Rpb24iLCJhbHRLZXkiLCJzaGlmdEtleSIsIl9vbkdsb2JhbENsaWNrIiwiX21vdmVkIiwiX3pvb21TdGFydGVkIiwiX21haW5TY3JvbGxBbmltYXRpbmciLCJfdmVydGljYWxEcmFnSW5pdGlhdGVkIiwiX3VwZGF0ZVBhZ2VTY3JvbGxPZmZzZXQiLCJzZXRTY3JvbGxPZmZzZXQiLCJfYW5pbWF0aW9ucyIsIl9udW1BbmltYXRpb25zIiwiX3N0b3BBbmltYXRpb24iLCJfcmVnaXN0ZXJTdGFydEFuaW1hdGlvbiIsIl9zdG9wQWxsQW5pbWF0aW9ucyIsIl9hbmltYXRlUHJvcCIsImVuZFByb3AiLCJlYXNpbmdGbiIsIm9uVXBkYXRlIiwib25Db21wbGV0ZSIsInN0YXJ0QW5pbVRpbWUiLCJhbmltbG9vcCIsInNob3V0IiwibGlzdGVuIiwidmlld3BvcnRTaXplIiwiaXNNYWluU2Nyb2xsQW5pbWF0aW5nIiwiZ2V0Wm9vbUxldmVsIiwiZ2V0Q3VycmVudEluZGV4IiwiaXNEcmFnZ2luZyIsImlzWm9vbWluZyIsIl9pc1pvb21pbmciLCJhcHBseVpvb21QYW4iLCJwYW5YIiwicGFuWSIsIml0ZW1Ib2xkZXJzIiwiZGlzcGxheSIsInJlc2l6ZSIsImtleWRvd24iLCJjbGljayIsIm9sZFBob25lIiwiYW5pbWF0aW9uTmFtZSIsInVpIiwiX2dldEl0ZW1BdCIsInJvb3RDbGFzc2VzIiwic2V0Q29udGVudCIsInVwZGF0ZUN1cnJJdGVtIiwiX3Nob3dPckhpZGUiLCJkZXN0cm95IiwiX3Nob3dPckhpZGVUaW1lb3V0IiwiX3N0b3BEcmFnVXBkYXRlTG9vcCIsImZvcmNlIiwiZGlmZiIsInVwZGF0ZUN1cnJab29tSXRlbSIsImVtdWxhdGVTZXRDb250ZW50Iiwiem9vbUVsZW1lbnQiLCJpbnZhbGlkYXRlQ3Vyckl0ZW1zIiwibmVlZHNVcGRhdGUiLCJiZWZvcmVBbmltYXRpb24iLCJkaWZmQWJzIiwidGVtcEhvbGRlciIsInVuc2hpZnQiLCJwcmV2SXRlbSIsIndpbmRvd1Njcm9sbFkiLCJjbGllbnRIZWlnaHQiLCJob2xkZXIiLCJoSW5kZXgiLCJjbGVhblNsaWRlIiwiem9vbVRvIiwic3BlZWQiLCJ1cGRhdGVGbiIsImluaXRpYWxQYW5PZmZzZXQiLCJub3ciLCJNSU5fU1dJUEVfRElTVEFOQ0UiLCJESVJFQ1RJT05fQ0hFQ0tfT0ZGU0VUIiwiX2dlc3R1cmVTdGFydFRpbWUiLCJfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lIiwiX2N1cnJQb2ludCIsIl9zdGFydFBvaW50IiwiX2N1cnJQb2ludGVycyIsIl9zdGFydE1haW5TY3JvbGxQb3MiLCJfcmVsZWFzZUFuaW1EYXRhIiwiX3Bvc1BvaW50cyIsIl90ZW1wUG9pbnQiLCJfaXNab29taW5nSW4iLCJfb2xkQW5kcm9pZFRvdWNoRW5kVGltZW91dCIsIl9jdXJyWm9vbWVkSXRlbUluZGV4IiwiX2NlbnRlclBvaW50IiwiX2xhc3RSZWxlYXNlVGltZSIsIl9pc011bHRpdG91Y2giLCJfZHJhZ0FuaW1GcmFtZSIsIl9tYWluU2Nyb2xsU2hpZnRlZCIsIl9jdXJyZW50UG9pbnRzIiwiX2N1cnJQb2ludHNEaXN0YW5jZSIsIl9zdGFydFBvaW50c0Rpc3RhbmNlIiwiX2N1cnJDZW50ZXJQb2ludCIsIl9kaXJlY3Rpb24iLCJfaXNGaXJzdE1vdmUiLCJfb3BhY2l0eUNoYW5nZWQiLCJfd2FzT3ZlckluaXRpYWxab29tIiwiX2lzRXF1YWxQb2ludHMiLCJfaXNOZWFyYnlQb2ludHMiLCJ0b3VjaDAiLCJ0b3VjaDEiLCJfY2FsY3VsYXRlUG9pbnRzRGlzdGFuY2UiLCJzcXJ0IiwiX2RyYWdVcGRhdGVMb29wIiwiX3JlbmRlck1vdmVtZW50IiwiX2NhblBhbiIsIl9jbG9zZXN0RWxlbWVudCIsIl9wcmV2ZW50T2JqIiwiX3ByZXZlbnREZWZhdWx0RXZlbnRCZWhhdmlvdXIiLCJpc0Rvd24iLCJwcmV2ZW50IiwiX2NvbnZlcnRUb3VjaFRvUG9pbnQiLCJwYWdlWCIsInBhZ2VZIiwiaWRlbnRpZmllciIsIl9maW5kQ2VudGVyT2ZQb2ludHMiLCJwQ2VudGVyIiwiX3B1c2hQb3NQb2ludCIsInRpbWUiLCJfY2FsY3VsYXRlVmVydGljYWxEcmFnT3BhY2l0eVJhdGlvIiwiX2VQb2ludDEiLCJfZVBvaW50MiIsIl90ZW1wUG9pbnRzQXJyIiwiX3RlbXBDb3VudGVyIiwiX2dldFRvdWNoUG9pbnRzIiwiX3Bhbk9yTW92ZU1haW5TY3JvbGwiLCJwYW5GcmljdGlvbiIsIm92ZXJEaWZmIiwibmV3T2Zmc2V0Iiwic3RhcnRPdmVyRGlmZiIsImRpciIsIm5ld01haW5TY3JvbGxQb3NpdGlvbiIsIm1haW5TY3JvbGxEaWZmIiwibmV3UGFuUG9zIiwibmV3TWFpblNjcm9sbFBvcyIsIl9vbkRyYWdTdGFydCIsImJ1dHRvbiIsIl9pbml0aWFsWm9vbVJ1bm5pbmciLCJwb2ludGVySW5kZXgiLCJwb2ludGVySWQiLCJzdGFydFBvaW50c0xpc3QiLCJudW1Qb2ludHMiLCJfb25EcmFnTW92ZSIsInRvdWNoZXNMaXN0IiwicG9pbnRzRGlzdGFuY2UiLCJfY2FsY3VsYXRlWm9vbUxldmVsIiwiem9vbUZyaWN0aW9uIiwibWluWm9vbUxldmVsIiwibWF4Wm9vbUxldmVsIiwibWludXNEaWZmIiwicGVyY2VudCIsIm9wYWNpdHlSYXRpbyIsIm1haW5TY3JvbGxDaGFuZ2VkIiwiX29uRHJhZ1JlbGVhc2UiLCJyZWxlYXNlUG9pbnQiLCJzcGxpY2UiLCJwb2ludGVyVHlwZSIsIk1TUE9JTlRFUl9UWVBFUyIsInRvdWNoTGlzdCIsImdlc3R1cmVUeXBlIiwiY2hhbmdlZFRvdWNoZXMiLCJyZWxlYXNlVGltZURpZmYiLCJfaW5pdERyYWdSZWxlYXNlQW5pbWF0aW9uRGF0YSIsImNhbGN1bGF0ZVN3aXBlU3BlZWQiLCJpbml0YWxQYW5ZIiwiaW5pdGlhbEJnT3BhY2l0eSIsIml0ZW1DaGFuZ2VkIiwiX2ZpbmlzaFN3aXBlTWFpblNjcm9sbEdlc3R1cmUiLCJfY29tcGxldGVab29tR2VzdHVyZSIsIl9jb21wbGV0ZVBhbkdlc3R1cmUiLCJsYXN0RmxpY2tEdXJhdGlvbiIsInRlbXBSZWxlYXNlUG9zIiwibGFzdEZsaWNrT2Zmc2V0IiwibGFzdEZsaWNrRGlzdCIsImxhc3RGbGlja1NwZWVkIiwic2xvd0Rvd25SYXRpbyIsInNsb3dEb3duUmF0aW9SZXZlcnNlIiwic3BlZWREZWNlbGVyYXRpb25SYXRpbyIsInNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnMiLCJkaXN0YW5jZU9mZnNldCIsImJhY2tBbmltRGVzdGluYXRpb24iLCJiYWNrQW5pbVN0YXJ0ZWQiLCJjYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldCIsInBvcyIsImNhbGN1bGF0ZUFuaW1PZmZzZXQiLCJ0aW1lRGlmZiIsInBhbkFuaW1Mb29wIiwiem9vbVBhbiIsImxhc3ROb3ciLCJhbmltRGF0YSIsIml0ZW1zRGlmZiIsInRvdGFsU2hpZnREaXN0IiwiaXNGYXN0TGFzdEZsaWNrIiwibmV4dENpcmNsZSIsImFuaW1hdGVUb1giLCJhbmltYXRlVG9EaXN0IiwiZmluaXNoQW5pbUR1cmF0aW9uIiwidG91Y2hlc0Rpc3RhbmNlIiwiZGVzdE9wYWNpdHkiLCJpbml0aWFsT3BhY2l0eSIsImluaXRHZXN0dXJlcyIsImFkZEV2ZW50TmFtZXMiLCJwcmVmIiwiZG93biIsIm1vdmUiLCJ1cCIsImNhbmNlbCIsIm1heFRvdWNoUG9pbnRzIiwibXNNYXhUb3VjaFBvaW50cyIsImxpa2VseVRvdWNoRGV2aWNlIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsImNvbXBsZXRlRm4iLCJfaW5pdGlhbENvbnRlbnRTZXQiLCJ0aHVtYkJvdW5kcyIsImluaXRpYWxMYXlvdXQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzdGFydEFuaW1hdGlvbiIsImNsb3NlV2l0aFJhZiIsImZhZGVFdmVyeXRoaW5nIiwibWluaUltZyIsIndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSIsImluaXRhbEJnT3BhY2l0eSIsIl9pdGVtcyIsIl90ZW1wUGFuQXJlYVNpemUiLCJfaW1hZ2VzVG9BcHBlbmRQb29sIiwiX2NvbnRyb2xsZXJEZWZhdWx0T3B0aW9ucyIsImVycm9yTXNnIiwiZm9yY2VQcm9ncmVzc2l2ZUxvYWRpbmciLCJnZXROdW1JdGVtc0ZuIiwiX2luaXRpYWxJc0xvb3AiLCJfZ2V0WmVyb0JvdW5kcyIsIl9jYWxjdWxhdGVTaW5nbGVJdGVtUGFuQm91bmRzIiwicmVhbFBhbkVsZW1lbnRXIiwicmVhbFBhbkVsZW1lbnRIIiwidkdhcCIsImlzSW5pdGlhbCIsImJvdHRvbSIsImhSYXRpbyIsInZSYXRpbyIsIl9hcHBlbmRJbWFnZSIsImJhc2VEaXYiLCJwcmV2ZW50QW5pbWF0aW9uIiwia2VlcFBsYWNlaG9sZGVyIiwiaW1hZ2VBcHBlbmRlZCIsInBsYWNlaG9sZGVyIiwiX3ByZWxvYWRJbWFnZSIsImxvYWRDb21wbGV0ZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJfY2hlY2tGb3JFcnJvciIsImNsZWFuVXAiLCJtYXhSZXMiLCJsYXN0Q2hpbGQiLCJfYXBwZW5kSW1hZ2VzUG9vbCIsInBvb2xJdGVtIiwiY2xlYXJQbGFjZWhvbGRlciIsImxhenlMb2FkSXRlbSIsImluaXRDb250cm9sbGVyIiwiZ2V0SXRlbUF0IiwiaXNOZXh0IiwicHJlbG9hZEJlZm9yZSIsInByZWxvYWRBZnRlciIsImFsbG93UHJvZ3Jlc3NpdmVJbWciLCJzY3JlZW4iLCJwbGFjZWhvbGRlckNsYXNzTmFtZSIsInRhcFRpbWVyIiwidGFwUmVsZWFzZVBvaW50IiwiX2Rpc3BhdGNoVGFwRXZlbnQiLCJvcmlnRXZlbnQiLCJjcmVhdGVFdmVudCIsImVEZXRhaWwiLCJpbml0Q3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiaW5pdFRhcCIsIm9uVGFwU3RhcnQiLCJvblRhcFJlbGVhc2UiLCJwMCIsImNsaWNrZWRUYWdOYW1lIiwiX3doZWVsRGVsdGEiLCJpbml0RGVza3RvcFpvb20iLCJzZXR1cERlc2t0b3Bab29tIiwib25Jbml0IiwiZXZlbnRzIiwiaGFuZGxlTW91c2VXaGVlbCIsIm1vdXNlWm9vbWVkSW4iLCJoYXNEcmFnZ2luZ0NsYXNzIiwidXBkYXRlWm9vbWFibGUiLCJyZW1vdmVEcmFnZ2luZ0NsYXNzIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwiZGVsdGFYIiwid2hlZWxEZWx0YVgiLCJ3aGVlbERlbHRhWSIsIndoZWVsRGVsdGEiLCJkZXRhaWwiLCJuZXdQYW5YIiwibmV3UGFuWSIsInRvZ2dsZURlc2t0b3Bab29tIiwiZG91YmxlVGFwWm9vbUxldmVsIiwiem9vbU91dCIsIl9oaXN0b3J5RGVmYXVsdE9wdGlvbnMiLCJoaXN0b3J5IiwiX2hpc3RvcnlVcGRhdGVUaW1lb3V0IiwiX2hhc2hDaGFuZ2VUaW1lb3V0IiwiX2hhc2hBbmltQ2hlY2tUaW1lb3V0IiwiX2hhc2hDaGFuZ2VkQnlTY3JpcHQiLCJfaGFzaENoYW5nZWRCeUhpc3RvcnkiLCJfaGFzaFJlc2V0ZWQiLCJfaW5pdGlhbEhhc2giLCJfaGlzdG9yeUNoYW5nZWQiLCJfY2xvc2VkRnJvbVVSTCIsIl91cmxDaGFuZ2VkT25jZSIsIl93aW5kb3dMb2MiLCJfc3VwcG9ydHNQdXNoU3RhdGUiLCJfZ2V0SGFzaCIsIl9jbGVhbkhpc3RvcnlUaW1lb3V0cyIsIl9wYXJzZUl0ZW1JbmRleEZyb21VUkwiLCJzZWFyY2hmb3IiLCJfdXBkYXRlSGFzaCIsIm5ld0hhc2giLCJuZXdVUkwiLCJpbml0SGlzdG9yeSIsInVwZGF0ZVVSTCIsIm9uSGFzaENoYW5nZSIsInJldHVyblRvT3JpZ2luYWwiLCJiYWNrIiwicHVzaFN0YXRlIiwicGF0aG5hbWUiLCJzZWFyY2giLCJTaGFyZSIsImFuaW1hdGluZ0NsYXNzIiwidmVsb2NpdHlDb25maWciLCJoYW5kZUJ1dHRvbkNsaWNrIiwidG9nZ2xlTGlzdCIsIiRsaXN0IiwiJGJ1dHRvbiIsIlZlbG9jaXR5IiwiaG9vayIsImhpZGVMaXN0Iiwic2hvd0xpc3QiLCJTdWJOYXYiLCJzdWJuYXZDb250ZW50cyIsInNldFRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uSW4iLCJ0cmFuc2l0aW9uT3V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O2tCQU13QkEsZTs7QUFOeEI7Ozs7OztBQUVBLElBQU1DLDRCQUE0QixTQUE1QkEseUJBQTRCO0FBQUEsa0NBQTRCQyxJQUE1QjtBQUFBLENBQWxDO0FBQ0EsSUFBTUMsa0JBQWtCLGdCQUF4QjtBQUNBLElBQU1DLG9CQUFvQixrQkFBMUI7O0FBRWUsU0FBU0osZUFBVCxDQUF5QkssTUFBekIsRUFBZ0Q7QUFBQSxRQUFmQyxLQUFlLHVFQUFQLEtBQU87O0FBQzNELFFBQU1DLFdBQVdDLEVBQUVDLElBQUYsQ0FBT0osTUFBUCxNQUFtQixRQUFuQixHQUNYSiwwQkFBMEJJLE1BQTFCLENBRFcsR0FFWCxLQUZOOztBQUlBLFFBQUlLLG1CQUFKO0FBQ0EsUUFBSUMsaUJBQUo7O0FBRUEsUUFBTUMsT0FBTyxTQUFQQSxJQUFPLEdBQU07QUFDZixZQUFJUCxrQkFBa0JRLE1BQXRCLEVBQThCO0FBQzFCSCx5QkFBYUwsTUFBYjtBQUNILFNBRkQsTUFFTztBQUNISyx5QkFBYUgsV0FBV0MsRUFBRUQsUUFBRixDQUFYLEdBQXlCQyxFQUFFSCxNQUFGLENBQXRDO0FBQ0g7O0FBRURL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Q0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdB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STtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RCxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxvRUFBb0U7QUFDOUU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWUsR0FBRyxlQUFlO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixFQUFFLEVBQUUsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxJQUFJO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxxREFBcUQsbUJBQW1CO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxPQUFPO0FBQ1AsNEZBQTRGO0FBQzVGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsOERBQThEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0g7O0FBRWhIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdGQUF3RjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RkFBd0Y7O0FBRXhGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQSxzSkFB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QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsMkNBQTJDO0FBQ3RFO0FBQ0EseUJBQXlCLGdFQUFnRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSx1S0FBdUs7QUFDdkssMEtBQTBLO0FBQzFLLDZJQUE2STs7QUFFN0k7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1Rzs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnREFBZ0QsVUFBVTtBQUMxRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGdCQUFnQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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O0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTs7QUFFL0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0g7QUFMa0MsYUFBdkM7QUFRSDs7Ozs7O2tCQTFFZ0J5b0MsTTs7Ozs7OztBQ05yQix5Qzs7Ozs7O0FDQUEseUMiLCJmaWxlIjoiL2pzL2J1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjYW1lbENhc2UgZnJvbSAnbG9kYXNoL2NhbWVsQ2FzZSdcblxuY29uc3QgY29tcG9uZW50U2VsZWN0b3JUZW1wbGF0ZSA9IG5hbWUgPT4gYFtkYXRhLWNvbXBvbmVudD0nJHtuYW1lfSddYFxuY29uc3QgZWxlbWVudFNlbGVjdG9yID0gJ1tkYXRhLWVsZW1lbnRdJ1xuY29uc3QgY29tcG9uZW50U2VsZWN0b3IgPSAnW2RhdGEtY29tcG9uZW50XSdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VsZWN0Q29tcG9uZW50KHRhcmdldCwgZGVidWcgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gJC50eXBlKHRhcmdldCkgPT09ICdzdHJpbmcnXG4gICAgICAgID8gY29tcG9uZW50U2VsZWN0b3JUZW1wbGF0ZSh0YXJnZXQpXG4gICAgICAgIDogZmFsc2VcbiAgICAgICAgXG4gICAgbGV0ICRjb21wb25lbnRcbiAgICBsZXQgZWxlbWVudHNcblxuICAgIGNvbnN0IGluaXQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBqUXVlcnkpIHtcbiAgICAgICAgICAgICRjb21wb25lbnQgPSB0YXJnZXRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRjb21wb25lbnQgPSBzZWxlY3RvciA/ICQoc2VsZWN0b3IpIDogJCh0YXJnZXQpXG4gICAgICAgIH1cblxuICAgICAgICAkY29tcG9uZW50LmVsZW1lbnRzID0gYnVpbGRFbGVtZW50cygkY29tcG9uZW50KVxuICAgICAgICAkY29tcG9uZW50LnJlZnJlc2ggPSByZWZyZXNoXG4gICAgICAgICRjb21wb25lbnQuc2VsZWN0b3IgPSBzZWxlY3RvclxuICAgIH1cblxuICAgIGNvbnN0IGJ1aWxkRWxlbWVudHMgPSBjb21wb25lbnQgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50TWFwID0ge31cbiAgICAgICAgbGV0ICRlbGVtZW50cyA9IGNvbXBvbmVudC5maW5kKGVsZW1lbnRTZWxlY3RvcilcblxuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPcmlnaW5hbCBlbGVtZW50cycsICRlbGVtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgJGV4Y2x1ZGVkRWxlbWVudHMgPSAkZWxlbWVudHMuZmlsdGVyKChpbmRleCwgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKGVsZW1lbnQpLnBhcmVudHNVbnRpbCgkY29tcG9uZW50KS5maWx0ZXIoY29tcG9uZW50U2VsZWN0b3IpLmxlbmd0aFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgJGVsZW1lbnRzID0gJGVsZW1lbnRzLm5vdCgkZXhjbHVkZWRFbGVtZW50cylcblxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbHRlcmVkIGVsZW1lbnRzJywgJGVsZW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGVsZW1lbnRzLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgJGVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudE5hbWUgPSBjYW1lbENhc2UoJGVsZW1lbnQuZGF0YSgnZWxlbWVudCcpKVxuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRNYXAuaGFzT3duUHJvcGVydHkoZWxlbWVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNYXBbZWxlbWVudE5hbWVdID0gZWxlbWVudE1hcFtlbGVtZW50TmFtZV0uYWRkKCRlbGVtZW50KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNYXBbZWxlbWVudE5hbWVdID0gJGVsZW1lbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudE1hcFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgY29uc3QgcmVmcmVzaCA9IGRlYnVnU2V0dGluZyA9PiB7XG4gICAgICAgIGRlYnVnID0gZGVidWdTZXR0aW5nXG4gICAgICAgICRjb21wb25lbnQuZWxlbWVudHMgPSBidWlsZEVsZW1lbnRzKCRjb21wb25lbnQpXG4gICAgfVxuXG4gICAgaW5pdCgpXG5cbiAgICByZXR1cm4gJGNvbXBvbmVudFxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvdXRpbGl0aWVzL3NlbGVjdC1jb21wb25lbnQuanMiLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyohIFZlbG9jaXR5SlMub3JnICgxLjUuMCkuIChDKSAyMDE0IEp1bGlhbiBTaGFwaXJvLiBNSVQgQGxpY2Vuc2U6IGVuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZSAqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKlxuIFZlbG9jaXR5IGpRdWVyeSBTaGltXG4gKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyohIFZlbG9jaXR5SlMub3JnIGpRdWVyeSBTaGltICgxLjAuMSkuIChDKSAyMDE0IFRoZSBqUXVlcnkgRm91bmRhdGlvbi4gTUlUIEBsaWNlbnNlOiBlbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UuICovXG5cbi8qIFRoaXMgZmlsZSBjb250YWlucyB0aGUgalF1ZXJ5IGZ1bmN0aW9ucyB0aGF0IFZlbG9jaXR5IHJlbGllcyBvbiwgdGhlcmVieSByZW1vdmluZyBWZWxvY2l0eSdzIGRlcGVuZGVuY3kgb24gYSBmdWxsIGNvcHkgb2YgalF1ZXJ5LCBhbmQgYWxsb3dpbmcgaXQgdG8gd29yayBpbiBhbnkgZW52aXJvbm1lbnQuICovXG4vKiBUaGVzZSBzaGltbWVkIGZ1bmN0aW9ucyBhcmUgb25seSB1c2VkIGlmIGpRdWVyeSBpc24ndCBwcmVzZW50LiBJZiBib3RoIHRoaXMgc2hpbSBhbmQgalF1ZXJ5IGFyZSBsb2FkZWQsIFZlbG9jaXR5IGRlZmF1bHRzIHRvIGpRdWVyeSBwcm9wZXIuICovXG4vKiBCcm93c2VyIHN1cHBvcnQ6IFVzaW5nIHRoaXMgc2hpbSBpbnN0ZWFkIG9mIGpRdWVyeSBwcm9wZXIgcmVtb3ZlcyBzdXBwb3J0IGZvciBJRTguICovXG5cbihmdW5jdGlvbih3aW5kb3cpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKioqKioqKioqKioqKipcblx0IFNldHVwXG5cdCAqKioqKioqKioqKioqKiovXG5cblx0LyogSWYgalF1ZXJ5IGlzIGFscmVhZHkgbG9hZGVkLCB0aGVyZSdzIG5vIHBvaW50IGluIGxvYWRpbmcgdGhpcyBzaGltLiAqL1xuXHRpZiAod2luZG93LmpRdWVyeSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8qIGpRdWVyeSBiYXNlLiAqL1xuXHR2YXIgJCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KSB7XG5cdFx0cmV0dXJuIG5ldyAkLmZuLmluaXQoc2VsZWN0b3IsIGNvbnRleHQpO1xuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKlxuXHQgUHJpdmF0ZSBNZXRob2RzXG5cdCAqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvKiBqUXVlcnkgKi9cblx0JC5pc1dpbmRvdyA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdC8qIGpzaGludCBlcWVxZXE6IGZhbHNlICovXG5cdFx0cmV0dXJuIG9iaiAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblx0LyogalF1ZXJ5ICovXG5cdCQudHlwZSA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdGlmICghb2JqKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0XHRjbGFzczJ0eXBlW3RvU3RyaW5nLmNhbGwob2JqKV0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHRcdHR5cGVvZiBvYmo7XG5cdH07XG5cblx0LyogalF1ZXJ5ICovXG5cdCQuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG5cdFx0cmV0dXJuICQudHlwZShvYmopID09PSBcImFycmF5XCI7XG5cdH07XG5cblx0LyogalF1ZXJ5ICovXG5cdGZ1bmN0aW9uIGlzQXJyYXlsaWtlKG9iaikge1xuXHRcdHZhciBsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdFx0XHR0eXBlID0gJC50eXBlKG9iaik7XG5cblx0XHRpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8ICQuaXNXaW5kb3cob2JqKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChvYmoubm9kZVR5cGUgPT09IDEgJiYgbGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKGxlbmd0aCAtIDEpIGluIG9iajtcblx0fVxuXG5cdC8qKioqKioqKioqKioqKipcblx0ICQgTWV0aG9kc1xuXHQgKioqKioqKioqKioqKioqL1xuXG5cdC8qIGpRdWVyeTogU3VwcG9ydCByZW1vdmVkIGZvciBJRTw5LiAqL1xuXHQkLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0aWYgKCFvYmogfHwgJC50eXBlKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8ICQuaXNXaW5kb3cob2JqKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAob2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdFx0IWhhc093bi5jYWxsKG9iaiwgXCJjb25zdHJ1Y3RvclwiKSAmJlxuXHRcdFx0XHRcdCFoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIikpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiBvYmopIHtcblx0XHR9XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgaGFzT3duLmNhbGwob2JqLCBrZXkpO1xuXHR9O1xuXG5cdC8qIGpRdWVyeSAqL1xuXHQkLmVhY2ggPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrLCBhcmdzKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aCxcblx0XHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKG9iaik7XG5cblx0XHRpZiAoYXJncykge1xuXHRcdFx0aWYgKGlzQXJyYXkpIHtcblx0XHRcdFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkob2JqW2ldLCBhcmdzKTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpIGluIG9iaikge1xuXHRcdFx0XHRcdGlmICghb2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseShvYmpbaV0sIGFyZ3MpO1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGlzQXJyYXkpIHtcblx0XHRcdFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSk7XG5cblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoaSBpbiBvYmopIHtcblx0XHRcdFx0XHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSk7XG5cblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9O1xuXG5cdC8qIEN1c3RvbSAqL1xuXHQkLmRhdGEgPSBmdW5jdGlvbihub2RlLCBrZXksIHZhbHVlKSB7XG5cdFx0LyogJC5nZXREYXRhKCkgKi9cblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIGdldElkID0gbm9kZVskLmV4cGFuZG9dLFxuXHRcdFx0XHRcdHN0b3JlID0gZ2V0SWQgJiYgY2FjaGVbZ2V0SWRdO1xuXG5cdFx0XHRpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHN0b3JlO1xuXHRcdFx0fSBlbHNlIGlmIChzdG9yZSkge1xuXHRcdFx0XHRpZiAoa2V5IGluIHN0b3JlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0b3JlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8qICQuc2V0RGF0YSgpICovXG5cdFx0fSBlbHNlIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIHNldElkID0gbm9kZVskLmV4cGFuZG9dIHx8IChub2RlWyQuZXhwYW5kb10gPSArKyQudXVpZCk7XG5cblx0XHRcdGNhY2hlW3NldElkXSA9IGNhY2hlW3NldElkXSB8fCB7fTtcblx0XHRcdGNhY2hlW3NldElkXVtrZXldID0gdmFsdWU7XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH07XG5cblx0LyogQ3VzdG9tICovXG5cdCQucmVtb3ZlRGF0YSA9IGZ1bmN0aW9uKG5vZGUsIGtleXMpIHtcblx0XHR2YXIgaWQgPSBub2RlWyQuZXhwYW5kb10sXG5cdFx0XHRcdHN0b3JlID0gaWQgJiYgY2FjaGVbaWRdO1xuXG5cdFx0aWYgKHN0b3JlKSB7XG5cdFx0XHQvLyBDbGVhbnVwIHRoZSBlbnRpcmUgc3RvcmUgaWYgbm8ga2V5cyBhcmUgcHJvdmlkZWQuXG5cdFx0XHRpZiAoIWtleXMpIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlW2lkXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQuZWFjaChrZXlzLCBmdW5jdGlvbihfLCBrZXkpIHtcblx0XHRcdFx0XHRkZWxldGUgc3RvcmVba2V5XTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qIGpRdWVyeSAqL1xuXHQkLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzcmMsIGNvcHlJc0FycmF5LCBjb3B5LCBuYW1lLCBvcHRpb25zLCBjbG9uZSxcblx0XHRcdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMSxcblx0XHRcdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdFx0aWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0XHR0YXJnZXQgPSBhcmd1bWVudHNbaV0gfHwge307XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgJC50eXBlKHRhcmdldCkgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dGFyZ2V0ID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKGkgPT09IGxlbmd0aCkge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRcdGktLTtcblx0XHR9XG5cblx0XHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0W25hbWVdO1xuXHRcdFx0XHRcdGNvcHkgPSBvcHRpb25zW25hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKHRhcmdldCA9PT0gY29weSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGRlZXAgJiYgY29weSAmJiAoJC5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9ICQuaXNBcnJheShjb3B5KSkpKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29weUlzQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgJC5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgJC5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGFyZ2V0W25hbWVdID0gJC5leHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IGNvcHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKiBqUXVlcnkgMS40LjMgKi9cblx0JC5xdWV1ZSA9IGZ1bmN0aW9uKGVsZW0sIHR5cGUsIGRhdGEpIHtcblx0XHRmdW5jdGlvbiAkbWFrZUFycmF5KGFyciwgcmVzdWx0cykge1xuXHRcdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRcdGlmIChhcnIpIHtcblx0XHRcdFx0aWYgKGlzQXJyYXlsaWtlKE9iamVjdChhcnIpKSkge1xuXHRcdFx0XHRcdC8qICQubWVyZ2UgKi9cblx0XHRcdFx0XHQoZnVuY3Rpb24oZmlyc3QsIHNlY29uZCkge1xuXHRcdFx0XHRcdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRcdGogPSAwLFxuXHRcdFx0XHRcdFx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdHdoaWxlIChqIDwgbGVuKSB7XG5cdFx0XHRcdFx0XHRcdGZpcnN0W2krK10gPSBzZWNvbmRbaisrXTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGxlbiAhPT0gbGVuKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlIChzZWNvbmRbal0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdGZpcnN0W2krK10gPSBzZWNvbmRbaisrXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmlyc3Q7XG5cdFx0XHRcdFx0fSkocmV0LCB0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID8gW2Fycl0gOiBhcnIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFtdLnB1c2guY2FsbChyZXQsIGFycik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRpZiAoIWVsZW0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0eXBlID0gKHR5cGUgfHwgXCJmeFwiKSArIFwicXVldWVcIjtcblxuXHRcdHZhciBxID0gJC5kYXRhKGVsZW0sIHR5cGUpO1xuXG5cdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRyZXR1cm4gcSB8fCBbXTtcblx0XHR9XG5cblx0XHRpZiAoIXEgfHwgJC5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRxID0gJC5kYXRhKGVsZW0sIHR5cGUsICRtYWtlQXJyYXkoZGF0YSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRxLnB1c2goZGF0YSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHE7XG5cdH07XG5cblx0LyogalF1ZXJ5IDEuNC4zICovXG5cdCQuZGVxdWV1ZSA9IGZ1bmN0aW9uKGVsZW1zLCB0eXBlKSB7XG5cdFx0LyogQ3VzdG9tOiBFbWJlZCBlbGVtZW50IGl0ZXJhdGlvbi4gKi9cblx0XHQkLmVhY2goZWxlbXMubm9kZVR5cGUgPyBbZWxlbXNdIDogZWxlbXMsIGZ1bmN0aW9uKGksIGVsZW0pIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdFx0dmFyIHF1ZXVlID0gJC5xdWV1ZShlbGVtLCB0eXBlKSxcblx0XHRcdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cblx0XHRcdGlmIChmbiA9PT0gXCJpbnByb2dyZXNzXCIpIHtcblx0XHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZm4pIHtcblx0XHRcdFx0aWYgKHR5cGUgPT09IFwiZnhcIikge1xuXHRcdFx0XHRcdHF1ZXVlLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm4uY2FsbChlbGVtLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRlcXVldWUoZWxlbSwgdHlwZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKipcblx0ICQuZm4gTWV0aG9kc1xuXHQgKioqKioqKioqKioqKioqKioqL1xuXG5cdC8qIGpRdWVyeSAqL1xuXHQkLmZuID0gJC5wcm90b3R5cGUgPSB7XG5cdFx0aW5pdDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRcdC8qIEp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IHdyYXBwZWQgaW5zaWRlIGFuIGFycmF5OyBkb24ndCBwcm9jZWVkIHdpdGggdGhlIGFjdHVhbCBqUXVlcnkgbm9kZSB3cmFwcGluZyBwcm9jZXNzLiAqL1xuXHRcdFx0aWYgKHNlbGVjdG9yLm5vZGVUeXBlKSB7XG5cdFx0XHRcdHRoaXNbMF0gPSBzZWxlY3RvcjtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBhIERPTSBub2RlLlwiKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvKiBqUXVlcnkgYWx0ZXJlZCBjb2RlOiBEcm9wcGVkIGRpc2Nvbm5lY3RlZCBET00gbm9kZSBjaGVja2luZy4gKi9cblx0XHRcdHZhciBib3ggPSB0aGlzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IHRoaXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7dG9wOiAwLCBsZWZ0OiAwfTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiBib3gudG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jdW1lbnQuY2xpZW50VG9wIHx8IDApLFxuXHRcdFx0XHRsZWZ0OiBib3gubGVmdCArICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2N1bWVudC5jbGllbnRMZWZ0IHx8IDApXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0LyogalF1ZXJ5ICovXG5cdFx0XHRmdW5jdGlvbiBvZmZzZXRQYXJlbnRGbihlbGVtKSB7XG5cdFx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudDtcblxuXHRcdFx0XHR3aGlsZSAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImh0bWxcIiAmJiBvZmZzZXRQYXJlbnQuc3R5bGUgJiYgb2Zmc2V0UGFyZW50LnN0eWxlLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSB7XG5cdFx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8qIFplcHRvICovXG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbMF0sXG5cdFx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Rm4oZWxlbSksXG5cdFx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKSxcblx0XHRcdFx0XHRwYXJlbnRPZmZzZXQgPSAvXig/OmJvZHl8aHRtbCkkL2kudGVzdChvZmZzZXRQYXJlbnQubm9kZU5hbWUpID8ge3RvcDogMCwgbGVmdDogMH0gOiAkKG9mZnNldFBhcmVudCkub2Zmc2V0KCk7XG5cblx0XHRcdG9mZnNldC50b3AgLT0gcGFyc2VGbG9hdChlbGVtLnN0eWxlLm1hcmdpblRvcCkgfHwgMDtcblx0XHRcdG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoZWxlbS5zdHlsZS5tYXJnaW5MZWZ0KSB8fCAwO1xuXG5cdFx0XHRpZiAob2Zmc2V0UGFyZW50LnN0eWxlKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0gcGFyc2VGbG9hdChvZmZzZXRQYXJlbnQuc3R5bGUuYm9yZGVyVG9wV2lkdGgpIHx8IDA7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQob2Zmc2V0UGFyZW50LnN0eWxlLmJvcmRlckxlZnRXaWR0aCkgfHwgMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCxcblx0XHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdFxuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKipcblx0IFByaXZhdGUgVmFyaWFibGVzXG5cdCAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdC8qIEZvciAkLmRhdGEoKSAqL1xuXHR2YXIgY2FjaGUgPSB7fTtcblx0JC5leHBhbmRvID0gXCJ2ZWxvY2l0eVwiICsgKG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblx0JC51dWlkID0gMDtcblxuXHQvKiBGb3IgJC5xdWV1ZSgpICovXG5cdHZhciBjbGFzczJ0eXBlID0ge30sXG5cdFx0XHRoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5LFxuXHRcdFx0dG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG5cdHZhciB0eXBlcyA9IFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdGNsYXNzMnR5cGVbXCJbb2JqZWN0IFwiICsgdHlwZXNbaV0gKyBcIl1cIl0gPSB0eXBlc1tpXS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cblx0LyogTWFrZXMgJChub2RlKSBwb3NzaWJsZSwgd2l0aG91dCBoYXZpbmcgdG8gY2FsbCBpbml0LiAqL1xuXHQkLmZuLmluaXQucHJvdG90eXBlID0gJC5mbjtcblxuXHQvKiBHbG9iYWxpemUgVmVsb2NpdHkgb250byB0aGUgd2luZG93LCBhbmQgYXNzaWduIGl0cyBVdGlsaXRpZXMgcHJvcGVydHkuICovXG5cdHdpbmRvdy5WZWxvY2l0eSA9IHtVdGlsaXRpZXM6ICR9O1xufSkod2luZG93KTtcblxuLyoqKioqKioqKioqKioqKioqKlxuIFZlbG9jaXR5LmpzXG4gKioqKioqKioqKioqKioqKioqL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0LyogQ29tbW9uSlMgbW9kdWxlLiAqL1xuXHRpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0XHQvKiBBTUQgbW9kdWxlLiAqL1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHRcdC8qIEJyb3dzZXIgZ2xvYmFscy4gKi9cblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRyZXR1cm4gZnVuY3Rpb24oZ2xvYmFsLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuXHRcdC8qKioqKioqKioqKioqKipcblx0XHQgU3VtbWFyeVxuXHRcdCAqKioqKioqKioqKioqKiovXG5cblx0XHQvKlxuXHRcdCAtIENTUzogQ1NTIHN0YWNrIHRoYXQgd29ya3MgaW5kZXBlbmRlbnRseSBmcm9tIHRoZSByZXN0IG9mIFZlbG9jaXR5LlxuXHRcdCAtIGFuaW1hdGUoKTogQ29yZSBhbmltYXRpb24gbWV0aG9kIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgdGFyZ2V0ZWQgZWxlbWVudHMgYW5kIHF1ZXVlcyB0aGUgaW5jb21pbmcgY2FsbCBvbnRvIGVhY2ggZWxlbWVudCBpbmRpdmlkdWFsbHkuXG5cdFx0IC0gUHJlLVF1ZXVlaW5nOiBQcmVwYXJlIHRoZSBlbGVtZW50IGZvciBhbmltYXRpb24gYnkgaW5zdGFudGlhdGluZyBpdHMgZGF0YSBjYWNoZSBhbmQgcHJvY2Vzc2luZyB0aGUgY2FsbCdzIG9wdGlvbnMuXG5cdFx0IC0gUXVldWVpbmc6IFRoZSBsb2dpYyB0aGF0IHJ1bnMgb25jZSB0aGUgY2FsbCBoYXMgcmVhY2hlZCBpdHMgcG9pbnQgb2YgZXhlY3V0aW9uIGluIHRoZSBlbGVtZW50J3MgJC5xdWV1ZSgpIHN0YWNrLlxuXHRcdCBNb3N0IGxvZ2ljIGlzIHBsYWNlZCBoZXJlIHRvIGF2b2lkIHJpc2tpbmcgaXQgYmVjb21pbmcgc3RhbGUgKGlmIHRoZSBlbGVtZW50J3MgcHJvcGVydGllcyBoYXZlIGNoYW5nZWQpLlxuXHRcdCAtIFB1c2hpbmc6IENvbnNvbGlkYXRpb24gb2YgdGhlIHR3ZWVuIGRhdGEgZm9sbG93ZWQgYnkgaXRzIHB1c2ggb250byB0aGUgZ2xvYmFsIGluLXByb2dyZXNzIGNhbGxzIGNvbnRhaW5lci5cblx0XHQgLSB0aWNrKCk6IFRoZSBzaW5nbGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AgcmVzcG9uc2libGUgZm9yIHR3ZWVuaW5nIGFsbCBpbi1wcm9ncmVzcyBjYWxscy5cblx0XHQgLSBjb21wbGV0ZUNhbGwoKTogSGFuZGxlcyB0aGUgY2xlYW51cCBwcm9jZXNzIGZvciBlYWNoIFZlbG9jaXR5IGNhbGwuXG5cdFx0ICovXG5cblx0XHQvKioqKioqKioqKioqKioqKioqKioqXG5cdFx0IEhlbHBlciBGdW5jdGlvbnNcblx0XHQgKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogSUUgZGV0ZWN0aW9uLiBHaXN0OiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qdWxpYW5zaGFwaXJvLzkwOTg2MDkgKi9cblx0XHR2YXIgSUUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gNzsgaSA+IDQ7IGktLSkge1xuXHRcdFx0XHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdFx0XHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiPCEtLVtpZiBJRSBcIiArIGkgKyBcIl0+PHNwYW4+PC9zcGFuPjwhW2VuZGlmXS0tPlwiO1xuXG5cdFx0XHRcdFx0aWYgKGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNwYW5cIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkaXYgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9KSgpO1xuXG5cdFx0LyogckFGIHNoaW0uIEdpc3Q6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2p1bGlhbnNoYXBpcm8vOTQ5NzUxMyAqL1xuXHRcdHZhciByQUZTaGltID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRpbWVMYXN0ID0gMDtcblxuXHRcdFx0cmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgdGltZUN1cnJlbnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuXHRcdFx0XHRcdFx0dGltZURlbHRhO1xuXG5cdFx0XHRcdC8qIER5bmFtaWNhbGx5IHNldCBkZWxheSBvbiBhIHBlci10aWNrIGJhc2lzIHRvIG1hdGNoIDYwZnBzLiAqL1xuXHRcdFx0XHQvKiBUZWNobmlxdWUgYnkgRXJpayBNb2xsZXIuIE1JVCBsaWNlbnNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MSAqL1xuXHRcdFx0XHR0aW1lRGVsdGEgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lQ3VycmVudCAtIHRpbWVMYXN0KSk7XG5cdFx0XHRcdHRpbWVMYXN0ID0gdGltZUN1cnJlbnQgKyB0aW1lRGVsdGE7XG5cblx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sodGltZUN1cnJlbnQgKyB0aW1lRGVsdGEpO1xuXHRcdFx0XHR9LCB0aW1lRGVsdGEpO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXG5cdFx0dmFyIHBlcmZvcm1hbmNlID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwge307XG5cblx0XHRcdGlmICh0eXBlb2YgcGVyZi5ub3cgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2YXIgbm93T2Zmc2V0ID0gcGVyZi50aW1pbmcgJiYgcGVyZi50aW1pbmcubmF2aWdhdGlvblN0YXJ0ID8gcGVyZi50aW1pbmcubmF2aWdhdGlvblN0YXJ0IDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHRwZXJmLm5vdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gbm93T2Zmc2V0O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBlcmY7XG5cdFx0fSkoKTtcblxuXHRcdC8qIEFycmF5IGNvbXBhY3RpbmcuIENvcHlyaWdodCBMby1EYXNoLiBNSVQgTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHQgKi9cblx0XHRmdW5jdGlvbiBjb21wYWN0U3BhcnNlQXJyYXkoYXJyYXkpIHtcblx0XHRcdHZhciBpbmRleCA9IC0xLFxuXHRcdFx0XHRcdGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcblx0XHRcdFx0XHRyZXN1bHQgPSBbXTtcblxuXHRcdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG5cdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFNoaW0gZm9yIFwiZml4aW5nXCIgSUUncyBsYWNrIG9mIHN1cHBvcnQgKElFIDwgOSkgZm9yIGFwcGx5aW5nIHNsaWNlXG5cdFx0ICogb24gaG9zdCBvYmplY3RzIGxpa2UgTmFtZWROb2RlTWFwLCBOb2RlTGlzdCwgYW5kIEhUTUxDb2xsZWN0aW9uXG5cdFx0ICogKHRlY2huaWNhbGx5LCBzaW5jZSBob3N0IG9iamVjdHMgaGF2ZSBiZWVuIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudCxcblx0XHQgKiBhdCBsZWFzdCBiZWZvcmUgRVMyMDE1LCBJRSBoYXNuJ3QgbmVlZGVkIHRvIHdvcmsgdGhpcyB3YXkpLlxuXHRcdCAqIEFsc28gd29ya3Mgb24gc3RyaW5ncywgZml4ZXMgSUUgPCA5IHRvIGFsbG93IGFuIGV4cGxpY2l0IHVuZGVmaW5lZFxuXHRcdCAqIGZvciB0aGUgMm5kIGFyZ3VtZW50IChhcyBpbiBGaXJlZm94KSwgYW5kIHByZXZlbnRzIGVycm9ycyB3aGVuXG5cdFx0ICogY2FsbGVkIG9uIG90aGVyIERPTSBvYmplY3RzLlxuXHRcdCAqL1xuXHRcdHZhciBfc2xpY2UgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIENhbid0IGJlIHVzZWQgd2l0aCBET00gZWxlbWVudHMgaW4gSUUgPCA5XG5cdFx0XHRcdHNsaWNlLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblx0XHRcdFx0cmV0dXJuIHNsaWNlO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyAvLyBGYWlscyBpbiBJRSA8IDlcblxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgd29yayBmb3IgZ2VudWluZSBhcnJheXMsIGFycmF5LWxpa2Ugb2JqZWN0cywgXG5cdFx0XHRcdC8vIE5hbWVkTm9kZU1hcCAoYXR0cmlidXRlcywgZW50aXRpZXMsIG5vdGF0aW9ucyksXG5cdFx0XHRcdC8vIE5vZGVMaXN0IChlLmcuLCBnZXRFbGVtZW50c0J5VGFnTmFtZSksIEhUTUxDb2xsZWN0aW9uIChlLmcuLCBjaGlsZE5vZGVzKSxcblx0XHRcdFx0Ly8gYW5kIHdpbGwgbm90IGZhaWwgb24gb3RoZXIgRE9NIG9iamVjdHMgKGFzIGRvIERPTSBlbGVtZW50cyBpbiBJRSA8IDkpXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG5cdFx0XHRcdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBiZWdpbiAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0YmVnaW4gPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBJRSA8IDkgZ2V0cyB1bmhhcHB5IHdpdGggYW4gdW5kZWZpbmVkIGVuZCBhcmd1bWVudFxuXHRcdFx0XHRcdGlmICh0eXBlb2YgZW5kICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBsZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEZvciBuYXRpdmUgQXJyYXkgb2JqZWN0cywgd2UgdXNlIHRoZSBuYXRpdmUgc2xpY2UgZnVuY3Rpb25cblx0XHRcdFx0XHRpZiAodGhpcy5zbGljZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEZvciBhcnJheSBsaWtlIG9iamVjdCB3ZSBoYW5kbGUgaXQgb3Vyc2VsdmVzLlxuXHRcdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdFx0XHRjbG9uZWQgPSBbXSxcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG5lZ2F0aXZlIHZhbHVlIGZvciBcImJlZ2luXCJcblx0XHRcdFx0XHRcdFx0c3RhcnQgPSAoYmVnaW4gPj0gMCkgPyBiZWdpbiA6IE1hdGgubWF4KDAsIGxlbiArIGJlZ2luKSxcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG5lZ2F0aXZlIHZhbHVlIGZvciBcImVuZFwiXG5cdFx0XHRcdFx0XHRcdHVwVG8gPSBlbmQgPCAwID8gbGVuICsgZW5kIDogTWF0aC5taW4oZW5kLCBsZW4pLFxuXHRcdFx0XHRcdFx0XHQvLyBBY3R1YWwgZXhwZWN0ZWQgc2l6ZSBvZiB0aGUgc2xpY2Vcblx0XHRcdFx0XHRcdFx0c2l6ZSA9IHVwVG8gLSBzdGFydDtcblxuXHRcdFx0XHRcdGlmIChzaXplID4gMCkge1xuXHRcdFx0XHRcdFx0Y2xvbmVkID0gbmV3IEFycmF5KHNpemUpO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuY2hhckF0KSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZWRbaV0gPSB0aGlzLmNoYXJBdChzdGFydCArIGkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvbmVkW2ldID0gdGhpc1tzdGFydCArIGldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjbG9uZWQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSkoKTtcblxuXHRcdC8qIC5pbmRleE9mIGRvZXNuJ3QgZXhpc3QgaW4gSUU8OSAqL1xuXHRcdHZhciBfaW5BcnJheSA9IChmdW5jdGlvbigpIHtcblx0XHRcdGlmIChBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGFyciwgdmFsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFyci5pbmNsdWRlcyh2YWwpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihhcnIsIHZhbCkge1xuXHRcdFx0XHRcdHJldHVybiBhcnIuaW5kZXhPZih2YWwpID49IDA7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oYXJyLCB2YWwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoYXJyW2ldID09PSB2YWwpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0ZnVuY3Rpb24gc2FuaXRpemVFbGVtZW50cyhlbGVtZW50cykge1xuXHRcdFx0LyogVW53cmFwIGpRdWVyeS9aZXB0byBvYmplY3RzLiAqL1xuXHRcdFx0aWYgKFR5cGUuaXNXcmFwcGVkKGVsZW1lbnRzKSkge1xuXHRcdFx0XHRlbGVtZW50cyA9IF9zbGljZS5jYWxsKGVsZW1lbnRzKTtcblx0XHRcdFx0LyogV3JhcCBhIHNpbmdsZSBlbGVtZW50IGluIGFuIGFycmF5IHNvIHRoYXQgJC5lYWNoKCkgY2FuIGl0ZXJhdGUgd2l0aCB0aGUgZWxlbWVudCBpbnN0ZWFkIG9mIGl0cyBub2RlJ3MgY2hpbGRyZW4uICovXG5cdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNOb2RlKGVsZW1lbnRzKSkge1xuXHRcdFx0XHRlbGVtZW50cyA9IFtlbGVtZW50c107XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtZW50cztcblx0XHR9XG5cblx0XHR2YXIgVHlwZSA9IHtcblx0XHRcdGlzTnVtYmVyOiBmdW5jdGlvbih2YXJpYWJsZSkge1xuXHRcdFx0XHRyZXR1cm4gKHR5cGVvZiB2YXJpYWJsZSA9PT0gXCJudW1iZXJcIik7XG5cdFx0XHR9LFxuXHRcdFx0aXNTdHJpbmc6IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiAodHlwZW9mIHZhcmlhYmxlID09PSBcInN0cmluZ1wiKTtcblx0XHRcdH0sXG5cdFx0XHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFyaWFibGUpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cdFx0XHR9LFxuXHRcdFx0aXNGdW5jdGlvbjogZnVuY3Rpb24odmFyaWFibGUpIHtcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YXJpYWJsZSkgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcblx0XHRcdH0sXG5cdFx0XHRpc05vZGU6IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiB2YXJpYWJsZSAmJiB2YXJpYWJsZS5ub2RlVHlwZTtcblx0XHRcdH0sXG5cdFx0XHQvKiBEZXRlcm1pbmUgaWYgdmFyaWFibGUgaXMgYW4gYXJyYXktbGlrZSB3cmFwcGVkIGpRdWVyeSwgWmVwdG8gb3Igc2ltaWxhciBlbGVtZW50LCBvciBldmVuIGEgTm9kZUxpc3QgZXRjLiAqL1xuXHRcdFx0LyogTk9URTogSFRNTEZvcm1FbGVtZW50cyBhbHNvIGhhdmUgYSBsZW5ndGguICovXG5cdFx0XHRpc1dyYXBwZWQ6IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0JiYgdmFyaWFibGUgIT09IHdpbmRvd1xuXHRcdFx0XHRcdFx0JiYgVHlwZS5pc051bWJlcih2YXJpYWJsZS5sZW5ndGgpXG5cdFx0XHRcdFx0XHQmJiAhVHlwZS5pc1N0cmluZyh2YXJpYWJsZSlcblx0XHRcdFx0XHRcdCYmICFUeXBlLmlzRnVuY3Rpb24odmFyaWFibGUpXG5cdFx0XHRcdFx0XHQmJiAhVHlwZS5pc05vZGUodmFyaWFibGUpXG5cdFx0XHRcdFx0XHQmJiAodmFyaWFibGUubGVuZ3RoID09PSAwIHx8IFR5cGUuaXNOb2RlKHZhcmlhYmxlWzBdKSk7XG5cdFx0XHR9LFxuXHRcdFx0aXNTVkc6IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cuU1ZHRWxlbWVudCAmJiAodmFyaWFibGUgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCk7XG5cdFx0XHR9LFxuXHRcdFx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24odmFyaWFibGUpIHtcblx0XHRcdFx0Zm9yICh2YXIgbmFtZSBpbiB2YXJpYWJsZSkge1xuXHRcdFx0XHRcdGlmICh2YXJpYWJsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKioqKioqKioqKioqKioqKipcblx0XHQgRGVwZW5kZW5jaWVzXG5cdFx0ICoqKioqKioqKioqKioqKioqL1xuXG5cdFx0dmFyICQsXG5cdFx0XHRcdGlzSlF1ZXJ5ID0gZmFsc2U7XG5cblx0XHRpZiAoZ2xvYmFsLmZuICYmIGdsb2JhbC5mbi5qcXVlcnkpIHtcblx0XHRcdCQgPSBnbG9iYWw7XG5cdFx0XHRpc0pRdWVyeSA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQgPSB3aW5kb3cuVmVsb2NpdHkuVXRpbGl0aWVzO1xuXHRcdH1cblxuXHRcdGlmIChJRSA8PSA4ICYmICFpc0pRdWVyeSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHk6IElFOCBhbmQgYmVsb3cgcmVxdWlyZSBqUXVlcnkgdG8gYmUgbG9hZGVkIGJlZm9yZSBWZWxvY2l0eS5cIik7XG5cdFx0fSBlbHNlIGlmIChJRSA8PSA3KSB7XG5cdFx0XHQvKiBSZXZlcnQgdG8galF1ZXJ5J3MgJC5hbmltYXRlKCksIGFuZCBsb3NlIFZlbG9jaXR5J3MgZXh0cmEgZmVhdHVyZXMuICovXG5cdFx0XHRqUXVlcnkuZm4udmVsb2NpdHkgPSBqUXVlcnkuZm4uYW5pbWF0ZTtcblxuXHRcdFx0LyogTm93IHRoYXQgJC5mbi52ZWxvY2l0eSBpcyBhbGlhc2VkLCBhYm9ydCB0aGlzIFZlbG9jaXR5IGRlY2xhcmF0aW9uLiAqL1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qKioqKioqKioqKioqKioqKlxuXHRcdCBDb25zdGFudHNcblx0XHQgKioqKioqKioqKioqKioqKiovXG5cblx0XHR2YXIgRFVSQVRJT05fREVGQVVMVCA9IDQwMCxcblx0XHRcdFx0RUFTSU5HX0RFRkFVTFQgPSBcInN3aW5nXCI7XG5cblx0XHQvKioqKioqKioqKioqKlxuXHRcdCBTdGF0ZVxuXHRcdCAqKioqKioqKioqKioqL1xuXG5cdFx0dmFyIFZlbG9jaXR5ID0ge1xuXHRcdFx0LyogQ29udGFpbmVyIGZvciBwYWdlLXdpZGUgVmVsb2NpdHkgc3RhdGUgZGF0YS4gKi9cblx0XHRcdFN0YXRlOiB7XG5cdFx0XHRcdC8qIERldGVjdCBtb2JpbGUgZGV2aWNlcyB0byBkZXRlcm1pbmUgaWYgbW9iaWxlSEEgc2hvdWxkIGJlIHR1cm5lZCBvbi4gKi9cblx0XHRcdFx0aXNNb2JpbGU6IC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcblx0XHRcdFx0LyogVGhlIG1vYmlsZUhBIG9wdGlvbidzIGJlaGF2aW9yIGNoYW5nZXMgb24gb2xkZXIgQW5kcm9pZCBkZXZpY2VzIChHaW5nZXJicmVhZCwgdmVyc2lvbnMgMi4zLjMtMi4zLjcpLiAqL1xuXHRcdFx0XHRpc0FuZHJvaWQ6IC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcblx0XHRcdFx0aXNHaW5nZXJicmVhZDogL0FuZHJvaWQgMlxcLjNcXC5bMy03XS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksXG5cdFx0XHRcdGlzQ2hyb21lOiB3aW5kb3cuY2hyb21lLFxuXHRcdFx0XHRpc0ZpcmVmb3g6IC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcblx0XHRcdFx0LyogQ3JlYXRlIGEgY2FjaGVkIGVsZW1lbnQgZm9yIHJlLXVzZSB3aGVuIGNoZWNraW5nIGZvciBDU1MgcHJvcGVydHkgcHJlZml4ZXMuICovXG5cdFx0XHRcdHByZWZpeEVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRcdC8qIENhY2hlIGV2ZXJ5IHByZWZpeCBtYXRjaCB0byBhdm9pZCByZXBlYXRpbmcgbG9va3Vwcy4gKi9cblx0XHRcdFx0cHJlZml4TWF0Y2hlczoge30sXG5cdFx0XHRcdC8qIENhY2hlIHRoZSBhbmNob3IgdXNlZCBmb3IgYW5pbWF0aW5nIHdpbmRvdyBzY3JvbGxpbmcuICovXG5cdFx0XHRcdHNjcm9sbEFuY2hvcjogbnVsbCxcblx0XHRcdFx0LyogQ2FjaGUgdGhlIGJyb3dzZXItc3BlY2lmaWMgcHJvcGVydHkgbmFtZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzY3JvbGwgYW5jaG9yLiAqL1xuXHRcdFx0XHRzY3JvbGxQcm9wZXJ0eUxlZnQ6IG51bGwsXG5cdFx0XHRcdHNjcm9sbFByb3BlcnR5VG9wOiBudWxsLFxuXHRcdFx0XHQvKiBLZWVwIHRyYWNrIG9mIHdoZXRoZXIgb3VyIFJBRiB0aWNrIGlzIHJ1bm5pbmcuICovXG5cdFx0XHRcdGlzVGlja2luZzogZmFsc2UsXG5cdFx0XHRcdC8qIENvbnRhaW5lciBmb3IgZXZlcnkgaW4tcHJvZ3Jlc3MgY2FsbCB0byBWZWxvY2l0eS4gKi9cblx0XHRcdFx0Y2FsbHM6IFtdLFxuXHRcdFx0XHRkZWxheWVkRWxlbWVudHM6IHtcblx0XHRcdFx0XHRjb3VudDogMFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyogVmVsb2NpdHkncyBjdXN0b20gQ1NTIHN0YWNrLiBNYWRlIGdsb2JhbCBmb3IgdW5pdCB0ZXN0aW5nLiAqL1xuXHRcdFx0Q1NTOiB7LyogRGVmaW5lZCBiZWxvdy4gKi99LFxuXHRcdFx0LyogQSBzaGltIG9mIHRoZSBqUXVlcnkgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBieSBWZWxvY2l0eSAtLSBwcm92aWRlZCBieSBWZWxvY2l0eSdzIG9wdGlvbmFsIGpRdWVyeSBzaGltLiAqL1xuXHRcdFx0VXRpbGl0aWVzOiAkLFxuXHRcdFx0LyogQ29udGFpbmVyIGZvciB0aGUgdXNlcidzIGN1c3RvbSBhbmltYXRpb24gcmVkaXJlY3RzIHRoYXQgYXJlIHJlZmVyZW5jZWQgYnkgbmFtZSBpbiBwbGFjZSBvZiB0aGUgcHJvcGVydGllcyBtYXAgYXJndW1lbnQuICovXG5cdFx0XHRSZWRpcmVjdHM6IHsvKiBNYW51YWxseSByZWdpc3RlcmVkIGJ5IHRoZSB1c2VyLiAqL30sXG5cdFx0XHRFYXNpbmdzOiB7LyogRGVmaW5lZCBiZWxvdy4gKi99LFxuXHRcdFx0LyogQXR0ZW1wdCB0byB1c2UgRVM2IFByb21pc2VzIGJ5IGRlZmF1bHQuIFVzZXJzIGNhbiBvdmVycmlkZSB0aGlzIHdpdGggYSB0aGlyZC1wYXJ0eSBwcm9taXNlcyBsaWJyYXJ5LiAqL1xuXHRcdFx0UHJvbWlzZTogd2luZG93LlByb21pc2UsXG5cdFx0XHQvKiBWZWxvY2l0eSBvcHRpb24gZGVmYXVsdHMsIHdoaWNoIGNhbiBiZSBvdmVycmlkZW4gYnkgdGhlIHVzZXIuICovXG5cdFx0XHRkZWZhdWx0czoge1xuXHRcdFx0XHRxdWV1ZTogXCJcIixcblx0XHRcdFx0ZHVyYXRpb246IERVUkFUSU9OX0RFRkFVTFQsXG5cdFx0XHRcdGVhc2luZzogRUFTSU5HX0RFRkFVTFQsXG5cdFx0XHRcdGJlZ2luOiB1bmRlZmluZWQsXG5cdFx0XHRcdGNvbXBsZXRlOiB1bmRlZmluZWQsXG5cdFx0XHRcdHByb2dyZXNzOiB1bmRlZmluZWQsXG5cdFx0XHRcdGRpc3BsYXk6IHVuZGVmaW5lZCxcblx0XHRcdFx0dmlzaWJpbGl0eTogdW5kZWZpbmVkLFxuXHRcdFx0XHRsb29wOiBmYWxzZSxcblx0XHRcdFx0ZGVsYXk6IGZhbHNlLFxuXHRcdFx0XHRtb2JpbGVIQTogdHJ1ZSxcblx0XHRcdFx0LyogQWR2YW5jZWQ6IFNldCB0byBmYWxzZSB0byBwcmV2ZW50IHByb3BlcnR5IHZhbHVlcyBmcm9tIGJlaW5nIGNhY2hlZCBiZXR3ZWVuIGNvbnNlY3V0aXZlIFZlbG9jaXR5LWluaXRpYXRlZCBjaGFpbiBjYWxscy4gKi9cblx0XHRcdFx0X2NhY2hlVmFsdWVzOiB0cnVlLFxuXHRcdFx0XHQvKiBBZHZhbmNlZDogU2V0IHRvIGZhbHNlIGlmIHRoZSBwcm9taXNlIHNob3VsZCBhbHdheXMgcmVzb2x2ZSBvbiBlbXB0eSBlbGVtZW50IGxpc3RzLiAqL1xuXHRcdFx0XHRwcm9taXNlUmVqZWN0RW1wdHk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHQvKiBBIGRlc2lnbiBnb2FsIG9mIFZlbG9jaXR5IGlzIHRvIGNhY2hlIGRhdGEgd2hlcmV2ZXIgcG9zc2libGUgaW4gb3JkZXIgdG8gYXZvaWQgRE9NIHJlcXVlcnlpbmcuIEFjY29yZGluZ2x5LCBlYWNoIGVsZW1lbnQgaGFzIGEgZGF0YSBjYWNoZS4gKi9cblx0XHRcdGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0JC5kYXRhKGVsZW1lbnQsIFwidmVsb2NpdHlcIiwge1xuXHRcdFx0XHRcdC8qIFN0b3JlIHdoZXRoZXIgdGhpcyBpcyBhbiBTVkcgZWxlbWVudCwgc2luY2UgaXRzIHByb3BlcnRpZXMgYXJlIHJldHJpZXZlZCBhbmQgdXBkYXRlZCBkaWZmZXJlbnRseSB0aGFuIHN0YW5kYXJkIEhUTUwgZWxlbWVudHMuICovXG5cdFx0XHRcdFx0aXNTVkc6IFR5cGUuaXNTVkcoZWxlbWVudCksXG5cdFx0XHRcdFx0LyogS2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZCBieSBWZWxvY2l0eS5cblx0XHRcdFx0XHQgVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IHByb3BlcnR5IHZhbHVlcyBhcmUgbm90IHRyYW5zZmVycmVkIGJldHdlZW4gbm9uLWNvbnNlY3V0aXZlIChzdGFsZSkgY2FsbHMuICovXG5cdFx0XHRcdFx0aXNBbmltYXRpbmc6IGZhbHNlLFxuXHRcdFx0XHRcdC8qIEEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50J3MgbGl2ZSBjb21wdXRlZFN0eWxlIG9iamVjdC4gTGVhcm4gbW9yZSBoZXJlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvd2luZG93LmdldENvbXB1dGVkU3R5bGUgKi9cblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlOiBudWxsLFxuXHRcdFx0XHRcdC8qIFR3ZWVuIGRhdGEgaXMgY2FjaGVkIGZvciBlYWNoIGFuaW1hdGlvbiBvbiB0aGUgZWxlbWVudCBzbyB0aGF0IGRhdGEgY2FuIGJlIHBhc3NlZCBhY3Jvc3MgY2FsbHMgLS1cblx0XHRcdFx0XHQgaW4gcGFydGljdWxhciwgZW5kIHZhbHVlcyBhcmUgdXNlZCBhcyBzdWJzZXF1ZW50IHN0YXJ0IHZhbHVlcyBpbiBjb25zZWN1dGl2ZSBWZWxvY2l0eSBjYWxscy4gKi9cblx0XHRcdFx0XHR0d2VlbnNDb250YWluZXI6IG51bGwsXG5cdFx0XHRcdFx0LyogVGhlIGZ1bGwgcm9vdCBwcm9wZXJ0eSB2YWx1ZXMgb2YgZWFjaCBDU1MgaG9vayBiZWluZyBhbmltYXRlZCBvbiB0aGlzIGVsZW1lbnQgYXJlIGNhY2hlZCBzbyB0aGF0OlxuXHRcdFx0XHRcdCAxKSBDb25jdXJyZW50bHktYW5pbWF0aW5nIGhvb2tzIHNoYXJpbmcgdGhlIHNhbWUgcm9vdCBjYW4gaGF2ZSB0aGVpciByb290IHZhbHVlcycgbWVyZ2VkIGludG8gb25lIHdoaWxlIHR3ZWVuaW5nLlxuXHRcdFx0XHRcdCAyKSBQb3N0LWhvb2staW5qZWN0aW9uIHJvb3QgdmFsdWVzIGNhbiBiZSB0cmFuc2ZlcnJlZCBvdmVyIHRvIGNvbnNlY3V0aXZlbHkgY2hhaW5lZCBWZWxvY2l0eSBjYWxscyBhcyBzdGFydGluZyByb290IHZhbHVlcy4gKi9cblx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZUNhY2hlOiB7fSxcblx0XHRcdFx0XHQvKiBBIGNhY2hlIGZvciB0cmFuc2Zvcm0gdXBkYXRlcywgd2hpY2ggbXVzdCBiZSBtYW51YWxseSBmbHVzaGVkIHZpYSBDU1MuZmx1c2hUcmFuc2Zvcm1DYWNoZSgpLiAqL1xuXHRcdFx0XHRcdHRyYW5zZm9ybUNhY2hlOiB7fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHQvKiBBIHBhcmFsbGVsIHRvIGpRdWVyeSdzICQuY3NzKCksIHVzZWQgZm9yIGdldHRpbmcvc2V0dGluZyBWZWxvY2l0eSdzIGhvb2tlZCBDU1MgcHJvcGVydGllcy4gKi9cblx0XHRcdGhvb2s6IG51bGwsIC8qIERlZmluZWQgYmVsb3cuICovXG5cdFx0XHQvKiBWZWxvY2l0eS13aWRlIGFuaW1hdGlvbiB0aW1lIHJlbWFwcGluZyBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gKi9cblx0XHRcdG1vY2s6IGZhbHNlLFxuXHRcdFx0dmVyc2lvbjoge21ham9yOiAxLCBtaW5vcjogNSwgcGF0Y2g6IDB9LFxuXHRcdFx0LyogU2V0IHRvIDEgb3IgMiAobW9zdCB2ZXJib3NlKSB0byBvdXRwdXQgZGVidWcgaW5mbyB0byBjb25zb2xlLiAqL1xuXHRcdFx0ZGVidWc6IGZhbHNlLFxuXHRcdFx0LyogVXNlIHJBRiBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIHdoZW4gYXZhaWxhYmxlICovXG5cdFx0XHR0aW1lc3RhbXA6IHRydWUsXG5cdFx0XHQvKiBQYXVzZSBhbGwgYW5pbWF0aW9ucyAqL1xuXHRcdFx0cGF1c2VBbGw6IGZ1bmN0aW9uKHF1ZXVlTmFtZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG5cdFx0XHRcdCQuZWFjaChWZWxvY2l0eS5TdGF0ZS5jYWxscywgZnVuY3Rpb24oaSwgYWN0aXZlQ2FsbCkge1xuXG5cdFx0XHRcdFx0aWYgKGFjdGl2ZUNhbGwpIHtcblxuXHRcdFx0XHRcdFx0LyogSWYgd2UgaGF2ZSBhIHF1ZXVlTmFtZSBhbmQgdGhpcyBjYWxsIGlzIG5vdCBvbiB0aGF0IHF1ZXVlLCBza2lwICovXG5cdFx0XHRcdFx0XHRpZiAocXVldWVOYW1lICE9PSB1bmRlZmluZWQgJiYgKChhY3RpdmVDYWxsWzJdLnF1ZXVlICE9PSBxdWV1ZU5hbWUpIHx8IChhY3RpdmVDYWxsWzJdLnF1ZXVlID09PSBmYWxzZSkpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBTZXQgY2FsbCB0byBwYXVzZWQgKi9cblx0XHRcdFx0XHRcdGFjdGl2ZUNhbGxbNV0gPSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VtZTogZmFsc2Vcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvKiBQYXVzZSB0aW1lcnMgb24gYW55IGN1cnJlbnRseSBkZWxheWVkIGNhbGxzICovXG5cdFx0XHRcdCQuZWFjaChWZWxvY2l0eS5TdGF0ZS5kZWxheWVkRWxlbWVudHMsIGZ1bmN0aW9uKGssIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRpZiAoIWVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGF1c2VEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdC8qIFJlc3VtZSBhbGwgYW5pbWF0aW9ucyAqL1xuXHRcdFx0cmVzdW1lQWxsOiBmdW5jdGlvbihxdWV1ZU5hbWUpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHQkLmVhY2goVmVsb2NpdHkuU3RhdGUuY2FsbHMsIGZ1bmN0aW9uKGksIGFjdGl2ZUNhbGwpIHtcblxuXHRcdFx0XHRcdGlmIChhY3RpdmVDYWxsKSB7XG5cblx0XHRcdFx0XHRcdC8qIElmIHdlIGhhdmUgYSBxdWV1ZU5hbWUgYW5kIHRoaXMgY2FsbCBpcyBub3Qgb24gdGhhdCBxdWV1ZSwgc2tpcCAqL1xuXHRcdFx0XHRcdFx0aWYgKHF1ZXVlTmFtZSAhPT0gdW5kZWZpbmVkICYmICgoYWN0aXZlQ2FsbFsyXS5xdWV1ZSAhPT0gcXVldWVOYW1lKSB8fCAoYWN0aXZlQ2FsbFsyXS5xdWV1ZSA9PT0gZmFsc2UpKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogU2V0IGNhbGwgdG8gcmVzdW1lZCBpZiBpdCB3YXMgcGF1c2VkICovXG5cdFx0XHRcdFx0XHRpZiAoYWN0aXZlQ2FsbFs1XSkge1xuXHRcdFx0XHRcdFx0XHRhY3RpdmVDYWxsWzVdLnJlc3VtZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0LyogUmVzdW1lIHRpbWVycyBvbiBhbnkgY3VycmVudGx5IGRlbGF5ZWQgY2FsbHMgKi9cblx0XHRcdFx0JC5lYWNoKFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50cywgZnVuY3Rpb24oaywgZWxlbWVudCkge1xuXHRcdFx0XHRcdGlmICghZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bWVEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKiBSZXRyaWV2ZSB0aGUgYXBwcm9wcmlhdGUgc2Nyb2xsIGFuY2hvciBhbmQgcHJvcGVydHkgbmFtZSBmb3IgdGhlIGJyb3dzZXI6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuc2Nyb2xsWSAqL1xuXHRcdGlmICh3aW5kb3cucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuc2Nyb2xsQW5jaG9yID0gd2luZG93O1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuc2Nyb2xsUHJvcGVydHlMZWZ0ID0gXCJwYWdlWE9mZnNldFwiO1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuc2Nyb2xsUHJvcGVydHlUb3AgPSBcInBhZ2VZT2Zmc2V0XCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFZlbG9jaXR5LlN0YXRlLnNjcm9sbEFuY2hvciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keTtcblx0XHRcdFZlbG9jaXR5LlN0YXRlLnNjcm9sbFByb3BlcnR5TGVmdCA9IFwic2Nyb2xsTGVmdFwiO1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuc2Nyb2xsUHJvcGVydHlUb3AgPSBcInNjcm9sbFRvcFwiO1xuXHRcdH1cblxuXHRcdC8qIFNob3J0aGFuZCBhbGlhcyBmb3IgalF1ZXJ5J3MgJC5kYXRhKCkgdXRpbGl0eS4gKi9cblx0XHRmdW5jdGlvbiBEYXRhKGVsZW1lbnQpIHtcblx0XHRcdC8qIEhhcmRjb2RlIGEgcmVmZXJlbmNlIHRvIHRoZSBwbHVnaW4gbmFtZS4gKi9cblx0XHRcdHZhciByZXNwb25zZSA9ICQuZGF0YShlbGVtZW50LCBcInZlbG9jaXR5XCIpO1xuXG5cdFx0XHQvKiBqUXVlcnkgPD0xLjQuMiByZXR1cm5zIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQgd2hlbiBubyBtYXRjaCBpcyBmb3VuZC4gV2Ugbm9ybWFsaXplIHRoaXMgYmVoYXZpb3IuICovXG5cdFx0XHRyZXR1cm4gcmVzcG9uc2UgPT09IG51bGwgPyB1bmRlZmluZWQgOiByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvKioqKioqKioqKioqKipcblx0XHQgRGVsYXkgVGltZXJcblx0XHQgKioqKioqKioqKioqKiovXG5cblx0XHRmdW5jdGlvbiBwYXVzZURlbGF5T25FbGVtZW50KGVsZW1lbnQsIGN1cnJlbnRUaW1lKSB7XG5cdFx0XHQvKiBDaGVjayBmb3IgYW55IGRlbGF5IHRpbWVycywgYW5kIHBhdXNlIHRoZSBzZXQgdGltZW91dHMgKHdoaWxlIHByZXNlcnZpbmcgdGltZSBkYXRhKVxuXHRcdFx0IHRvIGJlIHJlc3VtZWQgd2hlbiB0aGUgXCJyZXN1bWVcIiBjb21tYW5kIGlzIGlzc3VlZCAqL1xuXHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5kZWxheVRpbWVyICYmICFkYXRhLmRlbGF5UGF1c2VkKSB7XG5cdFx0XHRcdGRhdGEuZGVsYXlSZW1haW5pbmcgPSBkYXRhLmRlbGF5IC0gY3VycmVudFRpbWUgKyBkYXRhLmRlbGF5QmVnaW47XG5cdFx0XHRcdGRhdGEuZGVsYXlQYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoZGF0YS5kZWxheVRpbWVyLnNldFRpbWVvdXQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc3VtZURlbGF5T25FbGVtZW50KGVsZW1lbnQsIGN1cnJlbnRUaW1lKSB7XG5cdFx0XHQvKiBDaGVjayBmb3IgYW55IHBhdXNlZCB0aW1lcnMgYW5kIHJlc3VtZSAqL1xuXHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5kZWxheVRpbWVyICYmIGRhdGEuZGVsYXlQYXVzZWQpIHtcblx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2FzIG1pZC1kZWxheSwgcmUgaW5pdGlhdGUgdGhlIHRpbWVvdXQgd2l0aCB0aGUgcmVtYWluaW5nIGRlbGF5ICovXG5cdFx0XHRcdGRhdGEuZGVsYXlQYXVzZWQgPSBmYWxzZTtcblx0XHRcdFx0ZGF0YS5kZWxheVRpbWVyLnNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KGRhdGEuZGVsYXlUaW1lci5uZXh0LCBkYXRhLmRlbGF5UmVtYWluaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXG5cdFx0LyoqKioqKioqKioqKioqXG5cdFx0IEVhc2luZ1xuXHRcdCAqKioqKioqKioqKioqKi9cblxuXHRcdC8qIFN0ZXAgZWFzaW5nIGdlbmVyYXRvci4gKi9cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVN0ZXAoc3RlcHMpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKHAgKiBzdGVwcykgKiAoMSAvIHN0ZXBzKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyogQmV6aWVyIGN1cnZlIGZ1bmN0aW9uIGdlbmVyYXRvci4gQ29weXJpZ2h0IEdhZXRhbiBSZW5hdWRlYXUuIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG5cdFx0XHR2YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0LFxuXHRcdFx0XHRcdE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMSxcblx0XHRcdFx0XHRTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDEsXG5cdFx0XHRcdFx0U1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMCxcblx0XHRcdFx0XHRrU3BsaW5lVGFibGVTaXplID0gMTEsXG5cdFx0XHRcdFx0a1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApLFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IFwiRmxvYXQzMkFycmF5XCIgaW4gd2luZG93O1xuXG5cdFx0XHQvKiBNdXN0IGNvbnRhaW4gZm91ciBhcmd1bWVudHMuICovXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8qIEFyZ3VtZW50cyBtdXN0IGJlIG51bWJlcnMuICovXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihhcmd1bWVudHNbaV0pIHx8ICFpc0Zpbml0ZShhcmd1bWVudHNbaV0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qIFggdmFsdWVzIG11c3QgYmUgaW4gdGhlIFswLCAxXSByYW5nZS4gKi9cblx0XHRcdG1YMSA9IE1hdGgubWluKG1YMSwgMSk7XG5cdFx0XHRtWDIgPSBNYXRoLm1pbihtWDIsIDEpO1xuXHRcdFx0bVgxID0gTWF0aC5tYXgobVgxLCAwKTtcblx0XHRcdG1YMiA9IE1hdGgubWF4KG1YMiwgMCk7XG5cblx0XHRcdHZhciBtU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcblxuXHRcdFx0ZnVuY3Rpb24gQShhQTEsIGFBMikge1xuXHRcdFx0XHRyZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gQihhQTEsIGFBMikge1xuXHRcdFx0XHRyZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gQyhhQTEpIHtcblx0XHRcdFx0cmV0dXJuIDMuMCAqIGFBMTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcblx0XHRcdFx0cmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcblx0XHRcdFx0cmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NUKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuXHRcdFx0XHRcdHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG5cblx0XHRcdFx0XHRpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcblx0XHRcdFx0XHRcdHJldHVybiBhR3Vlc3NUO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG5cdFx0XHRcdFx0YUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBhR3Vlc3NUO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjYWxjU2FtcGxlVmFsdWVzKCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuXHRcdFx0XHRcdG1TYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQikge1xuXHRcdFx0XHR2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcblxuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Y3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcblx0XHRcdFx0XHRjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuXHRcdFx0XHRcdGlmIChjdXJyZW50WCA+IDAuMCkge1xuXHRcdFx0XHRcdFx0YUIgPSBjdXJyZW50VDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YUEgPSBjdXJyZW50VDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRUO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuXHRcdFx0XHR2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMCxcblx0XHRcdFx0XHRcdGN1cnJlbnRTYW1wbGUgPSAxLFxuXHRcdFx0XHRcdFx0bGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG5cdFx0XHRcdGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuXHRcdFx0XHRcdGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LS1jdXJyZW50U2FtcGxlO1xuXG5cdFx0XHRcdHZhciBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAobVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSxcblx0XHRcdFx0XHRcdGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplLFxuXHRcdFx0XHRcdFx0aW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG5cblx0XHRcdFx0aWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGd1ZXNzRm9yVDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgX3ByZWNvbXB1dGVkID0gZmFsc2U7XG5cblx0XHRcdGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG5cdFx0XHRcdF9wcmVjb21wdXRlZCA9IHRydWU7XG5cdFx0XHRcdGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuXHRcdFx0XHRcdGNhbGNTYW1wbGVWYWx1ZXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZiA9IGZ1bmN0aW9uKGFYKSB7XG5cdFx0XHRcdGlmICghX3ByZWNvbXB1dGVkKSB7XG5cdFx0XHRcdFx0cHJlY29tcHV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuXHRcdFx0XHRcdHJldHVybiBhWDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYVggPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYVggPT09IDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKGFYKSwgbVkxLCBtWTIpO1xuXHRcdFx0fTtcblxuXHRcdFx0Zi5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBbe3g6IG1YMSwgeTogbVkxfSwge3g6IG1YMiwgeTogbVkyfV07XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgc3RyID0gXCJnZW5lcmF0ZUJlemllcihcIiArIFttWDEsIG1ZMSwgbVgyLCBtWTJdICsgXCIpXCI7XG5cdFx0XHRmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gZjtcblx0XHR9XG5cblx0XHQvKiBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cblx0XHQvKiBHaXZlbiBhIHRlbnNpb24sIGZyaWN0aW9uLCBhbmQgZHVyYXRpb24sIGEgc2ltdWxhdGlvbiBhdCA2MEZQUyB3aWxsIGZpcnN0IHJ1biB3aXRob3V0IGEgZGVmaW5lZCBkdXJhdGlvbiBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgcGF0aC4gQSBzZWNvbmQgcGFzc1xuXHRcdCB0aGVuIGFkanVzdHMgdGhlIHRpbWUgZGVsdGEgLS0gdXNpbmcgdGhlIHJlbGF0aW9uIGJldHdlZW4gYWN0dWFsIHRpbWUgYW5kIGR1cmF0aW9uIC0tIHRvIGNhbGN1bGF0ZSB0aGUgcGF0aCBmb3IgdGhlIGR1cmF0aW9uLWNvbnN0cmFpbmVkIGFuaW1hdGlvbi4gKi9cblx0XHR2YXIgZ2VuZXJhdGVTcHJpbmdSSzQgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHRmdW5jdGlvbiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gKC1zdGF0ZS50ZW5zaW9uICogc3RhdGUueCkgLSAoc3RhdGUuZnJpY3Rpb24gKiBzdGF0ZS52KTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKGluaXRpYWxTdGF0ZSwgZHQsIGRlcml2YXRpdmUpIHtcblx0XHRcdFx0dmFyIHN0YXRlID0ge1xuXHRcdFx0XHRcdHg6IGluaXRpYWxTdGF0ZS54ICsgZGVyaXZhdGl2ZS5keCAqIGR0LFxuXHRcdFx0XHRcdHY6IGluaXRpYWxTdGF0ZS52ICsgZGVyaXZhdGl2ZS5kdiAqIGR0LFxuXHRcdFx0XHRcdHRlbnNpb246IGluaXRpYWxTdGF0ZS50ZW5zaW9uLFxuXHRcdFx0XHRcdGZyaWN0aW9uOiBpbml0aWFsU3RhdGUuZnJpY3Rpb25cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZXR1cm4ge2R4OiBzdGF0ZS52LCBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpfTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUoc3RhdGUsIGR0KSB7XG5cdFx0XHRcdHZhciBhID0ge1xuXHRcdFx0XHRcdGR4OiBzdGF0ZS52LFxuXHRcdFx0XHRcdGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcblx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGIgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBhKSxcblx0XHRcdFx0XHRcdGMgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBiKSxcblx0XHRcdFx0XHRcdGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0LCBjKSxcblx0XHRcdFx0XHRcdGR4ZHQgPSAxLjAgLyA2LjAgKiAoYS5keCArIDIuMCAqIChiLmR4ICsgYy5keCkgKyBkLmR4KSxcblx0XHRcdFx0XHRcdGR2ZHQgPSAxLjAgLyA2LjAgKiAoYS5kdiArIDIuMCAqIChiLmR2ICsgYy5kdikgKyBkLmR2KTtcblxuXHRcdFx0XHRzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcblx0XHRcdFx0c3RhdGUudiA9IHN0YXRlLnYgKyBkdmR0ICogZHQ7XG5cblx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcblxuXHRcdFx0XHR2YXIgaW5pdFN0YXRlID0ge1xuXHRcdFx0XHRcdHg6IC0xLFxuXHRcdFx0XHRcdHY6IDAsXG5cdFx0XHRcdFx0dGVuc2lvbjogbnVsbCxcblx0XHRcdFx0XHRmcmljdGlvbjogbnVsbFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0cGF0aCA9IFswXSxcblx0XHRcdFx0XHRcdHRpbWVfbGFwc2VkID0gMCxcblx0XHRcdFx0XHRcdHRvbGVyYW5jZSA9IDEgLyAxMDAwMCxcblx0XHRcdFx0XHRcdERUID0gMTYgLyAxMDAwLFxuXHRcdFx0XHRcdFx0aGF2ZV9kdXJhdGlvbiwgZHQsIGxhc3Rfc3RhdGU7XG5cblx0XHRcdFx0dGVuc2lvbiA9IHBhcnNlRmxvYXQodGVuc2lvbikgfHwgNTAwO1xuXHRcdFx0XHRmcmljdGlvbiA9IHBhcnNlRmxvYXQoZnJpY3Rpb24pIHx8IDIwO1xuXHRcdFx0XHRkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IG51bGw7XG5cblx0XHRcdFx0aW5pdFN0YXRlLnRlbnNpb24gPSB0ZW5zaW9uO1xuXHRcdFx0XHRpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcblxuXHRcdFx0XHRoYXZlX2R1cmF0aW9uID0gZHVyYXRpb24gIT09IG51bGw7XG5cblx0XHRcdFx0LyogQ2FsY3VsYXRlIHRoZSBhY3R1YWwgdGltZSBpdCB0YWtlcyBmb3IgdGhpcyBhbmltYXRpb24gdG8gY29tcGxldGUgd2l0aCB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy4gKi9cblx0XHRcdFx0aWYgKGhhdmVfZHVyYXRpb24pIHtcblx0XHRcdFx0XHQvKiBSdW4gdGhlIHNpbXVsYXRpb24gd2l0aG91dCBhIGR1cmF0aW9uLiAqL1xuXHRcdFx0XHRcdHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbik7XG5cdFx0XHRcdFx0LyogQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgdGltZSBkZWx0YS4gKi9cblx0XHRcdFx0XHRkdCA9IHRpbWVfbGFwc2VkIC8gZHVyYXRpb24gKiBEVDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkdCA9IERUO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0XHQvKiBOZXh0L3N0ZXAgZnVuY3Rpb24gLiovXG5cdFx0XHRcdFx0bGFzdF9zdGF0ZSA9IHNwcmluZ0ludGVncmF0ZVN0YXRlKGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCk7XG5cdFx0XHRcdFx0LyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuXHRcdFx0XHRcdHBhdGgucHVzaCgxICsgbGFzdF9zdGF0ZS54KTtcblx0XHRcdFx0XHR0aW1lX2xhcHNlZCArPSAxNjtcblx0XHRcdFx0XHQvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cblx0XHRcdFx0XHRpZiAoIShNYXRoLmFicyhsYXN0X3N0YXRlLngpID4gdG9sZXJhbmNlICYmIE1hdGguYWJzKGxhc3Rfc3RhdGUudikgPiB0b2xlcmFuY2UpKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBJZiBkdXJhdGlvbiBpcyBub3QgZGVmaW5lZCwgcmV0dXJuIHRoZSBhY3R1YWwgdGltZSByZXF1aXJlZCBmb3IgY29tcGxldGluZyB0aGlzIGFuaW1hdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBjbG9zdXJlIHRoYXQgaG9sZHMgdGhlXG5cdFx0XHRcdCBjb21wdXRlZCBwYXRoIGFuZCByZXR1cm5zIGEgc25hcHNob3Qgb2YgdGhlIHBvc2l0aW9uIGFjY29yZGluZyB0byBhIGdpdmVuIHBlcmNlbnRDb21wbGV0ZS4gKi9cblx0XHRcdFx0cmV0dXJuICFoYXZlX2R1cmF0aW9uID8gdGltZV9sYXBzZWQgOiBmdW5jdGlvbihwZXJjZW50Q29tcGxldGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0aFsgKHBlcmNlbnRDb21wbGV0ZSAqIChwYXRoLmxlbmd0aCAtIDEpKSB8IDAgXTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fSgpKTtcblxuXHRcdC8qIGpRdWVyeSBlYXNpbmdzLiAqL1xuXHRcdFZlbG9jaXR5LkVhc2luZ3MgPSB7XG5cdFx0XHRsaW5lYXI6IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHR9LFxuXHRcdFx0c3dpbmc6IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKHAgKiBNYXRoLlBJKSAvIDI7XG5cdFx0XHR9LFxuXHRcdFx0LyogQm9udXMgXCJzcHJpbmdcIiBlYXNpbmcsIHdoaWNoIGlzIGEgbGVzcyBleGFnZ2VyYXRlZCB2ZXJzaW9uIG9mIGVhc2VJbk91dEVsYXN0aWMuICovXG5cdFx0XHRzcHJpbmc6IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIDEgLSAoTWF0aC5jb3MocCAqIDQuNSAqIE1hdGguUEkpICogTWF0aC5leHAoLXAgKiA2KSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qIENTUzMgYW5kIFJvYmVydCBQZW5uZXIgZWFzaW5ncy4gKi9cblx0XHQkLmVhY2goXG5cdFx0XHRcdFtcblx0XHRcdFx0XHRbXCJlYXNlXCIsIFswLjI1LCAwLjEsIDAuMjUsIDEuMF1dLFxuXHRcdFx0XHRcdFtcImVhc2UtaW5cIiwgWzAuNDIsIDAuMCwgMS4wMCwgMS4wXV0sXG5cdFx0XHRcdFx0W1wiZWFzZS1vdXRcIiwgWzAuMDAsIDAuMCwgMC41OCwgMS4wXV0sXG5cdFx0XHRcdFx0W1wiZWFzZS1pbi1vdXRcIiwgWzAuNDIsIDAuMCwgMC41OCwgMS4wXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluU2luZVwiLCBbMC40NywgMCwgMC43NDUsIDAuNzE1XV0sXG5cdFx0XHRcdFx0W1wiZWFzZU91dFNpbmVcIiwgWzAuMzksIDAuNTc1LCAwLjU2NSwgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJbk91dFNpbmVcIiwgWzAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1XV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluUXVhZFwiLCBbMC41NSwgMC4wODUsIDAuNjgsIDAuNTNdXSxcblx0XHRcdFx0XHRbXCJlYXNlT3V0UXVhZFwiLCBbMC4yNSwgMC40NiwgMC40NSwgMC45NF1dLFxuXHRcdFx0XHRcdFtcImVhc2VJbk91dFF1YWRcIiwgWzAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTVdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5DdWJpY1wiLCBbMC41NSwgMC4wNTUsIDAuNjc1LCAwLjE5XV0sXG5cdFx0XHRcdFx0W1wiZWFzZU91dEN1YmljXCIsIFswLjIxNSwgMC42MSwgMC4zNTUsIDFdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5PdXRDdWJpY1wiLCBbMC42NDUsIDAuMDQ1LCAwLjM1NSwgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJblF1YXJ0XCIsIFswLjg5NSwgMC4wMywgMC42ODUsIDAuMjJdXSxcblx0XHRcdFx0XHRbXCJlYXNlT3V0UXVhcnRcIiwgWzAuMTY1LCAwLjg0LCAwLjQ0LCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluT3V0UXVhcnRcIiwgWzAuNzcsIDAsIDAuMTc1LCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluUXVpbnRcIiwgWzAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNl1dLFxuXHRcdFx0XHRcdFtcImVhc2VPdXRRdWludFwiLCBbMC4yMywgMSwgMC4zMiwgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJbk91dFF1aW50XCIsIFswLjg2LCAwLCAwLjA3LCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluRXhwb1wiLCBbMC45NSwgMC4wNSwgMC43OTUsIDAuMDM1XV0sXG5cdFx0XHRcdFx0W1wiZWFzZU91dEV4cG9cIiwgWzAuMTksIDEsIDAuMjIsIDFdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5PdXRFeHBvXCIsIFsxLCAwLCAwLCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluQ2lyY1wiLCBbMC42LCAwLjA0LCAwLjk4LCAwLjMzNV1dLFxuXHRcdFx0XHRcdFtcImVhc2VPdXRDaXJjXCIsIFswLjA3NSwgMC44MiwgMC4xNjUsIDFdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5PdXRDaXJjXCIsIFswLjc4NSwgMC4xMzUsIDAuMTUsIDAuODZdXVxuXHRcdFx0XHRdLCBmdW5jdGlvbihpLCBlYXNpbmdBcnJheSkge1xuXHRcdFx0VmVsb2NpdHkuRWFzaW5nc1tlYXNpbmdBcnJheVswXV0gPSBnZW5lcmF0ZUJlemllci5hcHBseShudWxsLCBlYXNpbmdBcnJheVsxXSk7XG5cdFx0fSk7XG5cblx0XHQvKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGVhc2luZyB0eXBlIGdpdmVuIGFuIGVhc2luZyBpbnB1dC4gKi9cblx0XHRmdW5jdGlvbiBnZXRFYXNpbmcodmFsdWUsIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgZWFzaW5nID0gdmFsdWU7XG5cblx0XHRcdC8qIFRoZSBlYXNpbmcgb3B0aW9uIGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcgdGhhdCByZWZlcmVuY2VzIGEgcHJlLXJlZ2lzdGVyZWQgZWFzaW5nLFxuXHRcdFx0IG9yIGl0IGNhbiBiZSBhIHR3by0vZm91ci1pdGVtIGFycmF5IG9mIGludGVnZXJzIHRvIGJlIGNvbnZlcnRlZCBpbnRvIGEgYmV6aWVyL3NwcmluZyBmdW5jdGlvbi4gKi9cblx0XHRcdGlmIChUeXBlLmlzU3RyaW5nKHZhbHVlKSkge1xuXHRcdFx0XHQvKiBFbnN1cmUgdGhhdCB0aGUgZWFzaW5nIGhhcyBiZWVuIGFzc2lnbmVkIHRvIGpRdWVyeSdzIFZlbG9jaXR5LkVhc2luZ3Mgb2JqZWN0LiAqL1xuXHRcdFx0XHRpZiAoIVZlbG9jaXR5LkVhc2luZ3NbdmFsdWVdKSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0ZWFzaW5nID0gZ2VuZXJhdGVTdGVwLmFwcGx5KG51bGwsIHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0Lyogc3ByaW5nUks0IG11c3QgYmUgcGFzc2VkIHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbi4gKi9cblx0XHRcdFx0LyogTm90ZTogSWYgdGhlIHNwcmluZ1JLNCBhcnJheSBjb250YWlucyBub24tbnVtYmVycywgZ2VuZXJhdGVTcHJpbmdSSzQoKSByZXR1cm5zIGFuIGVhc2luZ1xuXHRcdFx0XHQgZnVuY3Rpb24gZ2VuZXJhdGVkIHdpdGggZGVmYXVsdCB0ZW5zaW9uIGFuZCBmcmljdGlvbiB2YWx1ZXMuICovXG5cdFx0XHRcdGVhc2luZyA9IGdlbmVyYXRlU3ByaW5nUks0LmFwcGx5KG51bGwsIHZhbHVlLmNvbmNhdChbZHVyYXRpb25dKSk7XG5cdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSA0KSB7XG5cdFx0XHRcdC8qIE5vdGU6IElmIHRoZSBiZXppZXIgYXJyYXkgY29udGFpbnMgbm9uLW51bWJlcnMsIGdlbmVyYXRlQmV6aWVyKCkgcmV0dXJucyBmYWxzZS4gKi9cblx0XHRcdFx0ZWFzaW5nID0gZ2VuZXJhdGVCZXppZXIuYXBwbHkobnVsbCwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFzaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8qIFJldmVydCB0byB0aGUgVmVsb2NpdHktd2lkZSBkZWZhdWx0IGVhc2luZyB0eXBlLCBvciBmYWxsIGJhY2sgdG8gXCJzd2luZ1wiICh3aGljaCBpcyBhbHNvIGpRdWVyeSdzIGRlZmF1bHQpXG5cdFx0XHQgaWYgdGhlIFZlbG9jaXR5LXdpZGUgZGVmYXVsdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBtb2RpZmllZC4gKi9cblx0XHRcdGlmIChlYXNpbmcgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmIChWZWxvY2l0eS5FYXNpbmdzW1ZlbG9jaXR5LmRlZmF1bHRzLmVhc2luZ10pIHtcblx0XHRcdFx0XHRlYXNpbmcgPSBWZWxvY2l0eS5kZWZhdWx0cy5lYXNpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gRUFTSU5HX0RFRkFVTFQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVhc2luZztcblx0XHR9XG5cblx0XHQvKioqKioqKioqKioqKioqKipcblx0XHQgQ1NTIFN0YWNrXG5cdFx0ICoqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogVGhlIENTUyBvYmplY3QgaXMgYSBoaWdobHkgY29uZGVuc2VkIGFuZCBwZXJmb3JtYW50IENTUyBzdGFjayB0aGF0IGZ1bGx5IHJlcGxhY2VzIGpRdWVyeSdzLlxuXHRcdCBJdCBoYW5kbGVzIHRoZSB2YWxpZGF0aW9uLCBnZXR0aW5nLCBhbmQgc2V0dGluZyBvZiBib3RoIHN0YW5kYXJkIENTUyBwcm9wZXJ0aWVzIGFuZCBDU1MgcHJvcGVydHkgaG9va3MuICovXG5cdFx0LyogTm90ZTogQSBcIkNTU1wiIHNob3J0aGFuZCBpcyBhbGlhc2VkIHNvIHRoYXQgb3VyIGNvZGUgaXMgZWFzaWVyIHRvIHJlYWQuICovXG5cdFx0dmFyIENTUyA9IFZlbG9jaXR5LkNTUyA9IHtcblx0XHRcdC8qKioqKioqKioqKioqXG5cdFx0XHQgUmVnRXhcblx0XHRcdCAqKioqKioqKioqKioqL1xuXG5cdFx0XHRSZWdFeDoge1xuXHRcdFx0XHRpc0hleDogL14jKFtBLWZcXGRdezN9KXsxLDJ9JC9pLFxuXHRcdFx0XHQvKiBVbndyYXAgYSBwcm9wZXJ0eSB2YWx1ZSdzIHN1cnJvdW5kaW5nIHRleHQsIGUuZy4gXCJyZ2JhKDQsIDMsIDIsIDEpXCIgPT0+IFwiNCwgMywgMiwgMVwiIGFuZCBcInJlY3QoNHB4IDNweCAycHggMXB4KVwiID09PiBcIjRweCAzcHggMnB4IDFweFwiLiAqL1xuXHRcdFx0XHR2YWx1ZVVud3JhcDogL15bQS16XStcXCgoLiopXFwpJC9pLFxuXHRcdFx0XHR3cmFwcGVkVmFsdWVBbHJlYWR5RXh0cmFjdGVkOiAvWzAtOS5dKyBbMC05Ll0rIFswLTkuXSsoIFswLTkuXSspPy8sXG5cdFx0XHRcdC8qIFNwbGl0IGEgbXVsdGktdmFsdWUgcHJvcGVydHkgaW50byBhbiBhcnJheSBvZiBzdWJ2YWx1ZXMsIGUuZy4gXCJyZ2JhKDQsIDMsIDIsIDEpIDRweCAzcHggMnB4IDFweFwiID09PiBbIFwicmdiYSg0LCAzLCAyLCAxKVwiLCBcIjRweFwiLCBcIjNweFwiLCBcIjJweFwiLCBcIjFweFwiIF0uICovXG5cdFx0XHRcdHZhbHVlU3BsaXQ6IC8oW0Etel0rXFwoLitcXCkpfCgoW0EtejAtOSMtLl0rPykoPz1cXHN8JCkpL2lnXG5cdFx0XHR9LFxuXHRcdFx0LyoqKioqKioqKioqKlxuXHRcdFx0IExpc3RzXG5cdFx0XHQgKioqKioqKioqKioqL1xuXG5cdFx0XHRMaXN0czoge1xuXHRcdFx0XHRjb2xvcnM6IFtcImZpbGxcIiwgXCJzdHJva2VcIiwgXCJzdG9wQ29sb3JcIiwgXCJjb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyVG9wQ29sb3JcIiwgXCJib3JkZXJSaWdodENvbG9yXCIsIFwiYm9yZGVyQm90dG9tQ29sb3JcIiwgXCJib3JkZXJMZWZ0Q29sb3JcIiwgXCJvdXRsaW5lQ29sb3JcIl0sXG5cdFx0XHRcdHRyYW5zZm9ybXNCYXNlOiBbXCJ0cmFuc2xhdGVYXCIsIFwidHJhbnNsYXRlWVwiLCBcInNjYWxlXCIsIFwic2NhbGVYXCIsIFwic2NhbGVZXCIsIFwic2tld1hcIiwgXCJza2V3WVwiLCBcInJvdGF0ZVpcIl0sXG5cdFx0XHRcdHRyYW5zZm9ybXMzRDogW1widHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCJ0cmFuc2xhdGVaXCIsIFwic2NhbGVaXCIsIFwicm90YXRlWFwiLCBcInJvdGF0ZVlcIl0sXG5cdFx0XHRcdHVuaXRzOiBbXG5cdFx0XHRcdFx0XCIlXCIsIC8vIHJlbGF0aXZlXG5cdFx0XHRcdFx0XCJlbVwiLCBcImV4XCIsIFwiY2hcIiwgXCJyZW1cIiwgLy8gZm9udCByZWxhdGl2ZVxuXHRcdFx0XHRcdFwidndcIiwgXCJ2aFwiLCBcInZtaW5cIiwgXCJ2bWF4XCIsIC8vIHZpZXdwb3J0IHJlbGF0aXZlXG5cdFx0XHRcdFx0XCJjbVwiLCBcIm1tXCIsIFwiUVwiLCBcImluXCIsIFwicGNcIiwgXCJwdFwiLCBcInB4XCIsIC8vIGFic29sdXRlIGxlbmd0aHNcblx0XHRcdFx0XHRcImRlZ1wiLCBcImdyYWRcIiwgXCJyYWRcIiwgXCJ0dXJuXCIsIC8vIGFuZ2xlc1xuXHRcdFx0XHRcdFwic1wiLCBcIm1zXCIgLy8gdGltZVxuXHRcdFx0XHRdLFxuXHRcdFx0XHRjb2xvck5hbWVzOiB7XG5cdFx0XHRcdFx0XCJhbGljZWJsdWVcIjogXCIyNDAsMjQ4LDI1NVwiLFxuXHRcdFx0XHRcdFwiYW50aXF1ZXdoaXRlXCI6IFwiMjUwLDIzNSwyMTVcIixcblx0XHRcdFx0XHRcImFxdWFtYXJpbmVcIjogXCIxMjcsMjU1LDIxMlwiLFxuXHRcdFx0XHRcdFwiYXF1YVwiOiBcIjAsMjU1LDI1NVwiLFxuXHRcdFx0XHRcdFwiYXp1cmVcIjogXCIyNDAsMjU1LDI1NVwiLFxuXHRcdFx0XHRcdFwiYmVpZ2VcIjogXCIyNDUsMjQ1LDIyMFwiLFxuXHRcdFx0XHRcdFwiYmlzcXVlXCI6IFwiMjU1LDIyOCwxOTZcIixcblx0XHRcdFx0XHRcImJsYWNrXCI6IFwiMCwwLDBcIixcblx0XHRcdFx0XHRcImJsYW5jaGVkYWxtb25kXCI6IFwiMjU1LDIzNSwyMDVcIixcblx0XHRcdFx0XHRcImJsdWV2aW9sZXRcIjogXCIxMzgsNDMsMjI2XCIsXG5cdFx0XHRcdFx0XCJibHVlXCI6IFwiMCwwLDI1NVwiLFxuXHRcdFx0XHRcdFwiYnJvd25cIjogXCIxNjUsNDIsNDJcIixcblx0XHRcdFx0XHRcImJ1cmx5d29vZFwiOiBcIjIyMiwxODQsMTM1XCIsXG5cdFx0XHRcdFx0XCJjYWRldGJsdWVcIjogXCI5NSwxNTgsMTYwXCIsXG5cdFx0XHRcdFx0XCJjaGFydHJldXNlXCI6IFwiMTI3LDI1NSwwXCIsXG5cdFx0XHRcdFx0XCJjaG9jb2xhdGVcIjogXCIyMTAsMTA1LDMwXCIsXG5cdFx0XHRcdFx0XCJjb3JhbFwiOiBcIjI1NSwxMjcsODBcIixcblx0XHRcdFx0XHRcImNvcm5mbG93ZXJibHVlXCI6IFwiMTAwLDE0OSwyMzdcIixcblx0XHRcdFx0XHRcImNvcm5zaWxrXCI6IFwiMjU1LDI0OCwyMjBcIixcblx0XHRcdFx0XHRcImNyaW1zb25cIjogXCIyMjAsMjAsNjBcIixcblx0XHRcdFx0XHRcImN5YW5cIjogXCIwLDI1NSwyNTVcIixcblx0XHRcdFx0XHRcImRhcmtibHVlXCI6IFwiMCwwLDEzOVwiLFxuXHRcdFx0XHRcdFwiZGFya2N5YW5cIjogXCIwLDEzOSwxMzlcIixcblx0XHRcdFx0XHRcImRhcmtnb2xkZW5yb2RcIjogXCIxODQsMTM0LDExXCIsXG5cdFx0XHRcdFx0XCJkYXJrZ3JheVwiOiBcIjE2OSwxNjksMTY5XCIsXG5cdFx0XHRcdFx0XCJkYXJrZ3JleVwiOiBcIjE2OSwxNjksMTY5XCIsXG5cdFx0XHRcdFx0XCJkYXJrZ3JlZW5cIjogXCIwLDEwMCwwXCIsXG5cdFx0XHRcdFx0XCJkYXJra2hha2lcIjogXCIxODksMTgzLDEwN1wiLFxuXHRcdFx0XHRcdFwiZGFya21hZ2VudGFcIjogXCIxMzksMCwxMzlcIixcblx0XHRcdFx0XHRcImRhcmtvbGl2ZWdyZWVuXCI6IFwiODUsMTA3LDQ3XCIsXG5cdFx0XHRcdFx0XCJkYXJrb3JhbmdlXCI6IFwiMjU1LDE0MCwwXCIsXG5cdFx0XHRcdFx0XCJkYXJrb3JjaGlkXCI6IFwiMTUzLDUwLDIwNFwiLFxuXHRcdFx0XHRcdFwiZGFya3JlZFwiOiBcIjEzOSwwLDBcIixcblx0XHRcdFx0XHRcImRhcmtzYWxtb25cIjogXCIyMzMsMTUwLDEyMlwiLFxuXHRcdFx0XHRcdFwiZGFya3NlYWdyZWVuXCI6IFwiMTQzLDE4OCwxNDNcIixcblx0XHRcdFx0XHRcImRhcmtzbGF0ZWJsdWVcIjogXCI3Miw2MSwxMzlcIixcblx0XHRcdFx0XHRcImRhcmtzbGF0ZWdyYXlcIjogXCI0Nyw3OSw3OVwiLFxuXHRcdFx0XHRcdFwiZGFya3R1cnF1b2lzZVwiOiBcIjAsMjA2LDIwOVwiLFxuXHRcdFx0XHRcdFwiZGFya3Zpb2xldFwiOiBcIjE0OCwwLDIxMVwiLFxuXHRcdFx0XHRcdFwiZGVlcHBpbmtcIjogXCIyNTUsMjAsMTQ3XCIsXG5cdFx0XHRcdFx0XCJkZWVwc2t5Ymx1ZVwiOiBcIjAsMTkxLDI1NVwiLFxuXHRcdFx0XHRcdFwiZGltZ3JheVwiOiBcIjEwNSwxMDUsMTA1XCIsXG5cdFx0XHRcdFx0XCJkaW1ncmV5XCI6IFwiMTA1LDEwNSwxMDVcIixcblx0XHRcdFx0XHRcImRvZGdlcmJsdWVcIjogXCIzMCwxNDQsMjU1XCIsXG5cdFx0XHRcdFx0XCJmaXJlYnJpY2tcIjogXCIxNzgsMzQsMzRcIixcblx0XHRcdFx0XHRcImZsb3JhbHdoaXRlXCI6IFwiMjU1LDI1MCwyNDBcIixcblx0XHRcdFx0XHRcImZvcmVzdGdyZWVuXCI6IFwiMzQsMTM5LDM0XCIsXG5cdFx0XHRcdFx0XCJmdWNoc2lhXCI6IFwiMjU1LDAsMjU1XCIsXG5cdFx0XHRcdFx0XCJnYWluc2Jvcm9cIjogXCIyMjAsMjIwLDIyMFwiLFxuXHRcdFx0XHRcdFwiZ2hvc3R3aGl0ZVwiOiBcIjI0OCwyNDgsMjU1XCIsXG5cdFx0XHRcdFx0XCJnb2xkXCI6IFwiMjU1LDIxNSwwXCIsXG5cdFx0XHRcdFx0XCJnb2xkZW5yb2RcIjogXCIyMTgsMTY1LDMyXCIsXG5cdFx0XHRcdFx0XCJncmF5XCI6IFwiMTI4LDEyOCwxMjhcIixcblx0XHRcdFx0XHRcImdyZXlcIjogXCIxMjgsMTI4LDEyOFwiLFxuXHRcdFx0XHRcdFwiZ3JlZW55ZWxsb3dcIjogXCIxNzMsMjU1LDQ3XCIsXG5cdFx0XHRcdFx0XCJncmVlblwiOiBcIjAsMTI4LDBcIixcblx0XHRcdFx0XHRcImhvbmV5ZGV3XCI6IFwiMjQwLDI1NSwyNDBcIixcblx0XHRcdFx0XHRcImhvdHBpbmtcIjogXCIyNTUsMTA1LDE4MFwiLFxuXHRcdFx0XHRcdFwiaW5kaWFucmVkXCI6IFwiMjA1LDkyLDkyXCIsXG5cdFx0XHRcdFx0XCJpbmRpZ29cIjogXCI3NSwwLDEzMFwiLFxuXHRcdFx0XHRcdFwiaXZvcnlcIjogXCIyNTUsMjU1LDI0MFwiLFxuXHRcdFx0XHRcdFwia2hha2lcIjogXCIyNDAsMjMwLDE0MFwiLFxuXHRcdFx0XHRcdFwibGF2ZW5kZXJibHVzaFwiOiBcIjI1NSwyNDAsMjQ1XCIsXG5cdFx0XHRcdFx0XCJsYXZlbmRlclwiOiBcIjIzMCwyMzAsMjUwXCIsXG5cdFx0XHRcdFx0XCJsYXduZ3JlZW5cIjogXCIxMjQsMjUyLDBcIixcblx0XHRcdFx0XHRcImxlbW9uY2hpZmZvblwiOiBcIjI1NSwyNTAsMjA1XCIsXG5cdFx0XHRcdFx0XCJsaWdodGJsdWVcIjogXCIxNzMsMjE2LDIzMFwiLFxuXHRcdFx0XHRcdFwibGlnaHRjb3JhbFwiOiBcIjI0MCwxMjgsMTI4XCIsXG5cdFx0XHRcdFx0XCJsaWdodGN5YW5cIjogXCIyMjQsMjU1LDI1NVwiLFxuXHRcdFx0XHRcdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogXCIyNTAsMjUwLDIxMFwiLFxuXHRcdFx0XHRcdFwibGlnaHRncmF5XCI6IFwiMjExLDIxMSwyMTFcIixcblx0XHRcdFx0XHRcImxpZ2h0Z3JleVwiOiBcIjIxMSwyMTEsMjExXCIsXG5cdFx0XHRcdFx0XCJsaWdodGdyZWVuXCI6IFwiMTQ0LDIzOCwxNDRcIixcblx0XHRcdFx0XHRcImxpZ2h0cGlua1wiOiBcIjI1NSwxODIsMTkzXCIsXG5cdFx0XHRcdFx0XCJsaWdodHNhbG1vblwiOiBcIjI1NSwxNjAsMTIyXCIsXG5cdFx0XHRcdFx0XCJsaWdodHNlYWdyZWVuXCI6IFwiMzIsMTc4LDE3MFwiLFxuXHRcdFx0XHRcdFwibGlnaHRza3libHVlXCI6IFwiMTM1LDIwNiwyNTBcIixcblx0XHRcdFx0XHRcImxpZ2h0c2xhdGVncmF5XCI6IFwiMTE5LDEzNiwxNTNcIixcblx0XHRcdFx0XHRcImxpZ2h0c3RlZWxibHVlXCI6IFwiMTc2LDE5NiwyMjJcIixcblx0XHRcdFx0XHRcImxpZ2h0eWVsbG93XCI6IFwiMjU1LDI1NSwyMjRcIixcblx0XHRcdFx0XHRcImxpbWVncmVlblwiOiBcIjUwLDIwNSw1MFwiLFxuXHRcdFx0XHRcdFwibGltZVwiOiBcIjAsMjU1LDBcIixcblx0XHRcdFx0XHRcImxpbmVuXCI6IFwiMjUwLDI0MCwyMzBcIixcblx0XHRcdFx0XHRcIm1hZ2VudGFcIjogXCIyNTUsMCwyNTVcIixcblx0XHRcdFx0XHRcIm1hcm9vblwiOiBcIjEyOCwwLDBcIixcblx0XHRcdFx0XHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogXCIxMDIsMjA1LDE3MFwiLFxuXHRcdFx0XHRcdFwibWVkaXVtYmx1ZVwiOiBcIjAsMCwyMDVcIixcblx0XHRcdFx0XHRcIm1lZGl1bW9yY2hpZFwiOiBcIjE4Niw4NSwyMTFcIixcblx0XHRcdFx0XHRcIm1lZGl1bXB1cnBsZVwiOiBcIjE0NywxMTIsMjE5XCIsXG5cdFx0XHRcdFx0XCJtZWRpdW1zZWFncmVlblwiOiBcIjYwLDE3OSwxMTNcIixcblx0XHRcdFx0XHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBcIjEyMywxMDQsMjM4XCIsXG5cdFx0XHRcdFx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBcIjAsMjUwLDE1NFwiLFxuXHRcdFx0XHRcdFwibWVkaXVtdHVycXVvaXNlXCI6IFwiNzIsMjA5LDIwNFwiLFxuXHRcdFx0XHRcdFwibWVkaXVtdmlvbGV0cmVkXCI6IFwiMTk5LDIxLDEzM1wiLFxuXHRcdFx0XHRcdFwibWlkbmlnaHRibHVlXCI6IFwiMjUsMjUsMTEyXCIsXG5cdFx0XHRcdFx0XCJtaW50Y3JlYW1cIjogXCIyNDUsMjU1LDI1MFwiLFxuXHRcdFx0XHRcdFwibWlzdHlyb3NlXCI6IFwiMjU1LDIyOCwyMjVcIixcblx0XHRcdFx0XHRcIm1vY2Nhc2luXCI6IFwiMjU1LDIyOCwxODFcIixcblx0XHRcdFx0XHRcIm5hdmFqb3doaXRlXCI6IFwiMjU1LDIyMiwxNzNcIixcblx0XHRcdFx0XHRcIm5hdnlcIjogXCIwLDAsMTI4XCIsXG5cdFx0XHRcdFx0XCJvbGRsYWNlXCI6IFwiMjUzLDI0NSwyMzBcIixcblx0XHRcdFx0XHRcIm9saXZlZHJhYlwiOiBcIjEwNywxNDIsMzVcIixcblx0XHRcdFx0XHRcIm9saXZlXCI6IFwiMTI4LDEyOCwwXCIsXG5cdFx0XHRcdFx0XCJvcmFuZ2VyZWRcIjogXCIyNTUsNjksMFwiLFxuXHRcdFx0XHRcdFwib3JhbmdlXCI6IFwiMjU1LDE2NSwwXCIsXG5cdFx0XHRcdFx0XCJvcmNoaWRcIjogXCIyMTgsMTEyLDIxNFwiLFxuXHRcdFx0XHRcdFwicGFsZWdvbGRlbnJvZFwiOiBcIjIzOCwyMzIsMTcwXCIsXG5cdFx0XHRcdFx0XCJwYWxlZ3JlZW5cIjogXCIxNTIsMjUxLDE1MlwiLFxuXHRcdFx0XHRcdFwicGFsZXR1cnF1b2lzZVwiOiBcIjE3NSwyMzgsMjM4XCIsXG5cdFx0XHRcdFx0XCJwYWxldmlvbGV0cmVkXCI6IFwiMjE5LDExMiwxNDdcIixcblx0XHRcdFx0XHRcInBhcGF5YXdoaXBcIjogXCIyNTUsMjM5LDIxM1wiLFxuXHRcdFx0XHRcdFwicGVhY2hwdWZmXCI6IFwiMjU1LDIxOCwxODVcIixcblx0XHRcdFx0XHRcInBlcnVcIjogXCIyMDUsMTMzLDYzXCIsXG5cdFx0XHRcdFx0XCJwaW5rXCI6IFwiMjU1LDE5MiwyMDNcIixcblx0XHRcdFx0XHRcInBsdW1cIjogXCIyMjEsMTYwLDIyMVwiLFxuXHRcdFx0XHRcdFwicG93ZGVyYmx1ZVwiOiBcIjE3NiwyMjQsMjMwXCIsXG5cdFx0XHRcdFx0XCJwdXJwbGVcIjogXCIxMjgsMCwxMjhcIixcblx0XHRcdFx0XHRcInJlZFwiOiBcIjI1NSwwLDBcIixcblx0XHRcdFx0XHRcInJvc3licm93blwiOiBcIjE4OCwxNDMsMTQzXCIsXG5cdFx0XHRcdFx0XCJyb3lhbGJsdWVcIjogXCI2NSwxMDUsMjI1XCIsXG5cdFx0XHRcdFx0XCJzYWRkbGVicm93blwiOiBcIjEzOSw2OSwxOVwiLFxuXHRcdFx0XHRcdFwic2FsbW9uXCI6IFwiMjUwLDEyOCwxMTRcIixcblx0XHRcdFx0XHRcInNhbmR5YnJvd25cIjogXCIyNDQsMTY0LDk2XCIsXG5cdFx0XHRcdFx0XCJzZWFncmVlblwiOiBcIjQ2LDEzOSw4N1wiLFxuXHRcdFx0XHRcdFwic2Vhc2hlbGxcIjogXCIyNTUsMjQ1LDIzOFwiLFxuXHRcdFx0XHRcdFwic2llbm5hXCI6IFwiMTYwLDgyLDQ1XCIsXG5cdFx0XHRcdFx0XCJzaWx2ZXJcIjogXCIxOTIsMTkyLDE5MlwiLFxuXHRcdFx0XHRcdFwic2t5Ymx1ZVwiOiBcIjEzNSwyMDYsMjM1XCIsXG5cdFx0XHRcdFx0XCJzbGF0ZWJsdWVcIjogXCIxMDYsOTAsMjA1XCIsXG5cdFx0XHRcdFx0XCJzbGF0ZWdyYXlcIjogXCIxMTIsMTI4LDE0NFwiLFxuXHRcdFx0XHRcdFwic25vd1wiOiBcIjI1NSwyNTAsMjUwXCIsXG5cdFx0XHRcdFx0XCJzcHJpbmdncmVlblwiOiBcIjAsMjU1LDEyN1wiLFxuXHRcdFx0XHRcdFwic3RlZWxibHVlXCI6IFwiNzAsMTMwLDE4MFwiLFxuXHRcdFx0XHRcdFwidGFuXCI6IFwiMjEwLDE4MCwxNDBcIixcblx0XHRcdFx0XHRcInRlYWxcIjogXCIwLDEyOCwxMjhcIixcblx0XHRcdFx0XHRcInRoaXN0bGVcIjogXCIyMTYsMTkxLDIxNlwiLFxuXHRcdFx0XHRcdFwidG9tYXRvXCI6IFwiMjU1LDk5LDcxXCIsXG5cdFx0XHRcdFx0XCJ0dXJxdW9pc2VcIjogXCI2NCwyMjQsMjA4XCIsXG5cdFx0XHRcdFx0XCJ2aW9sZXRcIjogXCIyMzgsMTMwLDIzOFwiLFxuXHRcdFx0XHRcdFwid2hlYXRcIjogXCIyNDUsMjIyLDE3OVwiLFxuXHRcdFx0XHRcdFwid2hpdGVzbW9rZVwiOiBcIjI0NSwyNDUsMjQ1XCIsXG5cdFx0XHRcdFx0XCJ3aGl0ZVwiOiBcIjI1NSwyNTUsMjU1XCIsXG5cdFx0XHRcdFx0XCJ5ZWxsb3dncmVlblwiOiBcIjE1NCwyMDUsNTBcIixcblx0XHRcdFx0XHRcInllbGxvd1wiOiBcIjI1NSwyNTUsMFwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKioqKioqKioqKioqXG5cdFx0XHQgSG9va3Ncblx0XHRcdCAqKioqKioqKioqKiovXG5cblx0XHRcdC8qIEhvb2tzIGFsbG93IGEgc3VicHJvcGVydHkgKGUuZy4gXCJib3hTaGFkb3dCbHVyXCIpIG9mIGEgY29tcG91bmQtdmFsdWUgQ1NTIHByb3BlcnR5XG5cdFx0XHQgKGUuZy4gXCJib3hTaGFkb3c6IFggWSBCbHVyIFNwcmVhZCBDb2xvclwiKSB0byBiZSBhbmltYXRlZCBhcyBpZiBpdCB3ZXJlIGEgZGlzY3JldGUgcHJvcGVydHkuICovXG5cdFx0XHQvKiBOb3RlOiBCZXlvbmQgZW5hYmxpbmcgZmluZS1ncmFpbmVkIHByb3BlcnR5IGFuaW1hdGlvbiwgaG9va2luZyBpcyBuZWNlc3Nhcnkgc2luY2UgVmVsb2NpdHkgb25seVxuXHRcdFx0IHR3ZWVucyBwcm9wZXJ0aWVzIHdpdGggc2luZ2xlIG51bWVyaWMgdmFsdWVzOyB1bmxpa2UgQ1NTIHRyYW5zaXRpb25zLCBWZWxvY2l0eSBkb2VzIG5vdCBpbnRlcnBvbGF0ZSBjb21wb3VuZC12YWx1ZXMuICovXG5cdFx0XHRIb29rczoge1xuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IFJlZ2lzdHJhdGlvblxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogVGVtcGxhdGVzIGFyZSBhIGNvbmNpc2Ugd2F5IG9mIGluZGljYXRpbmcgd2hpY2ggc3VicHJvcGVydGllcyBtdXN0IGJlIGluZGl2aWR1YWxseSByZWdpc3RlcmVkIGZvciBlYWNoIGNvbXBvdW5kLXZhbHVlIENTUyBwcm9wZXJ0eS4gKi9cblx0XHRcdFx0LyogRWFjaCB0ZW1wbGF0ZSBjb25zaXN0cyBvZiB0aGUgY29tcG91bmQtdmFsdWUncyBiYXNlIG5hbWUsIGl0cyBjb25zdGl0dWVudCBzdWJwcm9wZXJ0eSBuYW1lcywgYW5kIHRob3NlIHN1YnByb3BlcnRpZXMnIGRlZmF1bHQgdmFsdWVzLiAqL1xuXHRcdFx0XHR0ZW1wbGF0ZXM6IHtcblx0XHRcdFx0XHRcInRleHRTaGFkb3dcIjogW1wiQ29sb3IgWCBZIEJsdXJcIiwgXCJibGFjayAwcHggMHB4IDBweFwiXSxcblx0XHRcdFx0XHRcImJveFNoYWRvd1wiOiBbXCJDb2xvciBYIFkgQmx1ciBTcHJlYWRcIiwgXCJibGFjayAwcHggMHB4IDBweCAwcHhcIl0sXG5cdFx0XHRcdFx0XCJjbGlwXCI6IFtcIlRvcCBSaWdodCBCb3R0b20gTGVmdFwiLCBcIjBweCAwcHggMHB4IDBweFwiXSxcblx0XHRcdFx0XHRcImJhY2tncm91bmRQb3NpdGlvblwiOiBbXCJYIFlcIiwgXCIwJSAwJVwiXSxcblx0XHRcdFx0XHRcInRyYW5zZm9ybU9yaWdpblwiOiBbXCJYIFkgWlwiLCBcIjUwJSA1MCUgMHB4XCJdLFxuXHRcdFx0XHRcdFwicGVyc3BlY3RpdmVPcmlnaW5cIjogW1wiWCBZXCIsIFwiNTAlIDUwJVwiXVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBBIFwicmVnaXN0ZXJlZFwiIGhvb2sgaXMgb25lIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIGZyb20gaXRzIHRlbXBsYXRlIGZvcm0gaW50byBhIGxpdmUsXG5cdFx0XHRcdCB0d2VlbmFibGUgcHJvcGVydHkuIEl0IGNvbnRhaW5zIGRhdGEgdG8gYXNzb2NpYXRlIGl0IHdpdGggaXRzIHJvb3QgcHJvcGVydHkuICovXG5cdFx0XHRcdHJlZ2lzdGVyZWQ6IHtcblx0XHRcdFx0XHQvKiBOb3RlOiBBIHJlZ2lzdGVyZWQgaG9vayBsb29rcyBsaWtlIHRoaXMgPT0+IHRleHRTaGFkb3dCbHVyOiBbIFwidGV4dFNoYWRvd1wiLCAzIF0sXG5cdFx0XHRcdFx0IHdoaWNoIGNvbnNpc3RzIG9mIHRoZSBzdWJwcm9wZXJ0eSdzIG5hbWUsIHRoZSBhc3NvY2lhdGVkIHJvb3QgcHJvcGVydHkncyBuYW1lLFxuXHRcdFx0XHRcdCBhbmQgdGhlIHN1YnByb3BlcnR5J3MgcG9zaXRpb24gaW4gdGhlIHJvb3QncyB2YWx1ZS4gKi9cblx0XHRcdFx0fSxcblx0XHRcdFx0LyogQ29udmVydCB0aGUgdGVtcGxhdGVzIGludG8gaW5kaXZpZHVhbCBob29rcyB0aGVuIGFwcGVuZCB0aGVtIHRvIHRoZSByZWdpc3RlcmVkIG9iamVjdCBhYm92ZS4gKi9cblx0XHRcdFx0cmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8qIENvbG9yIGhvb2tzIHJlZ2lzdHJhdGlvbjogQ29sb3JzIGFyZSBkZWZhdWx0ZWQgdG8gd2hpdGUgLS0gYXMgb3Bwb3NlZCB0byBibGFjayAtLSBzaW5jZSBjb2xvcnMgdGhhdCBhcmVcblx0XHRcdFx0XHQgY3VycmVudGx5IHNldCB0byBcInRyYW5zcGFyZW50XCIgZGVmYXVsdCB0byB0aGVpciByZXNwZWN0aXZlIHRlbXBsYXRlIGJlbG93IHdoZW4gY29sb3ItYW5pbWF0ZWQsXG5cdFx0XHRcdFx0IGFuZCB3aGl0ZSBpcyB0eXBpY2FsbHkgYSBjbG9zZXIgbWF0Y2ggdG8gdHJhbnNwYXJlbnQgdGhhbiBibGFjayBpcy4gQW4gZXhjZXB0aW9uIGlzIG1hZGUgZm9yIHRleHQgKFwiY29sb3JcIiksXG5cdFx0XHRcdFx0IHdoaWNoIGlzIGFsbW9zdCBhbHdheXMgc2V0IGNsb3NlciB0byBibGFjayB0aGFuIHdoaXRlLiAqL1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgQ1NTLkxpc3RzLmNvbG9ycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHJnYkNvbXBvbmVudHMgPSAoQ1NTLkxpc3RzLmNvbG9yc1tpXSA9PT0gXCJjb2xvclwiKSA/IFwiMCAwIDAgMVwiIDogXCIyNTUgMjU1IDI1NSAxXCI7XG5cdFx0XHRcdFx0XHRDU1MuSG9va3MudGVtcGxhdGVzW0NTUy5MaXN0cy5jb2xvcnNbaV1dID0gW1wiUmVkIEdyZWVuIEJsdWUgQWxwaGFcIiwgcmdiQ29tcG9uZW50c107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJvb3RQcm9wZXJ0eSxcblx0XHRcdFx0XHRcdFx0aG9va1RlbXBsYXRlLFxuXHRcdFx0XHRcdFx0XHRob29rTmFtZXM7XG5cblx0XHRcdFx0XHQvKiBJbiBJRSwgY29sb3IgdmFsdWVzIGluc2lkZSBjb21wb3VuZC12YWx1ZSBwcm9wZXJ0aWVzIGFyZSBwb3NpdGlvbmVkIGF0IHRoZSBlbmQgdGhlIHZhbHVlIGluc3RlYWQgb2YgYXQgdGhlIGJlZ2lubmluZy5cblx0XHRcdFx0XHQgVGh1cywgd2UgcmUtYXJyYW5nZSB0aGUgdGVtcGxhdGVzIGFjY29yZGluZ2x5LiAqL1xuXHRcdFx0XHRcdGlmIChJRSkge1xuXHRcdFx0XHRcdFx0Zm9yIChyb290UHJvcGVydHkgaW4gQ1NTLkhvb2tzLnRlbXBsYXRlcykge1xuXHRcdFx0XHRcdFx0XHRpZiAoIUNTUy5Ib29rcy50ZW1wbGF0ZXMuaGFzT3duUHJvcGVydHkocm9vdFByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGhvb2tUZW1wbGF0ZSA9IENTUy5Ib29rcy50ZW1wbGF0ZXNbcm9vdFByb3BlcnR5XTtcblx0XHRcdFx0XHRcdFx0aG9va05hbWVzID0gaG9va1RlbXBsYXRlWzBdLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZGVmYXVsdFZhbHVlcyA9IGhvb2tUZW1wbGF0ZVsxXS5tYXRjaChDU1MuUmVnRXgudmFsdWVTcGxpdCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGhvb2tOYW1lc1swXSA9PT0gXCJDb2xvclwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogUmVwb3NpdGlvbiBib3RoIHRoZSBob29rJ3MgbmFtZSBhbmQgaXRzIGRlZmF1bHQgdmFsdWUgdG8gdGhlIGVuZCBvZiB0aGVpciByZXNwZWN0aXZlIHN0cmluZ3MuICovXG5cdFx0XHRcdFx0XHRcdFx0aG9va05hbWVzLnB1c2goaG9va05hbWVzLnNoaWZ0KCkpO1xuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZXMucHVzaChkZWZhdWx0VmFsdWVzLnNoaWZ0KCkpO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogUmVwbGFjZSB0aGUgZXhpc3RpbmcgdGVtcGxhdGUgZm9yIHRoZSBob29rJ3Mgcm9vdCBwcm9wZXJ0eS4gKi9cblx0XHRcdFx0XHRcdFx0XHRDU1MuSG9va3MudGVtcGxhdGVzW3Jvb3RQcm9wZXJ0eV0gPSBbaG9va05hbWVzLmpvaW4oXCIgXCIpLCBkZWZhdWx0VmFsdWVzLmpvaW4oXCIgXCIpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIEhvb2sgcmVnaXN0cmF0aW9uLiAqL1xuXHRcdFx0XHRcdGZvciAocm9vdFByb3BlcnR5IGluIENTUy5Ib29rcy50ZW1wbGF0ZXMpIHtcblx0XHRcdFx0XHRcdGlmICghQ1NTLkhvb2tzLnRlbXBsYXRlcy5oYXNPd25Qcm9wZXJ0eShyb290UHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aG9va1RlbXBsYXRlID0gQ1NTLkhvb2tzLnRlbXBsYXRlc1tyb290UHJvcGVydHldO1xuXHRcdFx0XHRcdFx0aG9va05hbWVzID0gaG9va1RlbXBsYXRlWzBdLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiBpbiBob29rTmFtZXMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFob29rTmFtZXMuaGFzT3duUHJvcGVydHkoaikpIHtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YXIgZnVsbEhvb2tOYW1lID0gcm9vdFByb3BlcnR5ICsgaG9va05hbWVzW2pdLFxuXHRcdFx0XHRcdFx0XHRcdFx0aG9va1Bvc2l0aW9uID0gajtcblxuXHRcdFx0XHRcdFx0XHQvKiBGb3IgZWFjaCBob29rLCByZWdpc3RlciBpdHMgZnVsbCBuYW1lIChlLmcuIHRleHRTaGFkb3dCbHVyKSB3aXRoIGl0cyByb290IHByb3BlcnR5IChlLmcuIHRleHRTaGFkb3cpXG5cdFx0XHRcdFx0XHRcdCBhbmQgdGhlIGhvb2sncyBwb3NpdGlvbiBpbiBpdHMgdGVtcGxhdGUncyBkZWZhdWx0IHZhbHVlIHN0cmluZy4gKi9cblx0XHRcdFx0XHRcdFx0Q1NTLkhvb2tzLnJlZ2lzdGVyZWRbZnVsbEhvb2tOYW1lXSA9IFtyb290UHJvcGVydHksIGhvb2tQb3NpdGlvbl07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IEluamVjdGlvbiBhbmQgRXh0cmFjdGlvblxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogTG9vayB1cCB0aGUgcm9vdCBwcm9wZXJ0eSBhc3NvY2lhdGVkIHdpdGggdGhlIGhvb2sgKGUuZy4gcmV0dXJuIFwidGV4dFNoYWRvd1wiIGZvciBcInRleHRTaGFkb3dCbHVyXCIpLiAqL1xuXHRcdFx0XHQvKiBTaW5jZSBhIGhvb2sgY2Fubm90IGJlIHNldCBkaXJlY3RseSAodGhlIGJyb3dzZXIgd29uJ3QgcmVjb2duaXplIGl0KSwgc3R5bGUgdXBkYXRpbmcgZm9yIGhvb2tzIGlzIHJvdXRlZCB0aHJvdWdoIHRoZSBob29rJ3Mgcm9vdCBwcm9wZXJ0eS4gKi9cblx0XHRcdFx0Z2V0Um9vdDogZnVuY3Rpb24ocHJvcGVydHkpIHtcblx0XHRcdFx0XHR2YXIgaG9va0RhdGEgPSBDU1MuSG9va3MucmVnaXN0ZXJlZFtwcm9wZXJ0eV07XG5cblx0XHRcdFx0XHRpZiAoaG9va0RhdGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiBob29rRGF0YVswXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogSWYgdGhlcmUgd2FzIG5vIGhvb2sgbWF0Y2gsIHJldHVybiB0aGUgcHJvcGVydHkgbmFtZSB1bnRvdWNoZWQuICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvcGVydHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXRVbml0OiBmdW5jdGlvbihzdHIsIHN0YXJ0KSB7XG5cdFx0XHRcdFx0dmFyIHVuaXQgPSAoc3RyLnN1YnN0cihzdGFydCB8fCAwLCA1KS5tYXRjaCgvXlthLXolXSsvKSB8fCBbXSlbMF0gfHwgXCJcIjtcblxuXHRcdFx0XHRcdGlmICh1bml0ICYmIF9pbkFycmF5KENTUy5MaXN0cy51bml0cywgdW5pdCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiB1bml0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFx0fSxcblx0XHRcdFx0Zml4Q29sb3JzOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyhyZ2JhP1xcKFxccyopPyhcXGJbYS16XStcXGIpL2csIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHtcblx0XHRcdFx0XHRcdGlmIChDU1MuTGlzdHMuY29sb3JOYW1lcy5oYXNPd25Qcm9wZXJ0eSgkMikpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuICgkMSA/ICQxIDogXCJyZ2JhKFwiKSArIENTUy5MaXN0cy5jb2xvck5hbWVzWyQyXSArICgkMSA/IFwiXCIgOiBcIiwxKVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiAkMSArICQyO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBDb252ZXJ0IGFueSByb290UHJvcGVydHlWYWx1ZSwgbnVsbCBvciBvdGhlcndpc2UsIGludG8gYSBzcGFjZS1kZWxpbWl0ZWQgbGlzdCBvZiBob29rIHZhbHVlcyBzbyB0aGF0XG5cdFx0XHRcdCB0aGUgdGFyZ2V0ZWQgaG9vayBjYW4gYmUgaW5qZWN0ZWQgb3IgZXh0cmFjdGVkIGF0IGl0cyBzdGFuZGFyZCBwb3NpdGlvbi4gKi9cblx0XHRcdFx0Y2xlYW5Sb290UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24ocm9vdFByb3BlcnR5LCByb290UHJvcGVydHlWYWx1ZSkge1xuXHRcdFx0XHRcdC8qIElmIHRoZSByb290UHJvcGVydHlWYWx1ZSBpcyB3cmFwcGVkIHdpdGggXCJyZ2IoKVwiLCBcImNsaXAoKVwiLCBldGMuLCByZW1vdmUgdGhlIHdyYXBwaW5nIHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgYmVmb3JlIG1hbmlwdWxhdGlvbi4gKi9cblx0XHRcdFx0XHRpZiAoQ1NTLlJlZ0V4LnZhbHVlVW53cmFwLnRlc3Qocm9vdFByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IHJvb3RQcm9wZXJ0eVZhbHVlLm1hdGNoKENTUy5SZWdFeC52YWx1ZVVud3JhcClbMV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogSWYgcm9vdFByb3BlcnR5VmFsdWUgaXMgYSBDU1MgbnVsbC12YWx1ZSAoZnJvbSB3aGljaCB0aGVyZSdzIGluaGVyZW50bHkgbm8gaG9vayB2YWx1ZSB0byBleHRyYWN0KSxcblx0XHRcdFx0XHQgZGVmYXVsdCB0byB0aGUgcm9vdCdzIGRlZmF1bHQgdmFsdWUgYXMgZGVmaW5lZCBpbiBDU1MuSG9va3MudGVtcGxhdGVzLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IENTUyBudWxsLXZhbHVlcyBpbmNsdWRlIFwibm9uZVwiLCBcImF1dG9cIiwgYW5kIFwidHJhbnNwYXJlbnRcIi4gVGhleSBtdXN0IGJlIGNvbnZlcnRlZCBpbnRvIHRoZWlyXG5cdFx0XHRcdFx0IHplcm8tdmFsdWVzIChlLmcuIHRleHRTaGFkb3c6IFwibm9uZVwiID09PiB0ZXh0U2hhZG93OiBcIjBweCAwcHggMHB4IGJsYWNrXCIpIGZvciBob29rIG1hbmlwdWxhdGlvbiB0byBwcm9jZWVkLiAqL1xuXHRcdFx0XHRcdGlmIChDU1MuVmFsdWVzLmlzQ1NTTnVsbFZhbHVlKHJvb3RQcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuSG9va3MudGVtcGxhdGVzW3Jvb3RQcm9wZXJ0eV1bMV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHJvb3RQcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBFeHRyYWN0ZWQgdGhlIGhvb2sncyB2YWx1ZSBmcm9tIGl0cyByb290IHByb3BlcnR5J3MgdmFsdWUuIFRoaXMgaXMgdXNlZCB0byBnZXQgdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIGFuIGFuaW1hdGluZyBob29rLiAqL1xuXHRcdFx0XHRleHRyYWN0VmFsdWU6IGZ1bmN0aW9uKGZ1bGxIb29rTmFtZSwgcm9vdFByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgaG9va0RhdGEgPSBDU1MuSG9va3MucmVnaXN0ZXJlZFtmdWxsSG9va05hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKGhvb2tEYXRhKSB7XG5cdFx0XHRcdFx0XHR2YXIgaG9va1Jvb3QgPSBob29rRGF0YVswXSxcblx0XHRcdFx0XHRcdFx0XHRob29rUG9zaXRpb24gPSBob29rRGF0YVsxXTtcblxuXHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuSG9va3MuY2xlYW5Sb290UHJvcGVydHlWYWx1ZShob29rUm9vdCwgcm9vdFByb3BlcnR5VmFsdWUpO1xuXG5cdFx0XHRcdFx0XHQvKiBTcGxpdCByb290UHJvcGVydHlWYWx1ZSBpbnRvIGl0cyBjb25zdGl0dWVudCBob29rIHZhbHVlcyB0aGVuIGdyYWIgdGhlIGRlc2lyZWQgaG9vayBhdCBpdHMgc3RhbmRhcmQgcG9zaXRpb24uICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gcm9vdFByb3BlcnR5VmFsdWUudG9TdHJpbmcoKS5tYXRjaChDU1MuUmVnRXgudmFsdWVTcGxpdClbaG9va1Bvc2l0aW9uXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogSWYgdGhlIHByb3ZpZGVkIGZ1bGxIb29rTmFtZSBpc24ndCBhIHJlZ2lzdGVyZWQgaG9vaywgcmV0dXJuIHRoZSByb290UHJvcGVydHlWYWx1ZSB0aGF0IHdhcyBwYXNzZWQgaW4uICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gcm9vdFByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBJbmplY3QgdGhlIGhvb2sncyB2YWx1ZSBpbnRvIGl0cyByb290IHByb3BlcnR5J3MgdmFsdWUuIFRoaXMgaXMgdXNlZCB0byBwaWVjZSBiYWNrIHRvZ2V0aGVyIHRoZSByb290IHByb3BlcnR5XG5cdFx0XHRcdCBvbmNlIFZlbG9jaXR5IGhhcyB1cGRhdGVkIG9uZSBvZiBpdHMgaW5kaXZpZHVhbGx5IGhvb2tlZCB2YWx1ZXMgdGhyb3VnaCB0d2VlbmluZy4gKi9cblx0XHRcdFx0aW5qZWN0VmFsdWU6IGZ1bmN0aW9uKGZ1bGxIb29rTmFtZSwgaG9va1ZhbHVlLCByb290UHJvcGVydHlWYWx1ZSkge1xuXHRcdFx0XHRcdHZhciBob29rRGF0YSA9IENTUy5Ib29rcy5yZWdpc3RlcmVkW2Z1bGxIb29rTmFtZV07XG5cblx0XHRcdFx0XHRpZiAoaG9va0RhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBob29rUm9vdCA9IGhvb2tEYXRhWzBdLFxuXHRcdFx0XHRcdFx0XHRcdGhvb2tQb3NpdGlvbiA9IGhvb2tEYXRhWzFdLFxuXHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlUGFydHMsXG5cdFx0XHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWVVcGRhdGVkO1xuXG5cdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IENTUy5Ib29rcy5jbGVhblJvb3RQcm9wZXJ0eVZhbHVlKGhvb2tSb290LCByb290UHJvcGVydHlWYWx1ZSk7XG5cblx0XHRcdFx0XHRcdC8qIFNwbGl0IHJvb3RQcm9wZXJ0eVZhbHVlIGludG8gaXRzIGluZGl2aWR1YWwgaG9vayB2YWx1ZXMsIHJlcGxhY2UgdGhlIHRhcmdldGVkIHZhbHVlIHdpdGggaG9va1ZhbHVlLFxuXHRcdFx0XHRcdFx0IHRoZW4gcmVjb25zdHJ1Y3QgdGhlIHJvb3RQcm9wZXJ0eVZhbHVlIHN0cmluZy4gKi9cblx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlUGFydHMgPSByb290UHJvcGVydHlWYWx1ZS50b1N0cmluZygpLm1hdGNoKENTUy5SZWdFeC52YWx1ZVNwbGl0KTtcblx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlUGFydHNbaG9va1Bvc2l0aW9uXSA9IGhvb2tWYWx1ZTtcblx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlVXBkYXRlZCA9IHJvb3RQcm9wZXJ0eVZhbHVlUGFydHMuam9pbihcIiBcIik7XG5cblx0XHRcdFx0XHRcdHJldHVybiByb290UHJvcGVydHlWYWx1ZVVwZGF0ZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIElmIHRoZSBwcm92aWRlZCBmdWxsSG9va05hbWUgaXNuJ3QgYSByZWdpc3RlcmVkIGhvb2ssIHJldHVybiB0aGUgcm9vdFByb3BlcnR5VmFsdWUgdGhhdCB3YXMgcGFzc2VkIGluLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJvb3RQcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgTm9ybWFsaXphdGlvbnNcblx0XHRcdCAqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBOb3JtYWxpemF0aW9ucyBzdGFuZGFyZGl6ZSBDU1MgcHJvcGVydHkgbWFuaXB1bGF0aW9uIGJ5IHBvbGx5ZmlsbGluZyBicm93c2VyLXNwZWNpZmljIGltcGxlbWVudGF0aW9ucyAoZS5nLiBvcGFjaXR5KVxuXHRcdFx0IGFuZCByZWZvcm1hdHRpbmcgc3BlY2lhbCBwcm9wZXJ0aWVzIChlLmcuIGNsaXAsIHJnYmEpIHRvIGxvb2sgbGlrZSBzdGFuZGFyZCBvbmVzLiAqL1xuXHRcdFx0Tm9ybWFsaXphdGlvbnM6IHtcblx0XHRcdFx0LyogTm9ybWFsaXphdGlvbnMgYXJlIHBhc3NlZCBhIG5vcm1hbGl6YXRpb24gdGFyZ2V0IChlaXRoZXIgdGhlIHByb3BlcnR5J3MgbmFtZSwgaXRzIGV4dHJhY3RlZCB2YWx1ZSwgb3IgaXRzIGluamVjdGVkIHZhbHVlKSxcblx0XHRcdFx0IHRoZSB0YXJnZXRlZCBlbGVtZW50ICh3aGljaCBtYXkgbmVlZCB0byBiZSBxdWVyaWVkKSwgYW5kIHRoZSB0YXJnZXRlZCBwcm9wZXJ0eSB2YWx1ZS4gKi9cblx0XHRcdFx0cmVnaXN0ZXJlZDoge1xuXHRcdFx0XHRcdGNsaXA6IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwibmFtZVwiOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBcImNsaXBcIjtcblx0XHRcdFx0XHRcdFx0XHQvKiBDbGlwIG5lZWRzIHRvIGJlIHVud3JhcHBlZCBhbmQgc3RyaXBwZWQgb2YgaXRzIGNvbW1hcyBkdXJpbmcgZXh0cmFjdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXh0cmFjdGVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgVmVsb2NpdHkgYWxzbyBleHRyYWN0ZWQgdGhpcyB2YWx1ZSwgc2tpcCBleHRyYWN0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChDU1MuUmVnRXgud3JhcHBlZFZhbHVlQWxyZWFkeUV4dHJhY3RlZC50ZXN0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgPSBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBSZW1vdmUgdGhlIFwicmVjdCgpXCIgd3JhcHBlci4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RlZCA9IHByb3BlcnR5VmFsdWUudG9TdHJpbmcoKS5tYXRjaChDU1MuUmVnRXgudmFsdWVVbndyYXApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBTdHJpcCBvZmYgY29tbWFzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXh0cmFjdGVkID0gZXh0cmFjdGVkID8gZXh0cmFjdGVkWzFdLnJlcGxhY2UoLywoXFxzKyk/L2csIFwiIFwiKSA6IHByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dHJhY3RlZDtcblx0XHRcdFx0XHRcdFx0XHQvKiBDbGlwIG5lZWRzIHRvIGJlIHJlLXdyYXBwZWQgZHVyaW5nIGluamVjdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0Y2FzZSBcImluamVjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBcInJlY3QoXCIgKyBwcm9wZXJ0eVZhbHVlICsgXCIpXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRibHVyOiBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSBcIm5hbWVcIjpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gVmVsb2NpdHkuU3RhdGUuaXNGaXJlZm94ID8gXCJmaWx0ZXJcIiA6IFwiLXdlYmtpdC1maWx0ZXJcIjtcblx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXh0cmFjdGVkID0gcGFyc2VGbG9hdChwcm9wZXJ0eVZhbHVlKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIElmIGV4dHJhY3RlZCBpcyBOYU4sIG1lYW5pbmcgdGhlIHZhbHVlIGlzbid0IGFscmVhZHkgZXh0cmFjdGVkLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmICghKGV4dHJhY3RlZCB8fCBleHRyYWN0ZWQgPT09IDApKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgYmx1ckNvbXBvbmVudCA9IHByb3BlcnR5VmFsdWUudG9TdHJpbmcoKS5tYXRjaCgvYmx1clxcKChbMC05XStbQS16XSspXFwpL2kpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB0aGUgZmlsdGVyIHN0cmluZyBoYWQgYSBibHVyIGNvbXBvbmVudCwgcmV0dXJuIGp1c3QgdGhlIGJsdXIgdmFsdWUgYW5kIHVuaXQgdHlwZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChibHVyQ29tcG9uZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RlZCA9IGJsdXJDb21wb25lbnRbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBjb21wb25lbnQgZG9lc24ndCBleGlzdCwgZGVmYXVsdCBibHVyIHRvIDAuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBleHRyYWN0ZWQ7XG5cdFx0XHRcdFx0XHRcdFx0LyogQmx1ciBuZWVkcyB0byBiZSByZS13cmFwcGVkIGR1cmluZyBpbmplY3Rpb24uICovXG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJpbmplY3RcIjpcblx0XHRcdFx0XHRcdFx0XHQvKiBGb3IgdGhlIGJsdXIgZWZmZWN0IHRvIGJlIGZ1bGx5IGRlLWFwcGxpZWQsIGl0IG5lZWRzIHRvIGJlIHNldCB0byBcIm5vbmVcIiBpbnN0ZWFkIG9mIDAuICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFwYXJzZUZsb2F0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJub25lXCI7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBcImJsdXIoXCIgKyBwcm9wZXJ0eVZhbHVlICsgXCIpXCI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogPD1JRTggZG8gbm90IHN1cHBvcnQgdGhlIHN0YW5kYXJkIG9wYWNpdHkgcHJvcGVydHkuIFRoZXkgdXNlIGZpbHRlcjphbHBoYShvcGFjaXR5PUlOVCkgaW5zdGVhZC4gKi9cblx0XHRcdFx0XHRvcGFjaXR5OiBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG5cdFx0XHRcdFx0XHRpZiAoSUUgPD0gOCkge1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwibmFtZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiZmlsdGVyXCI7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdC8qIDw9SUU4IHJldHVybiBhIFwiZmlsdGVyXCIgdmFsdWUgb2YgXCJhbHBoYShvcGFjaXR5PVxcZHsxLDN9KVwiLlxuXHRcdFx0XHRcdFx0XHRcdFx0IEV4dHJhY3QgdGhlIHZhbHVlIGFuZCBjb252ZXJ0IGl0IHRvIGEgZGVjaW1hbCB2YWx1ZSB0byBtYXRjaCB0aGUgc3RhbmRhcmQgQ1NTIG9wYWNpdHkgcHJvcGVydHkncyBmb3JtYXR0aW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGV4dHJhY3RlZCA9IHByb3BlcnR5VmFsdWUudG9TdHJpbmcoKS5tYXRjaCgvYWxwaGFcXChvcGFjaXR5PSguKilcXCkvaSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChleHRyYWN0ZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCB0byBkZWNpbWFsIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gZXh0cmFjdGVkWzFdIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogV2hlbiBleHRyYWN0aW5nIG9wYWNpdHksIGRlZmF1bHQgdG8gMSBzaW5jZSBhIG51bGwgdmFsdWUgbWVhbnMgb3BhY2l0eSBoYXNuJ3QgYmVlbiBzZXQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiaW5qZWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBPcGFjaWZpZWQgZWxlbWVudHMgYXJlIHJlcXVpcmVkIHRvIGhhdmUgdGhlaXIgem9vbSBwcm9wZXJ0eSBzZXQgdG8gYSBub24temVybyB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUuem9vbSA9IDE7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIFNldHRpbmcgdGhlIGZpbHRlciBwcm9wZXJ0eSBvbiBlbGVtZW50cyB3aXRoIGNlcnRhaW4gZm9udCBwcm9wZXJ0eSBjb21iaW5hdGlvbnMgY2FuIHJlc3VsdCBpbiBhXG5cdFx0XHRcdFx0XHRcdFx0XHQgaGlnaGx5IHVuYXBwZWFsaW5nIHVsdHJhLWJvbGRpbmcgZWZmZWN0LiBUaGVyZSdzIG5vIHdheSB0byByZW1lZHkgdGhpcyB0aHJvdWdob3V0IGEgdHdlZW4sIGJ1dCBkcm9wcGluZyB0aGVcblx0XHRcdFx0XHRcdFx0XHRcdCB2YWx1ZSBhbHRvZ2V0aGVyICh3aGVuIG9wYWNpdHkgaGl0cyAxKSBhdCBsZWFzdHMgZW5zdXJlcyB0aGF0IHRoZSBnbGl0Y2ggaXMgZ29uZSBwb3N0LXR3ZWVuaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHBhcnNlRmxvYXQocHJvcGVydHlWYWx1ZSkgPj0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEFzIHBlciB0aGUgZmlsdGVyIHByb3BlcnR5J3Mgc3BlYywgY29udmVydCB0aGUgZGVjaW1hbCB2YWx1ZSB0byBhIHdob2xlIG51bWJlciBhbmQgd3JhcCB0aGUgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBcImFscGhhKG9wYWNpdHk9XCIgKyBwYXJzZUludChwYXJzZUZsb2F0KHByb3BlcnR5VmFsdWUpICogMTAwLCAxMCkgKyBcIilcIjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvKiBXaXRoIGFsbCBvdGhlciBicm93c2Vycywgbm9ybWFsaXphdGlvbiBpcyBub3QgcmVxdWlyZWQ7IHJldHVybiB0aGUgc2FtZSB2YWx1ZXMgdGhhdCB3ZXJlIHBhc3NlZCBpbi4gKi9cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJuYW1lXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJvcGFjaXR5XCI7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJpbmplY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IEJhdGNoZWQgUmVnaXN0cmF0aW9uc1xuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogTm90ZTogQmF0Y2hlZCBub3JtYWxpemF0aW9ucyBleHRlbmQgdGhlIENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkIG9iamVjdC4gKi9cblx0XHRcdFx0cmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IFRyYW5zZm9ybXNcblx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBUcmFuc2Zvcm1zIGFyZSB0aGUgc3VicHJvcGVydGllcyBjb250YWluZWQgYnkgdGhlIENTUyBcInRyYW5zZm9ybVwiIHByb3BlcnR5LiBUcmFuc2Zvcm1zIG11c3QgdW5kZXJnbyBub3JtYWxpemF0aW9uXG5cdFx0XHRcdFx0IHNvIHRoYXQgdGhleSBjYW4gYmUgcmVmZXJlbmNlZCBpbiBhIHByb3BlcnRpZXMgbWFwIGJ5IHRoZWlyIGluZGl2aWR1YWwgbmFtZXMuICovXG5cdFx0XHRcdFx0LyogTm90ZTogV2hlbiB0cmFuc2Zvcm1zIGFyZSBcInNldFwiLCB0aGV5IGFyZSBhY3R1YWxseSBhc3NpZ25lZCB0byBhIHBlci1lbGVtZW50IHRyYW5zZm9ybUNhY2hlLiBXaGVuIGFsbCB0cmFuc2Zvcm1cblx0XHRcdFx0XHQgc2V0dGluZyBpcyBjb21wbGV0ZSBjb21wbGV0ZSwgQ1NTLmZsdXNoVHJhbnNmb3JtQ2FjaGUoKSBtdXN0IGJlIG1hbnVhbGx5IGNhbGxlZCB0byBmbHVzaCB0aGUgdmFsdWVzIHRvIHRoZSBET00uXG5cdFx0XHRcdFx0IFRyYW5zZm9ybSBzZXR0aW5nIGlzIGJhdGNoZWQgaW4gdGhpcyB3YXkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZTogdGhlIHRyYW5zZm9ybSBzdHlsZSBvbmx5IG5lZWRzIHRvIGJlIHVwZGF0ZWRcblx0XHRcdFx0XHQgb25jZSB3aGVuIG11bHRpcGxlIHRyYW5zZm9ybSBzdWJwcm9wZXJ0aWVzIGFyZSBiZWluZyBhbmltYXRlZCBzaW11bHRhbmVvdXNseS4gKi9cblx0XHRcdFx0XHQvKiBOb3RlOiBJRTkgYW5kIEFuZHJvaWQgR2luZ2VyYnJlYWQgaGF2ZSBzdXBwb3J0IGZvciAyRCAtLSBidXQgbm90IDNEIC0tIHRyYW5zZm9ybXMuIFNpbmNlIGFuaW1hdGluZyB1bnN1cHBvcnRlZFxuXHRcdFx0XHRcdCB0cmFuc2Zvcm0gcHJvcGVydGllcyByZXN1bHRzIGluIHRoZSBicm93c2VyIGlnbm9yaW5nIHRoZSAqZW50aXJlKiB0cmFuc2Zvcm0gc3RyaW5nLCB3ZSBwcmV2ZW50IHRoZXNlIDNEIHZhbHVlc1xuXHRcdFx0XHRcdCBmcm9tIGJlaW5nIG5vcm1hbGl6ZWQgZm9yIHRoZXNlIGJyb3dzZXJzIHNvIHRoYXQgdHdlZW5pbmcgc2tpcHMgdGhlc2UgcHJvcGVydGllcyBhbHRvZ2V0aGVyXG5cdFx0XHRcdFx0IChzaW5jZSBpdCB3aWxsIGlnbm9yZSB0aGVtIGFzIGJlaW5nIHVuc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLikgKi9cblx0XHRcdFx0XHRpZiAoKCFJRSB8fCBJRSA+IDkpICYmICFWZWxvY2l0eS5TdGF0ZS5pc0dpbmdlcmJyZWFkKSB7XG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBTaW5jZSB0aGUgc3RhbmRhbG9uZSBDU1MgXCJwZXJzcGVjdGl2ZVwiIHByb3BlcnR5IGFuZCB0aGUgQ1NTIHRyYW5zZm9ybSBcInBlcnNwZWN0aXZlXCIgc3VicHJvcGVydHlcblx0XHRcdFx0XHRcdCBzaGFyZSB0aGUgc2FtZSBuYW1lLCB0aGUgbGF0dGVyIGlzIGdpdmVuIGEgdW5pcXVlIHRva2VuIHdpdGhpbiBWZWxvY2l0eTogXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLiAqL1xuXHRcdFx0XHRcdFx0Q1NTLkxpc3RzLnRyYW5zZm9ybXNCYXNlID0gQ1NTLkxpc3RzLnRyYW5zZm9ybXNCYXNlLmNvbmNhdChDU1MuTGlzdHMudHJhbnNmb3JtczNEKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IENTUy5MaXN0cy50cmFuc2Zvcm1zQmFzZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0LyogV3JhcCB0aGUgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIG5vcm1hbGl6YXRpb24gZnVuY3Rpb24gaW4gYSBuZXcgc2NvcGUgc28gdGhhdCB0cmFuc2Zvcm1OYW1lJ3MgdmFsdWUgaXNcblx0XHRcdFx0XHRcdCBwYWlyZWQgd2l0aCBpdHMgcmVzcGVjdGl2ZSBmdW5jdGlvbi4gKE90aGVyd2lzZSwgYWxsIGZ1bmN0aW9ucyB3b3VsZCB0YWtlIHRoZSBmaW5hbCBmb3IgbG9vcCdzIHRyYW5zZm9ybU5hbWUuKSAqL1xuXHRcdFx0XHRcdFx0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtTmFtZSA9IENTUy5MaXN0cy50cmFuc2Zvcm1zQmFzZVtpXTtcblxuXHRcdFx0XHRcdFx0XHRDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFt0cmFuc2Zvcm1OYW1lXSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIFRoZSBub3JtYWxpemVkIHByb3BlcnR5IG5hbWUgaXMgdGhlIHBhcmVudCBcInRyYW5zZm9ybVwiIHByb3BlcnR5IC0tIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIGFjdHVhbGx5IHNldCBpbiBDU1MuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwibmFtZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJ0cmFuc2Zvcm1cIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogVHJhbnNmb3JtIHZhbHVlcyBhcmUgY2FjaGVkIG9udG8gYSBwZXItZWxlbWVudCB0cmFuc2Zvcm1DYWNoZSBvYmplY3QuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiZXh0cmFjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB0aGlzIHRyYW5zZm9ybSBoYXMgeWV0IHRvIGJlIGFzc2lnbmVkIGEgdmFsdWUsIHJldHVybiBpdHMgbnVsbCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKERhdGEoZWxlbWVudCkgPT09IHVuZGVmaW5lZCB8fCBEYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlW3RyYW5zZm9ybU5hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTY2FsZSBDU1MuTGlzdHMudHJhbnNmb3Jtc0Jhc2UgZGVmYXVsdCB0byAxIHdoZXJlYXMgYWxsIG90aGVyIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGRlZmF1bHQgdG8gMC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gL15zY2FsZS9pLnRlc3QodHJhbnNmb3JtTmFtZSkgPyAxIDogMDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBXaGVuIHRyYW5zZm9ybSB2YWx1ZXMgYXJlIHNldCwgdGhleSBhcmUgd3JhcHBlZCBpbiBwYXJlbnRoZXNlcyBhcyBwZXIgdGhlIENTUyBzcGVjLlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBUaHVzLCB3aGVuIGV4dHJhY3RpbmcgdGhlaXIgdmFsdWVzIChmb3IgdHdlZW4gY2FsY3VsYXRpb25zKSwgd2Ugc3RyaXAgb2ZmIHRoZSBwYXJlbnRoZXNlcy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXS5yZXBsYWNlKC9bKCldL2csIFwiXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImluamVjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgaW52YWxpZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIGFuIGluZGl2aWR1YWwgdHJhbnNmb3JtIHByb3BlcnR5IGNvbnRhaW5zIGFuIHVuc3VwcG9ydGVkIHVuaXQgdHlwZSwgdGhlIGJyb3dzZXIgaWdub3JlcyB0aGUgKmVudGlyZSogdHJhbnNmb3JtIHByb3BlcnR5LlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgVGh1cywgcHJvdGVjdCB1c2VycyBmcm9tIHRoZW1zZWx2ZXMgYnkgc2tpcHBpbmcgc2V0dGluZyBmb3IgdHJhbnNmb3JtIHZhbHVlcyBzdXBwbGllZCB3aXRoIGludmFsaWQgdW5pdCB0eXBlcy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogU3dpdGNoIG9uIHRoZSBiYXNlIHRyYW5zZm9ybSB0eXBlOyBpZ25vcmUgdGhlIGF4aXMgYnkgcmVtb3ZpbmcgdGhlIGxhc3QgbGV0dGVyIGZyb20gdGhlIHRyYW5zZm9ybSdzIG5hbWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAodHJhbnNmb3JtTmFtZS5zdWJzdHIoMCwgdHJhbnNmb3JtTmFtZS5sZW5ndGggLSAxKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFdoaXRlbGlzdCB1bml0IHR5cGVzIGZvciBlYWNoIHRyYW5zZm9ybS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwidHJhbnNsYXRlXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbnZhbGlkID0gIS8oJXxweHxlbXxyZW18dnd8dmh8XFxkKSQvaS50ZXN0KHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTaW5jZSBhbiBheGlzLWZyZWUgXCJzY2FsZVwiIHByb3BlcnR5IGlzIHN1cHBvcnRlZCBhcyB3ZWxsLCBhIGxpdHRsZSBoYWNrIGlzIHVzZWQgaGVyZSB0byBkZXRlY3QgaXQgYnkgY2hvcHBpbmcgb2ZmIGl0cyBsYXN0IGxldHRlci4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwic2NhbFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJzY2FsZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ2hyb21lIG9uIEFuZHJvaWQgaGFzIGEgYnVnIGluIHdoaWNoIHNjYWxlZCBlbGVtZW50cyBibHVyIGlmIHRoZWlyIGluaXRpYWwgc2NhbGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCB2YWx1ZSBpcyBiZWxvdyAxICh3aGljaCBjYW4gaGFwcGVuIHdpdGggZm9yY2VmZWVkaW5nKS4gVGh1cywgd2UgZGV0ZWN0IGEgeWV0LXVuc2V0IHNjYWxlIHByb3BlcnR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgYW5kIGVuc3VyZSB0aGF0IGl0cyBmaXJzdCB2YWx1ZSBpcyBhbHdheXMgMS4gTW9yZSBpbmZvOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNDE3ODkwL2NzczMtYW5pbWF0aW9ucy13aXRoLXRyYW5zZm9ybS1jYXVzZXMtYmx1cnJlZC1lbGVtZW50cy1vbi13ZWJraXQvMTA0MTc5NjIjMTA0MTc5NjIgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5TdGF0ZS5pc0FuZHJvaWQgJiYgRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXSA9PT0gdW5kZWZpbmVkICYmIHByb3BlcnR5VmFsdWUgPCAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbnZhbGlkID0gIS8oXFxkKSQvaS50ZXN0KHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInNrZXdcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGludmFsaWQgPSAhLyhkZWd8XFxkKSQvaS50ZXN0KHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInJvdGF0ZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW52YWxpZCA9ICEvKGRlZ3xcXGQpJC9pLnRlc3QocHJvcGVydHlWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghaW52YWxpZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEFzIHBlciB0aGUgQ1NTIHNwZWMsIHdyYXAgdGhlIHZhbHVlIGluIHBhcmVudGhlc2VzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV0gPSBcIihcIiArIHByb3BlcnR5VmFsdWUgKyBcIilcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEFsdGhvdWdoIHRoZSB2YWx1ZSBpcyBzZXQgb24gdGhlIHRyYW5zZm9ybUNhY2hlIG9iamVjdCwgcmV0dXJuIHRoZSBuZXdseS11cGRhdGVkIHZhbHVlIGZvciB0aGUgY2FsbGluZyBjb2RlIHRvIHByb2Nlc3MgYXMgbm9ybWFsLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qKioqKioqKioqKioqXG5cdFx0XHRcdFx0IENvbG9yc1xuXHRcdFx0XHRcdCAqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogU2luY2UgVmVsb2NpdHkgb25seSBhbmltYXRlcyBhIHNpbmdsZSBudW1lcmljIHZhbHVlIHBlciBwcm9wZXJ0eSwgY29sb3IgYW5pbWF0aW9uIGlzIGFjaGlldmVkIGJ5IGhvb2tpbmcgdGhlIGluZGl2aWR1YWwgUkdCQSBjb21wb25lbnRzIG9mIENTUyBjb2xvciBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRcdCBBY2NvcmRpbmdseSwgY29sb3IgdmFsdWVzIG11c3QgYmUgbm9ybWFsaXplZCAoZS5nLiBcIiNmZjAwMDBcIiwgXCJyZWRcIiwgYW5kIFwicmdiKDI1NSwgMCwgMClcIiA9PT4gXCIyNTUgMCAwIDFcIikgc28gdGhhdCB0aGVpciBjb21wb25lbnRzIGNhbiBiZSBpbmplY3RlZC9leHRyYWN0ZWQgYnkgQ1NTLkhvb2tzIGxvZ2ljLiAqL1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgQ1NTLkxpc3RzLmNvbG9ycy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0LyogV3JhcCB0aGUgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIG5vcm1hbGl6YXRpb24gZnVuY3Rpb24gaW4gYSBuZXcgc2NvcGUgc28gdGhhdCBjb2xvck5hbWUncyB2YWx1ZSBpcyBwYWlyZWQgd2l0aCBpdHMgcmVzcGVjdGl2ZSBmdW5jdGlvbi5cblx0XHRcdFx0XHRcdCAoT3RoZXJ3aXNlLCBhbGwgZnVuY3Rpb25zIHdvdWxkIHRha2UgdGhlIGZpbmFsIGZvciBsb29wJ3MgY29sb3JOYW1lLikgKi9cblx0XHRcdFx0XHRcdChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGNvbG9yTmFtZSA9IENTUy5MaXN0cy5jb2xvcnNbal07XG5cblx0XHRcdFx0XHRcdFx0LyogTm90ZTogSW4gSUU8PTgsIHdoaWNoIHN1cHBvcnQgcmdiIGJ1dCBub3QgcmdiYSwgY29sb3IgcHJvcGVydGllcyBhcmUgcmV2ZXJ0ZWQgdG8gcmdiIGJ5IHN0cmlwcGluZyBvZmYgdGhlIGFscGhhIGNvbXBvbmVudC4gKi9cblx0XHRcdFx0XHRcdFx0Q1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbY29sb3JOYW1lXSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJuYW1lXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBjb2xvck5hbWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIENvbnZlcnQgYWxsIGNvbG9yIHZhbHVlcyBpbnRvIHRoZSByZ2IgZm9ybWF0LiAoT2xkIElFIGNhbiByZXR1cm4gaGV4IHZhbHVlcyBhbmQgY29sb3IgbmFtZXMgaW5zdGVhZCBvZiByZ2IvcmdiYS4pICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiZXh0cmFjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgZXh0cmFjdGVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBjb2xvciBpcyBhbHJlYWR5IGluIGl0cyBob29rYWJsZSBmb3JtIChlLmcuIFwiMjU1IDI1NSAyNTUgMVwiKSBkdWUgdG8gaGF2aW5nIGJlZW4gcHJldmlvdXNseSBleHRyYWN0ZWQsIHNraXAgZXh0cmFjdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5SZWdFeC53cmFwcGVkVmFsdWVBbHJlYWR5RXh0cmFjdGVkLnRlc3QocHJvcGVydHlWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgPSBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBjb252ZXJ0ZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG9yTmFtZXMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YmxhY2s6IFwicmdiKDAsIDAsIDApXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ymx1ZTogXCJyZ2IoMCwgMCwgMjU1KVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGdyYXk6IFwicmdiKDEyOCwgMTI4LCAxMjgpXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Z3JlZW46IFwicmdiKDAsIDEyOCwgMClcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZWQ6IFwicmdiKDI1NSwgMCwgMClcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3aGl0ZTogXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCBjb2xvciBuYW1lcyB0byByZ2IuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKC9eW0Etel0rJC9pLnRlc3QocHJvcGVydHlWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjb2xvck5hbWVzW3Byb3BlcnR5VmFsdWVdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udmVydGVkID0gY29sb3JOYW1lc1twcm9wZXJ0eVZhbHVlXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIGFuIHVubWF0Y2hlZCBjb2xvciBuYW1lIGlzIHByb3ZpZGVkLCBkZWZhdWx0IHRvIGJsYWNrLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZWQgPSBjb2xvck5hbWVzLmJsYWNrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCBoZXggdmFsdWVzIHRvIHJnYi4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKENTUy5SZWdFeC5pc0hleC50ZXN0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZWQgPSBcInJnYihcIiArIENTUy5WYWx1ZXMuaGV4VG9SZ2IocHJvcGVydHlWYWx1ZSkuam9pbihcIiBcIikgKyBcIilcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBwcm92aWRlZCBjb2xvciBkb2Vzbid0IG1hdGNoIGFueSBvZiB0aGUgYWNjZXB0ZWQgY29sb3IgZm9ybWF0cywgZGVmYXVsdCB0byBibGFjay4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCEoL15yZ2JhP1xcKC9pLnRlc3QocHJvcGVydHlWYWx1ZSkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZWQgPSBjb2xvck5hbWVzLmJsYWNrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFJlbW92ZSB0aGUgc3Vycm91bmRpbmcgXCJyZ2IvcmdiYSgpXCIgc3RyaW5nIHRoZW4gcmVwbGFjZSBjb21tYXMgd2l0aCBzcGFjZXMgYW5kIHN0cmlwXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHJlcGVhdGVkIHNwYWNlcyAoaW4gY2FzZSB0aGUgdmFsdWUgaW5jbHVkZWQgc3BhY2VzIHRvIGJlZ2luIHdpdGgpLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RlZCA9IChjb252ZXJ0ZWQgfHwgcHJvcGVydHlWYWx1ZSkudG9TdHJpbmcoKS5tYXRjaChDU1MuUmVnRXgudmFsdWVVbndyYXApWzFdLnJlcGxhY2UoLywoXFxzKyk/L2csIFwiIFwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFNvIGxvbmcgYXMgdGhpcyBpc24ndCA8PUlFOCwgYWRkIGEgZm91cnRoIChhbHBoYSkgY29tcG9uZW50IGlmIGl0J3MgbWlzc2luZyBhbmQgZGVmYXVsdCBpdCB0byAxICh2aXNpYmxlKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCghSUUgfHwgSUUgPiA4KSAmJiBleHRyYWN0ZWQuc3BsaXQoXCIgXCIpLmxlbmd0aCA9PT0gMykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RlZCArPSBcIiAxXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0cmFjdGVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImluamVjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB3ZSBoYXZlIGEgcGF0dGVybiB0aGVuIGl0IG1pZ2h0IGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgdmFsdWVzICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICgvXnJnYi8udGVzdChwcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogSWYgdGhpcyBpcyBJRTw9OCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IGV4aXN0cywgc3RyaXAgaXQgb2ZmLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoSUUgPD0gOCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eVZhbHVlLnNwbGl0KFwiIFwiKS5sZW5ndGggPT09IDQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBwcm9wZXJ0eVZhbHVlLnNwbGl0KC9cXHMrLykuc2xpY2UoMCwgMykuam9pbihcIiBcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIE90aGVyd2lzZSwgYWRkIGEgZm91cnRoIChhbHBoYSkgY29tcG9uZW50IGlmIGl0J3MgbWlzc2luZyBhbmQgZGVmYXVsdCBpdCB0byAxICh2aXNpYmxlKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9wZXJ0eVZhbHVlLnNwbGl0KFwiIFwiKS5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlICs9IFwiIDFcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFJlLWluc2VydCB0aGUgYnJvd3Nlci1hcHByb3ByaWF0ZSB3cmFwcGVyKFwicmdiL3JnYmEoKVwiKSwgaW5zZXJ0IGNvbW1hcywgYW5kIHN0cmlwIG9mZiBkZWNpbWFsIHVuaXRzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCBvbiBhbGwgdmFsdWVzIGJ1dCB0aGUgZm91cnRoIChSLCBHLCBhbmQgQiBvbmx5IGFjY2VwdCB3aG9sZSBudW1iZXJzKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChJRSA8PSA4ID8gXCJyZ2JcIiA6IFwicmdiYVwiKSArIFwiKFwiICsgcHJvcGVydHlWYWx1ZS5yZXBsYWNlKC9cXHMrL2csIFwiLFwiKS5yZXBsYWNlKC9cXC4oXFxkKSsoPz0sKS9nLCBcIlwiKSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0pKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IERpbWVuc2lvbnNcblx0XHRcdFx0XHQgKioqKioqKioqKioqKiovXG5cdFx0XHRcdFx0ZnVuY3Rpb24gYXVnbWVudERpbWVuc2lvbihuYW1lLCBlbGVtZW50LCB3YW50SW5uZXIpIHtcblx0XHRcdFx0XHRcdHZhciBpc0JvcmRlckJveCA9IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm94U2l6aW5nXCIpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHRcdFx0XHRcdGlmIChpc0JvcmRlckJveCA9PT0gKHdhbnRJbm5lciB8fCBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdFx0LyogaW4gYm94LXNpemluZyBtb2RlLCB0aGUgQ1NTIHdpZHRoIC8gaGVpZ2h0IGFjY2Vzc29ycyBhbHJlYWR5IGdpdmUgdGhlIG91dGVyV2lkdGggLyBvdXRlckhlaWdodC4gKi9cblx0XHRcdFx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdGF1Z21lbnQgPSAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0c2lkZXMgPSBuYW1lID09PSBcIndpZHRoXCIgPyBbXCJMZWZ0XCIsIFwiUmlnaHRcIl0gOiBbXCJUb3BcIiwgXCJCb3R0b21cIl0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHMgPSBbXCJwYWRkaW5nXCIgKyBzaWRlc1swXSwgXCJwYWRkaW5nXCIgKyBzaWRlc1sxXSwgXCJib3JkZXJcIiArIHNpZGVzWzBdICsgXCJXaWR0aFwiLCBcImJvcmRlclwiICsgc2lkZXNbMV0gKyBcIldpZHRoXCJdO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlRmxvYXQoQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgZmllbGRzW2ldKSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGF1Z21lbnQgKz0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB3YW50SW5uZXIgPyAtYXVnbWVudCA6IGF1Z21lbnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnVuY3Rpb24gZ2V0RGltZW5zaW9uKG5hbWUsIHdhbnRJbm5lcikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIm5hbWVcIjpcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBuYW1lO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJleHRyYWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdChwcm9wZXJ0eVZhbHVlKSArIGF1Z21lbnREaW1lbnNpb24obmFtZSwgZWxlbWVudCwgd2FudElubmVyKTtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiaW5qZWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKHBhcnNlRmxvYXQocHJvcGVydHlWYWx1ZSkgLSBhdWdtZW50RGltZW5zaW9uKG5hbWUsIGVsZW1lbnQsIHdhbnRJbm5lcikpICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZC5pbm5lcldpZHRoID0gZ2V0RGltZW5zaW9uKFwid2lkdGhcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0Q1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWQuaW5uZXJIZWlnaHQgPSBnZXREaW1lbnNpb24oXCJoZWlnaHRcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0Q1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWQub3V0ZXJXaWR0aCA9IGdldERpbWVuc2lvbihcIndpZHRoXCIpO1xuXHRcdFx0XHRcdENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkLm91dGVySGVpZ2h0ID0gZ2V0RGltZW5zaW9uKFwiaGVpZ2h0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IENTUyBQcm9wZXJ0eSBOYW1lc1xuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0TmFtZXM6IHtcblx0XHRcdFx0LyogQ2FtZWxjYXNlIGEgcHJvcGVydHkgbmFtZSBpbnRvIGl0cyBKYXZhU2NyaXB0IG5vdGF0aW9uIChlLmcuIFwiYmFja2dyb3VuZC1jb2xvclwiID09PiBcImJhY2tncm91bmRDb2xvclwiKS5cblx0XHRcdFx0IENhbWVsY2FzaW5nIGlzIHVzZWQgdG8gbm9ybWFsaXplIHByb3BlcnR5IG5hbWVzIGJldHdlZW4gYW5kIGFjcm9zcyBjYWxscy4gKi9cblx0XHRcdFx0Y2FtZWxDYXNlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9wZXJ0eS5yZXBsYWNlKC8tKFxcdykvZywgZnVuY3Rpb24obWF0Y2gsIHN1Yk1hdGNoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3ViTWF0Y2gudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyogRm9yIFNWRyBlbGVtZW50cywgc29tZSBwcm9wZXJ0aWVzIChuYW1lbHksIGRpbWVuc2lvbmFsIG9uZXMpIGFyZSBHRVQvU0VUIHZpYSB0aGUgZWxlbWVudCdzIEhUTUwgYXR0cmlidXRlcyAoaW5zdGVhZCBvZiB2aWEgQ1NTIHN0eWxlcykuICovXG5cdFx0XHRcdFNWR0F0dHJpYnV0ZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcblx0XHRcdFx0XHR2YXIgU1ZHQXR0cmlidXRlcyA9IFwid2lkdGh8aGVpZ2h0fHh8eXxjeHxjeXxyfHJ4fHJ5fHgxfHgyfHkxfHkyXCI7XG5cblx0XHRcdFx0XHQvKiBDZXJ0YWluIGJyb3dzZXJzIHJlcXVpcmUgYW4gU1ZHIHRyYW5zZm9ybSB0byBiZSBhcHBsaWVkIGFzIGFuIGF0dHJpYnV0ZS4gKE90aGVyd2lzZSwgYXBwbGljYXRpb24gdmlhIENTUyBpcyBwcmVmZXJhYmxlIGR1ZSB0byAzRCBzdXBwb3J0LikgKi9cblx0XHRcdFx0XHRpZiAoSUUgfHwgKFZlbG9jaXR5LlN0YXRlLmlzQW5kcm9pZCAmJiAhVmVsb2NpdHkuU3RhdGUuaXNDaHJvbWUpKSB7XG5cdFx0XHRcdFx0XHRTVkdBdHRyaWJ1dGVzICs9IFwifHRyYW5zZm9ybVwiO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVnRXhwKFwiXihcIiArIFNWR0F0dHJpYnV0ZXMgKyBcIikkXCIsIFwiaVwiKS50ZXN0KHByb3BlcnR5KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyogRGV0ZXJtaW5lIHdoZXRoZXIgYSBwcm9wZXJ0eSBzaG91bGQgYmUgc2V0IHdpdGggYSB2ZW5kb3IgcHJlZml4LiAqL1xuXHRcdFx0XHQvKiBJZiBhIHByZWZpeGVkIHZlcnNpb24gb2YgdGhlIHByb3BlcnR5IGV4aXN0cywgcmV0dXJuIGl0LiBPdGhlcndpc2UsIHJldHVybiB0aGUgb3JpZ2luYWwgcHJvcGVydHkgbmFtZS5cblx0XHRcdFx0IElmIHRoZSBwcm9wZXJ0eSBpcyBub3QgYXQgYWxsIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciwgcmV0dXJuIGEgZmFsc2UgZmxhZy4gKi9cblx0XHRcdFx0cHJlZml4Q2hlY2s6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0LyogSWYgdGhpcyBwcm9wZXJ0eSBoYXMgYWxyZWFkeSBiZWVuIGNoZWNrZWQsIHJldHVybiB0aGUgY2FjaGVkIHZhbHVlLiAqL1xuXHRcdFx0XHRcdGlmIChWZWxvY2l0eS5TdGF0ZS5wcmVmaXhNYXRjaGVzW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtWZWxvY2l0eS5TdGF0ZS5wcmVmaXhNYXRjaGVzW3Byb3BlcnR5XSwgdHJ1ZV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciB2ZW5kb3JzID0gW1wiXCIsIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiwgXCJPXCJdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgdmVuZG9yc0xlbmd0aCA9IHZlbmRvcnMubGVuZ3RoOyBpIDwgdmVuZG9yc0xlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eVByZWZpeGVkO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHlQcmVmaXhlZCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8qIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgcHJvcGVydHkgdG8gY29uZm9ybSB0byBKYXZhU2NyaXB0IHZlbmRvciBwcmVmaXggbm90YXRpb24gKGUuZy4gd2Via2l0RmlsdGVyKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVByZWZpeGVkID0gdmVuZG9yc1tpXSArIHByb3BlcnR5LnJlcGxhY2UoL15cXHcvLCBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHByb3BlcnR5IGFzIHByZWZpeGVkLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoVHlwZS5pc1N0cmluZyhWZWxvY2l0eS5TdGF0ZS5wcmVmaXhFbGVtZW50LnN0eWxlW3Byb3BlcnR5UHJlZml4ZWRdKSkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIENhY2hlIHRoZSBtYXRjaC4gKi9cblx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5TdGF0ZS5wcmVmaXhNYXRjaGVzW3Byb3BlcnR5XSA9IHByb3BlcnR5UHJlZml4ZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gW3Byb3BlcnR5UHJlZml4ZWQsIHRydWVdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIHByb3BlcnR5IGluIGFueSBmb3JtLCBpbmNsdWRlIGEgZmFsc2UgZmxhZyBzbyB0aGF0IHRoZSBjYWxsZXIgY2FuIGRlY2lkZSBob3cgdG8gcHJvY2VlZC4gKi9cblx0XHRcdFx0XHRcdHJldHVybiBbcHJvcGVydHksIGZhbHNlXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgQ1NTIFByb3BlcnR5IFZhbHVlc1xuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0VmFsdWVzOiB7XG5cdFx0XHRcdC8qIEhleCB0byBSR0IgY29udmVyc2lvbi4gQ29weXJpZ2h0IFRpbSBEb3duOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYiAqL1xuXHRcdFx0XHRoZXhUb1JnYjogZnVuY3Rpb24oaGV4KSB7XG5cdFx0XHRcdFx0dmFyIHNob3J0Zm9ybVJlZ2V4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaSxcblx0XHRcdFx0XHRcdFx0bG9uZ2Zvcm1SZWdleCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2ksXG5cdFx0XHRcdFx0XHRcdHJnYlBhcnRzO1xuXG5cdFx0XHRcdFx0aGV4ID0gaGV4LnJlcGxhY2Uoc2hvcnRmb3JtUmVnZXgsIGZ1bmN0aW9uKG0sIHIsIGcsIGIpIHtcblx0XHRcdFx0XHRcdHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZ2JQYXJ0cyA9IGxvbmdmb3JtUmVnZXguZXhlYyhoZXgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJnYlBhcnRzID8gW3BhcnNlSW50KHJnYlBhcnRzWzFdLCAxNiksIHBhcnNlSW50KHJnYlBhcnRzWzJdLCAxNiksIHBhcnNlSW50KHJnYlBhcnRzWzNdLCAxNildIDogWzAsIDAsIDBdO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRpc0NTU051bGxWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHQvKiBUaGUgYnJvd3NlciBkZWZhdWx0cyBDU1MgdmFsdWVzIHRoYXQgaGF2ZSBub3QgYmVlbiBzZXQgdG8gZWl0aGVyIDAgb3Igb25lIG9mIHNldmVyYWwgcG9zc2libGUgbnVsbC12YWx1ZSBzdHJpbmdzLlxuXHRcdFx0XHRcdCBUaHVzLCB3ZSBjaGVjayBmb3IgYm90aCBmYWxzaW5lc3MgYW5kIHRoZXNlIHNwZWNpYWwgc3RyaW5ncy4gKi9cblx0XHRcdFx0XHQvKiBOdWxsLXZhbHVlIGNoZWNraW5nIGlzIHBlcmZvcm1lZCB0byBkZWZhdWx0IHRoZSBzcGVjaWFsIHN0cmluZ3MgdG8gMCAoZm9yIHRoZSBzYWtlIG9mIHR3ZWVuaW5nKSBvciB0aGVpciBob29rXG5cdFx0XHRcdFx0IHRlbXBsYXRlcyBhcyBkZWZpbmVkIGFzIENTUy5Ib29rcyAoZm9yIHRoZSBzYWtlIG9mIGhvb2sgaW5qZWN0aW9uL2V4dHJhY3Rpb24pLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IENocm9tZSByZXR1cm5zIFwicmdiYSgwLCAwLCAwLCAwKVwiIGZvciBhbiB1bmRlZmluZWQgY29sb3Igd2hlcmVhcyBJRSByZXR1cm5zIFwidHJhbnNwYXJlbnRcIi4gKi9cblx0XHRcdFx0XHRyZXR1cm4gKCF2YWx1ZSB8fCAvXihub25lfGF1dG98dHJhbnNwYXJlbnR8KHJnYmFcXCgwLCA/MCwgPzAsID8wXFwpKSkkL2kudGVzdCh2YWx1ZSkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBSZXRyaWV2ZSBhIHByb3BlcnR5J3MgZGVmYXVsdCB1bml0IHR5cGUuIFVzZWQgZm9yIGFzc2lnbmluZyBhIHVuaXQgdHlwZSB3aGVuIG9uZSBpcyBub3Qgc3VwcGxpZWQgYnkgdGhlIHVzZXIuICovXG5cdFx0XHRcdGdldFVuaXRUeXBlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdGlmICgvXihyb3RhdGV8c2tldykvaS50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwiZGVnXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICgvKF4oc2NhbGV8c2NhbGVYfHNjYWxlWXxzY2FsZVp8YWxwaGF8ZmxleEdyb3d8ZmxleEhlaWdodHx6SW5kZXh8Zm9udFdlaWdodCkkKXwoKG9wYWNpdHl8cmVkfGdyZWVufGJsdWV8YWxwaGEpJCkvaS50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0LyogVGhlIGFib3ZlIHByb3BlcnRpZXMgYXJlIHVuaXRsZXNzLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIERlZmF1bHQgdG8gcHggZm9yIGFsbCBvdGhlciBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qIEhUTUwgZWxlbWVudHMgZGVmYXVsdCB0byBhbiBhc3NvY2lhdGVkIGRpc3BsYXkgdHlwZSB3aGVuIHRoZXkncmUgbm90IHNldCB0byBkaXNwbGF5Om5vbmUuICovXG5cdFx0XHRcdC8qIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgY29ycmVjdGx5IHNldHRpbmcgdGhlIG5vbi1cIm5vbmVcIiBkaXNwbGF5IHZhbHVlIGluIGNlcnRhaW4gVmVsb2NpdHkgcmVkaXJlY3RzLCBzdWNoIGFzIGZhZGVJbi9PdXQuICovXG5cdFx0XHRcdGdldERpc3BsYXlUeXBlOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdFx0dmFyIHRhZ05hbWUgPSBlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0XHRpZiAoL14oYnxiaWd8aXxzbWFsbHx0dHxhYmJyfGFjcm9ueW18Y2l0ZXxjb2RlfGRmbnxlbXxrYmR8c3Ryb25nfHNhbXB8dmFyfGF8YmRvfGJyfGltZ3xtYXB8b2JqZWN0fHF8c2NyaXB0fHNwYW58c3VifHN1cHxidXR0b258aW5wdXR8bGFiZWx8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJpbmxpbmVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eKGxpKSQvaS50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJsaXN0LWl0ZW1cIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eKHRyKSQvaS50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJ0YWJsZS1yb3dcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eKHRhYmxlKSQvaS50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJ0YWJsZVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoL14odGJvZHkpJC9pLnRlc3QodGFnTmFtZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBcInRhYmxlLXJvdy1ncm91cFwiO1xuXHRcdFx0XHRcdFx0LyogRGVmYXVsdCB0byBcImJsb2NrXCIgd2hlbiBubyBtYXRjaCBpcyBmb3VuZC4gKi9cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwiYmxvY2tcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qIFRoZSBjbGFzcyBhZGQvcmVtb3ZlIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byB0ZW1wb3JhcmlseSBhcHBseSBhIFwidmVsb2NpdHktYW5pbWF0aW5nXCIgY2xhc3MgdG8gZWxlbWVudHMgd2hpbGUgdGhleSdyZSBhbmltYXRpbmcuICovXG5cdFx0XHRcdGFkZENsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcblx0XHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChUeXBlLmlzU3RyaW5nKGVsZW1lbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdFx0XHQvLyBFbGVtZW50LmNsYXNzTmFtZSBpcyBhcm91bmQgMTUlIGZhc3RlciB0aGVuIHNldC9nZXRBdHRyaWJ1dGVcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5jbGFzc05hbWUgKz0gKGVsZW1lbnQuY2xhc3NOYW1lLmxlbmd0aCA/IFwiIFwiIDogXCJcIikgKyBjbGFzc05hbWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBXb3JrIGFyb3VuZCBmb3IgSUUgc3RyaWN0IG1vZGUgYW5pbWF0aW5nIFNWRyAtIGFuZCBhbnl0aGluZyBlbHNlIHRoYXQgZG9lc24ndCBiZWhhdmUgY29ycmVjdGx5IC0gdGhlIHNhbWUgd2F5IGpRdWVyeSBkb2VzIGl0XG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50Q2xhc3MgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShJRSA8PSA3ID8gXCJjbGFzc05hbWVcIiA6IFwiY2xhc3NcIikgfHwgXCJcIjtcblxuXHRcdFx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGN1cnJlbnRDbGFzcyArIChjdXJyZW50Q2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcblx0XHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChUeXBlLmlzU3RyaW5nKGVsZW1lbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdFx0XHQvLyBFbGVtZW50LmNsYXNzTmFtZSBpcyBhcm91bmQgMTUlIGZhc3RlciB0aGVuIHNldC9nZXRBdHRyaWJ1dGVcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogTmVlZCBzb21lIGpzcGVyZiB0ZXN0cyBvbiBwZXJmb3JtYW5jZSAtIGNhbiB3ZSBnZXQgcmlkIG9mIHRoZSByZWdleCBhbmQgbWF5YmUgdXNlIHNwbGl0IC8gYXJyYXkgbWFuaXB1bGF0aW9uP1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnRvU3RyaW5nKCkucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbGFzc05hbWUuc3BsaXQoXCIgXCIpLmpvaW4oXCJ8XCIpICsgXCIoXFxcXHN8JClcIiwgXCJnaVwiKSwgXCIgXCIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gV29yayBhcm91bmQgZm9yIElFIHN0cmljdCBtb2RlIGFuaW1hdGluZyBTVkcgLSBhbmQgYW55dGhpbmcgZWxzZSB0aGF0IGRvZXNuJ3QgYmVoYXZlIGNvcnJlY3RseSAtIHRoZSBzYW1lIHdheSBqUXVlcnkgZG9lcyBpdFxuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudENsYXNzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoSUUgPD0gNyA/IFwiY2xhc3NOYW1lXCIgOiBcImNsYXNzXCIpIHx8IFwiXCI7XG5cblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBjdXJyZW50Q2xhc3MucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxzKVwiICsgY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5qb2luKFwifFwiKSArIFwiKFxcc3wkKVwiLCBcImdpXCIpLCBcIiBcIikpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgU3R5bGUgR2V0dGluZyAmIFNldHRpbmdcblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBUaGUgc2luZ3VsYXIgZ2V0UHJvcGVydHlWYWx1ZSwgd2hpY2ggcm91dGVzIHRoZSBsb2dpYyBmb3IgYWxsIG5vcm1hbGl6YXRpb25zLCBob29rcywgYW5kIHN0YW5kYXJkIENTUyBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0Z2V0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHJvb3RQcm9wZXJ0eVZhbHVlLCBmb3JjZVN0eWxlTG9va3VwKSB7XG5cdFx0XHRcdC8qIEdldCBhbiBlbGVtZW50J3MgY29tcHV0ZWQgcHJvcGVydHkgdmFsdWUuICovXG5cdFx0XHRcdC8qIE5vdGU6IFJldHJpZXZpbmcgdGhlIHZhbHVlIG9mIGEgQ1NTIHByb3BlcnR5IGNhbm5vdCBzaW1wbHkgYmUgcGVyZm9ybWVkIGJ5IGNoZWNraW5nIGFuIGVsZW1lbnQnc1xuXHRcdFx0XHQgc3R5bGUgYXR0cmlidXRlICh3aGljaCBvbmx5IHJlZmxlY3RzIHVzZXItZGVmaW5lZCB2YWx1ZXMpLiBJbnN0ZWFkLCB0aGUgYnJvd3NlciBtdXN0IGJlIHF1ZXJpZWQgZm9yIGEgcHJvcGVydHknc1xuXHRcdFx0XHQgKmNvbXB1dGVkKiB2YWx1ZS4gWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgZ2V0Q29tcHV0ZWRTdHlsZSBoZXJlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvd2luZG93LmdldENvbXB1dGVkU3R5bGUgKi9cblx0XHRcdFx0ZnVuY3Rpb24gY29tcHV0ZVByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcblx0XHRcdFx0XHQvKiBXaGVuIGJveC1zaXppbmcgaXNuJ3Qgc2V0IHRvIGJvcmRlci1ib3gsIGhlaWdodCBhbmQgd2lkdGggc3R5bGUgdmFsdWVzIGFyZSBpbmNvcnJlY3RseSBjb21wdXRlZCB3aGVuIGFuXG5cdFx0XHRcdFx0IGVsZW1lbnQncyBzY3JvbGxiYXJzIGFyZSB2aXNpYmxlICh3aGljaCBleHBhbmRzIHRoZSBlbGVtZW50J3MgZGltZW5zaW9ucykuIFRodXMsIHdlIGRlZmVyIHRvIHRoZSBtb3JlIGFjY3VyYXRlXG5cdFx0XHRcdFx0IG9mZnNldEhlaWdodC9XaWR0aCBwcm9wZXJ0eSwgd2hpY2ggaW5jbHVkZXMgdGhlIHRvdGFsIGRpbWVuc2lvbnMgZm9yIGludGVyaW9yLCBib3JkZXIsIHBhZGRpbmcsIGFuZCBzY3JvbGxiYXIuXG5cdFx0XHRcdFx0IFdlIHN1YnRyYWN0IGJvcmRlciBhbmQgcGFkZGluZyB0byBnZXQgdGhlIHN1bSBvZiBpbnRlcmlvciArIHNjcm9sbGJhci4gKi9cblx0XHRcdFx0XHR2YXIgY29tcHV0ZWRWYWx1ZSA9IDA7XG5cblx0XHRcdFx0XHQvKiBJRTw9OCBkb2Vzbid0IHN1cHBvcnQgd2luZG93LmdldENvbXB1dGVkU3R5bGUsIHRodXMgd2UgZGVmZXIgdG8galF1ZXJ5LCB3aGljaCBoYXMgYW4gZXh0ZW5zaXZlIGFycmF5XG5cdFx0XHRcdFx0IG9mIGhhY2tzIHRvIGFjY3VyYXRlbHkgcmV0cmlldmUgSUU4IHByb3BlcnR5IHZhbHVlcy4gUmUtaW1wbGVtZW50aW5nIHRoYXQgbG9naWMgaGVyZSBpcyBub3Qgd29ydGggYmxvYXRpbmcgdGhlXG5cdFx0XHRcdFx0IGNvZGViYXNlIGZvciBhIGR5aW5nIGJyb3dzZXIuIFRoZSBwZXJmb3JtYW5jZSByZXBlcmN1c3Npb25zIG9mIHVzaW5nIGpRdWVyeSBoZXJlIGFyZSBtaW5pbWFsIHNpbmNlXG5cdFx0XHRcdFx0IFZlbG9jaXR5IGlzIG9wdGltaXplZCB0byByYXJlbHkgKGFuZCBzb21ldGltZXMgbmV2ZXIpIHF1ZXJ5IHRoZSBET00uIEZ1cnRoZXIsIHRoZSAkLmNzcygpIGNvZGVwYXRoIGlzbid0IHRoYXQgc2xvdy4gKi9cblx0XHRcdFx0XHRpZiAoSUUgPD0gOCkge1xuXHRcdFx0XHRcdFx0Y29tcHV0ZWRWYWx1ZSA9ICQuY3NzKGVsZW1lbnQsIHByb3BlcnR5KTsgLyogR0VUICovXG5cdFx0XHRcdFx0XHQvKiBBbGwgb3RoZXIgYnJvd3NlcnMgc3VwcG9ydCBnZXRDb21wdXRlZFN0eWxlLiBUaGUgcmV0dXJuZWQgbGl2ZSBvYmplY3QgcmVmZXJlbmNlIGlzIGNhY2hlZCBvbnRvIGl0c1xuXHRcdFx0XHRcdFx0IGFzc29jaWF0ZWQgZWxlbWVudCBzbyB0aGF0IGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgcmVmZXRjaGVkIHVwb24gZXZlcnkgR0VULiAqL1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKiBCcm93c2VycyBkbyBub3QgcmV0dXJuIGhlaWdodCBhbmQgd2lkdGggdmFsdWVzIGZvciBlbGVtZW50cyB0aGF0IGFyZSBzZXQgdG8gZGlzcGxheTpcIm5vbmVcIi4gVGh1cywgd2UgdGVtcG9yYXJpbHlcblx0XHRcdFx0XHRcdCB0b2dnbGUgZGlzcGxheSB0byB0aGUgZWxlbWVudCB0eXBlJ3MgZGVmYXVsdCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdHZhciB0b2dnbGVEaXNwbGF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdGlmICgvXih3aWR0aHxoZWlnaHQpJC8udGVzdChwcm9wZXJ0eSkgJiYgQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRvZ2dsZURpc3BsYXkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImRpc3BsYXlcIiwgQ1NTLlZhbHVlcy5nZXREaXNwbGF5VHlwZShlbGVtZW50KSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciByZXZlcnREaXNwbGF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0b2dnbGVEaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKCFmb3JjZVN0eWxlTG9va3VwKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eSA9PT0gXCJoZWlnaHRcIiAmJiBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImJveFNpemluZ1wiKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgIT09IFwiYm9yZGVyLWJveFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGNvbnRlbnRCb3hIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm9yZGVyVG9wV2lkdGhcIikpIHx8IDApIC0gKHBhcnNlRmxvYXQoQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJib3JkZXJCb3R0b21XaWR0aFwiKSkgfHwgMCkgLSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInBhZGRpbmdUb3BcIikpIHx8IDApIC0gKHBhcnNlRmxvYXQoQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJwYWRkaW5nQm90dG9tXCIpKSB8fCAwKTtcblx0XHRcdFx0XHRcdFx0XHRyZXZlcnREaXNwbGF5KCk7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29udGVudEJveEhlaWdodDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gXCJ3aWR0aFwiICYmIENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm94U2l6aW5nXCIpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSAhPT0gXCJib3JkZXItYm94XCIpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgY29udGVudEJveFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIpKSB8fCAwKSAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm9yZGVyUmlnaHRXaWR0aFwiKSkgfHwgMCkgLSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInBhZGRpbmdMZWZ0XCIpKSB8fCAwKSAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwicGFkZGluZ1JpZ2h0XCIpKSB8fCAwKTtcblx0XHRcdFx0XHRcdFx0XHRyZXZlcnREaXNwbGF5KCk7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29udGVudEJveFdpZHRoO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBjb21wdXRlZFN0eWxlO1xuXG5cdFx0XHRcdFx0XHQvKiBGb3IgZWxlbWVudHMgdGhhdCBWZWxvY2l0eSBoYXNuJ3QgYmVlbiBjYWxsZWQgb24gZGlyZWN0bHkgKGUuZy4gd2hlbiBWZWxvY2l0eSBxdWVyaWVzIHRoZSBET00gb24gYmVoYWxmXG5cdFx0XHRcdFx0XHQgb2YgYSBwYXJlbnQgb2YgYW4gZWxlbWVudCBpdHMgYW5pbWF0aW5nKSwgcGVyZm9ybSBhIGRpcmVjdCBnZXRDb21wdXRlZFN0eWxlIGxvb2t1cCBzaW5jZSB0aGUgb2JqZWN0IGlzbid0IGNhY2hlZC4gKi9cblx0XHRcdFx0XHRcdGlmIChEYXRhKGVsZW1lbnQpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpOyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGNvbXB1dGVkU3R5bGUgb2JqZWN0IGhhcyB5ZXQgdG8gYmUgY2FjaGVkLCBkbyBzbyBub3cuICovXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFEYXRhKGVsZW1lbnQpLmNvbXB1dGVkU3R5bGUpIHtcblx0XHRcdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZSA9IERhdGEoZWxlbWVudCkuY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpOyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0LyogSWYgY29tcHV0ZWRTdHlsZSBpcyBjYWNoZWQsIHVzZSBpdC4gKi9cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBEYXRhKGVsZW1lbnQpLmNvbXB1dGVkU3R5bGU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElFIGFuZCBGaXJlZm94IGRvIG5vdCByZXR1cm4gYSB2YWx1ZSBmb3IgdGhlIGdlbmVyaWMgYm9yZGVyQ29sb3IgLS0gdGhleSBvbmx5IHJldHVybiBpbmRpdmlkdWFsIHZhbHVlcyBmb3IgZWFjaCBib3JkZXIgc2lkZSdzIGNvbG9yLlxuXHRcdFx0XHRcdFx0IEFsc28sIGluIGFsbCBicm93c2Vycywgd2hlbiBib3JkZXIgY29sb3JzIGFyZW4ndCBhbGwgdGhlIHNhbWUsIGEgY29tcG91bmQgdmFsdWUgaXMgcmV0dXJuZWQgdGhhdCBWZWxvY2l0eSBpc24ndCBzZXR1cCB0byBwYXJzZS5cblx0XHRcdFx0XHRcdCBTbywgYXMgYSBwb2x5ZmlsbCBmb3IgcXVlcnlpbmcgaW5kaXZpZHVhbCBib3JkZXIgc2lkZSBjb2xvcnMsIHdlIGp1c3QgcmV0dXJuIHRoZSB0b3AgYm9yZGVyJ3MgY29sb3IgYW5kIGFuaW1hdGUgYWxsIGJvcmRlcnMgZnJvbSB0aGF0IHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0aWYgKHByb3BlcnR5ID09PSBcImJvcmRlckNvbG9yXCIpIHtcblx0XHRcdFx0XHRcdFx0cHJvcGVydHkgPSBcImJvcmRlclRvcENvbG9yXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElFOSBoYXMgYSBidWcgaW4gd2hpY2ggdGhlIFwiZmlsdGVyXCIgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBmcm9tIGNvbXB1dGVkU3R5bGUgdXNpbmcgdGhlIGdldFByb3BlcnR5VmFsdWUgbWV0aG9kXG5cdFx0XHRcdFx0XHQgaW5zdGVhZCBvZiBhIGRpcmVjdCBwcm9wZXJ0eSBsb29rdXAuIFRoZSBnZXRQcm9wZXJ0eVZhbHVlIG1ldGhvZCBpcyBzbG93ZXIgdGhhbiBhIGRpcmVjdCBsb29rdXAsIHdoaWNoIGlzIHdoeSB3ZSBhdm9pZCBpdCBieSBkZWZhdWx0LiAqL1xuXHRcdFx0XHRcdFx0aWYgKElFID09PSA5ICYmIHByb3BlcnR5ID09PSBcImZpbHRlclwiKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXB1dGVkVmFsdWUgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpOyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbXB1dGVkVmFsdWUgPSBjb21wdXRlZFN0eWxlW3Byb3BlcnR5XTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogRmFsbCBiYWNrIHRvIHRoZSBwcm9wZXJ0eSdzIHN0eWxlIHZhbHVlIChpZiBkZWZpbmVkKSB3aGVuIGNvbXB1dGVkVmFsdWUgcmV0dXJucyBub3RoaW5nLFxuXHRcdFx0XHRcdFx0IHdoaWNoIGNhbiBoYXBwZW4gd2hlbiB0aGUgZWxlbWVudCBoYXNuJ3QgYmVlbiBwYWludGVkLiAqL1xuXHRcdFx0XHRcdFx0aWYgKGNvbXB1dGVkVmFsdWUgPT09IFwiXCIgfHwgY29tcHV0ZWRWYWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRjb21wdXRlZFZhbHVlID0gZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldmVydERpc3BsYXkoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBGb3IgdG9wLCByaWdodCwgYm90dG9tLCBhbmQgbGVmdCAoVFJCTCkgdmFsdWVzIHRoYXQgYXJlIHNldCB0byBcImF1dG9cIiBvbiBlbGVtZW50cyBvZiBcImZpeGVkXCIgb3IgXCJhYnNvbHV0ZVwiIHBvc2l0aW9uLFxuXHRcdFx0XHRcdCBkZWZlciB0byBqUXVlcnkgZm9yIGNvbnZlcnRpbmcgXCJhdXRvXCIgdG8gYSBudW1lcmljIHZhbHVlLiAoRm9yIGVsZW1lbnRzIHdpdGggYSBcInN0YXRpY1wiIG9yIFwicmVsYXRpdmVcIiBwb3NpdGlvbiwgXCJhdXRvXCIgaGFzIHRoZSBzYW1lXG5cdFx0XHRcdFx0IGVmZmVjdCBhcyBiZWluZyBzZXQgdG8gMCwgc28gbm8gY29udmVyc2lvbiBpcyBuZWNlc3NhcnkuKSAqL1xuXHRcdFx0XHRcdC8qIEFuIGV4YW1wbGUgb2Ygd2h5IG51bWVyaWMgY29udmVyc2lvbiBpcyBuZWNlc3Nhcnk6IFdoZW4gYW4gZWxlbWVudCB3aXRoIFwicG9zaXRpb246YWJzb2x1dGVcIiBoYXMgYW4gdW50b3VjaGVkIFwibGVmdFwiXG5cdFx0XHRcdFx0IHByb3BlcnR5LCB3aGljaCByZXZlcnRzIHRvIFwiYXV0b1wiLCBsZWZ0J3MgdmFsdWUgaXMgMCByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGVsZW1lbnQsIGJ1dCBpcyBvZnRlbiBub24temVybyByZWxhdGl2ZVxuXHRcdFx0XHRcdCB0byBpdHMgKmNvbnRhaW5pbmcqIChub3QgcGFyZW50KSBlbGVtZW50LCB3aGljaCBpcyB0aGUgbmVhcmVzdCBcInBvc2l0aW9uOnJlbGF0aXZlXCIgYW5jZXN0b3Igb3IgdGhlIHZpZXdwb3J0IChhbmQgYWx3YXlzIHRoZSB2aWV3cG9ydCBpbiB0aGUgY2FzZSBvZiBcInBvc2l0aW9uOmZpeGVkXCIpLiAqL1xuXHRcdFx0XHRcdGlmIChjb21wdXRlZFZhbHVlID09PSBcImF1dG9cIiAmJiAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC9pLnRlc3QocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHR2YXIgcG9zaXRpb24gPSBjb21wdXRlUHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInBvc2l0aW9uXCIpOyAvKiBHRVQgKi9cblxuXHRcdFx0XHRcdFx0LyogRm9yIGFic29sdXRlIHBvc2l0aW9uaW5nLCBqUXVlcnkncyAkLnBvc2l0aW9uKCkgb25seSByZXR1cm5zIHZhbHVlcyBmb3IgdG9wIGFuZCBsZWZ0O1xuXHRcdFx0XHRcdFx0IHJpZ2h0IGFuZCBib3R0b20gd2lsbCBoYXZlIHRoZWlyIFwiYXV0b1wiIHZhbHVlIHJldmVydGVkIHRvIDAuICovXG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBBIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBjcmVhdGVkIGhlcmUgc2luY2UgalF1ZXJ5IGRvZXNuJ3QgaGF2ZSBhIGxvdy1sZXZlbCBhbGlhcyBmb3IgJC5wb3NpdGlvbigpLlxuXHRcdFx0XHRcdFx0IE5vdCBhIGJpZyBkZWFsIHNpbmNlIHdlJ3JlIGN1cnJlbnRseSBpbiBhIEdFVCBiYXRjaCBhbnl3YXkuICovXG5cdFx0XHRcdFx0XHRpZiAocG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiAvdG9wfGxlZnQvaS50ZXN0KHByb3BlcnR5KSkpIHtcblx0XHRcdFx0XHRcdFx0LyogTm90ZTogalF1ZXJ5IHN0cmlwcyB0aGUgcGl4ZWwgdW5pdCBmcm9tIGl0cyByZXR1cm5lZCB2YWx1ZXM7IHdlIHJlLWFkZCBpdCBoZXJlIHRvIGNvbmZvcm0gd2l0aCBjb21wdXRlUHJvcGVydHlWYWx1ZSdzIGJlaGF2aW9yLiAqL1xuXHRcdFx0XHRcdFx0XHRjb21wdXRlZFZhbHVlID0gJChlbGVtZW50KS5wb3NpdGlvbigpW3Byb3BlcnR5XSArIFwicHhcIjsgLyogR0VUICovXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGNvbXB1dGVkVmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcHJvcGVydHlWYWx1ZTtcblxuXHRcdFx0XHQvKiBJZiB0aGlzIGlzIGEgaG9va2VkIHByb3BlcnR5IChlLmcuIFwiY2xpcExlZnRcIiBpbnN0ZWFkIG9mIHRoZSByb290IHByb3BlcnR5IG9mIFwiY2xpcFwiKSxcblx0XHRcdFx0IGV4dHJhY3QgdGhlIGhvb2sncyB2YWx1ZSBmcm9tIGEgbm9ybWFsaXplZCByb290UHJvcGVydHlWYWx1ZSB1c2luZyBDU1MuSG9va3MuZXh0cmFjdFZhbHVlKCkuICovXG5cdFx0XHRcdGlmIChDU1MuSG9va3MucmVnaXN0ZXJlZFtwcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHR2YXIgaG9vayA9IHByb3BlcnR5LFxuXHRcdFx0XHRcdFx0XHRob29rUm9vdCA9IENTUy5Ib29rcy5nZXRSb290KGhvb2spO1xuXG5cdFx0XHRcdFx0LyogSWYgYSBjYWNoZWQgcm9vdFByb3BlcnR5VmFsdWUgd2Fzbid0IHBhc3NlZCBpbiAod2hpY2ggVmVsb2NpdHkgYWx3YXlzIGF0dGVtcHRzIHRvIGRvIGluIG9yZGVyIHRvIGF2b2lkIHJlcXVlcnlpbmcgdGhlIERPTSksXG5cdFx0XHRcdFx0IHF1ZXJ5IHRoZSBET00gZm9yIHRoZSByb290IHByb3BlcnR5J3MgdmFsdWUuICovXG5cdFx0XHRcdFx0aWYgKHJvb3RQcm9wZXJ0eVZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdC8qIFNpbmNlIHRoZSBicm93c2VyIGlzIG5vdyBiZWluZyBkaXJlY3RseSBxdWVyaWVkLCB1c2UgdGhlIG9mZmljaWFsIHBvc3QtcHJlZml4aW5nIHByb3BlcnR5IG5hbWUgZm9yIHRoaXMgbG9va3VwLiAqL1xuXHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBDU1MuTmFtZXMucHJlZml4Q2hlY2soaG9va1Jvb3QpWzBdKTsgLyogR0VUICovXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogSWYgdGhpcyByb290IGhhcyBhIG5vcm1hbGl6YXRpb24gcmVnaXN0ZXJlZCwgcGVmb3JtIHRoZSBhc3NvY2lhdGVkIG5vcm1hbGl6YXRpb24gZXh0cmFjdGlvbi4gKi9cblx0XHRcdFx0XHRpZiAoQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbaG9va1Jvb3RdKSB7XG5cdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW2hvb2tSb290XShcImV4dHJhY3RcIiwgZWxlbWVudCwgcm9vdFByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIEV4dHJhY3QgdGhlIGhvb2sncyB2YWx1ZS4gKi9cblx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gQ1NTLkhvb2tzLmV4dHJhY3RWYWx1ZShob29rLCByb290UHJvcGVydHlWYWx1ZSk7XG5cblx0XHRcdFx0XHQvKiBJZiB0aGlzIGlzIGEgbm9ybWFsaXplZCBwcm9wZXJ0eSAoZS5nLiBcIm9wYWNpdHlcIiBiZWNvbWVzIFwiZmlsdGVyXCIgaW4gPD1JRTgpIG9yIFwidHJhbnNsYXRlWFwiIGJlY29tZXMgXCJ0cmFuc2Zvcm1cIiksXG5cdFx0XHRcdFx0IG5vcm1hbGl6ZSB0aGUgcHJvcGVydHkncyBuYW1lIGFuZCB2YWx1ZSwgYW5kIGhhbmRsZSB0aGUgc3BlY2lhbCBjYXNlIG9mIHRyYW5zZm9ybXMuICovXG5cdFx0XHRcdFx0LyogTm90ZTogTm9ybWFsaXppbmcgYSBwcm9wZXJ0eSBpcyBtdXR1YWxseSBleGNsdXNpdmUgZnJvbSBob29raW5nIGEgcHJvcGVydHkgc2luY2UgaG9vay1leHRyYWN0ZWQgdmFsdWVzIGFyZSBzdHJpY3RseVxuXHRcdFx0XHRcdCBudW1lcmljYWwgYW5kIHRoZXJlZm9yZSBkbyBub3QgcmVxdWlyZSBub3JtYWxpemF0aW9uIGV4dHJhY3Rpb24uICovXG5cdFx0XHRcdH0gZWxzZSBpZiAoQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcHJvcGVydHldKSB7XG5cdFx0XHRcdFx0dmFyIG5vcm1hbGl6ZWRQcm9wZXJ0eU5hbWUsXG5cdFx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wZXJ0eVZhbHVlO1xuXG5cdFx0XHRcdFx0bm9ybWFsaXplZFByb3BlcnR5TmFtZSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XShcIm5hbWVcIiwgZWxlbWVudCk7XG5cblx0XHRcdFx0XHQvKiBUcmFuc2Zvcm0gdmFsdWVzIGFyZSBjYWxjdWxhdGVkIHZpYSBub3JtYWxpemF0aW9uIGV4dHJhY3Rpb24gKHNlZSBiZWxvdyksIHdoaWNoIGNoZWNrcyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgdHJhbnNmb3JtQ2FjaGUuXG5cdFx0XHRcdFx0IEF0IG5vIHBvaW50IGRvIHRyYW5zZm9ybSBHRVRzIGV2ZXIgYWN0dWFsbHkgcXVlcnkgdGhlIERPTTsgaW5pdGlhbCBzdHlsZXNoZWV0IHZhbHVlcyBhcmUgbmV2ZXIgcHJvY2Vzc2VkLlxuXHRcdFx0XHRcdCBUaGlzIGlzIGJlY2F1c2UgcGFyc2luZyAzRCB0cmFuc2Zvcm0gbWF0cmljZXMgaXMgbm90IGFsd2F5cyBhY2N1cmF0ZSBhbmQgd291bGQgYmxvYXQgb3VyIGNvZGViYXNlO1xuXHRcdFx0XHRcdCB0aHVzLCBub3JtYWxpemF0aW9uIGV4dHJhY3Rpb24gZGVmYXVsdHMgaW5pdGlhbCB0cmFuc2Zvcm0gdmFsdWVzIHRvIHRoZWlyIHplcm8tdmFsdWVzIChlLmcuIDEgZm9yIHNjYWxlWCBhbmQgMCBmb3IgdHJhbnNsYXRlWCkuICovXG5cdFx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wZXJ0eU5hbWUgIT09IFwidHJhbnNmb3JtXCIpIHtcblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wZXJ0eVZhbHVlID0gY29tcHV0ZVByb3BlcnR5VmFsdWUoZWxlbWVudCwgQ1NTLk5hbWVzLnByZWZpeENoZWNrKG5vcm1hbGl6ZWRQcm9wZXJ0eU5hbWUpWzBdKTsgLyogR0VUICovXG5cblx0XHRcdFx0XHRcdC8qIElmIHRoZSB2YWx1ZSBpcyBhIENTUyBudWxsLXZhbHVlIGFuZCB0aGlzIHByb3BlcnR5IGhhcyBhIGhvb2sgdGVtcGxhdGUsIHVzZSB0aGF0IHplcm8tdmFsdWUgdGVtcGxhdGUgc28gdGhhdCBob29rcyBjYW4gYmUgZXh0cmFjdGVkIGZyb20gaXQuICovXG5cdFx0XHRcdFx0XHRpZiAoQ1NTLlZhbHVlcy5pc0NTU051bGxWYWx1ZShub3JtYWxpemVkUHJvcGVydHlWYWx1ZSkgJiYgQ1NTLkhvb2tzLnRlbXBsYXRlc1twcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BlcnR5VmFsdWUgPSBDU1MuSG9va3MudGVtcGxhdGVzW3Byb3BlcnR5XVsxXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcHJvcGVydHldKFwiZXh0cmFjdFwiLCBlbGVtZW50LCBub3JtYWxpemVkUHJvcGVydHlWYWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBJZiBhIChudW1lcmljKSB2YWx1ZSB3YXNuJ3QgcHJvZHVjZWQgdmlhIGhvb2sgZXh0cmFjdGlvbiBvciBub3JtYWxpemF0aW9uLCBxdWVyeSB0aGUgRE9NLiAqL1xuXHRcdFx0XHRpZiAoIS9eW1xcZC1dLy50ZXN0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0LyogRm9yIFNWRyBlbGVtZW50cywgZGltZW5zaW9uYWwgcHJvcGVydGllcyAod2hpY2ggU1ZHQXR0cmlidXRlKCkgZGV0ZWN0cykgYXJlIHR3ZWVuZWQgdmlhXG5cdFx0XHRcdFx0IHRoZWlyIEhUTUwgYXR0cmlidXRlIHZhbHVlcyBpbnN0ZWFkIG9mIHRoZWlyIENTUyBzdHlsZSB2YWx1ZXMuICovXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5pc1NWRyAmJiBDU1MuTmFtZXMuU1ZHQXR0cmlidXRlKHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0LyogU2luY2UgdGhlIGhlaWdodC93aWR0aCBhdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgc2V0IG1hbnVhbGx5LCB0aGV5IGRvbid0IHJlZmxlY3QgY29tcHV0ZWQgdmFsdWVzLlxuXHRcdFx0XHRcdFx0IFRodXMsIHdlIHVzZSB1c2UgZ2V0QkJveCgpIHRvIGVuc3VyZSB3ZSBhbHdheXMgZ2V0IHZhbHVlcyBmb3IgZWxlbWVudHMgd2l0aCB1bmRlZmluZWQgaGVpZ2h0L3dpZHRoIGF0dHJpYnV0ZXMuICovXG5cdFx0XHRcdFx0XHRpZiAoL14oaGVpZ2h0fHdpZHRoKSQvaS50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHQvKiBGaXJlZm94IHRocm93cyBhbiBlcnJvciBpZiAuZ2V0QkJveCgpIGlzIGNhbGxlZCBvbiBhbiBTVkcgdGhhdCBpc24ndCBhdHRhY2hlZCB0byB0aGUgRE9NLiAqL1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBlbGVtZW50LmdldEJCb3goKVtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0LyogT3RoZXJ3aXNlLCBhY2Nlc3MgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBkaXJlY3RseS4gKi9cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShwcm9wZXJ0eSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBjb21wdXRlUHJvcGVydHlWYWx1ZShlbGVtZW50LCBDU1MuTmFtZXMucHJlZml4Q2hlY2socHJvcGVydHkpWzBdKTsgLyogR0VUICovXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogU2luY2UgcHJvcGVydHkgbG9va3VwcyBhcmUgZm9yIGFuaW1hdGlvbiBwdXJwb3NlcyAod2hpY2ggZW50YWlscyBjb21wdXRpbmcgdGhlIG51bWVyaWMgZGVsdGEgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlcyksXG5cdFx0XHRcdCBjb252ZXJ0IENTUyBudWxsLXZhbHVlcyB0byBhbiBpbnRlZ2VyIG9mIHZhbHVlIDAuICovXG5cdFx0XHRcdGlmIChDU1MuVmFsdWVzLmlzQ1NTTnVsbFZhbHVlKHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSA9IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcgPj0gMikge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiR2V0IFwiICsgcHJvcGVydHkgKyBcIjogXCIgKyBwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdC8qIFRoZSBzaW5ndWxhciBzZXRQcm9wZXJ0eVZhbHVlLCB3aGljaCByb3V0ZXMgdGhlIGxvZ2ljIGZvciBhbGwgbm9ybWFsaXphdGlvbnMsIGhvb2tzLCBhbmQgc3RhbmRhcmQgQ1NTIHByb3BlcnRpZXMuICovXG5cdFx0XHRzZXRQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSwgcHJvcGVydHlWYWx1ZSwgcm9vdFByb3BlcnR5VmFsdWUsIHNjcm9sbERhdGEpIHtcblx0XHRcdFx0dmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5O1xuXG5cdFx0XHRcdC8qIEluIG9yZGVyIHRvIGJlIHN1YmplY3RlZCB0byBjYWxsIG9wdGlvbnMgYW5kIGVsZW1lbnQgcXVldWVpbmcsIHNjcm9sbCBhbmltYXRpb24gaXMgcm91dGVkIHRocm91Z2ggVmVsb2NpdHkgYXMgaWYgaXQgd2VyZSBhIHN0YW5kYXJkIENTUyBwcm9wZXJ0eS4gKi9cblx0XHRcdFx0aWYgKHByb3BlcnR5ID09PSBcInNjcm9sbFwiKSB7XG5cdFx0XHRcdFx0LyogSWYgYSBjb250YWluZXIgb3B0aW9uIGlzIHByZXNlbnQsIHNjcm9sbCB0aGUgY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGJyb3dzZXIgd2luZG93LiAqL1xuXHRcdFx0XHRcdGlmIChzY3JvbGxEYXRhLmNvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0c2Nyb2xsRGF0YS5jb250YWluZXJbXCJzY3JvbGxcIiArIHNjcm9sbERhdGEuZGlyZWN0aW9uXSA9IHByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0XHQvKiBPdGhlcndpc2UsIFZlbG9jaXR5IGRlZmF1bHRzIHRvIHNjcm9sbGluZyB0aGUgYnJvd3NlciB3aW5kb3cuICovXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChzY3JvbGxEYXRhLmRpcmVjdGlvbiA9PT0gXCJMZWZ0XCIpIHtcblx0XHRcdFx0XHRcdFx0d2luZG93LnNjcm9sbFRvKHByb3BlcnR5VmFsdWUsIHNjcm9sbERhdGEuYWx0ZXJuYXRlVmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0d2luZG93LnNjcm9sbFRvKHNjcm9sbERhdGEuYWx0ZXJuYXRlVmFsdWUsIHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBUcmFuc2Zvcm1zICh0cmFuc2xhdGVYLCByb3RhdGVaLCBldGMuKSBhcmUgYXBwbGllZCB0byBhIHBlci1lbGVtZW50IHRyYW5zZm9ybUNhY2hlIG9iamVjdCwgd2hpY2ggaXMgbWFudWFsbHkgZmx1c2hlZCB2aWEgZmx1c2hUcmFuc2Zvcm1DYWNoZSgpLlxuXHRcdFx0XHRcdCBUaHVzLCBmb3Igbm93LCB3ZSBtZXJlbHkgY2FjaGUgdHJhbnNmb3JtcyBiZWluZyBTRVQuICovXG5cdFx0XHRcdFx0aWYgKENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XSAmJiBDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtwcm9wZXJ0eV0oXCJuYW1lXCIsIGVsZW1lbnQpID09PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHRcdFx0XHQvKiBQZXJmb3JtIGEgbm9ybWFsaXphdGlvbiBpbmplY3Rpb24uICovXG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBUaGUgbm9ybWFsaXphdGlvbiBsb2dpYyBoYW5kbGVzIHRoZSB0cmFuc2Zvcm1DYWNoZSB1cGRhdGluZy4gKi9cblx0XHRcdFx0XHRcdENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XShcImluamVjdFwiLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKTtcblxuXHRcdFx0XHRcdFx0cHJvcGVydHlOYW1lID0gXCJ0cmFuc2Zvcm1cIjtcblx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBEYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlW3Byb3BlcnR5XTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogSW5qZWN0IGhvb2tzLiAqL1xuXHRcdFx0XHRcdFx0aWYgKENTUy5Ib29rcy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaG9va05hbWUgPSBwcm9wZXJ0eSxcblx0XHRcdFx0XHRcdFx0XHRcdGhvb2tSb290ID0gQ1NTLkhvb2tzLmdldFJvb3QocHJvcGVydHkpO1xuXG5cdFx0XHRcdFx0XHRcdC8qIElmIGEgY2FjaGVkIHJvb3RQcm9wZXJ0eVZhbHVlIHdhcyBub3QgcHJvdmlkZWQsIHF1ZXJ5IHRoZSBET00gZm9yIHRoZSBob29rUm9vdCdzIGN1cnJlbnQgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlID0gcm9vdFByb3BlcnR5VmFsdWUgfHwgQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgaG9va1Jvb3QpOyAvKiBHRVQgKi9cblxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gQ1NTLkhvb2tzLmluamVjdFZhbHVlKGhvb2tOYW1lLCBwcm9wZXJ0eVZhbHVlLCByb290UHJvcGVydHlWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5ID0gaG9va1Jvb3Q7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIE5vcm1hbGl6ZSBuYW1lcyBhbmQgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdFx0aWYgKENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcHJvcGVydHldKFwiaW5qZWN0XCIsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XShcIm5hbWVcIiwgZWxlbWVudCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIEFzc2lnbiB0aGUgYXBwcm9wcmlhdGUgdmVuZG9yIHByZWZpeCBiZWZvcmUgcGVyZm9ybWluZyBhbiBvZmZpY2lhbCBzdHlsZSB1cGRhdGUuICovXG5cdFx0XHRcdFx0XHRwcm9wZXJ0eU5hbWUgPSBDU1MuTmFtZXMucHJlZml4Q2hlY2socHJvcGVydHkpWzBdO1xuXG5cdFx0XHRcdFx0XHQvKiBBIHRyeS9jYXRjaCBpcyB1c2VkIGZvciBJRTw9OCwgd2hpY2ggdGhyb3dzIGFuIGVycm9yIHdoZW4gXCJpbnZhbGlkXCIgQ1NTIHZhbHVlcyBhcmUgc2V0LCBlLmcuIGEgbmVnYXRpdmUgd2lkdGguXG5cdFx0XHRcdFx0XHQgVHJ5L2NhdGNoIGlzIGF2b2lkZWQgZm9yIG90aGVyIGJyb3dzZXJzIHNpbmNlIGl0IGluY3VycyBhIHBlcmZvcm1hbmNlIG92ZXJoZWFkLiAqL1xuXHRcdFx0XHRcdFx0aWYgKElFIDw9IDgpIHtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnN0eWxlW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgW1wiICsgcHJvcGVydHlWYWx1ZSArIFwiXSBmb3IgW1wiICsgcHJvcGVydHlOYW1lICsgXCJdXCIpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvKiBTVkcgZWxlbWVudHMgaGF2ZSB0aGVpciBkaW1lbnNpb25hbCBwcm9wZXJ0aWVzICh3aWR0aCwgaGVpZ2h0LCB4LCB5LCBjeCwgZXRjLikgYXBwbGllZCBkaXJlY3RseSBhcyBhdHRyaWJ1dGVzIGluc3RlYWQgb2YgYXMgc3R5bGVzLiAqL1xuXHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBJRTggZG9lcyBub3Qgc3VwcG9ydCBTVkcgZWxlbWVudHMsIHNvIGl0J3Mgb2theSB0aGF0IHdlIHNraXAgaXQgZm9yIFNWRyBhbmltYXRpb24uICovXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZGF0YSA9IERhdGEoZWxlbWVudCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5pc1NWRyAmJiBDU1MuTmFtZXMuU1ZHQXR0cmlidXRlKHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IEZvciBTVkcgYXR0cmlidXRlcywgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG5hbWVzIGFyZSBuZXZlciB1c2VkLiAqL1xuXHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IE5vdCBhbGwgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIGFuaW1hdGVkIHZpYSBhdHRyaWJ1dGVzLCBidXQgdGhlIGJyb3dzZXIgd29uJ3QgdGhyb3cgYW4gZXJyb3IgZm9yIHVuc3VwcG9ydGVkIHByb3BlcnRpZXMuICovXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcGVydHksIHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQuc3R5bGVbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnID49IDIpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJTZXQgXCIgKyBwcm9wZXJ0eSArIFwiIChcIiArIHByb3BlcnR5TmFtZSArIFwiKTogXCIgKyBwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBSZXR1cm4gdGhlIG5vcm1hbGl6ZWQgcHJvcGVydHkgbmFtZSBhbmQgdmFsdWUgaW4gY2FzZSB0aGUgY2FsbGVyIHdhbnRzIHRvIGtub3cgaG93IHRoZXNlIHZhbHVlcyB3ZXJlIG1vZGlmaWVkIGJlZm9yZSBiZWluZyBhcHBsaWVkIHRvIHRoZSBET00uICovXG5cdFx0XHRcdHJldHVybiBbcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlXTtcblx0XHRcdH0sXG5cdFx0XHQvKiBUbyBpbmNyZWFzZSBwZXJmb3JtYW5jZSBieSBiYXRjaGluZyB0cmFuc2Zvcm0gdXBkYXRlcyBpbnRvIGEgc2luZ2xlIFNFVCwgdHJhbnNmb3JtcyBhcmUgbm90IGRpcmVjdGx5IGFwcGxpZWQgdG8gYW4gZWxlbWVudCB1bnRpbCBmbHVzaFRyYW5zZm9ybUNhY2hlKCkgaXMgY2FsbGVkLiAqL1xuXHRcdFx0LyogTm90ZTogVmVsb2NpdHkgYXBwbGllcyB0cmFuc2Zvcm0gcHJvcGVydGllcyBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGNocm9ub2dpY2FsbHkgaW50cm9kdWNlZCB0byB0aGUgZWxlbWVudCdzIENTUyBzdHlsZXMuICovXG5cdFx0XHRmbHVzaFRyYW5zZm9ybUNhY2hlOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdHZhciB0cmFuc2Zvcm1TdHJpbmcgPSBcIlwiLFxuXHRcdFx0XHRcdFx0ZGF0YSA9IERhdGEoZWxlbWVudCk7XG5cblx0XHRcdFx0LyogQ2VydGFpbiBicm93c2VycyByZXF1aXJlIHRoYXQgU1ZHIHRyYW5zZm9ybXMgYmUgYXBwbGllZCBhcyBhbiBhdHRyaWJ1dGUuIEhvd2V2ZXIsIHRoZSBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSB0YWtlcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgQ1NTJ3MgdHJhbnNmb3JtIHN0cmluZ1xuXHRcdFx0XHQgKHVuaXRzIGFyZSBkcm9wcGVkIGFuZCwgZXhjZXB0IGZvciBza2V3WC9ZLCBzdWJwcm9wZXJ0aWVzIGFyZSBtZXJnZWQgaW50byB0aGVpciBtYXN0ZXIgcHJvcGVydHkgLS0gZS5nLiBzY2FsZVggYW5kIHNjYWxlWSBhcmUgbWVyZ2VkIGludG8gc2NhbGUoWCBZKS4gKi9cblx0XHRcdFx0aWYgKChJRSB8fCAoVmVsb2NpdHkuU3RhdGUuaXNBbmRyb2lkICYmICFWZWxvY2l0eS5TdGF0ZS5pc0Nocm9tZSkpICYmIGRhdGEgJiYgZGF0YS5pc1NWRykge1xuXHRcdFx0XHRcdC8qIFNpbmNlIHRyYW5zZm9ybSB2YWx1ZXMgYXJlIHN0b3JlZCBpbiB0aGVpciBwYXJlbnRoZXNlcy13cmFwcGVkIGZvcm0sIHdlIHVzZSBhIGhlbHBlciBmdW5jdGlvbiB0byBzdHJpcCBvdXQgdGhlaXIgbnVtZXJpYyB2YWx1ZXMuXG5cdFx0XHRcdFx0IEZ1cnRoZXIsIFNWRyB0cmFuc2Zvcm0gcHJvcGVydGllcyBvbmx5IHRha2UgdW5pdGxlc3MgKHJlcHJlc2VudGluZyBwaXhlbHMpIHZhbHVlcywgc28gaXQncyBva2F5IHRoYXQgcGFyc2VGbG9hdCgpIHN0cmlwcyB0aGUgdW5pdCBzdWZmaXhlZCB0byB0aGUgZmxvYXQgdmFsdWUuICovXG5cdFx0XHRcdFx0dmFyIGdldFRyYW5zZm9ybUZsb2F0ID0gZnVuY3Rpb24odHJhbnNmb3JtUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHRyYW5zZm9ybVByb3BlcnR5KSk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8qIENyZWF0ZSBhbiBvYmplY3QgdG8gb3JnYW5pemUgYWxsIHRoZSB0cmFuc2Zvcm1zIHRoYXQgd2UnbGwgYXBwbHkgdG8gdGhlIFNWRyBlbGVtZW50LiBUbyBrZWVwIHRoZSBsb2dpYyBzaW1wbGUsXG5cdFx0XHRcdFx0IHdlIHByb2Nlc3MgKmFsbCogdHJhbnNmb3JtIHByb3BlcnRpZXMgLS0gZXZlbiB0aG9zZSB0aGF0IG1heSBub3QgYmUgZXhwbGljaXRseSBhcHBsaWVkIChzaW5jZSB0aGV5IGRlZmF1bHQgdG8gdGhlaXIgemVyby12YWx1ZXMgYW55d2F5KS4gKi9cblx0XHRcdFx0XHR2YXIgU1ZHVHJhbnNmb3JtcyA9IHtcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZTogW2dldFRyYW5zZm9ybUZsb2F0KFwidHJhbnNsYXRlWFwiKSwgZ2V0VHJhbnNmb3JtRmxvYXQoXCJ0cmFuc2xhdGVZXCIpXSxcblx0XHRcdFx0XHRcdHNrZXdYOiBbZ2V0VHJhbnNmb3JtRmxvYXQoXCJza2V3WFwiKV0sIHNrZXdZOiBbZ2V0VHJhbnNmb3JtRmxvYXQoXCJza2V3WVwiKV0sXG5cdFx0XHRcdFx0XHQvKiBJZiB0aGUgc2NhbGUgcHJvcGVydHkgaXMgc2V0IChub24tMSksIHVzZSB0aGF0IHZhbHVlIGZvciB0aGUgc2NhbGVYIGFuZCBzY2FsZVkgdmFsdWVzXG5cdFx0XHRcdFx0XHQgKHRoaXMgYmVoYXZpb3IgbWltaWNzIHRoZSByZXN1bHQgb2YgYW5pbWF0aW5nIGFsbCB0aGVzZSBwcm9wZXJ0aWVzIGF0IG9uY2Ugb24gSFRNTCBlbGVtZW50cykuICovXG5cdFx0XHRcdFx0XHRzY2FsZTogZ2V0VHJhbnNmb3JtRmxvYXQoXCJzY2FsZVwiKSAhPT0gMSA/IFtnZXRUcmFuc2Zvcm1GbG9hdChcInNjYWxlXCIpLCBnZXRUcmFuc2Zvcm1GbG9hdChcInNjYWxlXCIpXSA6IFtnZXRUcmFuc2Zvcm1GbG9hdChcInNjYWxlWFwiKSwgZ2V0VHJhbnNmb3JtRmxvYXQoXCJzY2FsZVlcIildLFxuXHRcdFx0XHRcdFx0LyogTm90ZTogU1ZHJ3Mgcm90YXRlIHRyYW5zZm9ybSB0YWtlcyB0aHJlZSB2YWx1ZXM6IHJvdGF0aW9uIGRlZ3JlZXMgZm9sbG93ZWQgYnkgdGhlIFggYW5kIFkgdmFsdWVzXG5cdFx0XHRcdFx0XHQgZGVmaW5pbmcgdGhlIHJvdGF0aW9uJ3Mgb3JpZ2luIHBvaW50LiBXZSBpZ25vcmUgdGhlIG9yaWdpbiB2YWx1ZXMgKGRlZmF1bHQgdGhlbSB0byAwKS4gKi9cblx0XHRcdFx0XHRcdHJvdGF0ZTogW2dldFRyYW5zZm9ybUZsb2F0KFwicm90YXRlWlwiKSwgMCwgMF1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBpbiB0aGUgdXNlci1kZWZpbmVkIHByb3BlcnR5IG1hcCBvcmRlci5cblx0XHRcdFx0XHQgKFRoaXMgbWltaWNzIHRoZSBiZWhhdmlvciBvZiBub24tU1ZHIHRyYW5zZm9ybSBhbmltYXRpb24uKSAqL1xuXHRcdFx0XHRcdCQuZWFjaChEYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlLCBmdW5jdGlvbih0cmFuc2Zvcm1OYW1lKSB7XG5cdFx0XHRcdFx0XHQvKiBFeGNlcHQgZm9yIHdpdGggc2tld1gvWSwgcmV2ZXJ0IHRoZSBheGlzLXNwZWNpZmljIHRyYW5zZm9ybSBzdWJwcm9wZXJ0aWVzIHRvIHRoZWlyIGF4aXMtZnJlZSBtYXN0ZXJcblx0XHRcdFx0XHRcdCBwcm9wZXJ0aWVzIHNvIHRoYXQgdGhleSBtYXRjaCB1cCB3aXRoIFNWRydzIGFjY2VwdGVkIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0XHRcdFx0aWYgKC9edHJhbnNsYXRlL2kudGVzdCh0cmFuc2Zvcm1OYW1lKSkge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1OYW1lID0gXCJ0cmFuc2xhdGVcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoL15zY2FsZS9pLnRlc3QodHJhbnNmb3JtTmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtTmFtZSA9IFwic2NhbGVcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoL15yb3RhdGUvaS50ZXN0KHRyYW5zZm9ybU5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybU5hbWUgPSBcInJvdGF0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBDaGVjayB0aGF0IHdlIGhhdmVuJ3QgeWV0IGRlbGV0ZWQgdGhlIHByb3BlcnR5IGZyb20gdGhlIFNWR1RyYW5zZm9ybXMgY29udGFpbmVyLiAqL1xuXHRcdFx0XHRcdFx0aWYgKFNWR1RyYW5zZm9ybXNbdHJhbnNmb3JtTmFtZV0pIHtcblx0XHRcdFx0XHRcdFx0LyogQXBwZW5kIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgaW4gdGhlIFNWRy1zdXBwb3J0ZWQgdHJhbnNmb3JtIGZvcm1hdC4gQXMgcGVyIHRoZSBzcGVjLCBzdXJyb3VuZCB0aGUgc3BhY2UtZGVsaW1pdGVkIHZhbHVlcyBpbiBwYXJlbnRoZXNlcy4gKi9cblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtU3RyaW5nICs9IHRyYW5zZm9ybU5hbWUgKyBcIihcIiArIFNWR1RyYW5zZm9ybXNbdHJhbnNmb3JtTmFtZV0uam9pbihcIiBcIikgKyBcIilcIiArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRcdC8qIEFmdGVyIHByb2Nlc3NpbmcgYW4gU1ZHIHRyYW5zZm9ybSBwcm9wZXJ0eSwgZGVsZXRlIGl0IGZyb20gdGhlIFNWR1RyYW5zZm9ybXMgY29udGFpbmVyIHNvIHdlIGRvbid0XG5cdFx0XHRcdFx0XHRcdCByZS1pbnNlcnQgdGhlIHNhbWUgbWFzdGVyIHByb3BlcnR5IGlmIHdlIGVuY291bnRlciBhbm90aGVyIG9uZSBvZiBpdHMgYXhpcy1zcGVjaWZpYyBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgU1ZHVHJhbnNmb3Jtc1t0cmFuc2Zvcm1OYW1lXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtVmFsdWUsXG5cdFx0XHRcdFx0XHRcdHBlcnNwZWN0aXZlO1xuXG5cdFx0XHRcdFx0LyogVHJhbnNmb3JtIHByb3BlcnRpZXMgYXJlIHN0b3JlZCBhcyBtZW1iZXJzIG9mIHRoZSB0cmFuc2Zvcm1DYWNoZSBvYmplY3QuIENvbmNhdGVuYXRlIGFsbCB0aGUgbWVtYmVycyBpbnRvIGEgc3RyaW5nLiAqL1xuXHRcdFx0XHRcdCQuZWFjaChEYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlLCBmdW5jdGlvbih0cmFuc2Zvcm1OYW1lKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1WYWx1ZSA9IERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV07XG5cblx0XHRcdFx0XHRcdC8qIFRyYW5zZm9ybSdzIHBlcnNwZWN0aXZlIHN1YnByb3BlcnR5IG11c3QgYmUgc2V0IGZpcnN0IGluIG9yZGVyIHRvIHRha2UgZWZmZWN0LiBTdG9yZSBpdCB0ZW1wb3JhcmlseS4gKi9cblx0XHRcdFx0XHRcdGlmICh0cmFuc2Zvcm1OYW1lID09PSBcInRyYW5zZm9ybVBlcnNwZWN0aXZlXCIpIHtcblx0XHRcdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSB0cmFuc2Zvcm1WYWx1ZTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElFOSBvbmx5IHN1cHBvcnRzIG9uZSByb3RhdGlvbiB0eXBlLCByb3RhdGVaLCB3aGljaCBpdCByZWZlcnMgdG8gYXMgXCJyb3RhdGVcIi4gKi9cblx0XHRcdFx0XHRcdGlmIChJRSA9PT0gOSAmJiB0cmFuc2Zvcm1OYW1lID09PSBcInJvdGF0ZVpcIikge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1OYW1lID0gXCJyb3RhdGVcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dHJhbnNmb3JtU3RyaW5nICs9IHRyYW5zZm9ybU5hbWUgKyB0cmFuc2Zvcm1WYWx1ZSArIFwiIFwiO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0LyogSWYgcHJlc2VudCwgc2V0IHRoZSBwZXJzcGVjdGl2ZSBzdWJwcm9wZXJ0eSBmaXJzdC4gKi9cblx0XHRcdFx0XHRpZiAocGVyc3BlY3RpdmUpIHtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybVN0cmluZyA9IFwicGVyc3BlY3RpdmVcIiArIHBlcnNwZWN0aXZlICsgXCIgXCIgKyB0cmFuc2Zvcm1TdHJpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtU3RyaW5nKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyogUmVnaXN0ZXIgaG9va3MgYW5kIG5vcm1hbGl6YXRpb25zLiAqL1xuXHRcdENTUy5Ib29rcy5yZWdpc3RlcigpO1xuXHRcdENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcigpO1xuXG5cdFx0LyogQWxsb3cgaG9vayBzZXR0aW5nIGluIHRoZSBzYW1lIGZhc2hpb24gYXMgalF1ZXJ5J3MgJC5jc3MoKS4gKi9cblx0XHRWZWxvY2l0eS5ob29rID0gZnVuY3Rpb24oZWxlbWVudHMsIGFyZzIsIGFyZzMpIHtcblx0XHRcdHZhciB2YWx1ZTtcblxuXHRcdFx0ZWxlbWVudHMgPSBzYW5pdGl6ZUVsZW1lbnRzKGVsZW1lbnRzKTtcblxuXHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdFx0XHRcdC8qIEluaXRpYWxpemUgVmVsb2NpdHkncyBwZXItZWxlbWVudCBkYXRhIGNhY2hlIGlmIHRoaXMgZWxlbWVudCBoYXNuJ3QgcHJldmlvdXNseSBiZWVuIGFuaW1hdGVkLiAqL1xuXHRcdFx0XHRpZiAoRGF0YShlbGVtZW50KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0VmVsb2NpdHkuaW5pdChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIEdldCBwcm9wZXJ0eSB2YWx1ZS4gSWYgYW4gZWxlbWVudCBzZXQgd2FzIHBhc3NlZCBpbiwgb25seSByZXR1cm4gdGhlIHZhbHVlIGZvciB0aGUgZmlyc3QgZWxlbWVudC4gKi9cblx0XHRcdFx0aWYgKGFyZzMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIGFyZzIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvKiBTZXQgcHJvcGVydHkgdmFsdWUuICovXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Lyogc1BWIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIG5vcm1hbGl6ZWQgcHJvcGVydHlOYW1lL3Byb3BlcnR5VmFsdWUgcGFpciB1c2VkIHRvIHVwZGF0ZSB0aGUgRE9NLiAqL1xuXHRcdFx0XHRcdHZhciBhZGp1c3RlZFNldCA9IENTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIGFyZzIsIGFyZzMpO1xuXG5cdFx0XHRcdFx0LyogVHJhbnNmb3JtIHByb3BlcnRpZXMgZG9uJ3QgYXV0b21hdGljYWxseSBzZXQuIFRoZXkgaGF2ZSB0byBiZSBmbHVzaGVkIHRvIHRoZSBET00uICovXG5cdFx0XHRcdFx0aWYgKGFkanVzdGVkU2V0WzBdID09PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHRcdFx0XHRWZWxvY2l0eS5DU1MuZmx1c2hUcmFuc2Zvcm1DYWNoZShlbGVtZW50KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YWx1ZSA9IGFkanVzdGVkU2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHQvKioqKioqKioqKioqKioqKipcblx0XHQgQW5pbWF0aW9uXG5cdFx0ICoqKioqKioqKioqKioqKioqL1xuXG5cdFx0dmFyIGFuaW1hdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcHRzO1xuXG5cdFx0XHQvKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgQ2FsbCBDaGFpblxuXHRcdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0LyogTG9naWMgZm9yIGRldGVybWluaW5nIHdoYXQgdG8gcmV0dXJuIHRvIHRoZSBjYWxsIHN0YWNrIHdoZW4gZXhpdGluZyBvdXQgb2YgVmVsb2NpdHkuICovXG5cdFx0XHRmdW5jdGlvbiBnZXRDaGFpbigpIHtcblx0XHRcdFx0LyogSWYgd2UgYXJlIHVzaW5nIHRoZSB1dGlsaXR5IGZ1bmN0aW9uLCBhdHRlbXB0IHRvIHJldHVybiB0aGlzIGNhbGwncyBwcm9taXNlLiBJZiBubyBwcm9taXNlIGxpYnJhcnkgd2FzIGRldGVjdGVkLFxuXHRcdFx0XHQgZGVmYXVsdCB0byBudWxsIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZSB0YXJnZXRlZCBlbGVtZW50cyBzbyB0aGF0IHV0aWxpdHkgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgaXMgc3RhbmRhcmRpemVkLiAqL1xuXHRcdFx0XHRpZiAoaXNVdGlsaXR5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2VEYXRhLnByb21pc2UgfHwgbnVsbDtcblx0XHRcdFx0XHQvKiBPdGhlcndpc2UsIGlmIHdlJ3JlIHVzaW5nICQuZm4sIHJldHVybiB0aGUgalF1ZXJ5LS9aZXB0by13cmFwcGVkIGVsZW1lbnQgc2V0LiAqL1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50c1dyYXBwZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdCBBcmd1bWVudHMgQXNzaWdubWVudFxuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIFRvIGFsbG93IGZvciBleHByZXNzaXZlIENvZmZlZVNjcmlwdCBjb2RlLCBWZWxvY2l0eSBzdXBwb3J0cyBhbiBhbHRlcm5hdGl2ZSBzeW50YXggaW4gd2hpY2ggXCJlbGVtZW50c1wiIChvciBcImVcIiksIFwicHJvcGVydGllc1wiIChvciBcInBcIiksIGFuZCBcIm9wdGlvbnNcIiAob3IgXCJvXCIpXG5cdFx0XHQgb2JqZWN0cyBhcmUgZGVmaW5lZCBvbiBhIGNvbnRhaW5lciBvYmplY3QgdGhhdCdzIHBhc3NlZCBpbiBhcyBWZWxvY2l0eSdzIHNvbGUgYXJndW1lbnQuICovXG5cdFx0XHQvKiBOb3RlOiBTb21lIGJyb3dzZXJzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGUgYXJndW1lbnRzIHdpdGggYSBcInByb3BlcnRpZXNcIiBvYmplY3QuIFdlIGRldGVjdCBpdCBieSBjaGVja2luZyBmb3IgaXRzIGRlZmF1bHQgXCJuYW1lc1wiIHByb3BlcnR5LiAqL1xuXHRcdFx0dmFyIHN5bnRhY3RpY1N1Z2FyID0gKGFyZ3VtZW50c1swXSAmJiAoYXJndW1lbnRzWzBdLnAgfHwgKCgkLmlzUGxhaW5PYmplY3QoYXJndW1lbnRzWzBdLnByb3BlcnRpZXMpICYmICFhcmd1bWVudHNbMF0ucHJvcGVydGllcy5uYW1lcykgfHwgVHlwZS5pc1N0cmluZyhhcmd1bWVudHNbMF0ucHJvcGVydGllcykpKSksXG5cdFx0XHRcdFx0LyogV2hldGhlciBWZWxvY2l0eSB3YXMgY2FsbGVkIHZpYSB0aGUgdXRpbGl0eSBmdW5jdGlvbiAoYXMgb3Bwb3NlZCB0byBvbiBhIGpRdWVyeS9aZXB0byBvYmplY3QpLiAqL1xuXHRcdFx0XHRcdGlzVXRpbGl0eSxcblx0XHRcdFx0XHQvKiBXaGVuIFZlbG9jaXR5IGlzIGNhbGxlZCB2aWEgdGhlIHV0aWxpdHkgZnVuY3Rpb24gKCQuVmVsb2NpdHkoKS9WZWxvY2l0eSgpKSwgZWxlbWVudHMgYXJlIGV4cGxpY2l0bHlcblx0XHRcdFx0XHQgcGFzc2VkIGluIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuIFRodXMsIGFyZ3VtZW50IHBvc2l0aW9uaW5nIHZhcmllcy4gV2Ugbm9ybWFsaXplIHRoZW0gaGVyZS4gKi9cblx0XHRcdFx0XHRlbGVtZW50c1dyYXBwZWQsXG5cdFx0XHRcdFx0YXJndW1lbnRJbmRleDtcblxuXHRcdFx0dmFyIGVsZW1lbnRzLFxuXHRcdFx0XHRcdHByb3BlcnRpZXNNYXAsXG5cdFx0XHRcdFx0b3B0aW9ucztcblxuXHRcdFx0LyogRGV0ZWN0IGpRdWVyeS9aZXB0byBlbGVtZW50cyBiZWluZyBhbmltYXRlZCB2aWEgdGhlICQuZm4gbWV0aG9kLiAqL1xuXHRcdFx0aWYgKFR5cGUuaXNXcmFwcGVkKHRoaXMpKSB7XG5cdFx0XHRcdGlzVXRpbGl0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdGFyZ3VtZW50SW5kZXggPSAwO1xuXHRcdFx0XHRlbGVtZW50cyA9IHRoaXM7XG5cdFx0XHRcdGVsZW1lbnRzV3JhcHBlZCA9IHRoaXM7XG5cdFx0XHRcdC8qIE90aGVyd2lzZSwgcmF3IGVsZW1lbnRzIGFyZSBiZWluZyBhbmltYXRlZCB2aWEgdGhlIHV0aWxpdHkgZnVuY3Rpb24uICovXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc1V0aWxpdHkgPSB0cnVlO1xuXG5cdFx0XHRcdGFyZ3VtZW50SW5kZXggPSAxO1xuXHRcdFx0XHRlbGVtZW50cyA9IHN5bnRhY3RpY1N1Z2FyID8gKGFyZ3VtZW50c1swXS5lbGVtZW50cyB8fCBhcmd1bWVudHNbMF0uZSkgOiBhcmd1bWVudHNbMF07XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKipcblx0XHRcdCBQcm9taXNlc1xuXHRcdFx0ICoqKioqKioqKioqKioqKi9cblxuXHRcdFx0dmFyIHByb21pc2VEYXRhID0ge1xuXHRcdFx0XHRwcm9taXNlOiBudWxsLFxuXHRcdFx0XHRyZXNvbHZlcjogbnVsbCxcblx0XHRcdFx0cmVqZWN0ZXI6IG51bGxcblx0XHRcdH07XG5cblx0XHRcdC8qIElmIHRoaXMgY2FsbCB3YXMgbWFkZSB2aWEgdGhlIHV0aWxpdHkgZnVuY3Rpb24gKHdoaWNoIGlzIHRoZSBkZWZhdWx0IG1ldGhvZCBvZiBpbnZvY2F0aW9uIHdoZW4galF1ZXJ5L1plcHRvIGFyZSBub3QgYmVpbmcgdXNlZCksIGFuZCBpZlxuXHRcdFx0IHByb21pc2Ugc3VwcG9ydCB3YXMgZGV0ZWN0ZWQsIGNyZWF0ZSBhIHByb21pc2Ugb2JqZWN0IGZvciB0aGlzIGNhbGwgYW5kIHN0b3JlIHJlZmVyZW5jZXMgdG8gaXRzIHJlc29sdmVyIGFuZCByZWplY3RlciBtZXRob2RzLiBUaGUgcmVzb2x2ZVxuXHRcdFx0IG1ldGhvZCBpcyB1c2VkIHdoZW4gYSBjYWxsIGNvbXBsZXRlcyBuYXR1cmFsbHkgb3IgaXMgcHJlbWF0dXJlbHkgc3RvcHBlZCBieSB0aGUgdXNlci4gSW4gYm90aCBjYXNlcywgY29tcGxldGVDYWxsKCkgaGFuZGxlcyB0aGUgYXNzb2NpYXRlZFxuXHRcdFx0IGNhbGwgY2xlYW51cCBhbmQgcHJvbWlzZSByZXNvbHZpbmcgbG9naWMuIFRoZSByZWplY3QgbWV0aG9kIGlzIHVzZWQgd2hlbiBhbiBpbnZhbGlkIHNldCBvZiBhcmd1bWVudHMgaXMgcGFzc2VkIGludG8gYSBWZWxvY2l0eSBjYWxsLiAqL1xuXHRcdFx0LyogTm90ZTogVmVsb2NpdHkgZW1wbG95cyBhIGNhbGwtYmFzZWQgcXVldWVpbmcgYXJjaGl0ZWN0dXJlLCB3aGljaCBtZWFucyB0aGF0IHN0b3BwaW5nIGFuIGFuaW1hdGluZyBlbGVtZW50IGFjdHVhbGx5IHN0b3BzIHRoZSBmdWxsIGNhbGwgdGhhdFxuXHRcdFx0IHRyaWdnZXJlZCBpdCAtLSBub3QgdGhhdCBvbmUgZWxlbWVudCBleGNsdXNpdmVseS4gU2ltaWxhcmx5LCB0aGVyZSBpcyBvbmUgcHJvbWlzZSBwZXIgY2FsbCwgYW5kIGFsbCBlbGVtZW50cyB0YXJnZXRlZCBieSBhIFZlbG9jaXR5IGNhbGwgYXJlXG5cdFx0XHQgZ3JvdXBlZCB0b2dldGhlciBmb3IgdGhlIHB1cnBvc2VzIG9mIHJlc29sdmluZyBhbmQgcmVqZWN0aW5nIGEgcHJvbWlzZS4gKi9cblx0XHRcdGlmIChpc1V0aWxpdHkgJiYgVmVsb2NpdHkuUHJvbWlzZSkge1xuXHRcdFx0XHRwcm9taXNlRGF0YS5wcm9taXNlID0gbmV3IFZlbG9jaXR5LlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdFx0cHJvbWlzZURhdGEucmVzb2x2ZXIgPSByZXNvbHZlO1xuXHRcdFx0XHRcdHByb21pc2VEYXRhLnJlamVjdGVyID0gcmVqZWN0O1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN5bnRhY3RpY1N1Z2FyKSB7XG5cdFx0XHRcdHByb3BlcnRpZXNNYXAgPSBhcmd1bWVudHNbMF0ucHJvcGVydGllcyB8fCBhcmd1bWVudHNbMF0ucDtcblx0XHRcdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1swXS5vcHRpb25zIHx8IGFyZ3VtZW50c1swXS5vO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJvcGVydGllc01hcCA9IGFyZ3VtZW50c1thcmd1bWVudEluZGV4XTtcblx0XHRcdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1thcmd1bWVudEluZGV4ICsgMV07XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnRzID0gc2FuaXRpemVFbGVtZW50cyhlbGVtZW50cyk7XG5cblx0XHRcdGlmICghZWxlbWVudHMpIHtcblx0XHRcdFx0aWYgKHByb21pc2VEYXRhLnByb21pc2UpIHtcblx0XHRcdFx0XHRpZiAoIXByb3BlcnRpZXNNYXAgfHwgIW9wdGlvbnMgfHwgb3B0aW9ucy5wcm9taXNlUmVqZWN0RW1wdHkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZWplY3RlcigpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZXNvbHZlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQgc2V0IChpbiB0aGUgZm9ybSBvZiBhIG5vZGVMaXN0IG9yIGFuIGFycmF5IG9mIGVsZW1lbnRzKSBpcyBkZWZhdWx0ZWQgdG8gMSBpbiBjYXNlIGFcblx0XHRcdCBzaW5nbGUgcmF3IERPTSBlbGVtZW50IGlzIHBhc3NlZCBpbiAod2hpY2ggZG9lc24ndCBjb250YWluIGEgbGVuZ3RoIHByb3BlcnR5KS4gKi9cblx0XHRcdHZhciBlbGVtZW50c0xlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aCxcblx0XHRcdFx0XHRlbGVtZW50c0luZGV4ID0gMDtcblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IEFyZ3VtZW50IE92ZXJsb2FkaW5nXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBTdXBwb3J0IGlzIGluY2x1ZGVkIGZvciBqUXVlcnkncyBhcmd1bWVudCBvdmVybG9hZGluZzogJC5hbmltYXRlKHByb3BlcnR5TWFwIFssIGR1cmF0aW9uXSBbLCBlYXNpbmddIFssIGNvbXBsZXRlXSkuXG5cdFx0XHQgT3ZlcmxvYWRpbmcgaXMgZGV0ZWN0ZWQgYnkgY2hlY2tpbmcgZm9yIHRoZSBhYnNlbmNlIG9mIGFuIG9iamVjdCBiZWluZyBwYXNzZWQgaW50byBvcHRpb25zLiAqL1xuXHRcdFx0LyogTm90ZTogVGhlIHN0b3AvZmluaXNoL3BhdXNlL3Jlc3VtZSBhY3Rpb25zIGRvIG5vdCBhY2NlcHQgYW5pbWF0aW9uIG9wdGlvbnMsIGFuZCBhcmUgdGhlcmVmb3JlIGV4Y2x1ZGVkIGZyb20gdGhpcyBjaGVjay4gKi9cblx0XHRcdGlmICghL14oc3RvcHxmaW5pc2h8ZmluaXNoQWxsfHBhdXNlfHJlc3VtZSkkL2kudGVzdChwcm9wZXJ0aWVzTWFwKSAmJiAhJC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG5cdFx0XHRcdC8qIFRoZSB1dGlsaXR5IGZ1bmN0aW9uIHNoaWZ0cyBhbGwgYXJndW1lbnRzIG9uZSBwb3NpdGlvbiB0byB0aGUgcmlnaHQsIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBvZmZzZXQuICovXG5cdFx0XHRcdHZhciBzdGFydGluZ0FyZ3VtZW50UG9zaXRpb24gPSBhcmd1bWVudEluZGV4ICsgMTtcblxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cblx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvcHRpb25zIGFyZ3VtZW50cyAqL1xuXHRcdFx0XHRmb3IgKHZhciBpID0gc3RhcnRpbmdBcmd1bWVudFBvc2l0aW9uOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0LyogVHJlYXQgYSBudW1iZXIgYXMgYSBkdXJhdGlvbi4gUGFyc2UgaXQgb3V0LiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IFRoZSBmb2xsb3dpbmcgUmVnRXggd2lsbCByZXR1cm4gdHJ1ZSBpZiBwYXNzZWQgYW4gYXJyYXkgd2l0aCBhIG51bWJlciBhcyBpdHMgZmlyc3QgaXRlbS5cblx0XHRcdFx0XHQgVGh1cywgYXJyYXlzIGFyZSBza2lwcGVkIGZyb20gdGhpcyBjaGVjay4gKi9cblx0XHRcdFx0XHRpZiAoIVR5cGUuaXNBcnJheShhcmd1bWVudHNbaV0pICYmICgvXihmYXN0fG5vcm1hbHxzbG93KSQvaS50ZXN0KGFyZ3VtZW50c1tpXSkgfHwgL15cXGQvLnRlc3QoYXJndW1lbnRzW2ldKSkpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnMuZHVyYXRpb24gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0XHQvKiBUcmVhdCBzdHJpbmdzIGFuZCBhcnJheXMgYXMgZWFzaW5ncy4gKi9cblx0XHRcdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNTdHJpbmcoYXJndW1lbnRzW2ldKSB8fCBUeXBlLmlzQXJyYXkoYXJndW1lbnRzW2ldKSkge1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5lYXNpbmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0XHQvKiBUcmVhdCBhIGZ1bmN0aW9uIGFzIGEgY29tcGxldGUgY2FsbGJhY2suICovXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChUeXBlLmlzRnVuY3Rpb24oYXJndW1lbnRzW2ldKSkge1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IEFjdGlvbiBEZXRlY3Rpb25cblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIFZlbG9jaXR5J3MgYmVoYXZpb3IgaXMgY2F0ZWdvcml6ZWQgaW50byBcImFjdGlvbnNcIjogRWxlbWVudHMgY2FuIGVpdGhlciBiZSBzcGVjaWFsbHkgc2Nyb2xsZWQgaW50byB2aWV3LFxuXHRcdFx0IG9yIHRoZXkgY2FuIGJlIHN0YXJ0ZWQsIHN0b3BwZWQsIHBhdXNlZCwgcmVzdW1lZCwgb3IgcmV2ZXJzZWQgLiBJZiBhIGxpdGVyYWwgb3IgcmVmZXJlbmNlZCBwcm9wZXJ0aWVzIG1hcCBpcyBwYXNzZWQgaW4gYXMgVmVsb2NpdHknc1xuXHRcdFx0IGZpcnN0IGFyZ3VtZW50LCB0aGUgYXNzb2NpYXRlZCBhY3Rpb24gaXMgXCJzdGFydFwiLiBBbHRlcm5hdGl2ZWx5LCBcInNjcm9sbFwiLCBcInJldmVyc2VcIiwgXCJwYXVzZVwiLCBcInJlc3VtZVwiIG9yIFwic3RvcFwiIGNhbiBiZSBwYXNzZWQgaW4gXG5cdFx0XHQgaW5zdGVhZCBvZiBhIHByb3BlcnRpZXMgbWFwLiAqL1xuXHRcdFx0dmFyIGFjdGlvbjtcblxuXHRcdFx0c3dpdGNoIChwcm9wZXJ0aWVzTWFwKSB7XG5cdFx0XHRcdGNhc2UgXCJzY3JvbGxcIjpcblx0XHRcdFx0XHRhY3Rpb24gPSBcInNjcm9sbFwiO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJyZXZlcnNlXCI6XG5cdFx0XHRcdFx0YWN0aW9uID0gXCJyZXZlcnNlXCI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcInBhdXNlXCI6XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBBY3Rpb246IFBhdXNlXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHR2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG5cdFx0XHRcdFx0LyogSGFuZGxlIGRlbGF5IHRpbWVycyAqL1xuXHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0cGF1c2VEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvKiBQYXVzZSBhbmQgUmVzdW1lIGFyZSBjYWxsLXdpZGUgKG5vdCBvbiBhIHBlciBlbGVtZW50IGJhc2lzKS4gVGh1cywgY2FsbGluZyBwYXVzZSBvciByZXN1bWUgb24gYSBcblx0XHRcdFx0XHQgc2luZ2xlIGVsZW1lbnQgd2lsbCBjYXVzZSBhbnkgY2FsbHMgdGhhdCBjb250YWludCB0d2VlbnMgZm9yIHRoYXQgZWxlbWVudCB0byBiZSBwYXVzZWQvcmVzdW1lZFxuXHRcdFx0XHRcdCBhcyB3ZWxsLiAqL1xuXG5cdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIGFsbCBjYWxscyBhbmQgcGF1c2UgYW55IHRoYXQgY29udGFpbiBhbnkgb2Ygb3VyIGVsZW1lbnRzICovXG5cdFx0XHRcdFx0JC5lYWNoKFZlbG9jaXR5LlN0YXRlLmNhbGxzLCBmdW5jdGlvbihpLCBhY3RpdmVDYWxsKSB7XG5cblx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0LyogSW5hY3RpdmUgY2FsbHMgYXJlIHNldCB0byBmYWxzZSBieSB0aGUgbG9naWMgaW5zaWRlIGNvbXBsZXRlQ2FsbCgpLiBTa2lwIHRoZW0uICovXG5cdFx0XHRcdFx0XHRpZiAoYWN0aXZlQ2FsbCkge1xuXHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGFjdGl2ZSBjYWxsJ3MgdGFyZ2V0ZWQgZWxlbWVudHMuICovXG5cdFx0XHRcdFx0XHRcdCQuZWFjaChhY3RpdmVDYWxsWzFdLCBmdW5jdGlvbihrLCBhY3RpdmVFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHF1ZXVlTmFtZSA9IChvcHRpb25zID09PSB1bmRlZmluZWQpID8gXCJcIiA6IG9wdGlvbnM7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAocXVldWVOYW1lICE9PSB0cnVlICYmIChhY3RpdmVDYWxsWzJdLnF1ZXVlICE9PSBxdWV1ZU5hbWUpICYmICEob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIGFjdGl2ZUNhbGxbMl0ucXVldWUgPT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSBjYWxscyB0YXJnZXRlZCBieSB0aGUgc3RvcCBjb21tYW5kLiAqL1xuXHRcdFx0XHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24obCwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQ2hlY2sgdGhhdCB0aGlzIGNhbGwgd2FzIGFwcGxpZWQgdG8gdGhlIHRhcmdldCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTZXQgY2FsbCB0byBwYXVzZWQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0aXZlQ2FsbFs1XSA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bWU6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogT25jZSB3ZSBtYXRjaCBhbiBlbGVtZW50LCB3ZSBjYW4gYm91bmNlIG91dCB0byB0aGUgbmV4dCBjYWxsIGVudGlyZWx5ICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogUHJvY2VlZCB0byBjaGVjayBuZXh0IGNhbGwgaWYgd2UgaGF2ZSBhbHJlYWR5IG1hdGNoZWQgKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoZm91bmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvKiBTaW5jZSBwYXVzZSBjcmVhdGVzIG5vIG5ldyB0d2VlbnMsIGV4aXQgb3V0IG9mIFZlbG9jaXR5LiAqL1xuXHRcdFx0XHRcdHJldHVybiBnZXRDaGFpbigpO1xuXG5cdFx0XHRcdGNhc2UgXCJyZXN1bWVcIjpcblxuXHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IEFjdGlvbjogUmVzdW1lXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBIYW5kbGUgZGVsYXkgdGltZXJzICovXG5cdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRyZXN1bWVEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvKiBQYXVzZSBhbmQgUmVzdW1lIGFyZSBjYWxsLXdpZGUgKG5vdCBvbiBhIHBlciBlbGVtbnQgYmFzaXMpLiBUaHVzLCBjYWxsaW5nIHBhdXNlIG9yIHJlc3VtZSBvbiBhIFxuXHRcdFx0XHRcdCBzaW5nbGUgZWxlbWVudCB3aWxsIGNhdXNlIGFueSBjYWxscyB0aGF0IGNvbnRhaW50IHR3ZWVucyBmb3IgdGhhdCBlbGVtZW50IHRvIGJlIHBhdXNlZC9yZXN1bWVkXG5cdFx0XHRcdFx0IGFzIHdlbGwuICovXG5cblx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggYWxsIGNhbGxzIGFuZCBwYXVzZSBhbnkgdGhhdCBjb250YWluIGFueSBvZiBvdXIgZWxlbWVudHMgKi9cblx0XHRcdFx0XHQkLmVhY2goVmVsb2NpdHkuU3RhdGUuY2FsbHMsIGZ1bmN0aW9uKGksIGFjdGl2ZUNhbGwpIHtcblx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0LyogSW5hY3RpdmUgY2FsbHMgYXJlIHNldCB0byBmYWxzZSBieSB0aGUgbG9naWMgaW5zaWRlIGNvbXBsZXRlQ2FsbCgpLiBTa2lwIHRoZW0uICovXG5cdFx0XHRcdFx0XHRpZiAoYWN0aXZlQ2FsbCkge1xuXHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGFjdGl2ZSBjYWxsJ3MgdGFyZ2V0ZWQgZWxlbWVudHMuICovXG5cdFx0XHRcdFx0XHRcdCQuZWFjaChhY3RpdmVDYWxsWzFdLCBmdW5jdGlvbihrLCBhY3RpdmVFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHF1ZXVlTmFtZSA9IChvcHRpb25zID09PSB1bmRlZmluZWQpID8gXCJcIiA6IG9wdGlvbnM7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAocXVldWVOYW1lICE9PSB0cnVlICYmIChhY3RpdmVDYWxsWzJdLnF1ZXVlICE9PSBxdWV1ZU5hbWUpICYmICEob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIGFjdGl2ZUNhbGxbMl0ucXVldWUgPT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogU2tpcCBhbnkgY2FsbHMgdGhhdCBoYXZlIG5ldmVyIGJlZW4gcGF1c2VkICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFhY3RpdmVDYWxsWzVdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGNhbGxzIHRhcmdldGVkIGJ5IHRoZSBzdG9wIGNvbW1hbmQuICovXG5cdFx0XHRcdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihsLCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBDaGVjayB0aGF0IHRoaXMgY2FsbCB3YXMgYXBwbGllZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEZsYWcgYSBwYXVzZSBvYmplY3QgdG8gYmUgcmVzdW1lZCwgd2hpY2ggd2lsbCBvY2N1ciBkdXJpbmcgdGhlIG5leHQgdGljay4gSW5cblx0XHRcdFx0XHRcdFx0XHRcdFx0IGFkZGl0aW9uLCB0aGUgcGF1c2Ugb2JqZWN0IHdpbGwgYXQgdGhhdCB0aW1lIGJlIGRlbGV0ZWQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0aXZlQ2FsbFs1XS5yZXN1bWUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIE9uY2Ugd2UgbWF0Y2ggYW4gZWxlbWVudCwgd2UgY2FuIGJvdW5jZSBvdXQgdG8gdGhlIG5leHQgY2FsbCBlbnRpcmVseSAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIFByb2NlZWQgdG8gY2hlY2sgbmV4dCBjYWxsIGlmIHdlIGhhdmUgYWxyZWFkeSBtYXRjaGVkICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGZvdW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0LyogU2luY2UgcmVzdW1lIGNyZWF0ZXMgbm8gbmV3IHR3ZWVucywgZXhpdCBvdXQgb2YgVmVsb2NpdHkuICovXG5cdFx0XHRcdFx0cmV0dXJuIGdldENoYWluKCk7XG5cblx0XHRcdFx0Y2FzZSBcImZpbmlzaFwiOlxuXHRcdFx0XHRjYXNlIFwiZmluaXNoQWxsXCI6XG5cdFx0XHRcdGNhc2UgXCJzdG9wXCI6XG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHQgQWN0aW9uOiBTdG9wXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBDbGVhciB0aGUgY3VycmVudGx5LWFjdGl2ZSBkZWxheSBvbiBlYWNoIHRhcmdldGVkIGVsZW1lbnQuICovXG5cdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRpZiAoRGF0YShlbGVtZW50KSAmJiBEYXRhKGVsZW1lbnQpLmRlbGF5VGltZXIpIHtcblx0XHRcdFx0XHRcdFx0LyogU3RvcCB0aGUgdGltZXIgZnJvbSB0cmlnZ2VyaW5nIGl0cyBjYWNoZWQgbmV4dCgpIGZ1bmN0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoRGF0YShlbGVtZW50KS5kZWxheVRpbWVyLnNldFRpbWVvdXQpO1xuXG5cdFx0XHRcdFx0XHRcdC8qIE1hbnVhbGx5IGNhbGwgdGhlIG5leHQoKSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBzdWJzZXF1ZW50IHF1ZXVlIGl0ZW1zIGNhbiBwcm9ncmVzcy4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKERhdGEoZWxlbWVudCkuZGVsYXlUaW1lci5uZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0RGF0YShlbGVtZW50KS5kZWxheVRpbWVyLm5leHQoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBEYXRhKGVsZW1lbnQpLmRlbGF5VGltZXI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElmIHdlIHdhbnQgdG8gZmluaXNoIGV2ZXJ5dGhpbmcgaW4gdGhlIHF1ZXVlLCB3ZSBoYXZlIHRvIGl0ZXJhdGUgdGhyb3VnaCBpdFxuXHRcdFx0XHRcdFx0IGFuZCBjYWxsIGVhY2ggZnVuY3Rpb24uIFRoaXMgd2lsbCBtYWtlIHRoZW0gYWN0aXZlIGNhbGxzIGJlbG93LCB3aGljaCB3aWxsXG5cdFx0XHRcdFx0XHQgY2F1c2UgdGhlbSB0byBiZSBhcHBsaWVkIHZpYSB0aGUgZHVyYXRpb24gc2V0dGluZy4gKi9cblx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0aWVzTWFwID09PSBcImZpbmlzaEFsbFwiICYmIChvcHRpb25zID09PSB0cnVlIHx8IFR5cGUuaXNTdHJpbmcob3B0aW9ucykpKSB7XG5cdFx0XHRcdFx0XHRcdC8qIEl0ZXJhdGUgdGhyb3VnaCB0aGUgaXRlbXMgaW4gdGhlIGVsZW1lbnQncyBxdWV1ZS4gKi9cblx0XHRcdFx0XHRcdFx0JC5lYWNoKCQucXVldWUoZWxlbWVudCwgVHlwZS5pc1N0cmluZyhvcHRpb25zKSA/IG9wdGlvbnMgOiBcIlwiKSwgZnVuY3Rpb24oXywgaXRlbSkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIFRoZSBxdWV1ZSBhcnJheSBjYW4gY29udGFpbiBhbiBcImlucHJvZ3Jlc3NcIiBzdHJpbmcsIHdoaWNoIHdlIHNraXAuICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNGdW5jdGlvbihpdGVtKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbSgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0LyogQ2xlYXJpbmcgdGhlICQucXVldWUoKSBhcnJheSBpcyBhY2hpZXZlZCBieSByZXNldHRpbmcgaXQgdG8gW10uICovXG5cdFx0XHRcdFx0XHRcdCQucXVldWUoZWxlbWVudCwgVHlwZS5pc1N0cmluZyhvcHRpb25zKSA/IG9wdGlvbnMgOiBcIlwiLCBbXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHR2YXIgY2FsbHNUb1N0b3AgPSBbXTtcblxuXHRcdFx0XHRcdC8qIFdoZW4gdGhlIHN0b3AgYWN0aW9uIGlzIHRyaWdnZXJlZCwgdGhlIGVsZW1lbnRzJyBjdXJyZW50bHkgYWN0aXZlIGNhbGwgaXMgaW1tZWRpYXRlbHkgc3RvcHBlZC4gVGhlIGFjdGl2ZSBjYWxsIG1pZ2h0IGhhdmVcblx0XHRcdFx0XHQgYmVlbiBhcHBsaWVkIHRvIG11bHRpcGxlIGVsZW1lbnRzLCBpbiB3aGljaCBjYXNlIGFsbCBvZiB0aGUgY2FsbCdzIGVsZW1lbnRzIHdpbGwgYmUgc3RvcHBlZC4gV2hlbiBhbiBlbGVtZW50XG5cdFx0XHRcdFx0IGlzIHN0b3BwZWQsIHRoZSBuZXh0IGl0ZW0gaW4gaXRzIGFuaW1hdGlvbiBxdWV1ZSBpcyBpbW1lZGlhdGVseSB0cmlnZ2VyZWQuICovXG5cdFx0XHRcdFx0LyogQW4gYWRkaXRpb25hbCBhcmd1bWVudCBtYXkgYmUgcGFzc2VkIGluIHRvIGNsZWFyIGFuIGVsZW1lbnQncyByZW1haW5pbmcgcXVldWVkIGNhbGxzLiBFaXRoZXIgdHJ1ZSAod2hpY2ggZGVmYXVsdHMgdG8gdGhlIFwiZnhcIiBxdWV1ZSlcblx0XHRcdFx0XHQgb3IgYSBjdXN0b20gcXVldWUgc3RyaW5nIGNhbiBiZSBwYXNzZWQgaW4uICovXG5cdFx0XHRcdFx0LyogTm90ZTogVGhlIHN0b3AgY29tbWFuZCBydW5zIHByaW9yIHRvIFZlbG9jaXR5J3MgUXVldWVpbmcgcGhhc2Ugc2luY2UgaXRzIGJlaGF2aW9yIGlzIGludGVuZGVkIHRvIHRha2UgZWZmZWN0ICppbW1lZGlhdGVseSosXG5cdFx0XHRcdFx0IHJlZ2FyZGxlc3Mgb2YgdGhlIGVsZW1lbnQncyBjdXJyZW50IHF1ZXVlIHN0YXRlLiAqL1xuXG5cdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IGFjdGl2ZSBjYWxsLiAqL1xuXHRcdFx0XHRcdCQuZWFjaChWZWxvY2l0eS5TdGF0ZS5jYWxscywgZnVuY3Rpb24oaSwgYWN0aXZlQ2FsbCkge1xuXHRcdFx0XHRcdFx0LyogSW5hY3RpdmUgY2FsbHMgYXJlIHNldCB0byBmYWxzZSBieSB0aGUgbG9naWMgaW5zaWRlIGNvbXBsZXRlQ2FsbCgpLiBTa2lwIHRoZW0uICovXG5cdFx0XHRcdFx0XHRpZiAoYWN0aXZlQ2FsbCkge1xuXHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGFjdGl2ZSBjYWxsJ3MgdGFyZ2V0ZWQgZWxlbWVudHMuICovXG5cdFx0XHRcdFx0XHRcdCQuZWFjaChhY3RpdmVDYWxsWzFdLCBmdW5jdGlvbihrLCBhY3RpdmVFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgdHJ1ZSB3YXMgcGFzc2VkIGluIGFzIGEgc2Vjb25kYXJ5IGFyZ3VtZW50LCBjbGVhciBhYnNvbHV0ZWx5IGFsbCBjYWxscyBvbiB0aGlzIGVsZW1lbnQuIE90aGVyd2lzZSwgb25seVxuXHRcdFx0XHRcdFx0XHRcdCBjbGVhciBjYWxscyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlbGV2YW50IHF1ZXVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdC8qIENhbGwgc3RvcHBpbmcgbG9naWMgd29ya3MgYXMgZm9sbG93czpcblx0XHRcdFx0XHRcdFx0XHQgLSBvcHRpb25zID09PSB0cnVlIC0tPiBzdG9wIGN1cnJlbnQgZGVmYXVsdCBxdWV1ZSBjYWxscyAoYW5kIHF1ZXVlOmZhbHNlIGNhbGxzKSwgaW5jbHVkaW5nIHJlbWFpbmluZyBxdWV1ZWQgb25lcy5cblx0XHRcdFx0XHRcdFx0XHQgLSBvcHRpb25zID09PSB1bmRlZmluZWQgLS0+IHN0b3AgY3VycmVudCBxdWV1ZTpcIlwiIGNhbGwgYW5kIGFsbCBxdWV1ZTpmYWxzZSBjYWxscy5cblx0XHRcdFx0XHRcdFx0XHQgLSBvcHRpb25zID09PSBmYWxzZSAtLT4gc3RvcCBvbmx5IHF1ZXVlOmZhbHNlIGNhbGxzLlxuXHRcdFx0XHRcdFx0XHRcdCAtIG9wdGlvbnMgPT09IFwiY3VzdG9tXCIgLS0+IHN0b3AgY3VycmVudCBxdWV1ZTpcImN1c3RvbVwiIGNhbGwsIGluY2x1ZGluZyByZW1haW5pbmcgcXVldWVkIG9uZXMgKHRoZXJlIGlzIG5vIGZ1bmN0aW9uYWxpdHkgdG8gb25seSBjbGVhciB0aGUgY3VycmVudGx5LXJ1bm5pbmcgcXVldWU6XCJjdXN0b21cIiBjYWxsKS4gKi9cblx0XHRcdFx0XHRcdFx0XHR2YXIgcXVldWVOYW1lID0gKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgPyBcIlwiIDogb3B0aW9ucztcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChxdWV1ZU5hbWUgIT09IHRydWUgJiYgKGFjdGl2ZUNhbGxbMl0ucXVldWUgIT09IHF1ZXVlTmFtZSkgJiYgIShvcHRpb25zID09PSB1bmRlZmluZWQgJiYgYWN0aXZlQ2FsbFsyXS5xdWV1ZSA9PT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGNhbGxzIHRhcmdldGVkIGJ5IHRoZSBzdG9wIGNvbW1hbmQuICovXG5cdFx0XHRcdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihsLCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBDaGVjayB0aGF0IHRoaXMgY2FsbCB3YXMgYXBwbGllZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBPcHRpb25hbGx5IGNsZWFyIHRoZSByZW1haW5pbmcgcXVldWVkIGNhbGxzLiBJZiB3ZSdyZSBkb2luZyBcImZpbmlzaEFsbFwiIHRoaXMgd29uJ3QgZmluZCBhbnl0aGluZyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0IGR1ZSB0byB0aGUgcXVldWUtY2xlYXJpbmcgYWJvdmUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zID09PSB0cnVlIHx8IFR5cGUuaXNTdHJpbmcob3B0aW9ucykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGl0ZW1zIGluIHRoZSBlbGVtZW50J3MgcXVldWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0JC5lYWNoKCQucXVldWUoZWxlbWVudCwgVHlwZS5pc1N0cmluZyhvcHRpb25zKSA/IG9wdGlvbnMgOiBcIlwiKSwgZnVuY3Rpb24oXywgaXRlbSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogVGhlIHF1ZXVlIGFycmF5IGNhbiBjb250YWluIGFuIFwiaW5wcm9ncmVzc1wiIHN0cmluZywgd2hpY2ggd2Ugc2tpcC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChUeXBlLmlzRnVuY3Rpb24oaXRlbSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogUGFzcyB0aGUgaXRlbSdzIGNhbGxiYWNrIGEgZmxhZyBpbmRpY2F0aW5nIHRoYXQgd2Ugd2FudCB0byBhYm9ydCBmcm9tIHRoZSBxdWV1ZSBjYWxsLlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgKFNwZWNpZmljYWxseSwgdGhlIHF1ZXVlIHdpbGwgcmVzb2x2ZSB0aGUgY2FsbCdzIGFzc29jaWF0ZWQgcHJvbWlzZSB0aGVuIGFib3J0LikgICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGl0ZW0obnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBDbGVhcmluZyB0aGUgJC5xdWV1ZSgpIGFycmF5IGlzIGFjaGlldmVkIGJ5IHJlc2V0dGluZyBpdCB0byBbXS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkLnF1ZXVlKGVsZW1lbnQsIFR5cGUuaXNTdHJpbmcob3B0aW9ucykgPyBvcHRpb25zIDogXCJcIiwgW10pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHByb3BlcnRpZXNNYXAgPT09IFwic3RvcFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogU2luY2UgXCJyZXZlcnNlXCIgdXNlcyBjYWNoZWQgc3RhcnQgdmFsdWVzICh0aGUgcHJldmlvdXMgY2FsbCdzIGVuZFZhbHVlcyksIHRoZXNlIHZhbHVlcyBtdXN0IGJlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IGNoYW5nZWQgdG8gcmVmbGVjdCB0aGUgZmluYWwgdmFsdWUgdGhhdCB0aGUgZWxlbWVudHMgd2VyZSBhY3R1YWxseSB0d2VlbmVkIHRvLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IElmIG9ubHkgcXVldWU6ZmFsc2UgYW5pbWF0aW9ucyBhcmUgY3VycmVudGx5IHJ1bm5pbmcgb24gYW4gZWxlbWVudCwgaXQgd29uJ3QgaGF2ZSBhIHR3ZWVuc0NvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBvYmplY3QuIEFsc28sIHF1ZXVlOmZhbHNlIGFuaW1hdGlvbnMgY2FuJ3QgYmUgcmV2ZXJzZWQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChkYXRhICYmIGRhdGEudHdlZW5zQ29udGFpbmVyICYmIHF1ZXVlTmFtZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCQuZWFjaChkYXRhLnR3ZWVuc0NvbnRhaW5lciwgZnVuY3Rpb24obSwgYWN0aXZlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0aXZlVHdlZW4uZW5kVmFsdWUgPSBhY3RpdmVUd2Vlbi5jdXJyZW50VmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYWxsc1RvU3RvcC5wdXNoKGkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BlcnRpZXNNYXAgPT09IFwiZmluaXNoXCIgfHwgcHJvcGVydGllc01hcCA9PT0gXCJmaW5pc2hBbGxcIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFRvIGdldCBhY3RpdmUgdHdlZW5zIHRvIGZpbmlzaCBpbW1lZGlhdGVseSwgd2UgZm9yY2VmdWxseSBzaG9ydGVuIHRoZWlyIGR1cmF0aW9ucyB0byAxbXMgc28gdGhhdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCB0aGV5IGZpbmlzaCB1cG9uIHRoZSBuZXh0IHJBZiB0aWNrIHRoZW4gcHJvY2VlZCB3aXRoIG5vcm1hbCBjYWxsIGNvbXBsZXRpb24gbG9naWMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0aXZlQ2FsbFsyXS5kdXJhdGlvbiA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvKiBQcmVtYXR1cmVseSBjYWxsIGNvbXBsZXRlQ2FsbCgpIG9uIGVhY2ggbWF0Y2hlZCBhY3RpdmUgY2FsbC4gUGFzcyBhbiBhZGRpdGlvbmFsIGZsYWcgZm9yIFwic3RvcFwiIHRvIGluZGljYXRlXG5cdFx0XHRcdFx0IHRoYXQgdGhlIGNvbXBsZXRlIGNhbGxiYWNrIGFuZCBkaXNwbGF5Om5vbmUgc2V0dGluZyBzaG91bGQgYmUgc2tpcHBlZCBzaW5jZSB3ZSdyZSBjb21wbGV0aW5nIHByZW1hdHVyZWx5LiAqL1xuXHRcdFx0XHRcdGlmIChwcm9wZXJ0aWVzTWFwID09PSBcInN0b3BcIikge1xuXHRcdFx0XHRcdFx0JC5lYWNoKGNhbGxzVG9TdG9wLCBmdW5jdGlvbihpLCBqKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlQ2FsbChqLCB0cnVlKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRpZiAocHJvbWlzZURhdGEucHJvbWlzZSkge1xuXHRcdFx0XHRcdFx0XHQvKiBJbW1lZGlhdGVseSByZXNvbHZlIHRoZSBwcm9taXNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0b3AgY2FsbCBzaW5jZSBzdG9wIHJ1bnMgc3luY2hyb25vdXNseS4gKi9cblx0XHRcdFx0XHRcdFx0cHJvbWlzZURhdGEucmVzb2x2ZXIoZWxlbWVudHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIFNpbmNlIHdlJ3JlIHN0b3BwaW5nLCBhbmQgbm90IHByb2NlZWRpbmcgd2l0aCBxdWV1ZWluZywgZXhpdCBvdXQgb2YgVmVsb2NpdHkuICovXG5cdFx0XHRcdFx0cmV0dXJuIGdldENoYWluKCk7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvKiBUcmVhdCBhIG5vbi1lbXB0eSBwbGFpbiBvYmplY3QgYXMgYSBsaXRlcmFsIHByb3BlcnRpZXMgbWFwLiAqL1xuXHRcdFx0XHRcdGlmICgkLmlzUGxhaW5PYmplY3QocHJvcGVydGllc01hcCkgJiYgIVR5cGUuaXNFbXB0eU9iamVjdChwcm9wZXJ0aWVzTWFwKSkge1xuXHRcdFx0XHRcdFx0YWN0aW9uID0gXCJzdGFydFwiO1xuXG5cdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0IFJlZGlyZWN0c1xuXHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdC8qIENoZWNrIGlmIGEgc3RyaW5nIG1hdGNoZXMgYSByZWdpc3RlcmVkIHJlZGlyZWN0IChzZWUgUmVkaXJlY3RzIGFib3ZlKS4gKi9cblx0XHRcdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNTdHJpbmcocHJvcGVydGllc01hcCkgJiYgVmVsb2NpdHkuUmVkaXJlY3RzW3Byb3BlcnRpZXNNYXBdKSB7XG5cdFx0XHRcdFx0XHRvcHRzID0gJC5leHRlbmQoe30sIG9wdGlvbnMpO1xuXG5cdFx0XHRcdFx0XHR2YXIgZHVyYXRpb25PcmlnaW5hbCA9IG9wdHMuZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0ZGVsYXlPcmlnaW5hbCA9IG9wdHMuZGVsYXkgfHwgMDtcblxuXHRcdFx0XHRcdFx0LyogSWYgdGhlIGJhY2t3YXJkcyBvcHRpb24gd2FzIHBhc3NlZCBpbiwgcmV2ZXJzZSB0aGUgZWxlbWVudCBzZXQgc28gdGhhdCBlbGVtZW50cyBhbmltYXRlIGZyb20gdGhlIGxhc3QgdG8gdGhlIGZpcnN0LiAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMuYmFja3dhcmRzID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzID0gJC5leHRlbmQodHJ1ZSwgW10sIGVsZW1lbnRzKS5yZXZlcnNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIEluZGl2aWR1YWxseSB0cmlnZ2VyIHRoZSByZWRpcmVjdCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQgdG8gcHJldmVudCB1c2VycyBmcm9tIGhhdmluZyB0byBoYW5kbGUgaXRlcmF0aW9uIGxvZ2ljIGluIHRoZWlyIHJlZGlyZWN0LiAqL1xuXHRcdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50SW5kZXgsIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIHN0YWdnZXIgb3B0aW9uIHdhcyBwYXNzZWQgaW4sIHN1Y2Nlc3NpdmVseSBkZWxheSBlYWNoIGVsZW1lbnQgYnkgdGhlIHN0YWdnZXIgdmFsdWUgKGluIG1zKS4gUmV0YWluIHRoZSBvcmlnaW5hbCBkZWxheSB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKHBhcnNlRmxvYXQob3B0cy5zdGFnZ2VyKSkge1xuXHRcdFx0XHRcdFx0XHRcdG9wdHMuZGVsYXkgPSBkZWxheU9yaWdpbmFsICsgKHBhcnNlRmxvYXQob3B0cy5zdGFnZ2VyKSAqIGVsZW1lbnRJbmRleCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc0Z1bmN0aW9uKG9wdHMuc3RhZ2dlcikpIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRzLmRlbGF5ID0gZGVsYXlPcmlnaW5hbCArIG9wdHMuc3RhZ2dlci5jYWxsKGVsZW1lbnQsIGVsZW1lbnRJbmRleCwgZWxlbWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGRyYWcgb3B0aW9uIHdhcyBwYXNzZWQgaW4sIHN1Y2Nlc3NpdmVseSBpbmNyZWFzZS9kZWNyZWFzZSAoZGVwZW5kaW5nIG9uIHRoZSBwcmVzZW5zZSBvZiBvcHRzLmJhY2t3YXJkcylcblx0XHRcdFx0XHRcdFx0IHRoZSBkdXJhdGlvbiBvZiBlYWNoIGVsZW1lbnQncyBhbmltYXRpb24sIHVzaW5nIGZsb29ycyB0byBwcmV2ZW50IHByb2R1Y2luZyB2ZXJ5IHNob3J0IGR1cmF0aW9ucy4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMuZHJhZykge1xuXHRcdFx0XHRcdFx0XHRcdC8qIERlZmF1bHQgdGhlIGR1cmF0aW9uIG9mIFVJIHBhY2sgZWZmZWN0cyAoY2FsbG91dHMgYW5kIHRyYW5zaXRpb25zKSB0byAxMDAwbXMgaW5zdGVhZCBvZiB0aGUgdXN1YWwgZGVmYXVsdCBkdXJhdGlvbiBvZiA0MDBtcy4gKi9cblx0XHRcdFx0XHRcdFx0XHRvcHRzLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbk9yaWdpbmFsKSB8fCAoL14oY2FsbG91dHx0cmFuc2l0aW9uKS8udGVzdChwcm9wZXJ0aWVzTWFwKSA/IDEwMDAgOiBEVVJBVElPTl9ERUZBVUxUKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIEZvciBlYWNoIGVsZW1lbnQsIHRha2UgdGhlIGdyZWF0ZXIgZHVyYXRpb24gb2Y6IEEpIGFuaW1hdGlvbiBjb21wbGV0aW9uIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIGR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdCBCKSA3NSUgb2YgdGhlIG9yaWdpbmFsIGR1cmF0aW9uLCBvciBDKSBhIDIwMG1zIGZhbGxiYWNrIChpbiBjYXNlIGR1cmF0aW9uIGlzIGFscmVhZHkgc2V0IHRvIGEgbG93IHZhbHVlKS5cblx0XHRcdFx0XHRcdFx0XHQgVGhlIGVuZCByZXN1bHQgaXMgYSBiYXNlbGluZSBvZiA3NSUgb2YgdGhlIHJlZGlyZWN0J3MgZHVyYXRpb24gdGhhdCBpbmNyZWFzZXMvZGVjcmVhc2VzIGFzIHRoZSBlbmQgb2YgdGhlIGVsZW1lbnQgc2V0IGlzIGFwcHJvYWNoZWQuICovXG5cdFx0XHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiA9IE1hdGgubWF4KG9wdHMuZHVyYXRpb24gKiAob3B0cy5iYWNrd2FyZHMgPyAxIC0gZWxlbWVudEluZGV4IC8gZWxlbWVudHNMZW5ndGggOiAoZWxlbWVudEluZGV4ICsgMSkgLyBlbGVtZW50c0xlbmd0aCksIG9wdHMuZHVyYXRpb24gKiAwLjc1LCAyMDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogUGFzcyBpbiB0aGUgY2FsbCdzIG9wdHMgb2JqZWN0IHNvIHRoYXQgdGhlIHJlZGlyZWN0IGNhbiBvcHRpb25hbGx5IGV4dGVuZCBpdC4gSXQgZGVmYXVsdHMgdG8gYW4gZW1wdHkgb2JqZWN0IGluc3RlYWQgb2YgbnVsbCB0b1xuXHRcdFx0XHRcdFx0XHQgcmVkdWNlIHRoZSBvcHRzIGNoZWNraW5nIGxvZ2ljIHJlcXVpcmVkIGluc2lkZSB0aGUgcmVkaXJlY3QuICovXG5cdFx0XHRcdFx0XHRcdFZlbG9jaXR5LlJlZGlyZWN0c1twcm9wZXJ0aWVzTWFwXS5jYWxsKGVsZW1lbnQsIGVsZW1lbnQsIG9wdHMgfHwge30sIGVsZW1lbnRJbmRleCwgZWxlbWVudHNMZW5ndGgsIGVsZW1lbnRzLCBwcm9taXNlRGF0YS5wcm9taXNlID8gcHJvbWlzZURhdGEgOiB1bmRlZmluZWQpO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdC8qIFNpbmNlIHRoZSBhbmltYXRpb24gbG9naWMgcmVzaWRlcyB3aXRoaW4gdGhlIHJlZGlyZWN0J3Mgb3duIGNvZGUsIGFib3J0IHRoZSByZW1haW5kZXIgb2YgdGhpcyBjYWxsLlxuXHRcdFx0XHRcdFx0IChUaGUgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQgdXAgdG8gdGhpcyBwb2ludCBpcyB2aXJ0dWFsbHkgbm9uLWV4aXN0YW50LikgKi9cblx0XHRcdFx0XHRcdC8qIE5vdGU6IFRoZSBqUXVlcnkgY2FsbCBjaGFpbiBpcyBrZXB0IGludGFjdCBieSByZXR1cm5pbmcgdGhlIGNvbXBsZXRlIGVsZW1lbnQgc2V0LiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldENoYWluKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gXCJWZWxvY2l0eTogRmlyc3QgYXJndW1lbnQgKFwiICsgcHJvcGVydGllc01hcCArIFwiKSB3YXMgbm90IGEgcHJvcGVydHkgbWFwLCBhIGtub3duIGFjdGlvbiwgb3IgYSByZWdpc3RlcmVkIHJlZGlyZWN0LiBBYm9ydGluZy5cIjtcblxuXHRcdFx0XHRcdFx0aWYgKHByb21pc2VEYXRhLnByb21pc2UpIHtcblx0XHRcdFx0XHRcdFx0cHJvbWlzZURhdGEucmVqZWN0ZXIobmV3IEVycm9yKGFib3J0RXJyb3IpKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAod2luZG93LmNvbnNvbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYWJvcnRFcnJvcik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBnZXRDaGFpbigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgQ2FsbC1XaWRlIFZhcmlhYmxlc1xuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBBIGNvbnRhaW5lciBmb3IgQ1NTIHVuaXQgY29udmVyc2lvbiByYXRpb3MgKGUuZy4gJSwgcmVtLCBhbmQgZW0gPT0+IHB4KSB0aGF0IGlzIHVzZWQgdG8gY2FjaGUgcmF0aW9zIGFjcm9zcyBhbGwgZWxlbWVudHNcblx0XHRcdCBiZWluZyBhbmltYXRlZCBpbiBhIHNpbmdsZSBWZWxvY2l0eSBjYWxsLiBDYWxjdWxhdGluZyB1bml0IHJhdGlvcyBuZWNlc3NpdGF0ZXMgRE9NIHF1ZXJ5aW5nIGFuZCB1cGRhdGluZywgYW5kIGlzIHRoZXJlZm9yZVxuXHRcdFx0IGF2b2lkZWQgKHZpYSBjYWNoaW5nKSB3aGVyZXZlciBwb3NzaWJsZS4gVGhpcyBjb250YWluZXIgaXMgY2FsbC13aWRlIGluc3RlYWQgb2YgcGFnZS13aWRlIHRvIGF2b2lkIHRoZSByaXNrIG9mIHVzaW5nIHN0YWxlXG5cdFx0XHQgY29udmVyc2lvbiBtZXRyaWNzIGFjcm9zcyBWZWxvY2l0eSBhbmltYXRpb25zIHRoYXQgYXJlIG5vdCBpbW1lZGlhdGVseSBjb25zZWN1dGl2ZWx5IGNoYWluZWQuICovXG5cdFx0XHR2YXIgY2FsbFVuaXRDb252ZXJzaW9uRGF0YSA9IHtcblx0XHRcdFx0bGFzdFBhcmVudDogbnVsbCxcblx0XHRcdFx0bGFzdFBvc2l0aW9uOiBudWxsLFxuXHRcdFx0XHRsYXN0Rm9udFNpemU6IG51bGwsXG5cdFx0XHRcdGxhc3RQZXJjZW50VG9QeFdpZHRoOiBudWxsLFxuXHRcdFx0XHRsYXN0UGVyY2VudFRvUHhIZWlnaHQ6IG51bGwsXG5cdFx0XHRcdGxhc3RFbVRvUHg6IG51bGwsXG5cdFx0XHRcdHJlbVRvUHg6IG51bGwsXG5cdFx0XHRcdHZ3VG9QeDogbnVsbCxcblx0XHRcdFx0dmhUb1B4OiBudWxsXG5cdFx0XHR9O1xuXG5cdFx0XHQvKiBBIGNvbnRhaW5lciBmb3IgYWxsIHRoZSBlbnN1aW5nIHR3ZWVuIGRhdGEgYW5kIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNhbGwuIFRoaXMgY29udGFpbmVyIGdldHMgcHVzaGVkIHRvIHRoZSBwYWdlLXdpZGVcblx0XHRcdCBWZWxvY2l0eS5TdGF0ZS5jYWxscyBhcnJheSB0aGF0IGlzIHByb2Nlc3NlZCBkdXJpbmcgYW5pbWF0aW9uIHRpY2tpbmcuICovXG5cdFx0XHR2YXIgY2FsbCA9IFtdO1xuXG5cdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgRWxlbWVudCBQcm9jZXNzaW5nXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBFbGVtZW50IHByb2Nlc3NpbmcgY29uc2lzdHMgb2YgdGhyZWUgcGFydHMgLS0gZGF0YSBwcm9jZXNzaW5nIHRoYXQgY2Fubm90IGdvIHN0YWxlIGFuZCBkYXRhIHByb2Nlc3NpbmcgdGhhdCAqY2FuKiBnbyBzdGFsZSAoaS5lLiB0aGlyZC1wYXJ0eSBzdHlsZSBtb2RpZmljYXRpb25zKTpcblx0XHRcdCAxKSBQcmUtUXVldWVpbmc6IEVsZW1lbnQtd2lkZSB2YXJpYWJsZXMsIGluY2x1ZGluZyB0aGUgZWxlbWVudCdzIGRhdGEgc3RvcmFnZSwgYXJlIGluc3RhbnRpYXRlZC4gQ2FsbCBvcHRpb25zIGFyZSBwcmVwYXJlZC4gSWYgdHJpZ2dlcmVkLCB0aGUgU3RvcCBhY3Rpb24gaXMgZXhlY3V0ZWQuXG5cdFx0XHQgMikgUXVldWVpbmc6IFRoZSBsb2dpYyB0aGF0IHJ1bnMgb25jZSB0aGlzIGNhbGwgaGFzIHJlYWNoZWQgaXRzIHBvaW50IG9mIGV4ZWN1dGlvbiBpbiB0aGUgZWxlbWVudCdzICQucXVldWUoKSBzdGFjay4gTW9zdCBsb2dpYyBpcyBwbGFjZWQgaGVyZSB0byBhdm9pZCByaXNraW5nIGl0IGJlY29taW5nIHN0YWxlLlxuXHRcdFx0IDMpIFB1c2hpbmc6IENvbnNvbGlkYXRpb24gb2YgdGhlIHR3ZWVuIGRhdGEgZm9sbG93ZWQgYnkgaXRzIHB1c2ggb250byB0aGUgZ2xvYmFsIGluLXByb2dyZXNzIGNhbGxzIGNvbnRhaW5lci5cblx0XHRcdCBgZWxlbWVudEFycmF5SW5kZXhgIGFsbG93cyBwYXNzaW5nIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCBhcnJheSB0byB2YWx1ZSBmdW5jdGlvbnMuXG5cdFx0XHQgSWYgYGVsZW1lbnRzSW5kZXhgIHdlcmUgdXNlZCBpbnN0ZWFkIHRoZSBpbmRleCB3b3VsZCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBlbGVtZW50cycgcGVyLWVsZW1lbnQgcXVldWUuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIGVsZW1lbnRBcnJheUluZGV4KSB7XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IFBhcnQgSTogUHJlLVF1ZXVlaW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IEVsZW1lbnQtV2lkZSBWYXJpYWJsZXNcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHR2YXIgLyogVGhlIHJ1bnRpbWUgb3B0cyBvYmplY3QgaXMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgY3VycmVudCBjYWxsJ3Mgb3B0aW9ucyBhbmQgVmVsb2NpdHkncyBwYWdlLXdpZGUgb3B0aW9uIGRlZmF1bHRzLiAqL1xuXHRcdFx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCBWZWxvY2l0eS5kZWZhdWx0cywgb3B0aW9ucyksXG5cdFx0XHRcdFx0XHQvKiBBIGNvbnRhaW5lciBmb3IgdGhlIHByb2Nlc3NlZCBkYXRhIGFzc29jaWF0ZWQgd2l0aCBlYWNoIHByb3BlcnR5IGluIHRoZSBwcm9wZXJ0eU1hcC5cblx0XHRcdFx0XHRcdCAoRWFjaCBwcm9wZXJ0eSBpbiB0aGUgbWFwIHByb2R1Y2VzIGl0cyBvd24gXCJ0d2VlblwiLikgKi9cblx0XHRcdFx0XHRcdHR3ZWVuc0NvbnRhaW5lciA9IHt9LFxuXHRcdFx0XHRcdFx0ZWxlbWVudFVuaXRDb252ZXJzaW9uRGF0YTtcblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBFbGVtZW50IEluaXRcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRpZiAoRGF0YShlbGVtZW50KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0VmVsb2NpdHkuaW5pdChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IE9wdGlvbjogRGVsYXlcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBTaW5jZSBxdWV1ZTpmYWxzZSBkb2Vzbid0IHJlc3BlY3QgdGhlIGl0ZW0ncyBleGlzdGluZyBxdWV1ZSwgd2UgYXZvaWQgaW5qZWN0aW5nIGl0cyBkZWxheSBoZXJlIChpdCdzIHNldCBsYXRlciBvbikuICovXG5cdFx0XHRcdC8qIE5vdGU6IFZlbG9jaXR5IHJvbGxzIGl0cyBvd24gZGVsYXkgZnVuY3Rpb24gc2luY2UgalF1ZXJ5IGRvZXNuJ3QgaGF2ZSBhIHV0aWxpdHkgYWxpYXMgZm9yICQuZm4uZGVsYXkoKVxuXHRcdFx0XHQgKGFuZCB0aHVzIHJlcXVpcmVzIGpRdWVyeSBlbGVtZW50IGNyZWF0aW9uLCB3aGljaCB3ZSBhdm9pZCBzaW5jZSBpdHMgb3ZlcmhlYWQgaW5jbHVkZXMgRE9NIHF1ZXJ5aW5nKS4gKi9cblx0XHRcdFx0aWYgKHBhcnNlRmxvYXQob3B0cy5kZWxheSkgJiYgb3B0cy5xdWV1ZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHQkLnF1ZXVlKGVsZW1lbnQsIG9wdHMucXVldWUsIGZ1bmN0aW9uKG5leHQpIHtcblx0XHRcdFx0XHRcdC8qIFRoaXMgaXMgYSBmbGFnIHVzZWQgdG8gaW5kaWNhdGUgdG8gdGhlIHVwY29taW5nIGNvbXBsZXRlQ2FsbCgpIGZ1bmN0aW9uIHRoYXQgdGhpcyBxdWV1ZSBlbnRyeSB3YXMgaW5pdGlhdGVkIGJ5IFZlbG9jaXR5LiBTZWUgY29tcGxldGVDYWxsKCkgZm9yIGZ1cnRoZXIgZGV0YWlscy4gKi9cblx0XHRcdFx0XHRcdFZlbG9jaXR5LnZlbG9jaXR5UXVldWVFbnRyeUZsYWcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHQvKiBUaGUgZW5zdWluZyBxdWV1ZSBpdGVtICh3aGljaCBpcyBhc3NpZ25lZCB0byB0aGUgXCJuZXh0XCIgYXJndW1lbnQgdGhhdCAkLnF1ZXVlKCkgYXV0b21hdGljYWxseSBwYXNzZXMgaW4pIHdpbGwgYmUgdHJpZ2dlcmVkIGFmdGVyIGEgc2V0VGltZW91dCBkZWxheS5cblx0XHRcdFx0XHRcdCBUaGUgc2V0VGltZW91dCBpcyBzdG9yZWQgc28gdGhhdCBpdCBjYW4gYmUgc3ViamVjdGVkIHRvIGNsZWFyVGltZW91dCgpIGlmIHRoaXMgYW5pbWF0aW9uIGlzIHByZW1hdHVyZWx5IHN0b3BwZWQgdmlhIFZlbG9jaXR5J3MgXCJzdG9wXCIgY29tbWFuZCwgYW5kXG5cdFx0XHRcdFx0XHQgZGVsYXlCZWdpbi9kZWxheVRpbWUgaXMgdXNlZCB0byBlbnN1cmUgd2UgY2FuIFwicGF1c2VcIiBhbmQgXCJyZXN1bWVcIiBhIHR3ZWVuIHRoYXQgaXMgc3RpbGwgbWlkLWRlbGF5LiAqL1xuXG5cdFx0XHRcdFx0XHQvKiBUZW1wb3JhcmlseSBzdG9yZSBkZWxheWVkIGVsZW1lbnRzIHRvIGZhY2lsaXRlIGFjY2VzcyBmb3IgZ2xvYmFsIHBhdXNlL3Jlc3VtZSAqL1xuXHRcdFx0XHRcdFx0dmFyIGNhbGxJbmRleCA9IFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50cy5jb3VudCsrO1xuXHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzW2NhbGxJbmRleF0gPSBlbGVtZW50O1xuXG5cdFx0XHRcdFx0XHR2YXIgZGVsYXlDb21wbGV0ZSA9IChmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogQ2xlYXIgdGhlIHRlbXBvcmFyeSBlbGVtZW50ICovXG5cdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzW2luZGV4XSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogRmluYWxseSwgaXNzdWUgdGhlIGNhbGwgKi9cblx0XHRcdFx0XHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KShjYWxsSW5kZXgpO1xuXG5cblx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkuZGVsYXlCZWdpbiA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLmRlbGF5ID0gcGFyc2VGbG9hdChvcHRzLmRlbGF5KTtcblx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkuZGVsYXlUaW1lciA9IHtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dDogc2V0VGltZW91dChuZXh0LCBwYXJzZUZsb2F0KG9wdHMuZGVsYXkpKSxcblx0XHRcdFx0XHRcdFx0bmV4dDogZGVsYXlDb21wbGV0ZVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IE9wdGlvbjogRHVyYXRpb25cblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBTdXBwb3J0IGZvciBqUXVlcnkncyBuYW1lZCBkdXJhdGlvbnMuICovXG5cdFx0XHRcdHN3aXRjaCAob3B0cy5kdXJhdGlvbi50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRjYXNlIFwiZmFzdFwiOlxuXHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiA9IDIwMDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBcIm5vcm1hbFwiOlxuXHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiA9IERVUkFUSU9OX0RFRkFVTFQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgXCJzbG93XCI6XG5cdFx0XHRcdFx0XHRvcHRzLmR1cmF0aW9uID0gNjAwO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0LyogUmVtb3ZlIHRoZSBwb3RlbnRpYWwgXCJtc1wiIHN1ZmZpeCBhbmQgZGVmYXVsdCB0byAxIGlmIHRoZSB1c2VyIGlzIGF0dGVtcHRpbmcgdG8gc2V0IGEgZHVyYXRpb24gb2YgMCAoaW4gb3JkZXIgdG8gcHJvZHVjZSBhbiBpbW1lZGlhdGUgc3R5bGUgY2hhbmdlKS4gKi9cblx0XHRcdFx0XHRcdG9wdHMuZHVyYXRpb24gPSBwYXJzZUZsb2F0KG9wdHMuZHVyYXRpb24pIHx8IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBHbG9iYWwgT3B0aW9uOiBNb2NrXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0aWYgKFZlbG9jaXR5Lm1vY2sgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0LyogSW4gbW9jayBtb2RlLCBhbGwgYW5pbWF0aW9ucyBhcmUgZm9yY2VkIHRvIDFtcyBzbyB0aGF0IHRoZXkgb2NjdXIgaW1tZWRpYXRlbHkgdXBvbiB0aGUgbmV4dCByQUYgdGljay5cblx0XHRcdFx0XHQgQWx0ZXJuYXRpdmVseSwgYSBtdWx0aXBsaWVyIGNhbiBiZSBwYXNzZWQgaW4gdG8gdGltZSByZW1hcCBhbGwgZGVsYXlzIGFuZCBkdXJhdGlvbnMuICovXG5cdFx0XHRcdFx0aWYgKFZlbG9jaXR5Lm1vY2sgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdG9wdHMuZHVyYXRpb24gPSBvcHRzLmRlbGF5ID0gMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiAqPSBwYXJzZUZsb2F0KFZlbG9jaXR5Lm1vY2spIHx8IDE7XG5cdFx0XHRcdFx0XHRvcHRzLmRlbGF5ICo9IHBhcnNlRmxvYXQoVmVsb2NpdHkubW9jaykgfHwgMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgT3B0aW9uOiBFYXNpbmdcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0b3B0cy5lYXNpbmcgPSBnZXRFYXNpbmcob3B0cy5lYXNpbmcsIG9wdHMuZHVyYXRpb24pO1xuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBPcHRpb246IENhbGxiYWNrc1xuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBDYWxsYmFja3MgbXVzdCBmdW5jdGlvbnMuIE90aGVyd2lzZSwgZGVmYXVsdCB0byBudWxsLiAqL1xuXHRcdFx0XHRpZiAob3B0cy5iZWdpbiAmJiAhVHlwZS5pc0Z1bmN0aW9uKG9wdHMuYmVnaW4pKSB7XG5cdFx0XHRcdFx0b3B0cy5iZWdpbiA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0cy5wcm9ncmVzcyAmJiAhVHlwZS5pc0Z1bmN0aW9uKG9wdHMucHJvZ3Jlc3MpKSB7XG5cdFx0XHRcdFx0b3B0cy5wcm9ncmVzcyA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0cy5jb21wbGV0ZSAmJiAhVHlwZS5pc0Z1bmN0aW9uKG9wdHMuY29tcGxldGUpKSB7XG5cdFx0XHRcdFx0b3B0cy5jb21wbGV0ZSA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBPcHRpb246IERpc3BsYXkgJiBWaXNpYmlsaXR5XG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogUmVmZXIgdG8gVmVsb2NpdHkncyBkb2N1bWVudGF0aW9uIChWZWxvY2l0eUpTLm9yZy8jZGlzcGxheUFuZFZpc2liaWxpdHkpIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBkaXNwbGF5IGFuZCB2aXNpYmlsaXR5IG9wdGlvbnMnIGJlaGF2aW9yLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBXZSBzdHJpY3RseSBjaGVjayBmb3IgdW5kZWZpbmVkIGluc3RlYWQgb2YgZmFsc2luZXNzIGJlY2F1c2UgZGlzcGxheSBhY2NlcHRzIGFuIGVtcHR5IHN0cmluZyB2YWx1ZS4gKi9cblx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIG9wdHMuZGlzcGxheSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdG9wdHMuZGlzcGxheSA9IG9wdHMuZGlzcGxheS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0XHQvKiBVc2VycyBjYW4gcGFzcyBpbiBhIHNwZWNpYWwgXCJhdXRvXCIgdmFsdWUgdG8gaW5zdHJ1Y3QgVmVsb2NpdHkgdG8gc2V0IHRoZSBlbGVtZW50IHRvIGl0cyBkZWZhdWx0IGRpc3BsYXkgdmFsdWUuICovXG5cdFx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSA9PT0gXCJhdXRvXCIpIHtcblx0XHRcdFx0XHRcdG9wdHMuZGlzcGxheSA9IFZlbG9jaXR5LkNTUy5WYWx1ZXMuZ2V0RGlzcGxheVR5cGUoZWxlbWVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdHMudmlzaWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmIG9wdHMudmlzaWJpbGl0eSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdG9wdHMudmlzaWJpbGl0eSA9IG9wdHMudmlzaWJpbGl0eS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgT3B0aW9uOiBtb2JpbGVIQVxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBXaGVuIHNldCB0byB0cnVlLCBhbmQgaWYgdGhpcyBpcyBhIG1vYmlsZSBkZXZpY2UsIG1vYmlsZUhBIGF1dG9tYXRpY2FsbHkgZW5hYmxlcyBoYXJkd2FyZSBhY2NlbGVyYXRpb24gKHZpYSBhIG51bGwgdHJhbnNmb3JtIGhhY2spXG5cdFx0XHRcdCBvbiBhbmltYXRpbmcgZWxlbWVudHMuIEhBIGlzIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCBhdCB0aGUgY29tcGxldGlvbiBvZiBpdHMgYW5pbWF0aW9uLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBBbmRyb2lkIEdpbmdlcmJyZWFkIGRvZXNuJ3Qgc3VwcG9ydCBIQS4gSWYgYSBudWxsIHRyYW5zZm9ybSBoYWNrIChtb2JpbGVIQSkgaXMgaW4gZmFjdCBzZXQsIGl0IHdpbGwgcHJldmVudCBvdGhlciB0cmFuZm9ybSBzdWJwcm9wZXJ0aWVzIGZyb20gdGFraW5nIGVmZmVjdC4gKi9cblx0XHRcdFx0LyogTm90ZTogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgdGhlIHVzZSBvZiBtb2JpbGVIQSBpbiBWZWxvY2l0eSdzIGRvY3VtZW50YXRpb246IFZlbG9jaXR5SlMub3JnLyNtb2JpbGVIQS4gKi9cblx0XHRcdFx0b3B0cy5tb2JpbGVIQSA9IChvcHRzLm1vYmlsZUhBICYmIFZlbG9jaXR5LlN0YXRlLmlzTW9iaWxlICYmICFWZWxvY2l0eS5TdGF0ZS5pc0dpbmdlcmJyZWFkKTtcblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IFBhcnQgSUk6IFF1ZXVlaW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBXaGVuIGEgc2V0IG9mIGVsZW1lbnRzIGlzIHRhcmdldGVkIGJ5IGEgVmVsb2NpdHkgY2FsbCwgdGhlIHNldCBpcyBicm9rZW4gdXAgYW5kIGVhY2ggZWxlbWVudCBoYXMgdGhlIGN1cnJlbnQgVmVsb2NpdHkgY2FsbCBpbmRpdmlkdWFsbHkgcXVldWVkIG9udG8gaXQuXG5cdFx0XHRcdCBJbiB0aGlzIHdheSwgZWFjaCBlbGVtZW50J3MgZXhpc3RpbmcgcXVldWUgaXMgcmVzcGVjdGVkOyBzb21lIGVsZW1lbnRzIG1heSBhbHJlYWR5IGJlIGFuaW1hdGluZyBhbmQgYWNjb3JkaW5nbHkgc2hvdWxkIG5vdCBoYXZlIHRoaXMgY3VycmVudCBWZWxvY2l0eSBjYWxsIHRyaWdnZXJlZCBpbW1lZGlhdGVseS4gKi9cblx0XHRcdFx0LyogSW4gZWFjaCBxdWV1ZSwgdHdlZW4gZGF0YSBpcyBwcm9jZXNzZWQgZm9yIGVhY2ggYW5pbWF0aW5nIHByb3BlcnR5IHRoZW4gcHVzaGVkIG9udG8gdGhlIGNhbGwtd2lkZSBjYWxscyBhcnJheS4gV2hlbiB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIGhhZCBpdHMgdHdlZW5zIHByb2Nlc3NlZCxcblx0XHRcdFx0IHRoZSBjYWxsIGFycmF5IGlzIHB1c2hlZCB0byBWZWxvY2l0eS5TdGF0ZS5jYWxscyBmb3IgbGl2ZSBwcm9jZXNzaW5nIGJ5IHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGljay4gKi9cblx0XHRcdFx0ZnVuY3Rpb24gYnVpbGRRdWV1ZShuZXh0KSB7XG5cdFx0XHRcdFx0dmFyIGRhdGEsIGxhc3RUd2VlbnNDb250YWluZXI7XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBPcHRpb246IEJlZ2luXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBUaGUgYmVnaW4gY2FsbGJhY2sgaXMgZmlyZWQgb25jZSBwZXIgY2FsbCAtLSBub3Qgb25jZSBwZXIgZWxlbWVuZXQgLS0gYW5kIGlzIHBhc3NlZCB0aGUgZnVsbCByYXcgRE9NIGVsZW1lbnQgc2V0IGFzIGJvdGggaXRzIGNvbnRleHQgYW5kIGl0cyBmaXJzdCBhcmd1bWVudC4gKi9cblx0XHRcdFx0XHRpZiAob3B0cy5iZWdpbiAmJiBlbGVtZW50c0luZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0XHQvKiBXZSB0aHJvdyBjYWxsYmFja3MgaW4gYSBzZXRUaW1lb3V0IHNvIHRoYXQgdGhyb3duIGVycm9ycyBkb24ndCBoYWx0IHRoZSBleGVjdXRpb24gb2YgVmVsb2NpdHkgaXRzZWxmLiAqL1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0b3B0cy5iZWdpbi5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cyk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XHRcdFx0XHR9LCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHQgVHdlZW4gRGF0YSBDb25zdHJ1Y3Rpb24gKGZvciBTY3JvbGwpXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogTm90ZTogSW4gb3JkZXIgdG8gYmUgc3ViamVjdGVkIHRvIGNoYWluaW5nIGFuZCBhbmltYXRpb24gb3B0aW9ucywgc2Nyb2xsJ3MgdHdlZW5pbmcgaXMgcm91dGVkIHRocm91Z2ggVmVsb2NpdHkgYXMgaWYgaXQgd2VyZSBhIHN0YW5kYXJkIENTUyBwcm9wZXJ0eSBhbmltYXRpb24uICovXG5cdFx0XHRcdFx0aWYgKGFjdGlvbiA9PT0gXCJzY3JvbGxcIikge1xuXHRcdFx0XHRcdFx0LyogVGhlIHNjcm9sbCBhY3Rpb24gdW5pcXVlbHkgdGFrZXMgYW4gb3B0aW9uYWwgXCJvZmZzZXRcIiBvcHRpb24gLS0gc3BlY2lmaWVkIGluIHBpeGVscyAtLSB0aGF0IG9mZnNldHMgdGhlIHRhcmdldGVkIHNjcm9sbCBwb3NpdGlvbi4gKi9cblx0XHRcdFx0XHRcdHZhciBzY3JvbGxEaXJlY3Rpb24gPSAoL154JC9pLnRlc3Qob3B0cy5heGlzKSA/IFwiTGVmdFwiIDogXCJUb3BcIiksXG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsT2Zmc2V0ID0gcGFyc2VGbG9hdChvcHRzLm9mZnNldCkgfHwgMCxcblx0XHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkN1cnJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsUG9zaXRpb25DdXJyZW50QWx0ZXJuYXRlLFxuXHRcdFx0XHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uRW5kO1xuXG5cdFx0XHRcdFx0XHQvKiBTY3JvbGwgYWxzbyB1bmlxdWVseSB0YWtlcyBhbiBvcHRpb25hbCBcImNvbnRhaW5lclwiIG9wdGlvbiwgd2hpY2ggaW5kaWNhdGVzIHRoZSBwYXJlbnQgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCAtLVxuXHRcdFx0XHRcdFx0IGFzIG9wcG9zZWQgdG8gdGhlIGJyb3dzZXIgd2luZG93IGl0c2VsZi4gVGhpcyBpcyB1c2VmdWwgZm9yIHNjcm9sbGluZyB0b3dhcmQgYW4gZWxlbWVudCB0aGF0J3MgaW5zaWRlIGFuIG92ZXJmbG93aW5nIHBhcmVudCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMuY29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRcdC8qIEVuc3VyZSB0aGF0IGVpdGhlciBhIGpRdWVyeSBvYmplY3Qgb3IgYSByYXcgRE9NIGVsZW1lbnQgd2FzIHBhc3NlZCBpbi4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNXcmFwcGVkKG9wdHMuY29udGFpbmVyKSB8fCBUeXBlLmlzTm9kZShvcHRzLmNvbnRhaW5lcikpIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBFeHRyYWN0IHRoZSByYXcgRE9NIGVsZW1lbnQgZnJvbSB0aGUgalF1ZXJ5IHdyYXBwZXIuICovXG5cdFx0XHRcdFx0XHRcdFx0b3B0cy5jb250YWluZXIgPSBvcHRzLmNvbnRhaW5lclswXSB8fCBvcHRzLmNvbnRhaW5lcjtcblx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBVbmxpa2Ugb3RoZXIgcHJvcGVydGllcyBpbiBWZWxvY2l0eSwgdGhlIGJyb3dzZXIncyBzY3JvbGwgcG9zaXRpb24gaXMgbmV2ZXIgY2FjaGVkIHNpbmNlIGl0IHNvIGZyZXF1ZW50bHkgY2hhbmdlc1xuXHRcdFx0XHRcdFx0XHRcdCAoZHVlIHRvIHRoZSB1c2VyJ3MgbmF0dXJhbCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBwYWdlKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkN1cnJlbnQgPSBvcHRzLmNvbnRhaW5lcltcInNjcm9sbFwiICsgc2Nyb2xsRGlyZWN0aW9uXTsgLyogR0VUICovXG5cblx0XHRcdFx0XHRcdFx0XHQvKiAkLnBvc2l0aW9uKCkgdmFsdWVzIGFyZSByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyJ3MgY3VycmVudGx5IHZpZXdhYmxlIGFyZWEgKHdpdGhvdXQgdGFraW5nIGludG8gYWNjb3VudCB0aGUgY29udGFpbmVyJ3MgdHJ1ZSBkaW1lbnNpb25zXG5cdFx0XHRcdFx0XHRcdFx0IC0tIHNheSwgZm9yIGV4YW1wbGUsIGlmIHRoZSBjb250YWluZXIgd2FzIG5vdCBvdmVyZmxvd2luZykuIFRodXMsIHRoZSBzY3JvbGwgZW5kIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGNoaWxkIGVsZW1lbnQncyBwb3NpdGlvbiAqYW5kKlxuXHRcdFx0XHRcdFx0XHRcdCB0aGUgc2Nyb2xsIGNvbnRhaW5lcidzIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uRW5kID0gKHNjcm9sbFBvc2l0aW9uQ3VycmVudCArICQoZWxlbWVudCkucG9zaXRpb24oKVtzY3JvbGxEaXJlY3Rpb24udG9Mb3dlckNhc2UoKV0pICsgc2Nyb2xsT2Zmc2V0OyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHQvKiBJZiBhIHZhbHVlIG90aGVyIHRoYW4gYSBqUXVlcnkgb2JqZWN0IG9yIGEgcmF3IERPTSBlbGVtZW50IHdhcyBwYXNzZWQgaW4sIGRlZmF1bHQgdG8gbnVsbCBzbyB0aGF0IHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQuICovXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0cy5jb250YWluZXIgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvKiBJZiB0aGUgd2luZG93IGl0c2VsZiBpcyBiZWluZyBzY3JvbGxlZCAtLSBub3QgYSBjb250YWluaW5nIGVsZW1lbnQgLS0gcGVyZm9ybSBhIGxpdmUgc2Nyb2xsIHBvc2l0aW9uIGxvb2t1cCB1c2luZ1xuXHRcdFx0XHRcdFx0XHQgdGhlIGFwcHJvcHJpYXRlIGNhY2hlZCBwcm9wZXJ0eSBuYW1lcyAod2hpY2ggZGlmZmVyIGJhc2VkIG9uIGJyb3dzZXIgdHlwZSkuICovXG5cdFx0XHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uQ3VycmVudCA9IFZlbG9jaXR5LlN0YXRlLnNjcm9sbEFuY2hvcltWZWxvY2l0eS5TdGF0ZVtcInNjcm9sbFByb3BlcnR5XCIgKyBzY3JvbGxEaXJlY3Rpb25dXTsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdC8qIFdoZW4gc2Nyb2xsaW5nIHRoZSBicm93c2VyIHdpbmRvdywgY2FjaGUgdGhlIGFsdGVybmF0ZSBheGlzJ3MgY3VycmVudCB2YWx1ZSBzaW5jZSB3aW5kb3cuc2Nyb2xsVG8oKSBkb2Vzbid0IGxldCB1cyBjaGFuZ2Ugb25seSBvbmUgdmFsdWUgYXQgYSB0aW1lLiAqL1xuXHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkN1cnJlbnRBbHRlcm5hdGUgPSBWZWxvY2l0eS5TdGF0ZS5zY3JvbGxBbmNob3JbVmVsb2NpdHkuU3RhdGVbXCJzY3JvbGxQcm9wZXJ0eVwiICsgKHNjcm9sbERpcmVjdGlvbiA9PT0gXCJMZWZ0XCIgPyBcIlRvcFwiIDogXCJMZWZ0XCIpXV07IC8qIEdFVCAqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIFVubGlrZSAkLnBvc2l0aW9uKCksICQub2Zmc2V0KCkgdmFsdWVzIGFyZSByZWxhdGl2ZSB0byB0aGUgYnJvd3NlciB3aW5kb3cncyB0cnVlIGRpbWVuc2lvbnMgLS0gbm90IG1lcmVseSBpdHMgY3VycmVudGx5IHZpZXdhYmxlIGFyZWEgLS1cblx0XHRcdFx0XHRcdFx0IGFuZCB0aGVyZWZvcmUgZW5kIHZhbHVlcyBkbyBub3QgbmVlZCB0byBiZSBjb21wb3VuZGVkIG9udG8gY3VycmVudCB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uRW5kID0gJChlbGVtZW50KS5vZmZzZXQoKVtzY3JvbGxEaXJlY3Rpb24udG9Mb3dlckNhc2UoKV0gKyBzY3JvbGxPZmZzZXQ7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBTaW5jZSB0aGVyZSdzIG9ubHkgb25lIGZvcm1hdCB0aGF0IHNjcm9sbCdzIGFzc29jaWF0ZWQgdHdlZW5zQ29udGFpbmVyIGNhbiB0YWtlLCB3ZSBjcmVhdGUgaXQgbWFudWFsbHkuICovXG5cdFx0XHRcdFx0XHR0d2VlbnNDb250YWluZXIgPSB7XG5cdFx0XHRcdFx0XHRcdHNjcm9sbDoge1xuXHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlOiBzY3JvbGxQb3NpdGlvbkN1cnJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlOiBzY3JvbGxQb3NpdGlvbkN1cnJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWU6IHNjcm9sbFBvc2l0aW9uRW5kLFxuXHRcdFx0XHRcdFx0XHRcdHVuaXRUeXBlOiBcIlwiLFxuXHRcdFx0XHRcdFx0XHRcdGVhc2luZzogb3B0cy5lYXNpbmcsXG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsRGF0YToge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGFpbmVyOiBvcHRzLmNvbnRhaW5lcixcblx0XHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogc2Nyb2xsRGlyZWN0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRlVmFsdWU6IHNjcm9sbFBvc2l0aW9uQ3VycmVudEFsdGVybmF0ZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudFxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwidHdlZW5zQ29udGFpbmVyIChzY3JvbGwpOiBcIiwgdHdlZW5zQ29udGFpbmVyLnNjcm9sbCwgZWxlbWVudCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBUd2VlbiBEYXRhIENvbnN0cnVjdGlvbiAoZm9yIFJldmVyc2UpXG5cdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHQvKiBSZXZlcnNlIGFjdHMgbGlrZSBhIFwic3RhcnRcIiBhY3Rpb24gaW4gdGhhdCBhIHByb3BlcnR5IG1hcCBpcyBhbmltYXRlZCB0b3dhcmQuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXNcblx0XHRcdFx0XHRcdCB0aGF0IHRoZSBwcm9wZXJ0eSBtYXAgdXNlZCBmb3IgcmV2ZXJzZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgbWFwIHVzZWQgaW4gdGhlIHByZXZpb3VzIGNhbGwuIFRodXMsIHdlIG1hbmlwdWxhdGVcblx0XHRcdFx0XHRcdCB0aGUgcHJldmlvdXMgY2FsbCB0byBjb25zdHJ1Y3Qgb3VyIG5ldyBtYXA6IHVzZSB0aGUgcHJldmlvdXMgbWFwJ3MgZW5kIHZhbHVlcyBhcyBvdXIgbmV3IG1hcCdzIHN0YXJ0IHZhbHVlcy4gQ29weSBvdmVyIGFsbCBvdGhlciBkYXRhLiAqL1xuXHRcdFx0XHRcdFx0LyogTm90ZTogUmV2ZXJzZSBjYW4gYmUgZGlyZWN0bHkgY2FsbGVkIHZpYSB0aGUgXCJyZXZlcnNlXCIgcGFyYW1ldGVyLCBvciBpdCBjYW4gYmUgaW5kaXJlY3RseSB0cmlnZ2VyZWQgdmlhIHRoZSBsb29wIG9wdGlvbi4gKExvb3BzIGFyZSBjb21wb3NlZCBvZiBtdWx0aXBsZSByZXZlcnNlcy4pICovXG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBSZXZlcnNlIGNhbGxzIGRvIG5vdCBuZWVkIHRvIGJlIGNvbnNlY3V0aXZlbHkgY2hhaW5lZCBvbnRvIGEgY3VycmVudGx5LWFuaW1hdGluZyBlbGVtZW50IGluIG9yZGVyIHRvIG9wZXJhdGUgb24gY2FjaGVkIHZhbHVlcztcblx0XHRcdFx0XHRcdCB0aGVyZSBpcyBubyBoYXJtIHRvIHJldmVyc2UgYmVpbmcgY2FsbGVkIG9uIGEgcG90ZW50aWFsbHkgc3RhbGUgZGF0YSBjYWNoZSBzaW5jZSByZXZlcnNlJ3MgYmVoYXZpb3IgaXMgc2ltcGx5IGRlZmluZWRcblx0XHRcdFx0XHRcdCBhcyByZXZlcnRpbmcgdG8gdGhlIGVsZW1lbnQncyB2YWx1ZXMgYXMgdGhleSB3ZXJlIHByaW9yIHRvIHRoZSBwcmV2aW91cyAqVmVsb2NpdHkqIGNhbGwuICovXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhY3Rpb24gPT09IFwicmV2ZXJzZVwiKSB7XG5cdFx0XHRcdFx0XHRkYXRhID0gRGF0YShlbGVtZW50KTtcblxuXHRcdFx0XHRcdFx0LyogQWJvcnQgaWYgdGhlcmUgaXMgbm8gcHJpb3IgYW5pbWF0aW9uIGRhdGEgdG8gcmV2ZXJzZSB0by4gKi9cblx0XHRcdFx0XHRcdGlmICghZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICghZGF0YS50d2VlbnNDb250YWluZXIpIHtcblx0XHRcdFx0XHRcdFx0LyogRGVxdWV1ZSB0aGUgZWxlbWVudCBzbyB0aGF0IHRoaXMgcXVldWUgZW50cnkgcmVsZWFzZXMgaXRzZWxmIGltbWVkaWF0ZWx5LCBhbGxvd2luZyBzdWJzZXF1ZW50IHF1ZXVlIGVudHJpZXMgdG8gcnVuLiAqL1xuXHRcdFx0XHRcdFx0XHQkLmRlcXVldWUoZWxlbWVudCwgb3B0cy5xdWV1ZSk7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgT3B0aW9ucyBQYXJzaW5nXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2FzIGhpZGRlbiB2aWEgdGhlIGRpc3BsYXkgb3B0aW9uIGluIHRoZSBwcmV2aW91cyBjYWxsLFxuXHRcdFx0XHRcdFx0XHQgcmV2ZXJ0IGRpc3BsYXkgdG8gXCJhdXRvXCIgcHJpb3IgdG8gcmV2ZXJzYWwgc28gdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGFnYWluLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5vcHRzLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5vcHRzLmRpc3BsYXkgPSBcImF1dG9cIjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhLm9wdHMudmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEub3B0cy52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBJZiB0aGUgbG9vcCBvcHRpb24gd2FzIHNldCBpbiB0aGUgcHJldmlvdXMgY2FsbCwgZGlzYWJsZSBpdCBzbyB0aGF0IFwicmV2ZXJzZVwiIGNhbGxzIGFyZW4ndCByZWN1cnNpdmVseSBnZW5lcmF0ZWQuXG5cdFx0XHRcdFx0XHRcdCBGdXJ0aGVyLCByZW1vdmUgdGhlIHByZXZpb3VzIGNhbGwncyBjYWxsYmFjayBvcHRpb25zOyB0eXBpY2FsbHksIHVzZXJzIGRvIG5vdCB3YW50IHRoZXNlIHRvIGJlIHJlZmlyZWQuICovXG5cdFx0XHRcdFx0XHRcdGRhdGEub3B0cy5sb29wID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGRhdGEub3B0cy5iZWdpbiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdGRhdGEub3B0cy5jb21wbGV0ZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0LyogU2luY2Ugd2UncmUgZXh0ZW5kaW5nIGFuIG9wdHMgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiBleHRlbmRlZCB3aXRoIHRoZSBkZWZhdWx0cyBvcHRpb25zIG9iamVjdCxcblx0XHRcdFx0XHRcdFx0IHdlIHJlbW92ZSBub24tZXhwbGljaXRseS1kZWZpbmVkIHByb3BlcnRpZXMgdGhhdCBhcmUgYXV0by1hc3NpZ25lZCB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5lYXNpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgb3B0cy5lYXNpbmc7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgb3B0cy5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIFRoZSBvcHRzIG9iamVjdCB1c2VkIGZvciByZXZlcnNhbCBpcyBhbiBleHRlbnNpb24gb2YgdGhlIG9wdGlvbnMgb2JqZWN0IG9wdGlvbmFsbHkgcGFzc2VkIGludG8gdGhpc1xuXHRcdFx0XHRcdFx0XHQgcmV2ZXJzZSBjYWxsIHBsdXMgdGhlIG9wdGlvbnMgdXNlZCBpbiB0aGUgcHJldmlvdXMgVmVsb2NpdHkgY2FsbC4gKi9cblx0XHRcdFx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCBkYXRhLm9wdHMsIG9wdHMpO1xuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdCBUd2VlbnMgQ29udGFpbmVyIFJlY29uc3RydWN0aW9uXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIENyZWF0ZSBhIGRlZXB5IGNvcHkgKGluZGljYXRlZCB2aWEgdGhlIHRydWUgZmxhZykgb2YgdGhlIHByZXZpb3VzIGNhbGwncyB0d2VlbnNDb250YWluZXIuICovXG5cdFx0XHRcdFx0XHRcdGxhc3RUd2VlbnNDb250YWluZXIgPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGF0YSA/IGRhdGEudHdlZW5zQ29udGFpbmVyIDogbnVsbCk7XG5cblx0XHRcdFx0XHRcdFx0LyogTWFuaXB1bGF0ZSB0aGUgcHJldmlvdXMgdHdlZW5zQ29udGFpbmVyIGJ5IHJlcGxhY2luZyBpdHMgZW5kIHZhbHVlcyBhbmQgY3VycmVudFZhbHVlcyB3aXRoIGl0cyBzdGFydCB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGxhc3RUd2VlbiBpbiBsYXN0VHdlZW5zQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogSW4gYWRkaXRpb24gdG8gdHdlZW4gZGF0YSwgdHdlZW5zQ29udGFpbmVycyBjb250YWluIGFuIGVsZW1lbnQgcHJvcGVydHkgdGhhdCB3ZSBpZ25vcmUgaGVyZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAobGFzdFR3ZWVuc0NvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShsYXN0VHdlZW4pICYmIGxhc3RUd2VlbiAhPT0gXCJlbGVtZW50XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBsYXN0U3RhcnRWYWx1ZSA9IGxhc3RUd2VlbnNDb250YWluZXJbbGFzdFR3ZWVuXS5zdGFydFZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0VHdlZW5zQ29udGFpbmVyW2xhc3RUd2Vlbl0uc3RhcnRWYWx1ZSA9IGxhc3RUd2VlbnNDb250YWluZXJbbGFzdFR3ZWVuXS5jdXJyZW50VmFsdWUgPSBsYXN0VHdlZW5zQ29udGFpbmVyW2xhc3RUd2Vlbl0uZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0VHdlZW5zQ29udGFpbmVyW2xhc3RUd2Vlbl0uZW5kVmFsdWUgPSBsYXN0U3RhcnRWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogRWFzaW5nIGlzIHRoZSBvbmx5IG9wdGlvbiB0aGF0IGVtYmVkcyBpbnRvIHRoZSBpbmRpdmlkdWFsIHR3ZWVuIGRhdGEgKHNpbmNlIGl0IGNhbiBiZSBkZWZpbmVkIG9uIGEgcGVyLXByb3BlcnR5IGJhc2lzKS5cblx0XHRcdFx0XHRcdFx0XHRcdCBBY2NvcmRpbmdseSwgZXZlcnkgcHJvcGVydHkncyBlYXNpbmcgdmFsdWUgbXVzdCBiZSB1cGRhdGVkIHdoZW4gYW4gb3B0aW9ucyBvYmplY3QgaXMgcGFzc2VkIGluIHdpdGggYSByZXZlcnNlIGNhbGwuXG5cdFx0XHRcdFx0XHRcdFx0XHQgVGhlIHNpZGUgZWZmZWN0IG9mIHRoaXMgZXh0ZW5zaWJpbGl0eSBpcyB0aGF0IGFsbCBwZXItcHJvcGVydHkgZWFzaW5nIHZhbHVlcyBhcmUgZm9yY2VmdWxseSByZXNldCB0byB0aGUgbmV3IHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFUeXBlLmlzRW1wdHlPYmplY3Qob3B0aW9ucykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bGFzdFR3ZWVuc0NvbnRhaW5lcltsYXN0VHdlZW5dLmVhc2luZyA9IG9wdHMuZWFzaW5nO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJyZXZlcnNlIHR3ZWVuc0NvbnRhaW5lciAoXCIgKyBsYXN0VHdlZW4gKyBcIik6IFwiICsgSlNPTi5zdHJpbmdpZnkobGFzdFR3ZWVuc0NvbnRhaW5lcltsYXN0VHdlZW5dKSwgZWxlbWVudCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dHdlZW5zQ29udGFpbmVyID0gbGFzdFR3ZWVuc0NvbnRhaW5lcjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHQgVHdlZW4gRGF0YSBDb25zdHJ1Y3Rpb24gKGZvciBTdGFydClcblx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInN0YXJ0XCIpIHtcblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBWYWx1ZSBUcmFuc2ZlcnJpbmdcblx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHQvKiBJZiB0aGlzIHF1ZXVlIGVudHJ5IGZvbGxvd3MgYSBwcmV2aW91cyBWZWxvY2l0eS1pbml0aWF0ZWQgcXVldWUgZW50cnkgKmFuZCogaWYgdGhpcyBlbnRyeSB3YXMgY3JlYXRlZFxuXHRcdFx0XHRcdFx0IHdoaWxlIHRoZSBlbGVtZW50IHdhcyBpbiB0aGUgcHJvY2VzcyBvZiBiZWluZyBhbmltYXRlZCBieSBWZWxvY2l0eSwgdGhlbiB0aGlzIGN1cnJlbnQgY2FsbCBpcyBzYWZlIHRvIHVzZVxuXHRcdFx0XHRcdFx0IHRoZSBlbmQgdmFsdWVzIGZyb20gdGhlIHByaW9yIGNhbGwgYXMgaXRzIHN0YXJ0IHZhbHVlcy4gVmVsb2NpdHkgYXR0ZW1wdHMgdG8gcGVyZm9ybSB0aGlzIHZhbHVlIHRyYW5zZmVyXG5cdFx0XHRcdFx0XHQgcHJvY2VzcyB3aGVuZXZlciBwb3NzaWJsZSBpbiBvcmRlciB0byBhdm9pZCByZXF1ZXJ5aW5nIHRoZSBET00uICovXG5cdFx0XHRcdFx0XHQvKiBJZiB2YWx1ZXMgYXJlbid0IHRyYW5zZmVycmVkIGZyb20gYSBwcmlvciBjYWxsIGFuZCBzdGFydCB2YWx1ZXMgd2VyZSBub3QgZm9yY2VmZWQgYnkgdGhlIHVzZXIgKG1vcmUgb24gdGhpcyBiZWxvdyksXG5cdFx0XHRcdFx0XHQgdGhlbiB0aGUgRE9NIGlzIHF1ZXJpZWQgZm9yIHRoZSBlbGVtZW50J3MgY3VycmVudCB2YWx1ZXMgYXMgYSBsYXN0IHJlc29ydC4gKi9cblx0XHRcdFx0XHRcdC8qIE5vdGU6IENvbnZlcnNlbHksIGFuaW1hdGlvbiByZXZlcnNhbCAoYW5kIGxvb3BpbmcpICphbHdheXMqIHBlcmZvcm0gaW50ZXItY2FsbCB2YWx1ZSB0cmFuc2ZlcnM7IHRoZXkgbmV2ZXIgcmVxdWVyeSB0aGUgRE9NLiAqL1xuXG5cdFx0XHRcdFx0XHRkYXRhID0gRGF0YShlbGVtZW50KTtcblxuXHRcdFx0XHRcdFx0LyogVGhlIHBlci1lbGVtZW50IGlzQW5pbWF0aW5nIGZsYWcgaXMgdXNlZCB0byBpbmRpY2F0ZSB3aGV0aGVyIGl0J3Mgc2FmZSAoaS5lLiB0aGUgZGF0YSBpc24ndCBzdGFsZSlcblx0XHRcdFx0XHRcdCB0byB0cmFuc2ZlciBvdmVyIGVuZCB2YWx1ZXMgdG8gdXNlIGFzIHN0YXJ0IHZhbHVlcy4gSWYgaXQncyBzZXQgdG8gdHJ1ZSBhbmQgdGhlcmUgaXMgYSBwcmV2aW91c1xuXHRcdFx0XHRcdFx0IFZlbG9jaXR5IGNhbGwgdG8gcHVsbCB2YWx1ZXMgZnJvbSwgZG8gc28uICovXG5cdFx0XHRcdFx0XHRpZiAoZGF0YSAmJiBkYXRhLnR3ZWVuc0NvbnRhaW5lciAmJiBkYXRhLmlzQW5pbWF0aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdGxhc3RUd2VlbnNDb250YWluZXIgPSBkYXRhLnR3ZWVuc0NvbnRhaW5lcjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0IFR3ZWVuIERhdGEgQ2FsY3VsYXRpb25cblx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdC8qIFRoaXMgZnVuY3Rpb24gcGFyc2VzIHByb3BlcnR5IGRhdGEgYW5kIGRlZmF1bHRzIGVuZFZhbHVlLCBlYXNpbmcsIGFuZCBzdGFydFZhbHVlIGFzIGFwcHJvcHJpYXRlLiAqL1xuXHRcdFx0XHRcdFx0LyogUHJvcGVydHkgbWFwIHZhbHVlcyBjYW4gZWl0aGVyIHRha2UgdGhlIGZvcm0gb2YgMSkgYSBzaW5nbGUgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBlbmQgdmFsdWUsXG5cdFx0XHRcdFx0XHQgb3IgMikgYW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgWyBlbmRWYWx1ZSwgWywgZWFzaW5nXSBbLCBzdGFydFZhbHVlXSBdLlxuXHRcdFx0XHRcdFx0IFRoZSBvcHRpb25hbCB0aGlyZCBwYXJhbWV0ZXIgaXMgYSBmb3JjZWZlZCBzdGFydFZhbHVlIHRvIGJlIHVzZWQgaW5zdGVhZCBvZiBxdWVyeWluZyB0aGUgRE9NIGZvclxuXHRcdFx0XHRcdFx0IHRoZSBlbGVtZW50J3MgY3VycmVudCB2YWx1ZS4gUmVhZCBWZWxvY2l0eSdzIGRvY21lbnRhdGlvbiB0byBsZWFybiBtb3JlIGFib3V0IGZvcmNlZmVlZGluZzogVmVsb2NpdHlKUy5vcmcvI2ZvcmNlZmVlZGluZyAqL1xuXHRcdFx0XHRcdFx0dmFyIHBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlRGF0YSwgc2tpcFJlc29sdmluZ0Vhc2luZykge1xuXHRcdFx0XHRcdFx0XHR2YXIgZW5kVmFsdWUsIGVhc2luZywgc3RhcnRWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHQvKiBJZiB3ZSBoYXZlIGEgZnVuY3Rpb24gYXMgdGhlIG1haW4gYXJndW1lbnQgdGhlbiByZXNvbHZlIGl0IGZpcnN0LCBpbiBjYXNlIGl0IHJldHVybnMgYW4gYXJyYXkgdGhhdCBuZWVkcyB0byBiZSBzcGxpdCAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoVHlwZS5pc0Z1bmN0aW9uKHZhbHVlRGF0YSkpIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZURhdGEgPSB2YWx1ZURhdGEuY2FsbChlbGVtZW50LCBlbGVtZW50QXJyYXlJbmRleCwgZWxlbWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogSGFuZGxlIHRoZSBhcnJheSBmb3JtYXQsIHdoaWNoIGNhbiBiZSBzdHJ1Y3R1cmVkIGFzIG9uZSBvZiB0aHJlZSBwb3RlbnRpYWwgb3ZlcmxvYWRzOlxuXHRcdFx0XHRcdFx0XHQgQSkgWyBlbmRWYWx1ZSwgZWFzaW5nLCBzdGFydFZhbHVlIF0sIEIpIFsgZW5kVmFsdWUsIGVhc2luZyBdLCBvciBDKSBbIGVuZFZhbHVlLCBzdGFydFZhbHVlIF0gKi9cblx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNBcnJheSh2YWx1ZURhdGEpKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogZW5kVmFsdWUgaXMgYWx3YXlzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheS4gRG9uJ3QgYm90aGVyIHZhbGlkYXRpbmcgZW5kVmFsdWUncyB2YWx1ZSBub3dcblx0XHRcdFx0XHRcdFx0XHQgc2luY2UgdGhlIGVuc3VpbmcgcHJvcGVydHkgY3ljbGluZyBsb2dpYyBkb2VzIHRoYXQuICovXG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSB2YWx1ZURhdGFbMF07XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBUd28taXRlbSBhcnJheSBmb3JtYXQ6IElmIHRoZSBzZWNvbmQgaXRlbSBpcyBhIG51bWJlciwgZnVuY3Rpb24sIG9yIGhleCBzdHJpbmcsIHRyZWF0IGl0IGFzIGFcblx0XHRcdFx0XHRcdFx0XHQgc3RhcnQgdmFsdWUgc2luY2UgZWFzaW5ncyBjYW4gb25seSBiZSBub24taGV4IHN0cmluZ3Mgb3IgYXJyYXlzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmICgoIVR5cGUuaXNBcnJheSh2YWx1ZURhdGFbMV0pICYmIC9eW1xcZC1dLy50ZXN0KHZhbHVlRGF0YVsxXSkpIHx8IFR5cGUuaXNGdW5jdGlvbih2YWx1ZURhdGFbMV0pIHx8IENTUy5SZWdFeC5pc0hleC50ZXN0KHZhbHVlRGF0YVsxXSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSB2YWx1ZURhdGFbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBUd28gb3IgdGhyZWUtaXRlbSBhcnJheTogSWYgdGhlIHNlY29uZCBpdGVtIGlzIGEgbm9uLWhleCBzdHJpbmcgZWFzaW5nIG5hbWUgb3IgYW4gYXJyYXksIHRyZWF0IGl0IGFzIGFuIGVhc2luZy4gKi9cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKChUeXBlLmlzU3RyaW5nKHZhbHVlRGF0YVsxXSkgJiYgIUNTUy5SZWdFeC5pc0hleC50ZXN0KHZhbHVlRGF0YVsxXSkgJiYgVmVsb2NpdHkuRWFzaW5nc1t2YWx1ZURhdGFbMV1dKSB8fCBUeXBlLmlzQXJyYXkodmFsdWVEYXRhWzFdKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWFzaW5nID0gc2tpcFJlc29sdmluZ0Vhc2luZyA/IHZhbHVlRGF0YVsxXSA6IGdldEVhc2luZyh2YWx1ZURhdGFbMV0sIG9wdHMuZHVyYXRpb24pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBEb24ndCBib3RoZXIgdmFsaWRhdGluZyBzdGFydFZhbHVlJ3MgdmFsdWUgbm93IHNpbmNlIHRoZSBlbnN1aW5nIHByb3BlcnR5IGN5Y2xpbmcgbG9naWMgaW5oZXJlbnRseSBkb2VzIHRoYXQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gdmFsdWVEYXRhWzJdO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gdmFsdWVEYXRhWzFdIHx8IHZhbHVlRGF0YVsyXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0LyogSGFuZGxlIHRoZSBzaW5nbGUtdmFsdWUgZm9ybWF0LiAqL1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gdmFsdWVEYXRhO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogRGVmYXVsdCB0byB0aGUgY2FsbCdzIGVhc2luZyBpZiBhIHBlci1wcm9wZXJ0eSBlYXNpbmcgdHlwZSB3YXMgbm90IGRlZmluZWQuICovXG5cdFx0XHRcdFx0XHRcdGlmICghc2tpcFJlc29sdmluZ0Vhc2luZykge1xuXHRcdFx0XHRcdFx0XHRcdGVhc2luZyA9IGVhc2luZyB8fCBvcHRzLmVhc2luZztcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIElmIGZ1bmN0aW9ucyB3ZXJlIHBhc3NlZCBpbiBhcyB2YWx1ZXMsIHBhc3MgdGhlIGZ1bmN0aW9uIHRoZSBjdXJyZW50IGVsZW1lbnQgYXMgaXRzIGNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdCBwbHVzIHRoZSBlbGVtZW50J3MgaW5kZXggYW5kIHRoZSBlbGVtZW50IHNldCdzIHNpemUgYXMgYXJndW1lbnRzLiBUaGVuLCBhc3NpZ24gdGhlIHJldHVybmVkIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoVHlwZS5pc0Z1bmN0aW9uKGVuZFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gZW5kVmFsdWUuY2FsbChlbGVtZW50LCBlbGVtZW50QXJyYXlJbmRleCwgZWxlbWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNGdW5jdGlvbihzdGFydFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSBzdGFydFZhbHVlLmNhbGwoZWxlbWVudCwgZWxlbWVudEFycmF5SW5kZXgsIGVsZW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIEFsbG93IHN0YXJ0VmFsdWUgdG8gYmUgbGVmdCBhcyB1bmRlZmluZWQgdG8gaW5kaWNhdGUgdG8gdGhlIGVuc3VpbmcgY29kZSB0aGF0IGl0cyB2YWx1ZSB3YXMgbm90IGZvcmNlZmVkLiAqL1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gW2VuZFZhbHVlIHx8IDAsIGVhc2luZywgc3RhcnRWYWx1ZV07XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHR2YXIgZml4UHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZURhdGEpIHtcblx0XHRcdFx0XHRcdFx0LyogSW4gY2FzZSB0aGlzIHByb3BlcnR5IGlzIGEgaG9vaywgdGhlcmUgYXJlIGNpcmN1bXN0YW5jZXMgd2hlcmUgd2Ugd2lsbCBpbnRlbmQgdG8gd29yayBvbiB0aGUgaG9vaydzIHJvb3QgcHJvcGVydHkgYW5kIG5vdCB0aGUgaG9va2VkIHN1YnByb3BlcnR5LiAqL1xuXHRcdFx0XHRcdFx0XHR2YXIgcm9vdFByb3BlcnR5ID0gQ1NTLkhvb2tzLmdldFJvb3QocHJvcGVydHkpLFxuXHRcdFx0XHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRcdC8qIFBhcnNlIG91dCBlbmRWYWx1ZSwgZWFzaW5nLCBhbmQgc3RhcnRWYWx1ZSBmcm9tIHRoZSBwcm9wZXJ0eSdzIGRhdGEuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHZhbHVlRGF0YVswXSxcblx0XHRcdFx0XHRcdFx0XHRcdGVhc2luZyA9IHZhbHVlRGF0YVsxXSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSB2YWx1ZURhdGFbMl0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuO1xuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgU3RhcnQgVmFsdWUgU291cmNpbmdcblx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIE90aGVyIHRoYW4gZm9yIHRoZSBkdW1teSB0d2VlbiBwcm9wZXJ0eSwgcHJvcGVydGllcyB0aGF0IGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIChhbmQgZG8gbm90IGhhdmUgYW4gYXNzb2NpYXRlZCBub3JtYWxpemF0aW9uKSB3aWxsXG5cdFx0XHRcdFx0XHRcdCBpbmhlcmVudGx5IHByb2R1Y2Ugbm8gc3R5bGUgY2hhbmdlcyB3aGVuIHNldCwgc28gdGhleSBhcmUgc2tpcHBlZCBpbiBvcmRlciB0byBkZWNyZWFzZSBhbmltYXRpb24gdGljayBvdmVyaGVhZC5cblx0XHRcdFx0XHRcdFx0IFByb3BlcnR5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZCB2aWEgcHJlZml4Q2hlY2soKSwgd2hpY2ggcmV0dXJucyBhIGZhbHNlIGZsYWcgd2hlbiBubyBzdXBwb3J0ZWQgaXMgZGV0ZWN0ZWQuICovXG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IFNpbmNlIFNWRyBlbGVtZW50cyBoYXZlIHNvbWUgb2YgdGhlaXIgcHJvcGVydGllcyBkaXJlY3RseSBhcHBsaWVkIGFzIEhUTUwgYXR0cmlidXRlcyxcblx0XHRcdFx0XHRcdFx0IHRoZXJlIGlzIG5vIHdheSB0byBjaGVjayBmb3IgdGhlaXIgZXhwbGljaXQgYnJvd3NlciBzdXBwb3J0LCBhbmQgc28gd2Ugc2tpcCBza2lwIHRoaXMgY2hlY2sgZm9yIHRoZW0uICovXG5cdFx0XHRcdFx0XHRcdGlmICgoIWRhdGEgfHwgIWRhdGEuaXNTVkcpICYmIHJvb3RQcm9wZXJ0eSAhPT0gXCJ0d2VlblwiICYmIENTUy5OYW1lcy5wcmVmaXhDaGVjayhyb290UHJvcGVydHkpWzFdID09PSBmYWxzZSAmJiBDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyb290UHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiU2tpcHBpbmcgW1wiICsgcm9vdFByb3BlcnR5ICsgXCJdIGR1ZSB0byBhIGxhY2sgb2YgYnJvd3NlciBzdXBwb3J0LlwiKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGRpc3BsYXkgb3B0aW9uIGlzIGJlaW5nIHNldCB0byBhIG5vbi1cIm5vbmVcIiAoZS5nLiBcImJsb2NrXCIpIGFuZCBvcGFjaXR5IChmaWx0ZXIgb24gSUU8PTgpIGlzIGJlaW5nXG5cdFx0XHRcdFx0XHRcdCBhbmltYXRlZCB0byBhbiBlbmRWYWx1ZSBvZiBub24temVybywgdGhlIHVzZXIncyBpbnRlbnRpb24gaXMgdG8gZmFkZSBpbiBmcm9tIGludmlzaWJsZSwgdGh1cyB3ZSBmb3JjZWZlZWQgb3BhY2l0eVxuXHRcdFx0XHRcdFx0XHQgYSBzdGFydFZhbHVlIG9mIDAgaWYgaXRzIHN0YXJ0VmFsdWUgaGFzbid0IGFscmVhZHkgYmVlbiBzb3VyY2VkIGJ5IHZhbHVlIHRyYW5zZmVycmluZyBvciBwcmlvciBmb3JjZWZlZWRpbmcuICovXG5cdFx0XHRcdFx0XHRcdGlmICgoKG9wdHMuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIG9wdHMuZGlzcGxheSAhPT0gbnVsbCAmJiBvcHRzLmRpc3BsYXkgIT09IFwibm9uZVwiKSB8fCAob3B0cy52aXNpYmlsaXR5ICE9PSB1bmRlZmluZWQgJiYgb3B0cy52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiKSkgJiYgL29wYWNpdHl8ZmlsdGVyLy50ZXN0KHByb3BlcnR5KSAmJiAhc3RhcnRWYWx1ZSAmJiBlbmRWYWx1ZSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdmFsdWVzIGhhdmUgYmVlbiB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBwcmV2aW91cyBWZWxvY2l0eSBjYWxsLCBleHRyYWN0IHRoZSBlbmRWYWx1ZSBhbmQgcm9vdFByb3BlcnR5VmFsdWVcblx0XHRcdFx0XHRcdFx0IGZvciBhbGwgb2YgdGhlIGN1cnJlbnQgY2FsbCdzIHByb3BlcnRpZXMgdGhhdCB3ZXJlICphbHNvKiBhbmltYXRlZCBpbiB0aGUgcHJldmlvdXMgY2FsbC4gKi9cblx0XHRcdFx0XHRcdFx0LyogTm90ZTogVmFsdWUgdHJhbnNmZXJyaW5nIGNhbiBvcHRpb25hbGx5IGJlIGRpc2FibGVkIGJ5IHRoZSB1c2VyIHZpYSB0aGUgX2NhY2hlVmFsdWVzIG9wdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMuX2NhY2hlVmFsdWVzICYmIGxhc3RUd2VlbnNDb250YWluZXIgJiYgbGFzdFR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RhcnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gbGFzdFR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0uZW5kVmFsdWUgKyBsYXN0VHdlZW5zQ29udGFpbmVyW3Byb3BlcnR5XS51bml0VHlwZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBUaGUgcHJldmlvdXMgY2FsbCdzIHJvb3RQcm9wZXJ0eVZhbHVlIGlzIGV4dHJhY3RlZCBmcm9tIHRoZSBlbGVtZW50J3MgZGF0YSBjYWNoZSBzaW5jZSB0aGF0J3MgdGhlXG5cdFx0XHRcdFx0XHRcdFx0IGluc3RhbmNlIG9mIHJvb3RQcm9wZXJ0eVZhbHVlIHRoYXQgZ2V0cyBmcmVzaGx5IHVwZGF0ZWQgYnkgdGhlIHR3ZWVuaW5nIHByb2Nlc3MsIHdoZXJlYXMgdGhlIHJvb3RQcm9wZXJ0eVZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0IGF0dGFjaGVkIHRvIHRoZSBpbmNvbWluZyBsYXN0VHdlZW5zQ29udGFpbmVyIGlzIGVxdWFsIHRvIHRoZSByb290IHByb3BlcnR5J3MgdmFsdWUgcHJpb3IgdG8gYW55IHR3ZWVuaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlID0gZGF0YS5yb290UHJvcGVydHlWYWx1ZUNhY2hlW3Jvb3RQcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgdmFsdWVzIHdlcmUgbm90IHRyYW5zZmVycmVkIGZyb20gYSBwcmV2aW91cyBWZWxvY2l0eSBjYWxsLCBxdWVyeSB0aGUgRE9NIGFzIG5lZWRlZC4gKi9cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBIYW5kbGUgaG9va2VkIHByb3BlcnRpZXMuICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5Ib29rcy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHN0YXJ0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHJvb3RQcm9wZXJ0eSk7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBUaGUgZm9sbG93aW5nIGdldFByb3BlcnR5VmFsdWUoKSBjYWxsIGRvZXMgbm90IGFjdHVhbGx5IHRyaWdnZXIgYSBET00gcXVlcnk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCBnZXRQcm9wZXJ0eVZhbHVlKCkgd2lsbCBleHRyYWN0IHRoZSBob29rIGZyb20gcm9vdFByb3BlcnR5VmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSwgcm9vdFByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiBzdGFydFZhbHVlIGlzIGFscmVhZHkgZGVmaW5lZCB2aWEgZm9yY2VmZWVkaW5nLCBkbyBub3QgcXVlcnkgdGhlIERPTSBmb3IgdGhlIHJvb3QgcHJvcGVydHkncyB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0IGp1c3QgZ3JhYiByb290UHJvcGVydHkncyB6ZXJvLXZhbHVlIHRlbXBsYXRlIGZyb20gQ1NTLkhvb2tzLiBUaGlzIG92ZXJ3cml0ZXMgdGhlIGVsZW1lbnQncyBhY3R1YWxcblx0XHRcdFx0XHRcdFx0XHRcdFx0IHJvb3QgcHJvcGVydHkgdmFsdWUgKGlmIG9uZSBpcyBzZXQpLCBidXQgdGhpcyBpcyBhY2NlcHRhYmxlIHNpbmNlIHRoZSBwcmltYXJ5IHJlYXNvbiB1c2VycyBmb3JjZWZlZWQgaXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0IHRvIGF2b2lkIERPTSBxdWVyaWVzLCBhbmQgdGh1cyB3ZSBsaWtld2lzZSBhdm9pZCBxdWVyeWluZyB0aGUgRE9NIGZvciB0aGUgcm9vdCBwcm9wZXJ0eSdzIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogR3JhYiB0aGlzIGhvb2sncyB6ZXJvLXZhbHVlIHRlbXBsYXRlLCBlLmcuIFwiMHB4IDBweCAwcHggYmxhY2tcIi4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuSG9va3MudGVtcGxhdGVzW3Jvb3RQcm9wZXJ0eV1bMV07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBIYW5kbGUgbm9uLWhvb2tlZCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gZGVmaW5lZCB2aWEgZm9yY2VmZWVkaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhcnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHkpOyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0IFZhbHVlIERhdGEgRXh0cmFjdGlvblxuXHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0dmFyIHNlcGFyYXRlZFZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVVbml0VHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWVVbml0VHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhdG9yID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdFx0LyogU2VwYXJhdGVzIGEgcHJvcGVydHkgdmFsdWUgaW50byBpdHMgbnVtZXJpYyB2YWx1ZSBhbmQgaXRzIHVuaXQgdHlwZS4gKi9cblx0XHRcdFx0XHRcdFx0dmFyIHNlcGFyYXRlVmFsdWUgPSBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdW5pdFR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG51bWVyaWNWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdG51bWVyaWNWYWx1ZSA9ICh2YWx1ZSB8fCBcIjBcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnRvTG93ZXJDYXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogTWF0Y2ggdGhlIHVuaXQgdHlwZSBhdCB0aGUgZW5kIG9mIHRoZSB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1slQS16XSskLywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBHcmFiIHRoZSB1bml0IHR5cGUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pdFR5cGUgPSBtYXRjaDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFN0cmlwIHRoZSB1bml0IHR5cGUgb2ZmIG9mIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIElmIG5vIHVuaXQgdHlwZSB3YXMgc3VwcGxpZWQsIGFzc2lnbiBvbmUgdGhhdCBpcyBhcHByb3ByaWF0ZSBmb3IgdGhpcyBwcm9wZXJ0eSAoZS5nLiBcImRlZ1wiIGZvciByb3RhdGVaIG9yIFwicHhcIiBmb3Igd2lkdGgpLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmICghdW5pdFR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRUeXBlID0gQ1NTLlZhbHVlcy5nZXRVbml0VHlwZShwcm9wZXJ0eSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFtudW1lcmljVmFsdWUsIHVuaXRUeXBlXTtcblx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoc3RhcnRWYWx1ZSAhPT0gZW5kVmFsdWUgJiYgVHlwZS5pc1N0cmluZyhzdGFydFZhbHVlKSAmJiBUeXBlLmlzU3RyaW5nKGVuZFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdHRlcm4gPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBpU3RhcnQgPSAwLCAvLyBpbmRleCBpbiBzdGFydFZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlFbmQgPSAwLCAvLyBpbmRleCBpbiBlbmRWYWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhU3RhcnQgPSBbXSwgLy8gYXJyYXkgb2Ygc3RhcnRWYWx1ZSBudW1iZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFFbmQgPSBbXSwgLy8gYXJyYXkgb2YgZW5kVmFsdWUgbnVtYmVyc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpbkNhbGMgPSAwLCAvLyBLZWVwIHRyYWNrIG9mIGJlaW5nIGluc2lkZSBhIFwiY2FsYygpXCIgc28gd2UgZG9uJ3QgZHVwbGljYXRlIGl0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGluUkdCID0gMCwgLy8gS2VlcCB0cmFjayBvZiBiZWluZyBpbnNpZGUgYW4gUkdCIGFzIHdlIGNhbid0IHVzZSBmcmFjdGlvbmFsIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpblJHQkEgPSAwOyAvLyBLZWVwIHRyYWNrIG9mIGJlaW5nIGluc2lkZSBhbiBSR0JBIGFzIHdlIG11c3QgcGFzcyBmcmFjdGlvbmFsIGZvciB0aGUgYWxwaGEgY2hhbm5lbFxuXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IENTUy5Ib29rcy5maXhDb2xvcnMoc3RhcnRWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBDU1MuSG9va3MuZml4Q29sb3JzKGVuZFZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaVN0YXJ0IDwgc3RhcnRWYWx1ZS5sZW5ndGggJiYgaUVuZCA8IGVuZFZhbHVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGNTdGFydCA9IHN0YXJ0VmFsdWVbaVN0YXJ0XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjRW5kID0gZW5kVmFsdWVbaUVuZF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICgvW1xcZFxcLi1dLy50ZXN0KGNTdGFydCkgJiYgL1tcXGRcXC4tXS8udGVzdChjRW5kKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdFN0YXJ0ID0gY1N0YXJ0LCAvLyB0ZW1wb3JhcnkgY2hhcmFjdGVyIGJ1ZmZlclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dEVuZCA9IGNFbmQsIC8vIHRlbXBvcmFyeSBjaGFyYWN0ZXIgYnVmZmVyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb3RTdGFydCA9IFwiLlwiLCAvLyBNYWtlIHN1cmUgd2UgY2FuIG9ubHkgZXZlciBtYXRjaCBhIHNpbmdsZSBkb3QgaW4gYSBkZWNpbWFsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb3RFbmQgPSBcIi5cIjsgLy8gTWFrZSBzdXJlIHdlIGNhbiBvbmx5IGV2ZXIgbWF0Y2ggYSBzaW5nbGUgZG90IGluIGEgZGVjaW1hbFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlICgrK2lTdGFydCA8IHN0YXJ0VmFsdWUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y1N0YXJ0ID0gc3RhcnRWYWx1ZVtpU3RhcnRdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjU3RhcnQgPT09IGRvdFN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb3RTdGFydCA9IFwiLi5cIjsgLy8gQ2FuIG5ldmVyIG1hdGNoIHR3byBjaGFyYWN0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghL1xcZC8udGVzdChjU3RhcnQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dFN0YXJ0ICs9IGNTdGFydDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoKytpRW5kIDwgZW5kVmFsdWUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y0VuZCA9IGVuZFZhbHVlW2lFbmRdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjRW5kID09PSBkb3RFbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRvdEVuZCA9IFwiLi5cIjsgLy8gQ2FuIG5ldmVyIG1hdGNoIHR3byBjaGFyYWN0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghL1xcZC8udGVzdChjRW5kKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRFbmQgKz0gY0VuZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdVN0YXJ0ID0gQ1NTLkhvb2tzLmdldFVuaXQoc3RhcnRWYWx1ZSwgaVN0YXJ0KSwgLy8gdGVtcG9yYXJ5IHVuaXQgdHlwZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dUVuZCA9IENTUy5Ib29rcy5nZXRVbml0KGVuZFZhbHVlLCBpRW5kKTsgLy8gdGVtcG9yYXJ5IHVuaXQgdHlwZVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlTdGFydCArPSB1U3RhcnQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpRW5kICs9IHVFbmQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodVN0YXJ0ID09PSB1RW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU2FtZSB1bml0c1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh0U3RhcnQgPT09IHRFbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNhbWUgbnVtYmVycywgc28ganVzdCBjb3B5IG92ZXJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhdHRlcm4gKz0gdFN0YXJ0ICsgdVN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEaWZmZXJlbnQgbnVtYmVycywgc28gc3RvcmUgdGhlbVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybiArPSBcIntcIiArIGFTdGFydC5sZW5ndGggKyAoaW5SR0IgPyBcIiFcIiA6IFwiXCIpICsgXCJ9XCIgKyB1U3RhcnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhU3RhcnQucHVzaChwYXJzZUZsb2F0KHRTdGFydCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YUVuZC5wdXNoKHBhcnNlRmxvYXQodEVuZCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEaWZmZXJlbnQgdW5pdHMsIHNvIHB1dCBpbnRvIGEgXCJjYWxjKGZyb20gKyB0bylcIiBhbmQgYW5pbWF0ZSBlYWNoIHNpZGUgdG8vZnJvbSB6ZXJvXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIG5TdGFydCA9IHBhcnNlRmxvYXQodFN0YXJ0KSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bkVuZCA9IHBhcnNlRmxvYXQodEVuZCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuICs9IChpbkNhbGMgPCA1ID8gXCJjYWxjXCIgOiBcIlwiKSArIFwiKFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCsgKG5TdGFydCA/IFwie1wiICsgYVN0YXJ0Lmxlbmd0aCArIChpblJHQiA/IFwiIVwiIDogXCJcIikgKyBcIn1cIiA6IFwiMFwiKSArIHVTdGFydFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQrIFwiICsgXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KyAobkVuZCA/IFwie1wiICsgKGFTdGFydC5sZW5ndGggKyAoblN0YXJ0ID8gMSA6IDApKSArIChpblJHQiA/IFwiIVwiIDogXCJcIikgKyBcIn1cIiA6IFwiMFwiKSArIHVFbmRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KyBcIilcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoblN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhU3RhcnQucHVzaChuU3RhcnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YUVuZC5wdXNoKDApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobkVuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YVN0YXJ0LnB1c2goMCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhRW5kLnB1c2gobkVuZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGNTdGFydCA9PT0gY0VuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuICs9IGNTdGFydDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aVN0YXJ0Kys7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlFbmQrKztcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBiZWluZyBpbnNpZGUgYSBjYWxjKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGluQ2FsYyA9PT0gMCAmJiBjU3RhcnQgPT09IFwiY1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpbkNhbGMgPT09IDEgJiYgY1N0YXJ0ID09PSBcImFcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fHwgaW5DYWxjID09PSAyICYmIGNTdGFydCA9PT0gXCJsXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluQ2FsYyA9PT0gMyAmJiBjU3RhcnQgPT09IFwiY1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpbkNhbGMgPj0gNCAmJiBjU3RhcnQgPT09IFwiKFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbkNhbGMrKztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgoaW5DYWxjICYmIGluQ2FsYyA8IDUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpbkNhbGMgPj0gNCAmJiBjU3RhcnQgPT09IFwiKVwiICYmIC0taW5DYWxjIDwgNSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluQ2FsYyA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBiZWluZyBpbnNpZGUgYW4gcmdiKCkgLyByZ2JhKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGluUkdCID09PSAwICYmIGNTdGFydCA9PT0gXCJyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluUkdCID09PSAxICYmIGNTdGFydCA9PT0gXCJnXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluUkdCID09PSAyICYmIGNTdGFydCA9PT0gXCJiXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluUkdCID09PSAzICYmIGNTdGFydCA9PT0gXCJhXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluUkdCID49IDMgJiYgY1N0YXJ0ID09PSBcIihcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGluUkdCID09PSAzICYmIGNTdGFydCA9PT0gXCJhXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluUkdCQSA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluUkdCKys7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5SR0JBICYmIGNTdGFydCA9PT0gXCIsXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoKytpblJHQkEgPiAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpblJHQiA9IGluUkdCQSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKChpblJHQkEgJiYgaW5SR0IgPCAoaW5SR0JBID8gNSA6IDQpKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fHwgaW5SR0IgPj0gKGluUkdCQSA/IDQgOiAzKSAmJiBjU3RhcnQgPT09IFwiKVwiICYmIC0taW5SR0IgPCAoaW5SR0JBID8gNSA6IDQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5SR0IgPSBpblJHQkEgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpbkNhbGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBjaGFuZ2luZyB1bml0cywgZml4aW5nIGNvbG91cnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChpU3RhcnQgIT09IHN0YXJ0VmFsdWUubGVuZ3RoIHx8IGlFbmQgIT09IGVuZFZhbHVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJUcnlpbmcgdG8gcGF0dGVybiBtYXRjaCBtaXMtbWF0Y2hlZCBzdHJpbmdzIFtcXFwiXCIgKyBlbmRWYWx1ZSArIFwiXFxcIiwgXFxcIlwiICsgc3RhcnRWYWx1ZSArIFwiXFxcIl1cIik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAocGF0dGVybikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFTdGFydC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJQYXR0ZXJuIGZvdW5kIFxcXCJcIiArIHBhdHRlcm4gKyBcIlxcXCIgLT4gXCIsIGFTdGFydCwgYUVuZCwgXCJbXCIgKyBzdGFydFZhbHVlICsgXCIsXCIgKyBlbmRWYWx1ZSArIFwiXVwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gYVN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IGFFbmQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBzdGFydFZhbHVlVW5pdFR5cGUgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIXBhdHRlcm4pIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBTZXBhcmF0ZSBzdGFydFZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHNlcGFyYXRlZFZhbHVlID0gc2VwYXJhdGVWYWx1ZShwcm9wZXJ0eSwgc3RhcnRWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IHNlcGFyYXRlZFZhbHVlWzBdO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWVVbml0VHlwZSA9IHNlcGFyYXRlZFZhbHVlWzFdO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogU2VwYXJhdGUgZW5kVmFsdWUsIGFuZCBleHRyYWN0IGEgdmFsdWUgb3BlcmF0b3IgKGUuZy4gXCIrPVwiLCBcIi09XCIpIGlmIG9uZSBleGlzdHMuICovXG5cdFx0XHRcdFx0XHRcdFx0c2VwYXJhdGVkVmFsdWUgPSBzZXBhcmF0ZVZhbHVlKHByb3BlcnR5LCBlbmRWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBzZXBhcmF0ZWRWYWx1ZVswXS5yZXBsYWNlKC9eKFsrLVxcLypdKT0vLCBmdW5jdGlvbihtYXRjaCwgc3ViTWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhdG9yID0gc3ViTWF0Y2g7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIFN0cmlwIHRoZSBvcGVyYXRvciBvZmYgb2YgdGhlIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVVbml0VHlwZSA9IHNlcGFyYXRlZFZhbHVlWzFdO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogUGFyc2UgZmxvYXQgdmFsdWVzIGZyb20gZW5kVmFsdWUgYW5kIHN0YXJ0VmFsdWUuIERlZmF1bHQgdG8gMCBpZiBOYU4gaXMgcmV0dXJuZWQuICovXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSkgfHwgMDtcblx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpIHx8IDA7XG5cblx0XHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdFx0IFByb3BlcnR5LVNwZWNpZmljIFZhbHVlIENvbnZlcnNpb25cblx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogQ3VzdG9tIHN1cHBvcnQgZm9yIHByb3BlcnRpZXMgdGhhdCBkb24ndCBhY3R1YWxseSBhY2NlcHQgdGhlICUgdW5pdCB0eXBlLCBidXQgd2hlcmUgcG9sbHlmaWxsaW5nIGlzIHRyaXZpYWwgYW5kIHJlbGF0aXZlbHkgZm9vbHByb29mLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChlbmRWYWx1ZVVuaXRUeXBlID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQSAlLXZhbHVlIGZvbnRTaXplL2xpbmVIZWlnaHQgaXMgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCdzIGZvbnRTaXplIChhcyBvcHBvc2VkIHRvIHRoZSBwYXJlbnQncyBkaW1lbnNpb25zKSxcblx0XHRcdFx0XHRcdFx0XHRcdCB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhlIGVtIHVuaXQncyBiZWhhdmlvciwgc28gd2UgcGlnZ3liYWNrIG9mZiBvZiB0aGF0LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKC9eKGZvbnRTaXplfGxpbmVIZWlnaHQpJC8udGVzdChwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCAlIGludG8gYW4gZW0gZGVjaW1hbCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBlbmRWYWx1ZSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVVbml0VHlwZSA9IFwiZW1cIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogRm9yIHNjYWxlWCBhbmQgc2NhbGVZLCBjb252ZXJ0IHRoZSB2YWx1ZSBpbnRvIGl0cyBkZWNpbWFsIGZvcm1hdCBhbmQgc3RyaXAgb2ZmIHRoZSB1bml0IHR5cGUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKC9ec2NhbGUvLnRlc3QocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gZW5kVmFsdWUgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBGb3IgUkdCIGNvbXBvbmVudHMsIHRha2UgdGhlIGRlZmluZWQgcGVyY2VudGFnZSBvZiAyNTUgYW5kIHN0cmlwIG9mZiB0aGUgdW5pdCB0eXBlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgvKFJlZHxHcmVlbnxCbHVlKSQvaS50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IChlbmRWYWx1ZSAvIDEwMCkgKiAyNTU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0IFVuaXQgUmF0aW8gQ2FsY3VsYXRpb25cblx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHQvKiBXaGVuIHF1ZXJpZWQsIHRoZSBicm93c2VyIHJldHVybnMgKG1vc3QpIENTUyBwcm9wZXJ0eSB2YWx1ZXMgaW4gcGl4ZWxzLiBUaGVyZWZvcmUsIGlmIGFuIGVuZFZhbHVlIHdpdGggYSB1bml0IHR5cGUgb2Zcblx0XHRcdFx0XHRcdFx0ICUsIGVtLCBvciByZW0gaXMgYW5pbWF0ZWQgdG93YXJkLCBzdGFydFZhbHVlIG11c3QgYmUgY29udmVydGVkIGZyb20gcGl4ZWxzIGludG8gdGhlIHNhbWUgdW5pdCB0eXBlIGFzIGVuZFZhbHVlIGluIG9yZGVyXG5cdFx0XHRcdFx0XHRcdCBmb3IgdmFsdWUgbWFuaXB1bGF0aW9uIGxvZ2ljIChpbmNyZW1lbnQvZGVjcmVtZW50KSB0byBwcm9jZWVkLiBGdXJ0aGVyLCBpZiB0aGUgc3RhcnRWYWx1ZSB3YXMgZm9yY2VmZWQgb3IgdHJhbnNmZXJyZWRcblx0XHRcdFx0XHRcdFx0IGZyb20gYSBwcmV2aW91cyBjYWxsLCBzdGFydFZhbHVlIG1heSBhbHNvIG5vdCBiZSBpbiBwaXhlbHMuIFVuaXQgY29udmVyc2lvbiBsb2dpYyB0aGVyZWZvcmUgY29uc2lzdHMgb2YgdHdvIHN0ZXBzOlxuXHRcdFx0XHRcdFx0XHQgMSkgQ2FsY3VsYXRpbmcgdGhlIHJhdGlvIG9mICUvZW0vcmVtL3ZoL3Z3IHJlbGF0aXZlIHRvIHBpeGVsc1xuXHRcdFx0XHRcdFx0XHQgMikgQ29udmVydGluZyBzdGFydFZhbHVlIGludG8gdGhlIHNhbWUgdW5pdCBvZiBtZWFzdXJlbWVudCBhcyBlbmRWYWx1ZSBiYXNlZCBvbiB0aGVzZSByYXRpb3MuICovXG5cdFx0XHRcdFx0XHRcdC8qIFVuaXQgY29udmVyc2lvbiByYXRpb3MgYXJlIGNhbGN1bGF0ZWQgYnkgaW5zZXJ0aW5nIGEgc2libGluZyBub2RlIG5leHQgdG8gdGhlIHRhcmdldCBub2RlLCBjb3B5aW5nIG92ZXIgaXRzIHBvc2l0aW9uIHByb3BlcnR5LFxuXHRcdFx0XHRcdFx0XHQgc2V0dGluZyB2YWx1ZXMgd2l0aCB0aGUgdGFyZ2V0IHVuaXQgdHlwZSB0aGVuIGNvbXBhcmluZyB0aGUgcmV0dXJuZWQgcGl4ZWwgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IEV2ZW4gaWYgb25seSBvbmUgb2YgdGhlc2UgdW5pdCB0eXBlcyBpcyBiZWluZyBhbmltYXRlZCwgYWxsIHVuaXQgcmF0aW9zIGFyZSBjYWxjdWxhdGVkIGF0IG9uY2Ugc2luY2UgdGhlIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdCBvZiBiYXRjaGluZyB0aGUgU0VUcyBhbmQgR0VUcyB0b2dldGhlciB1cGZyb250IG91dHdlaWdodHMgdGhlIHBvdGVudGlhbCBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHQgb2YgbGF5b3V0IHRocmFzaGluZyBjYXVzZWQgYnkgcmUtcXVlcnlpbmcgZm9yIHVuY2FsY3VsYXRlZCByYXRpb3MgZm9yIHN1YnNlcXVlbnRseS1wcm9jZXNzZWQgcHJvcGVydGllcy4gKi9cblx0XHRcdFx0XHRcdFx0LyogVG9kbzogU2hpZnQgdGhpcyBsb2dpYyBpbnRvIHRoZSBjYWxscycgZmlyc3QgdGljayBpbnN0YW5jZSBzbyB0aGF0IGl0J3Mgc3luY2VkIHdpdGggUkFGLiAqL1xuXHRcdFx0XHRcdFx0XHR2YXIgY2FsY3VsYXRlVW5pdFJhdGlvcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdCBTYW1lIFJhdGlvIENoZWNrc1xuXHRcdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0XHQvKiBUaGUgcHJvcGVydGllcyBiZWxvdyBhcmUgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZWxlbWVudCBkaWZmZXJzIHN1ZmZpY2llbnRseSBmcm9tIHRoaXMgY2FsbCdzXG5cdFx0XHRcdFx0XHRcdFx0IHByZXZpb3VzbHkgaXRlcmF0ZWQgZWxlbWVudCB0byBhbHNvIGRpZmZlciBpbiBpdHMgdW5pdCBjb252ZXJzaW9uIHJhdGlvcy4gSWYgdGhlIHByb3BlcnRpZXMgbWF0Y2ggdXAgd2l0aCB0aG9zZVxuXHRcdFx0XHRcdFx0XHRcdCBvZiB0aGUgcHJpb3IgZWxlbWVudCwgdGhlIHByaW9yIGVsZW1lbnQncyBjb252ZXJzaW9uIHJhdGlvcyBhcmUgdXNlZC4gTGlrZSBtb3N0IG9wdGltaXphdGlvbnMgaW4gVmVsb2NpdHksXG5cdFx0XHRcdFx0XHRcdFx0IHRoaXMgaXMgZG9uZSB0byBtaW5pbWl6ZSBET00gcXVlcnlpbmcuICovXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHNhbWVSYXRpb0luZGljYXRvcnMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRteVBhcmVudDogZWxlbWVudC5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHksIC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb246IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwicG9zaXRpb25cIiksIC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9udFNpemU6IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiZm9udFNpemVcIikgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogRGV0ZXJtaW5lIGlmIHRoZSBzYW1lICUgcmF0aW8gY2FuIGJlIHVzZWQuICUgaXMgYmFzZWQgb24gdGhlIGVsZW1lbnQncyBwb3NpdGlvbiB2YWx1ZSBhbmQgaXRzIHBhcmVudCdzIHdpZHRoIGFuZCBoZWlnaHQgZGltZW5zaW9ucy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtZVBlcmNlbnRSYXRpbyA9ICgoc2FtZVJhdGlvSW5kaWNhdG9ycy5wb3NpdGlvbiA9PT0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UG9zaXRpb24pICYmIChzYW1lUmF0aW9JbmRpY2F0b3JzLm15UGFyZW50ID09PSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RQYXJlbnQpKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogRGV0ZXJtaW5lIGlmIHRoZSBzYW1lIGVtIHJhdGlvIGNhbiBiZSB1c2VkLiBlbSBpcyByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCdzIGZvbnRTaXplLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1lRW1SYXRpbyA9IChzYW1lUmF0aW9JbmRpY2F0b3JzLmZvbnRTaXplID09PSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RGb250U2l6ZSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBTdG9yZSB0aGVzZSByYXRpbyBpbmRpY2F0b3JzIGNhbGwtd2lkZSBmb3IgdGhlIG5leHQgZWxlbWVudCB0byBjb21wYXJlIGFnYWluc3QuICovXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UGFyZW50ID0gc2FtZVJhdGlvSW5kaWNhdG9ycy5teVBhcmVudDtcblx0XHRcdFx0XHRcdFx0XHRjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RQb3NpdGlvbiA9IHNhbWVSYXRpb0luZGljYXRvcnMucG9zaXRpb247XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0Rm9udFNpemUgPSBzYW1lUmF0aW9JbmRpY2F0b3JzLmZvbnRTaXplO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdCBFbGVtZW50LVNwZWNpZmljIFVuaXRzXG5cdFx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IElFOCByb3VuZHMgdG8gdGhlIG5lYXJlc3QgcGl4ZWwgd2hlbiByZXR1cm5pbmcgQ1NTIHZhbHVlcywgdGh1cyB3ZSBwZXJmb3JtIGNvbnZlcnNpb25zIHVzaW5nIGEgbWVhc3VyZW1lbnRcblx0XHRcdFx0XHRcdFx0XHQgb2YgMTAwIChpbnN0ZWFkIG9mIDEpIHRvIGdpdmUgb3VyIHJhdGlvcyBhIHByZWNpc2lvbiBvZiBhdCBsZWFzdCAyIGRlY2ltYWwgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtZWFzdXJlbWVudCA9IDEwMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcyA9IHt9O1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFzYW1lRW1SYXRpbyB8fCAhc2FtZVBlcmNlbnRSYXRpbykge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGR1bW15ID0gZGF0YSAmJiBkYXRhLmlzU1ZHID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJyZWN0XCIpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuaW5pdChkdW1teSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRzYW1lUmF0aW9JbmRpY2F0b3JzLm15UGFyZW50LmFwcGVuZENoaWxkKGR1bW15KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogVG8gYWNjdXJhdGVseSBhbmQgY29uc2lzdGVudGx5IGNhbGN1bGF0ZSBjb252ZXJzaW9uIHJhdGlvcywgdGhlIGVsZW1lbnQncyBjYXNjYWRlZCBvdmVyZmxvdyBhbmQgYm94LXNpemluZyBhcmUgc3RyaXBwZWQuXG5cdFx0XHRcdFx0XHRcdFx0XHQgU2ltaWxhcmx5LCBzaW5jZSB3aWR0aC9oZWlnaHQgY2FuIGJlIGFydGlmaWNpYWxseSBjb25zdHJhaW5lZCBieSB0aGVpciBtaW4tL21heC0gZXF1aXZhbGVudHMsIHRoZXNlIGFyZSBjb250cm9sbGVkIGZvciBhcyB3ZWxsLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogT3ZlcmZsb3cgbXVzdCBiZSBhbHNvIGJlIGNvbnRyb2xsZWQgZm9yIHBlci1heGlzIHNpbmNlIHRoZSBvdmVyZmxvdyBwcm9wZXJ0eSBvdmVyd3JpdGVzIGl0cyBwZXItYXhpcyB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHQkLmVhY2goW1wib3ZlcmZsb3dcIiwgXCJvdmVyZmxvd1hcIiwgXCJvdmVyZmxvd1lcIl0sIGZ1bmN0aW9uKGksIHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBwcm9wZXJ0eSwgXCJoaWRkZW5cIik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcInBvc2l0aW9uXCIsIHNhbWVSYXRpb0luZGljYXRvcnMucG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoZHVtbXksIFwiZm9udFNpemVcIiwgc2FtZVJhdGlvSW5kaWNhdG9ycy5mb250U2l6ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5DU1Muc2V0UHJvcGVydHlWYWx1ZShkdW1teSwgXCJib3hTaXppbmdcIiwgXCJjb250ZW50LWJveFwiKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Lyogd2lkdGggYW5kIGhlaWdodCBhY3QgYXMgb3VyIHByb3h5IHByb3BlcnRpZXMgZm9yIG1lYXN1cmluZyB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgJSByYXRpb3MuICovXG5cdFx0XHRcdFx0XHRcdFx0XHQkLmVhY2goW1wibWluV2lkdGhcIiwgXCJtYXhXaWR0aFwiLCBcIndpZHRoXCIsIFwibWluSGVpZ2h0XCIsIFwibWF4SGVpZ2h0XCIsIFwiaGVpZ2h0XCJdLCBmdW5jdGlvbihpLCBwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5DU1Muc2V0UHJvcGVydHlWYWx1ZShkdW1teSwgcHJvcGVydHksIG1lYXN1cmVtZW50ICsgXCIlXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBwYWRkaW5nTGVmdCBhcmJpdHJhcmlseSBhY3RzIGFzIG91ciBwcm94eSBwcm9wZXJ0eSBmb3IgdGhlIGVtIHJhdGlvLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoZHVtbXksIFwicGFkZGluZ0xlZnRcIiwgbWVhc3VyZW1lbnQgKyBcImVtXCIpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBEaXZpZGUgdGhlIHJldHVybmVkIHZhbHVlIGJ5IHRoZSBtZWFzdXJlbWVudCB0byBnZXQgdGhlIHJhdGlvIGJldHdlZW4gMSUgYW5kIDFweC4gRGVmYXVsdCB0byAxIHNpbmNlIHdvcmtpbmcgd2l0aCAwIGNhbiBwcm9kdWNlIEluZmluaXRlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcy5wZXJjZW50VG9QeFdpZHRoID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UGVyY2VudFRvUHhXaWR0aCA9IChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcIndpZHRoXCIsIG51bGwsIHRydWUpKSB8fCAxKSAvIG1lYXN1cmVtZW50OyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MucGVyY2VudFRvUHhIZWlnaHQgPSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RQZXJjZW50VG9QeEhlaWdodCA9IChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcImhlaWdodFwiLCBudWxsLCB0cnVlKSkgfHwgMSkgLyBtZWFzdXJlbWVudDsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0XHR1bml0UmF0aW9zLmVtVG9QeCA9IGNhbGxVbml0Q29udmVyc2lvbkRhdGEubGFzdEVtVG9QeCA9IChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcInBhZGRpbmdMZWZ0XCIpKSB8fCAxKSAvIG1lYXN1cmVtZW50OyAvKiBHRVQgKi9cblxuXHRcdFx0XHRcdFx0XHRcdFx0c2FtZVJhdGlvSW5kaWNhdG9ycy5teVBhcmVudC5yZW1vdmVDaGlsZChkdW1teSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MuZW1Ub1B4ID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0RW1Ub1B4O1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcy5wZXJjZW50VG9QeFdpZHRoID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UGVyY2VudFRvUHhXaWR0aDtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MucGVyY2VudFRvUHhIZWlnaHQgPSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RQZXJjZW50VG9QeEhlaWdodDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdFx0IEVsZW1lbnQtQWdub3N0aWMgVW5pdHNcblx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogV2hlcmVhcyAlIGFuZCBlbSByYXRpb3MgYXJlIGRldGVybWluZWQgb24gYSBwZXItZWxlbWVudCBiYXNpcywgdGhlIHJlbSB1bml0IG9ubHkgbmVlZHMgdG8gYmUgY2hlY2tlZFxuXHRcdFx0XHRcdFx0XHRcdCBvbmNlIHBlciBjYWxsIHNpbmNlIGl0J3MgZXhjbHVzaXZlbHkgZGVwZW5kYW50IHVwb24gZG9jdW1lbnQuYm9keSdzIGZvbnRTaXplLiBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lXG5cdFx0XHRcdFx0XHRcdFx0IHRoYXQgY2FsY3VsYXRlVW5pdFJhdGlvcygpIGlzIGJlaW5nIHJ1biBkdXJpbmcgdGhpcyBjYWxsLCByZW1Ub1B4IHdpbGwgc3RpbGwgYmUgc2V0IHRvIGl0cyBkZWZhdWx0IHZhbHVlIG9mIG51bGwsXG5cdFx0XHRcdFx0XHRcdFx0IHNvIHdlIGNhbGN1bGF0ZSBpdCBub3cuICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNhbGxVbml0Q29udmVyc2lvbkRhdGEucmVtVG9QeCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogRGVmYXVsdCB0byBicm93c2VycycgZGVmYXVsdCBmb250U2l6ZSBvZiAxNnB4IGluIHRoZSBjYXNlIG9mIDAuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYWxsVW5pdENvbnZlcnNpb25EYXRhLnJlbVRvUHggPSBwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGRvY3VtZW50LmJvZHksIFwiZm9udFNpemVcIikpIHx8IDE2OyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBTaW1pbGFybHksIHZpZXdwb3J0IHVuaXRzIGFyZSAlLXJlbGF0aXZlIHRvIHRoZSB3aW5kb3cncyBpbm5lciBkaW1lbnNpb25zLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjYWxsVW5pdENvbnZlcnNpb25EYXRhLnZ3VG9QeCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FsbFVuaXRDb252ZXJzaW9uRGF0YS52d1RvUHggPSBwYXJzZUZsb2F0KHdpbmRvdy5pbm5lcldpZHRoKSAvIDEwMDsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYWxsVW5pdENvbnZlcnNpb25EYXRhLnZoVG9QeCA9IHBhcnNlRmxvYXQod2luZG93LmlubmVySGVpZ2h0KSAvIDEwMDsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcy5yZW1Ub1B4ID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5yZW1Ub1B4O1xuXHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MudndUb1B4ID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS52d1RvUHg7XG5cdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcy52aFRvUHggPSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLnZoVG9QeDtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5kZWJ1ZyA+PSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlVuaXQgcmF0aW9zOiBcIiArIEpTT04uc3RyaW5naWZ5KHVuaXRSYXRpb3MpLCBlbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuaXRSYXRpb3M7XG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdCBVbml0IENvbnZlcnNpb25cblx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIFRoZSAqIGFuZCAvIG9wZXJhdG9ycywgd2hpY2ggYXJlIG5vdCBwYXNzZWQgaW4gd2l0aCBhbiBhc3NvY2lhdGVkIHVuaXQsIGluaGVyZW50bHkgdXNlIHN0YXJ0VmFsdWUncyB1bml0LiBTa2lwIHZhbHVlIGFuZCB1bml0IGNvbnZlcnNpb24uICovXG5cdFx0XHRcdFx0XHRcdGlmICgvW1xcLypdLy50ZXN0KG9wZXJhdG9yKSkge1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBzdGFydFZhbHVlVW5pdFR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgc3RhcnRWYWx1ZSBhbmQgZW5kVmFsdWUgZGlmZmVyIGluIHVuaXQgdHlwZSwgY29udmVydCBzdGFydFZhbHVlIGludG8gdGhlIHNhbWUgdW5pdCB0eXBlIGFzIGVuZFZhbHVlIHNvIHRoYXQgaWYgZW5kVmFsdWVVbml0VHlwZVxuXHRcdFx0XHRcdFx0XHRcdCBpcyBhIHJlbGF0aXZlIHVuaXQgKCUsIGVtLCByZW0pLCB0aGUgdmFsdWVzIHNldCBkdXJpbmcgdHdlZW5pbmcgd2lsbCBjb250aW51ZSB0byBiZSBhY2N1cmF0ZWx5IHJlbGF0aXZlIGV2ZW4gaWYgdGhlIG1ldHJpY3MgdGhleSBkZXBlbmRcblx0XHRcdFx0XHRcdFx0XHQgb24gYXJlIGR5bmFtaWNhbGx5IGNoYW5naW5nIGR1cmluZyB0aGUgY291cnNlIG9mIHRoZSBhbmltYXRpb24uIENvbnZlcnNlbHksIGlmIHdlIGFsd2F5cyBub3JtYWxpemVkIGludG8gcHggYW5kIHVzZWQgcHggZm9yIHNldHRpbmcgdmFsdWVzLCB0aGUgcHggcmF0aW9cblx0XHRcdFx0XHRcdFx0XHQgd291bGQgYmVjb21lIHN0YWxlIGlmIHRoZSBvcmlnaW5hbCB1bml0IGJlaW5nIGFuaW1hdGVkIHRvd2FyZCB3YXMgcmVsYXRpdmUgYW5kIHRoZSB1bmRlcmx5aW5nIG1ldHJpY3MgY2hhbmdlIGR1cmluZyB0aGUgYW5pbWF0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRcdC8qIFNpbmNlIDAgaXMgMCBpbiBhbnkgdW5pdCB0eXBlLCBubyBjb252ZXJzaW9uIGlzIG5lY2Vzc2FyeSB3aGVuIHN0YXJ0VmFsdWUgaXMgMCAtLSB3ZSBqdXN0IHN0YXJ0IGF0IDAgd2l0aCBlbmRWYWx1ZVVuaXRUeXBlLiAqL1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKChzdGFydFZhbHVlVW5pdFR5cGUgIT09IGVuZFZhbHVlVW5pdFR5cGUpICYmIHN0YXJ0VmFsdWUgIT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBVbml0IGNvbnZlcnNpb24gaXMgYWxzbyBza2lwcGVkIHdoZW4gZW5kVmFsdWUgaXMgMCwgYnV0ICpzdGFydFZhbHVlVW5pdFR5cGUqIG11c3QgYmUgdXNlZCBmb3IgdHdlZW4gdmFsdWVzIHRvIHJlbWFpbiBhY2N1cmF0ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBTa2lwcGluZyB1bml0IGNvbnZlcnNpb24gaGVyZSBtZWFucyB0aGF0IGlmIGVuZFZhbHVlVW5pdFR5cGUgd2FzIG9yaWdpbmFsbHkgYSByZWxhdGl2ZSB1bml0LCB0aGUgYW5pbWF0aW9uIHdvbid0IHJlbGF0aXZlbHlcblx0XHRcdFx0XHRcdFx0XHQgbWF0Y2ggdGhlIHVuZGVybHlpbmcgbWV0cmljcyBpZiB0aGV5IGNoYW5nZSwgYnV0IHRoaXMgaXMgYWNjZXB0YWJsZSBzaW5jZSB3ZSdyZSBhbmltYXRpbmcgdG93YXJkIGludmlzaWJpbGl0eSBpbnN0ZWFkIG9mIHRvd2FyZCB2aXNpYmlsaXR5LFxuXHRcdFx0XHRcdFx0XHRcdCB3aGljaCByZW1haW5zIHBhc3QgdGhlIHBvaW50IG9mIHRoZSBhbmltYXRpb24ncyBjb21wbGV0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChlbmRWYWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVVbml0VHlwZSA9IHN0YXJ0VmFsdWVVbml0VHlwZTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQnkgdGhpcyBwb2ludCwgd2UgY2Fubm90IGF2b2lkIHVuaXQgY29udmVyc2lvbiAoaXQncyB1bmRlc2lyYWJsZSBzaW5jZSBpdCBjYXVzZXMgbGF5b3V0IHRocmFzaGluZykuXG5cdFx0XHRcdFx0XHRcdFx0XHQgSWYgd2UgaGF2ZW4ndCBhbHJlYWR5LCB3ZSB0cmlnZ2VyIGNhbGN1bGF0ZVVuaXRSYXRpb3MoKSwgd2hpY2ggcnVucyBvbmNlIHBlciBlbGVtZW50IHBlciBjYWxsLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudFVuaXRDb252ZXJzaW9uRGF0YSA9IGVsZW1lbnRVbml0Q29udmVyc2lvbkRhdGEgfHwgY2FsY3VsYXRlVW5pdFJhdGlvcygpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBUaGUgZm9sbG93aW5nIFJlZ0V4IG1hdGNoZXMgQ1NTIHByb3BlcnRpZXMgdGhhdCBoYXZlIHRoZWlyICUgdmFsdWVzIG1lYXN1cmVkIHJlbGF0aXZlIHRvIHRoZSB4LWF4aXMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBXM0Mgc3BlYyBtYW5kYXRlcyB0aGF0IGFsbCBvZiBtYXJnaW4gYW5kIHBhZGRpbmcncyBwcm9wZXJ0aWVzIChldmVuIHRvcCBhbmQgYm90dG9tKSBhcmUgJS1yZWxhdGl2ZSB0byB0aGUgKndpZHRoKiBvZiB0aGUgcGFyZW50IGVsZW1lbnQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgYXhpcyA9ICgvbWFyZ2lufHBhZGRpbmd8bGVmdHxyaWdodHx3aWR0aHx0ZXh0fHdvcmR8bGV0dGVyL2kudGVzdChwcm9wZXJ0eSkgfHwgL1gkLy50ZXN0KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSA9PT0gXCJ4XCIpID8gXCJ4XCIgOiBcInlcIjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogSW4gb3JkZXIgdG8gYXZvaWQgZ2VuZXJhdGluZyBuXjIgYmVzcG9rZSBjb252ZXJzaW9uIGZ1bmN0aW9ucywgdW5pdCBjb252ZXJzaW9uIGlzIGEgdHdvLXN0ZXAgcHJvY2Vzczpcblx0XHRcdFx0XHRcdFx0XHRcdCAxKSBDb252ZXJ0IHN0YXJ0VmFsdWUgaW50byBwaXhlbHMuIDIpIENvbnZlcnQgdGhpcyBuZXcgcGl4ZWwgdmFsdWUgaW50byBlbmRWYWx1ZSdzIHVuaXQgdHlwZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoc3RhcnRWYWx1ZVVuaXRUeXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCIlXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogdHJhbnNsYXRlWCBhbmQgdHJhbnNsYXRlWSBhcmUgdGhlIG9ubHkgcHJvcGVydGllcyB0aGF0IGFyZSAlLXJlbGF0aXZlIHRvIGFuIGVsZW1lbnQncyBvd24gZGltZW5zaW9ucyAtLSBub3QgaXRzIHBhcmVudCdzIGRpbWVuc2lvbnMuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IFZlbG9jaXR5IGRvZXMgbm90IGluY2x1ZGUgYSBzcGVjaWFsIGNvbnZlcnNpb24gcHJvY2VzcyB0byBhY2NvdW50IGZvciB0aGlzIGJlaGF2aW9yLiBUaGVyZWZvcmUsIGFuaW1hdGluZyB0cmFuc2xhdGVYL1kgZnJvbSBhICUgdmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgdG8gYSBub24tJSB2YWx1ZSB3aWxsIHByb2R1Y2UgYW4gaW5jb3JyZWN0IHN0YXJ0IHZhbHVlLiBGb3J0dW5hdGVseSwgdGhpcyBzb3J0IG9mIGNyb3NzLXVuaXQgY29udmVyc2lvbiBpcyByYXJlbHkgZG9uZSBieSB1c2VycyBpbiBwcmFjdGljZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlICo9IChheGlzID09PSBcInhcIiA/IGVsZW1lbnRVbml0Q29udmVyc2lvbkRhdGEucGVyY2VudFRvUHhXaWR0aCA6IGVsZW1lbnRVbml0Q29udmVyc2lvbkRhdGEucGVyY2VudFRvUHhIZWlnaHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJweFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIHB4IGFjdHMgYXMgb3VyIG1pZHBvaW50IGluIHRoZSB1bml0IGNvbnZlcnNpb24gcHJvY2VzczsgZG8gbm90aGluZy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgKj0gZWxlbWVudFVuaXRDb252ZXJzaW9uRGF0YVtzdGFydFZhbHVlVW5pdFR5cGUgKyBcIlRvUHhcIl07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIEludmVydCB0aGUgcHggcmF0aW9zIHRvIGNvbnZlcnQgaW50byB0byB0aGUgdGFyZ2V0IHVuaXQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGVuZFZhbHVlVW5pdFR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIiVcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlICo9IDEgLyAoYXhpcyA9PT0gXCJ4XCIgPyBlbGVtZW50VW5pdENvbnZlcnNpb25EYXRhLnBlcmNlbnRUb1B4V2lkdGggOiBlbGVtZW50VW5pdENvbnZlcnNpb25EYXRhLnBlcmNlbnRUb1B4SGVpZ2h0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwicHhcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBzdGFydFZhbHVlIGlzIGFscmVhZHkgaW4gcHgsIGRvIG5vdGhpbmc7IHdlJ3JlIGRvbmUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlICo9IDEgLyBlbGVtZW50VW5pdENvbnZlcnNpb25EYXRhW2VuZFZhbHVlVW5pdFR5cGUgKyBcIlRvUHhcIl07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgUmVsYXRpdmUgVmFsdWVzXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0LyogT3BlcmF0b3IgbG9naWMgbXVzdCBiZSBwZXJmb3JtZWQgbGFzdCBzaW5jZSBpdCByZXF1aXJlcyB1bml0LW5vcm1hbGl6ZWQgc3RhcnQgYW5kIGVuZCB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IFJlbGF0aXZlICpwZXJjZW50IHZhbHVlcyogZG8gbm90IGJlaGF2ZSBob3cgbW9zdCBwZW9wbGUgdGhpbms7IHdoaWxlIG9uZSB3b3VsZCBleHBlY3QgXCIrPTUwJVwiXG5cdFx0XHRcdFx0XHRcdCB0byBpbmNyZWFzZSB0aGUgcHJvcGVydHkgMS41eCBpdHMgY3VycmVudCB2YWx1ZSwgaXQgaW4gZmFjdCBpbmNyZWFzZXMgdGhlIHBlcmNlbnQgdW5pdHMgaW4gYWJzb2x1dGUgdGVybXM6XG5cdFx0XHRcdFx0XHRcdCA1MCBwb2ludHMgaXMgYWRkZWQgb24gdG9wIG9mIHRoZSBjdXJyZW50ICUgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiK1wiOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBzdGFydFZhbHVlICsgZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCItXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHN0YXJ0VmFsdWUgLSBlbmRWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIipcIjpcblx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gc3RhcnRWYWx1ZSAqIGVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiL1wiOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBzdGFydFZhbHVlIC8gZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgdHdlZW5zQ29udGFpbmVyIFB1c2hcblx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIENvbnN0cnVjdCB0aGUgcGVyLXByb3BlcnR5IHR3ZWVuIG9iamVjdCwgYW5kIHB1c2ggaXQgdG8gdGhlIGVsZW1lbnQncyB0d2VlbnNDb250YWluZXIuICovXG5cdFx0XHRcdFx0XHRcdHR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0gPSB7XG5cdFx0XHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWU6IHJvb3RQcm9wZXJ0eVZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWU6IHN0YXJ0VmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlOiBzdGFydFZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlOiBlbmRWYWx1ZSxcblx0XHRcdFx0XHRcdFx0XHR1bml0VHlwZTogZW5kVmFsdWVVbml0VHlwZSxcblx0XHRcdFx0XHRcdFx0XHRlYXNpbmc6IGVhc2luZ1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRpZiAocGF0dGVybikge1xuXHRcdFx0XHRcdFx0XHRcdHR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0ucGF0dGVybiA9IHBhdHRlcm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInR3ZWVuc0NvbnRhaW5lciAoXCIgKyBwcm9wZXJ0eSArIFwiKTogXCIgKyBKU09OLnN0cmluZ2lmeSh0d2VlbnNDb250YWluZXJbcHJvcGVydHldKSwgZWxlbWVudCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8qIENyZWF0ZSBhIHR3ZWVuIG91dCBvZiBlYWNoIHByb3BlcnR5LCBhbmQgYXBwZW5kIGl0cyBhc3NvY2lhdGVkIGRhdGEgdG8gdHdlZW5zQ29udGFpbmVyLiAqL1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllc01hcCkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICghcHJvcGVydGllc01hcC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvKiBUaGUgb3JpZ2luYWwgcHJvcGVydHkgbmFtZSdzIGZvcm1hdCBtdXN0IGJlIHVzZWQgZm9yIHRoZSBwYXJzZVByb3BlcnR5VmFsdWUoKSBsb29rdXAsXG5cdFx0XHRcdFx0XHRcdCBidXQgd2UgdGhlbiB1c2UgaXRzIGNhbWVsQ2FzZSBzdHlsaW5nIHRvIG5vcm1hbGl6ZSBpdCBmb3IgbWFuaXB1bGF0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHR2YXIgcHJvcGVydHlOYW1lID0gQ1NTLk5hbWVzLmNhbWVsQ2FzZShwcm9wZXJ0eSksXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZURhdGEgPSBwYXJzZVByb3BlcnR5VmFsdWUocHJvcGVydGllc01hcFtwcm9wZXJ0eV0pO1xuXG5cdFx0XHRcdFx0XHRcdC8qIEZpbmQgc2hvcnRoYW5kIGNvbG9yIHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gcGFzc2VkIGEgaGV4IHN0cmluZy4gKi9cblx0XHRcdFx0XHRcdFx0LyogV291bGQgYmUgcXVpY2tlciB0byB1c2UgQ1NTLkxpc3RzLmNvbG9ycy5pbmNsdWRlcygpIGlmIHBvc3NpYmxlICovXG5cdFx0XHRcdFx0XHRcdGlmIChfaW5BcnJheShDU1MuTGlzdHMuY29sb3JzLCBwcm9wZXJ0eU5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogUGFyc2UgdGhlIHZhbHVlIGRhdGEgZm9yIGVhY2ggc2hvcnRoYW5kLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHZhciBlbmRWYWx1ZSA9IHZhbHVlRGF0YVswXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWFzaW5nID0gdmFsdWVEYXRhWzFdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gdmFsdWVEYXRhWzJdO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5SZWdFeC5pc0hleC50ZXN0KGVuZFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCB0aGUgaGV4IHN0cmluZ3MgaW50byB0aGVpciBSR0IgY29tcG9uZW50IGFycmF5cy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBjb2xvckNvbXBvbmVudHMgPSBbXCJSZWRcIiwgXCJHcmVlblwiLCBcIkJsdWVcIl0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVSR0IgPSBDU1MuVmFsdWVzLmhleFRvUmdiKGVuZFZhbHVlKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlUkdCID0gc3RhcnRWYWx1ZSA/IENTUy5WYWx1ZXMuaGV4VG9SZ2Ioc3RhcnRWYWx1ZSkgOiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIEluamVjdCB0aGUgUkdCIGNvbXBvbmVudCB0d2VlbnMgaW50byBwcm9wZXJ0aWVzTWFwLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvckNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGFBcnJheSA9IFtlbmRWYWx1ZVJHQltpXV07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVhc2luZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGFBcnJheS5wdXNoKGVhc2luZyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoc3RhcnRWYWx1ZVJHQiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YUFycmF5LnB1c2goc3RhcnRWYWx1ZVJHQltpXSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaXhQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSArIGNvbG9yQ29tcG9uZW50c1tpXSwgZGF0YUFycmF5KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHdlIGhhdmUgcmVwbGFjZWQgYSBzaG9ydGN1dCBjb2xvciB2YWx1ZSB0aGVuIGRvbid0IHVwZGF0ZSB0aGUgc3RhbmRhcmQgcHJvcGVydHkgbmFtZSAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZpeFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lLCB2YWx1ZURhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBBbG9uZyB3aXRoIGl0cyBwcm9wZXJ0eSBkYXRhLCBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBpdHNlbGYgb250byB0d2VlbnNDb250YWluZXIuICovXG5cdFx0XHRcdFx0XHR0d2VlbnNDb250YWluZXIuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IENhbGwgUHVzaFxuXHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdC8qIE5vdGU6IHR3ZWVuc0NvbnRhaW5lciBjYW4gYmUgZW1wdHkgaWYgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FsbCdzIHByb3BlcnR5IG1hcCB3ZXJlIHNraXBwZWQgZHVlIHRvIG5vdFxuXHRcdFx0XHRcdCBiZWluZyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuIFRoZSBlbGVtZW50IHByb3BlcnR5IGlzIHVzZWQgZm9yIGNoZWNraW5nIHRoYXQgdGhlIHR3ZWVuc0NvbnRhaW5lciBoYXMgYmVlbiBhcHBlbmRlZCB0by4gKi9cblx0XHRcdFx0XHRpZiAodHdlZW5zQ29udGFpbmVyLmVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdC8qIEFwcGx5IHRoZSBcInZlbG9jaXR5LWFuaW1hdGluZ1wiIGluZGljYXRvciBjbGFzcy4gKi9cblx0XHRcdFx0XHRcdENTUy5WYWx1ZXMuYWRkQ2xhc3MoZWxlbWVudCwgXCJ2ZWxvY2l0eS1hbmltYXRpbmdcIik7XG5cblx0XHRcdFx0XHRcdC8qIFRoZSBjYWxsIGFycmF5IGhvdXNlcyB0aGUgdHdlZW5zQ29udGFpbmVycyBmb3IgZWFjaCBlbGVtZW50IGJlaW5nIGFuaW1hdGVkIGluIHRoZSBjdXJyZW50IGNhbGwuICovXG5cdFx0XHRcdFx0XHRjYWxsLnB1c2godHdlZW5zQ29udGFpbmVyKTtcblxuXHRcdFx0XHRcdFx0ZGF0YSA9IERhdGEoZWxlbWVudCk7XG5cblx0XHRcdFx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdC8qIFN0b3JlIHRoZSB0d2VlbnNDb250YWluZXIgYW5kIG9wdGlvbnMgaWYgd2UncmUgd29ya2luZyBvbiB0aGUgZGVmYXVsdCBlZmZlY3RzIHF1ZXVlLCBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgYnkgdGhlIHJldmVyc2UgY29tbWFuZC4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMucXVldWUgPT09IFwiXCIpIHtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudHdlZW5zQ29udGFpbmVyID0gdHdlZW5zQ29udGFpbmVyO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEub3B0cyA9IG9wdHM7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBTd2l0Y2ggb24gdGhlIGVsZW1lbnQncyBhbmltYXRpbmcgZmxhZy4gKi9cblx0XHRcdFx0XHRcdFx0ZGF0YS5pc0FuaW1hdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIE9uY2UgdGhlIGZpbmFsIGVsZW1lbnQgaW4gdGhpcyBjYWxsJ3MgZWxlbWVudCBzZXQgaGFzIGJlZW4gcHJvY2Vzc2VkLCBwdXNoIHRoZSBjYWxsIGFycmF5IG9udG9cblx0XHRcdFx0XHRcdCBWZWxvY2l0eS5TdGF0ZS5jYWxscyBmb3IgdGhlIGFuaW1hdGlvbiB0aWNrIHRvIGltbWVkaWF0ZWx5IGJlZ2luIHByb2Nlc3NpbmcuICovXG5cdFx0XHRcdFx0XHRpZiAoZWxlbWVudHNJbmRleCA9PT0gZWxlbWVudHNMZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0XHRcdC8qIEFkZCB0aGUgY3VycmVudCBjYWxsIHBsdXMgaXRzIGFzc29jaWF0ZWQgbWV0YWRhdGEgKHRoZSBlbGVtZW50IHNldCBhbmQgdGhlIGNhbGwncyBvcHRpb25zKSBvbnRvIHRoZSBnbG9iYWwgY2FsbCBjb250YWluZXIuXG5cdFx0XHRcdFx0XHRcdCBBbnl0aGluZyBvbiB0aGlzIGNhbGwgY29udGFpbmVyIGlzIHN1YmplY3RlZCB0byB0aWNrKCkgcHJvY2Vzc2luZy4gKi9cblx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHMucHVzaChbY2FsbCwgZWxlbWVudHMsIG9wdHMsIG51bGwsIHByb21pc2VEYXRhLnJlc29sdmVyLCBudWxsLCAwXSk7XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGFuaW1hdGlvbiB0aWNrIGlzbid0IHJ1bm5pbmcsIHN0YXJ0IGl0LiAoVmVsb2NpdHkgc2h1dHMgaXQgb2ZmIHdoZW4gdGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscyB0byBwcm9jZXNzLikgKi9cblx0XHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LlN0YXRlLmlzVGlja2luZyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5TdGF0ZS5pc1RpY2tpbmcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogU3RhcnQgdGhlIHRpY2sgbG9vcC4gKi9cblx0XHRcdFx0XHRcdFx0XHR0aWNrKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzSW5kZXgrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBXaGVuIHRoZSBxdWV1ZSBvcHRpb24gaXMgc2V0IHRvIGZhbHNlLCB0aGUgY2FsbCBza2lwcyB0aGUgZWxlbWVudCdzIHF1ZXVlIGFuZCBmaXJlcyBpbW1lZGlhdGVseS4gKi9cblx0XHRcdFx0aWYgKG9wdHMucXVldWUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0LyogU2luY2UgdGhpcyBidWlsZFF1ZXVlIGNhbGwgZG9lc24ndCByZXNwZWN0IHRoZSBlbGVtZW50J3MgZXhpc3RpbmcgcXVldWUgKHdoaWNoIGlzIHdoZXJlIGEgZGVsYXkgb3B0aW9uIHdvdWxkIGhhdmUgYmVlbiBhcHBlbmRlZCksXG5cdFx0XHRcdFx0IHdlIG1hbnVhbGx5IGluamVjdCB0aGUgZGVsYXkgcHJvcGVydHkgaGVyZSB3aXRoIGFuIGV4cGxpY2l0IHNldFRpbWVvdXQuICovXG5cdFx0XHRcdFx0aWYgKG9wdHMuZGVsYXkpIHtcblxuXHRcdFx0XHRcdFx0LyogVGVtcG9yYXJpbHkgc3RvcmUgZGVsYXllZCBlbGVtZW50cyB0byBmYWNpbGl0YXRlIGFjY2VzcyBmb3IgZ2xvYmFsIHBhdXNlL3Jlc3VtZSAqL1xuXHRcdFx0XHRcdFx0dmFyIGNhbGxJbmRleCA9IFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50cy5jb3VudCsrO1xuXHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzW2NhbGxJbmRleF0gPSBlbGVtZW50O1xuXG5cdFx0XHRcdFx0XHR2YXIgZGVsYXlDb21wbGV0ZSA9IChmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogQ2xlYXIgdGhlIHRlbXBvcmFyeSBlbGVtZW50ICovXG5cdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzW2luZGV4XSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogRmluYWxseSwgaXNzdWUgdGhlIGNhbGwgKi9cblx0XHRcdFx0XHRcdFx0XHRidWlsZFF1ZXVlKCk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KShjYWxsSW5kZXgpO1xuXG5cdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLmRlbGF5QmVnaW4gPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0RGF0YShlbGVtZW50KS5kZWxheSA9IHBhcnNlRmxvYXQob3B0cy5kZWxheSk7XG5cdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLmRlbGF5VGltZXIgPSB7XG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQ6IHNldFRpbWVvdXQoYnVpbGRRdWV1ZSwgcGFyc2VGbG9hdChvcHRzLmRlbGF5KSksXG5cdFx0XHRcdFx0XHRcdG5leHQ6IGRlbGF5Q29tcGxldGVcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJ1aWxkUXVldWUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0LyogT3RoZXJ3aXNlLCB0aGUgY2FsbCB1bmRlcmdvZXMgZWxlbWVudCBxdWV1ZWluZyBhcyBub3JtYWwuICovXG5cdFx0XHRcdFx0LyogTm90ZTogVG8gaW50ZXJvcGVyYXRlIHdpdGggalF1ZXJ5LCBWZWxvY2l0eSB1c2VzIGpRdWVyeSdzIG93biAkLnF1ZXVlKCkgc3RhY2sgZm9yIHF1ZXVpbmcgbG9naWMuICovXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5xdWV1ZShlbGVtZW50LCBvcHRzLnF1ZXVlLCBmdW5jdGlvbihuZXh0LCBjbGVhclF1ZXVlKSB7XG5cdFx0XHRcdFx0XHQvKiBJZiB0aGUgY2xlYXJRdWV1ZSBmbGFnIHdhcyBwYXNzZWQgaW4gYnkgdGhlIHN0b3AgY29tbWFuZCwgcmVzb2x2ZSB0aGlzIGNhbGwncyBwcm9taXNlLiAoUHJvbWlzZXMgY2FuIG9ubHkgYmUgcmVzb2x2ZWQgb25jZSxcblx0XHRcdFx0XHRcdCBzbyBpdCdzIGZpbmUgaWYgdGhpcyBpcyByZXBlYXRlZGx5IHRyaWdnZXJlZCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhc3NvY2lhdGVkIGNhbGwuKSAqL1xuXHRcdFx0XHRcdFx0aWYgKGNsZWFyUXVldWUgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHByb21pc2VEYXRhLnByb21pc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZXNvbHZlcihlbGVtZW50cyk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBEbyBub3QgY29udGludWUgd2l0aCBhbmltYXRpb24gcXVldWVpbmcuICovXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBUaGlzIGZsYWcgaW5kaWNhdGVzIHRvIHRoZSB1cGNvbWluZyBjb21wbGV0ZUNhbGwoKSBmdW5jdGlvbiB0aGF0IHRoaXMgcXVldWUgZW50cnkgd2FzIGluaXRpYXRlZCBieSBWZWxvY2l0eS5cblx0XHRcdFx0XHRcdCBTZWUgY29tcGxldGVDYWxsKCkgZm9yIGZ1cnRoZXIgZGV0YWlscy4gKi9cblx0XHRcdFx0XHRcdFZlbG9jaXR5LnZlbG9jaXR5UXVldWVFbnRyeUZsYWcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRidWlsZFF1ZXVlKG5leHQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgQXV0by1EZXF1ZXVpbmdcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBBcyBwZXIgalF1ZXJ5J3MgJC5xdWV1ZSgpIGJlaGF2aW9yLCB0byBmaXJlIHRoZSBmaXJzdCBub24tY3VzdG9tLXF1ZXVlIGVudHJ5IG9uIGFuIGVsZW1lbnQsIHRoZSBlbGVtZW50XG5cdFx0XHRcdCBtdXN0IGJlIGRlcXVldWVkIGlmIGl0cyBxdWV1ZSBzdGFjayBjb25zaXN0cyAqc29sZWx5KiBvZiB0aGUgY3VycmVudCBjYWxsLiAoVGhpcyBjYW4gYmUgZGV0ZXJtaW5lZCBieSBjaGVja2luZ1xuXHRcdFx0XHQgZm9yIHRoZSBcImlucHJvZ3Jlc3NcIiBpdGVtIHRoYXQgalF1ZXJ5IHByZXBlbmRzIHRvIGFjdGl2ZSBxdWV1ZSBzdGFjayBhcnJheXMuKSBSZWdhcmRsZXNzLCB3aGVuZXZlciB0aGUgZWxlbWVudCdzXG5cdFx0XHRcdCBxdWV1ZSBpcyBmdXJ0aGVyIGFwcGVuZGVkIHdpdGggYWRkaXRpb25hbCBpdGVtcyAtLSBpbmNsdWRpbmcgJC5kZWxheSgpJ3Mgb3IgZXZlbiAkLmFuaW1hdGUoKSBjYWxscywgdGhlIHF1ZXVlJ3Ncblx0XHRcdFx0IGZpcnN0IGVudHJ5IGlzIGF1dG9tYXRpY2FsbHkgZmlyZWQuIFRoaXMgYmVoYXZpb3IgY29udHJhc3RzIHRoYXQgb2YgY3VzdG9tIHF1ZXVlcywgd2hpY2ggbmV2ZXIgYXV0by1maXJlLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBXaGVuIGFuIGVsZW1lbnQgc2V0IGlzIGJlaW5nIHN1YmplY3RlZCB0byBhIG5vbi1wYXJhbGxlbCBWZWxvY2l0eSBjYWxsLCB0aGUgYW5pbWF0aW9uIHdpbGwgbm90IGJlZ2luIHVudGlsXG5cdFx0XHRcdCBlYWNoIG9uZSBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIHNldCBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIGl0cyBpbmRpdmlkdWFsbHkgcHJlLWV4aXN0aW5nIHF1ZXVlIGNoYWluLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBVbmZvcnR1bmF0ZWx5LCBtb3N0IHBlb3BsZSBkb24ndCBmdWxseSBncmFzcCBqUXVlcnkncyBwb3dlcmZ1bCwgeWV0IHF1aXJreSwgJC5xdWV1ZSgpIGZ1bmN0aW9uLlxuXHRcdFx0XHQgTGVhbiBtb3JlIGhlcmU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1ODE1OC9jYW4tc29tZWJvZHktZXhwbGFpbi1qcXVlcnktcXVldWUtdG8tbWUgKi9cblx0XHRcdFx0aWYgKChvcHRzLnF1ZXVlID09PSBcIlwiIHx8IG9wdHMucXVldWUgPT09IFwiZnhcIikgJiYgJC5xdWV1ZShlbGVtZW50KVswXSAhPT0gXCJpbnByb2dyZXNzXCIpIHtcblx0XHRcdFx0XHQkLmRlcXVldWUoZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgRWxlbWVudCBTZXQgSXRlcmF0aW9uXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIElmIHRoZSBcIm5vZGVUeXBlXCIgcHJvcGVydHkgZXhpc3RzIG9uIHRoZSBlbGVtZW50cyB2YXJpYWJsZSwgd2UncmUgYW5pbWF0aW5nIGEgc2luZ2xlIGVsZW1lbnQuXG5cdFx0XHQgUGxhY2UgaXQgaW4gYW4gYXJyYXkgc28gdGhhdCAkLmVhY2goKSBjYW4gaXRlcmF0ZSBvdmVyIGl0LiAqL1xuXHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdFx0XHRcdC8qIEVuc3VyZSBlYWNoIGVsZW1lbnQgaW4gYSBzZXQgaGFzIGEgbm9kZVR5cGUgKGlzIGEgcmVhbCBlbGVtZW50KSB0byBhdm9pZCB0aHJvd2luZyBlcnJvcnMuICovXG5cdFx0XHRcdGlmIChUeXBlLmlzTm9kZShlbGVtZW50KSkge1xuXHRcdFx0XHRcdHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKlxuXHRcdFx0IE9wdGlvbjogTG9vcFxuXHRcdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0LyogVGhlIGxvb3Agb3B0aW9uIGFjY2VwdHMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIGhvdyBtYW55IHRpbWVzIHRoZSBlbGVtZW50IHNob3VsZCBsb29wIGJldHdlZW4gdGhlIHZhbHVlcyBpbiB0aGVcblx0XHRcdCBjdXJyZW50IGNhbGwncyBwcm9wZXJ0aWVzIG1hcCBhbmQgdGhlIGVsZW1lbnQncyBwcm9wZXJ0eSB2YWx1ZXMgcHJpb3IgdG8gdGhpcyBjYWxsLiAqL1xuXHRcdFx0LyogTm90ZTogVGhlIGxvb3Agb3B0aW9uJ3MgbG9naWMgaXMgcGVyZm9ybWVkIGhlcmUgLS0gYWZ0ZXIgZWxlbWVudCBwcm9jZXNzaW5nIC0tIGJlY2F1c2UgdGhlIGN1cnJlbnQgY2FsbCBuZWVkc1xuXHRcdFx0IHRvIHVuZGVyZ28gaXRzIHF1ZXVlIGluc2VydGlvbiBwcmlvciB0byB0aGUgbG9vcCBvcHRpb24gZ2VuZXJhdGluZyBpdHMgc2VyaWVzIG9mIGNvbnN0aXR1ZW50IFwicmV2ZXJzZVwiIGNhbGxzLFxuXHRcdFx0IHdoaWNoIGNoYWluIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwuIFR3byByZXZlcnNlIGNhbGxzICh0d28gXCJhbHRlcm5hdGlvbnNcIikgY29uc3RpdHV0ZSBvbmUgbG9vcC4gKi9cblx0XHRcdG9wdHMgPSAkLmV4dGVuZCh7fSwgVmVsb2NpdHkuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdFx0b3B0cy5sb29wID0gcGFyc2VJbnQob3B0cy5sb29wLCAxMCk7XG5cdFx0XHR2YXIgcmV2ZXJzZUNhbGxzQ291bnQgPSAob3B0cy5sb29wICogMikgLSAxO1xuXG5cdFx0XHRpZiAob3B0cy5sb29wKSB7XG5cdFx0XHRcdC8qIERvdWJsZSB0aGUgbG9vcCBjb3VudCB0byBjb252ZXJ0IGl0IGludG8gaXRzIGFwcHJvcHJpYXRlIG51bWJlciBvZiBcInJldmVyc2VcIiBjYWxscy5cblx0XHRcdFx0IFN1YnRyYWN0IDEgZnJvbSB0aGUgcmVzdWx0aW5nIHZhbHVlIHNpbmNlIHRoZSBjdXJyZW50IGNhbGwgaXMgaW5jbHVkZWQgaW4gdGhlIHRvdGFsIGFsdGVybmF0aW9uIGNvdW50LiAqL1xuXHRcdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IHJldmVyc2VDYWxsc0NvdW50OyB4KyspIHtcblx0XHRcdFx0XHQvKiBTaW5jZSB0aGUgbG9naWMgZm9yIHRoZSByZXZlcnNlIGFjdGlvbiBvY2N1cnMgaW5zaWRlIFF1ZXVlaW5nIGFuZCB0aGVyZWZvcmUgdGhpcyBjYWxsJ3Mgb3B0aW9ucyBvYmplY3Rcblx0XHRcdFx0XHQgaXNuJ3QgcGFyc2VkIHVudGlsIHRoZW4gYXMgd2VsbCwgdGhlIGN1cnJlbnQgY2FsbCdzIGRlbGF5IG9wdGlvbiBtdXN0IGJlIGV4cGxpY2l0bHkgcGFzc2VkIGludG8gdGhlIHJldmVyc2Vcblx0XHRcdFx0XHQgY2FsbCBzbyB0aGF0IHRoZSBkZWxheSBsb2dpYyB0aGF0IG9jY3VycyBpbnNpZGUgKlByZS1RdWV1ZWluZyogY2FuIHByb2Nlc3MgaXQuICovXG5cdFx0XHRcdFx0dmFyIHJldmVyc2VPcHRpb25zID0ge1xuXHRcdFx0XHRcdFx0ZGVsYXk6IG9wdHMuZGVsYXksXG5cdFx0XHRcdFx0XHRwcm9ncmVzczogb3B0cy5wcm9ncmVzc1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvKiBJZiBhIGNvbXBsZXRlIGNhbGxiYWNrIHdhcyBwYXNzZWQgaW50byB0aGlzIGNhbGwsIHRyYW5zZmVyIGl0IHRvIHRoZSBsb29wIHJlZGlyZWN0J3MgZmluYWwgXCJyZXZlcnNlXCIgY2FsbFxuXHRcdFx0XHRcdCBzbyB0aGF0IGl0J3MgdHJpZ2dlcmVkIHdoZW4gdGhlIGVudGlyZSByZWRpcmVjdCBpcyBjb21wbGV0ZSAoYW5kIG5vdCB3aGVuIHRoZSB2ZXJ5IGZpcnN0IGFuaW1hdGlvbiBpcyBjb21wbGV0ZSkuICovXG5cdFx0XHRcdFx0aWYgKHggPT09IHJldmVyc2VDYWxsc0NvdW50IC0gMSkge1xuXHRcdFx0XHRcdFx0cmV2ZXJzZU9wdGlvbnMuZGlzcGxheSA9IG9wdHMuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJldmVyc2VPcHRpb25zLnZpc2liaWxpdHkgPSBvcHRzLnZpc2liaWxpdHk7XG5cdFx0XHRcdFx0XHRyZXZlcnNlT3B0aW9ucy5jb21wbGV0ZSA9IG9wdHMuY29tcGxldGU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YW5pbWF0ZShlbGVtZW50cywgXCJyZXZlcnNlXCIsIHJldmVyc2VPcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKioqKioqKioqKioqKioqXG5cdFx0XHQgQ2hhaW5pbmdcblx0XHRcdCAqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIFJldHVybiB0aGUgZWxlbWVudHMgYmFjayB0byB0aGUgY2FsbCBjaGFpbiwgd2l0aCB3cmFwcGVkIGVsZW1lbnRzIHRha2luZyBwcmVjZWRlbmNlIGluIGNhc2UgVmVsb2NpdHkgd2FzIGNhbGxlZCB2aWEgdGhlICQuZm4uIGV4dGVuc2lvbi4gKi9cblx0XHRcdHJldHVybiBnZXRDaGFpbigpO1xuXHRcdH07XG5cblx0XHQvKiBUdXJuIFZlbG9jaXR5IGludG8gdGhlIGFuaW1hdGlvbiBmdW5jdGlvbiwgZXh0ZW5kZWQgd2l0aCB0aGUgcHJlLWV4aXN0aW5nIFZlbG9jaXR5IG9iamVjdC4gKi9cblx0XHRWZWxvY2l0eSA9ICQuZXh0ZW5kKGFuaW1hdGUsIFZlbG9jaXR5KTtcblx0XHQvKiBGb3IgbGVnYWN5IHN1cHBvcnQsIGFsc28gZXhwb3NlIHRoZSBsaXRlcmFsIGFuaW1hdGUgbWV0aG9kLiAqL1xuXHRcdFZlbG9jaXR5LmFuaW1hdGUgPSBhbmltYXRlO1xuXG5cdFx0LyoqKioqKioqKioqKioqXG5cdFx0IFRpbWluZ1xuXHRcdCAqKioqKioqKioqKioqKi9cblxuXHRcdC8qIFRpY2tlciBmdW5jdGlvbi4gKi9cblx0XHR2YXIgdGlja2VyID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCByQUZTaGltO1xuXG5cdFx0LyogSW5hY3RpdmUgYnJvd3NlciB0YWJzIHBhdXNlIHJBRiwgd2hpY2ggcmVzdWx0cyBpbiBhbGwgYWN0aXZlIGFuaW1hdGlvbnMgaW1tZWRpYXRlbHkgc3ByaW50aW5nIHRvIHRoZWlyIGNvbXBsZXRpb24gc3RhdGVzIHdoZW4gdGhlIHRhYiByZWZvY3VzZXMuXG5cdFx0IFRvIGdldCBhcm91bmQgdGhpcywgd2UgZHluYW1pY2FsbHkgc3dpdGNoIHJBRiB0byBzZXRUaW1lb3V0ICh3aGljaCB0aGUgYnJvd3NlciAqZG9lc24ndCogcGF1c2UpIHdoZW4gdGhlIHRhYiBsb3NlcyBmb2N1cy4gV2Ugc2tpcCB0aGlzIGZvciBtb2JpbGVcblx0XHQgZGV2aWNlcyB0byBhdm9pZCB3YXN0aW5nIGJhdHRlcnkgcG93ZXIgb24gaW5hY3RpdmUgdGFicy4gKi9cblx0XHQvKiBOb3RlOiBUYWIgZm9jdXMgZGV0ZWN0aW9uIGRvZXNuJ3Qgd29yayBvbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgYnV0IHRoYXQncyBva2F5IHNpbmNlIHRoZXkgZG9uJ3Qgc3VwcG9ydCByQUYgdG8gYmVnaW4gd2l0aC4gKi9cblx0XHRpZiAoIVZlbG9jaXR5LlN0YXRlLmlzTW9iaWxlICYmIGRvY3VtZW50LmhpZGRlbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgdXBkYXRlVGlja2VyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8qIFJlYXNzaWduIHRoZSByQUYgZnVuY3Rpb24gKHdoaWNoIHRoZSBnbG9iYWwgdGljaygpIGZ1bmN0aW9uIHVzZXMpIGJhc2VkIG9uIHRoZSB0YWIncyBmb2N1cyBzdGF0ZS4gKi9cblx0XHRcdFx0aWYgKGRvY3VtZW50LmhpZGRlbikge1xuXHRcdFx0XHRcdHRpY2tlciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHQvKiBUaGUgdGljayBmdW5jdGlvbiBuZWVkcyBhIHRydXRoeSBmaXJzdCBhcmd1bWVudCBpbiBvcmRlciB0byBwYXNzIGl0cyBpbnRlcm5hbCB0aW1lc3RhbXAgY2hlY2suICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sodHJ1ZSk7XG5cdFx0XHRcdFx0XHR9LCAxNik7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8qIFRoZSByQUYgbG9vcCBoYXMgYmVlbiBwYXVzZWQgYnkgdGhlIGJyb3dzZXIsIHNvIHdlIG1hbnVhbGx5IHJlc3RhcnQgdGhlIHRpY2suICovXG5cdFx0XHRcdFx0dGljaygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpY2tlciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgckFGU2hpbTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyogUGFnZSBjb3VsZCBiZSBzaXR0aW5nIGluIHRoZSBiYWNrZ3JvdW5kIGF0IHRoaXMgdGltZSAoaS5lLiBvcGVuZWQgYXMgbmV3IHRhYikgc28gbWFraW5nIHN1cmUgd2UgdXNlIGNvcnJlY3QgdGlja2VyIGZyb20gdGhlIHN0YXJ0ICovXG5cdFx0XHR1cGRhdGVUaWNrZXIoKTtcblxuXHRcdFx0LyogQW5kIHRoZW4gcnVuIGNoZWNrIGFnYWluIGV2ZXJ5IHRpbWUgdmlzaWJpbGl0eSBjaGFuZ2VzICovXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB1cGRhdGVUaWNrZXIpO1xuXHRcdH1cblxuXHRcdC8qKioqKioqKioqKipcblx0XHQgVGlja1xuXHRcdCAqKioqKioqKioqKiovXG5cblx0XHQvKiBOb3RlOiBBbGwgY2FsbHMgdG8gVmVsb2NpdHkgYXJlIHB1c2hlZCB0byB0aGUgVmVsb2NpdHkuU3RhdGUuY2FsbHMgYXJyYXksIHdoaWNoIGlzIGZ1bGx5IGl0ZXJhdGVkIHRocm91Z2ggdXBvbiBlYWNoIHRpY2suICovXG5cdFx0ZnVuY3Rpb24gdGljayh0aW1lc3RhbXApIHtcblx0XHRcdC8qIEFuIGVtcHR5IHRpbWVzdGFtcCBhcmd1bWVudCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGlzIHRoZSBmaXJzdCB0aWNrIG9jY3VyZW5jZSBzaW5jZSB0aWNraW5nIHdhcyB0dXJuZWQgb24uXG5cdFx0XHQgV2UgbGV2ZXJhZ2UgdGhpcyBtZXRhZGF0YSB0byBmdWxseSBpZ25vcmUgdGhlIGZpcnN0IHRpY2sgcGFzcyBzaW5jZSBSQUYncyBpbml0aWFsIHBhc3MgaXMgZmlyZWQgd2hlbmV2ZXJcblx0XHRcdCB0aGUgYnJvd3NlcidzIG5leHQgdGljayBzeW5jIHRpbWUgb2NjdXJzLCB3aGljaCByZXN1bHRzIGluIHRoZSBmaXJzdCBlbGVtZW50cyBzdWJqZWN0ZWQgdG8gVmVsb2NpdHlcblx0XHRcdCBjYWxscyBiZWluZyBhbmltYXRlZCBvdXQgb2Ygc3luYyB3aXRoIGFueSBlbGVtZW50cyBhbmltYXRlZCBpbW1lZGlhdGVseSB0aGVyZWFmdGVyLiBJbiBzaG9ydCwgd2UgaWdub3JlXG5cdFx0XHQgdGhlIGZpcnN0IFJBRiB0aWNrIHBhc3Mgc28gdGhhdCBlbGVtZW50cyBiZWluZyBpbW1lZGlhdGVseSBjb25zZWN1dGl2ZWx5IGFuaW1hdGVkIC0tIGluc3RlYWQgb2Ygc2ltdWx0YW5lb3VzbHkgYW5pbWF0ZWRcblx0XHRcdCBieSB0aGUgc2FtZSBWZWxvY2l0eSBjYWxsIC0tIGFyZSBwcm9wZXJseSBiYXRjaGVkIGludG8gdGhlIHNhbWUgaW5pdGlhbCBSQUYgdGljayBhbmQgY29uc2VxdWVudGx5IHJlbWFpbiBpbiBzeW5jIHRoZXJlYWZ0ZXIuICovXG5cdFx0XHRpZiAodGltZXN0YW1wKSB7XG5cdFx0XHRcdC8qIFdlIG5vcm1hbGx5IHVzZSBSQUYncyBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIGJ1dCBhcyBpdCBjYW4gYmUgc2lnbmlmaWNhbnRseSBvZmZzZXQgd2hlbiB0aGUgYnJvd3NlciBpc1xuXHRcdFx0XHQgdW5kZXIgaGlnaCBzdHJlc3Mgd2UgZ2l2ZSB0aGUgb3B0aW9uIGZvciBjaG9wcGluZXNzIG92ZXIgYWxsb3dpbmcgdGhlIGJyb3dzZXIgdG8gZHJvcCBodWdlIGNodW5rcyBvZiBmcmFtZXMuXG5cdFx0XHRcdCBXZSB1c2UgcGVyZm9ybWFuY2Uubm93KCkgYW5kIHNoaW0gaXQgaWYgaXQgZG9lc24ndCBleGlzdCBmb3Igd2hlbiB0aGUgdGFiIGlzIGhpZGRlbi4gKi9cblx0XHRcdFx0dmFyIHRpbWVDdXJyZW50ID0gVmVsb2NpdHkudGltZXN0YW1wICYmIHRpbWVzdGFtcCAhPT0gdHJ1ZSA/IHRpbWVzdGFtcCA6IHBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgQ2FsbCBJdGVyYXRpb25cblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdHZhciBjYWxsc0xlbmd0aCA9IFZlbG9jaXR5LlN0YXRlLmNhbGxzLmxlbmd0aDtcblxuXHRcdFx0XHQvKiBUbyBzcGVlZCB1cCBpdGVyYXRpbmcgb3ZlciB0aGlzIGFycmF5LCBpdCBpcyBjb21wYWN0ZWQgKGZhbHNleSBpdGVtcyAtLSBjYWxscyB0aGF0IGhhdmUgY29tcGxldGVkIC0tIGFyZSByZW1vdmVkKVxuXHRcdFx0XHQgd2hlbiBpdHMgbGVuZ3RoIGhhcyBiYWxsb29uZWQgdG8gYSBwb2ludCB0aGF0IGNhbiBpbXBhY3QgdGljayBwZXJmb3JtYW5jZS4gVGhpcyBvbmx5IGJlY29tZXMgbmVjZXNzYXJ5IHdoZW4gYW5pbWF0aW9uXG5cdFx0XHRcdCBoYXMgYmVlbiBjb250aW51b3VzIHdpdGggbWFueSBlbGVtZW50cyBvdmVyIGEgbG9uZyBwZXJpb2Qgb2YgdGltZTsgd2hlbmV2ZXIgYWxsIGFjdGl2ZSBjYWxscyBhcmUgY29tcGxldGVkLCBjb21wbGV0ZUNhbGwoKSBjbGVhcnMgVmVsb2NpdHkuU3RhdGUuY2FsbHMuICovXG5cdFx0XHRcdGlmIChjYWxsc0xlbmd0aCA+IDEwMDAwKSB7XG5cdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHMgPSBjb21wYWN0U3BhcnNlQXJyYXkoVmVsb2NpdHkuU3RhdGUuY2FsbHMpO1xuXHRcdFx0XHRcdGNhbGxzTGVuZ3RoID0gVmVsb2NpdHkuU3RhdGUuY2FsbHMubGVuZ3RoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIGVhY2ggYWN0aXZlIGNhbGwuICovXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbHNMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdC8qIFdoZW4gYSBWZWxvY2l0eSBjYWxsIGlzIGNvbXBsZXRlZCwgaXRzIFZlbG9jaXR5LlN0YXRlLmNhbGxzIGVudHJ5IGlzIHNldCB0byBmYWxzZS4gQ29udGludWUgb24gdG8gdGhlIG5leHQgY2FsbC4gKi9cblx0XHRcdFx0XHRpZiAoIVZlbG9jaXR5LlN0YXRlLmNhbGxzW2ldKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IENhbGwtV2lkZSBWYXJpYWJsZXNcblx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0dmFyIGNhbGxDb250YWluZXIgPSBWZWxvY2l0eS5TdGF0ZS5jYWxsc1tpXSxcblx0XHRcdFx0XHRcdFx0Y2FsbCA9IGNhbGxDb250YWluZXJbMF0sXG5cdFx0XHRcdFx0XHRcdG9wdHMgPSBjYWxsQ29udGFpbmVyWzJdLFxuXHRcdFx0XHRcdFx0XHR0aW1lU3RhcnQgPSBjYWxsQ29udGFpbmVyWzNdLFxuXHRcdFx0XHRcdFx0XHRmaXJzdFRpY2sgPSAhIXRpbWVTdGFydCxcblx0XHRcdFx0XHRcdFx0dHdlZW5EdW1teVZhbHVlID0gbnVsbCxcblx0XHRcdFx0XHRcdFx0cGF1c2VPYmplY3QgPSBjYWxsQ29udGFpbmVyWzVdLFxuXHRcdFx0XHRcdFx0XHRtaWxsaXNlY29uZHNFbGxhcHNlZCA9IGNhbGxDb250YWluZXJbNl07XG5cblxuXG5cdFx0XHRcdFx0LyogSWYgdGltZVN0YXJ0IGlzIHVuZGVmaW5lZCwgdGhlbiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoYXQgdGhpcyBjYWxsIGhhcyBiZWVuIHByb2Nlc3NlZCBieSB0aWNrKCkuXG5cdFx0XHRcdFx0IFdlIGFzc2lnbiB0aW1lU3RhcnQgbm93IHNvIHRoYXQgaXRzIHZhbHVlIGlzIGFzIGNsb3NlIHRvIHRoZSByZWFsIGFuaW1hdGlvbiBzdGFydCB0aW1lIGFzIHBvc3NpYmxlLlxuXHRcdFx0XHRcdCAoQ29udmVyc2VseSwgaGFkIHRpbWVTdGFydCBiZWVuIGRlZmluZWQgd2hlbiB0aGlzIGNhbGwgd2FzIGFkZGVkIHRvIFZlbG9jaXR5LlN0YXRlLmNhbGxzLCB0aGUgZGVsYXlcblx0XHRcdFx0XHQgYmV0d2VlbiB0aGF0IHRpbWUgYW5kIG5vdyB3b3VsZCBjYXVzZSB0aGUgZmlyc3QgZmV3IGZyYW1lcyBvZiB0aGUgdHdlZW4gdG8gYmUgc2tpcHBlZCBzaW5jZVxuXHRcdFx0XHRcdCBwZXJjZW50Q29tcGxldGUgaXMgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byB0aW1lU3RhcnQuKSAqL1xuXHRcdFx0XHRcdC8qIEZ1cnRoZXIsIHN1YnRyYWN0IDE2bXMgKHRoZSBhcHByb3hpbWF0ZSByZXNvbHV0aW9uIG9mIFJBRikgZnJvbSB0aGUgY3VycmVudCB0aW1lIHZhbHVlIHNvIHRoYXQgdGhlXG5cdFx0XHRcdFx0IGZpcnN0IHRpY2sgaXRlcmF0aW9uIGlzbid0IHdhc3RlZCBieSBhbmltYXRpbmcgYXQgMCUgdHdlZW4gY29tcGxldGlvbiwgd2hpY2ggd291bGQgcHJvZHVjZSB0aGVcblx0XHRcdFx0XHQgc2FtZSBzdHlsZSB2YWx1ZSBhcyB0aGUgZWxlbWVudCdzIGN1cnJlbnQgdmFsdWUuICovXG5cdFx0XHRcdFx0aWYgKCF0aW1lU3RhcnQpIHtcblx0XHRcdFx0XHRcdHRpbWVTdGFydCA9IFZlbG9jaXR5LlN0YXRlLmNhbGxzW2ldWzNdID0gdGltZUN1cnJlbnQgLSAxNjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBJZiBhIHBhdXNlIG9iamVjdCBpcyBwcmVzZW50LCBza2lwIHByb2Nlc3NpbmcgdW5sZXNzIGl0IGhhcyBiZWVuIHNldCB0byByZXN1bWUgKi9cblx0XHRcdFx0XHRpZiAocGF1c2VPYmplY3QpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZU9iamVjdC5yZXN1bWUgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0LyogVXBkYXRlIHRoZSB0aW1lIHN0YXJ0IHRvIGFjY29tb2RhdGUgdGhlIHBhdXNlZCBjb21wbGV0aW9uIGFtb3VudCAqL1xuXHRcdFx0XHRcdFx0XHR0aW1lU3RhcnQgPSBjYWxsQ29udGFpbmVyWzNdID0gTWF0aC5yb3VuZCh0aW1lQ3VycmVudCAtIG1pbGxpc2Vjb25kc0VsbGFwc2VkIC0gMTYpO1xuXG5cdFx0XHRcdFx0XHRcdC8qIFJlbW92ZSBwYXVzZSBvYmplY3QgYWZ0ZXIgcHJvY2Vzc2luZyAqL1xuXHRcdFx0XHRcdFx0XHRjYWxsQ29udGFpbmVyWzVdID0gbnVsbDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1pbGxpc2Vjb25kc0VsbGFwc2VkID0gY2FsbENvbnRhaW5lcls2XSA9IHRpbWVDdXJyZW50IC0gdGltZVN0YXJ0O1xuXG5cdFx0XHRcdFx0LyogVGhlIHR3ZWVuJ3MgY29tcGxldGlvbiBwZXJjZW50YWdlIGlzIHJlbGF0aXZlIHRvIHRoZSB0d2VlbidzIHN0YXJ0IHRpbWUsIG5vdCB0aGUgdHdlZW4ncyBzdGFydCB2YWx1ZVxuXHRcdFx0XHRcdCAod2hpY2ggd291bGQgcmVzdWx0IGluIHVucHJlZGljdGFibGUgdHdlZW4gZHVyYXRpb25zIHNpbmNlIEphdmFTY3JpcHQncyB0aW1lcnMgYXJlIG5vdCBwYXJ0aWN1bGFybHkgYWNjdXJhdGUpLlxuXHRcdFx0XHRcdCBBY2NvcmRpbmdseSwgd2UgZW5zdXJlIHRoYXQgcGVyY2VudENvbXBsZXRlIGRvZXMgbm90IGV4Y2VlZCAxLiAqL1xuXHRcdFx0XHRcdHZhciBwZXJjZW50Q29tcGxldGUgPSBNYXRoLm1pbigobWlsbGlzZWNvbmRzRWxsYXBzZWQpIC8gb3B0cy5kdXJhdGlvbiwgMSk7XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBFbGVtZW50IEl0ZXJhdGlvblxuXHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogRm9yIGV2ZXJ5IGNhbGwsIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIG9mIHRoZSBlbGVtZW50cyBpbiBpdHMgc2V0LiAqL1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBjYWxsTGVuZ3RoID0gY2FsbC5sZW5ndGg7IGogPCBjYWxsTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdHZhciB0d2VlbnNDb250YWluZXIgPSBjYWxsW2pdLFxuXHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQgPSB0d2VlbnNDb250YWluZXIuZWxlbWVudDtcblxuXHRcdFx0XHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHRoaXMgZWxlbWVudCBoYXMgYmVlbiBkZWxldGVkIG1pZHdheSB0aHJvdWdoIHRoZSBhbmltYXRpb24gYnkgY2hlY2tpbmcgZm9yIHRoZVxuXHRcdFx0XHRcdFx0IGNvbnRpbnVlZCBleGlzdGVuY2Ugb2YgaXRzIGRhdGEgY2FjaGUuIElmIGl0J3MgZ29uZSwgb3IgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IHBhdXNlZCwgc2tpcCBhbmltYXRpbmcgdGhpcyBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0aWYgKCFEYXRhKGVsZW1lbnQpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtUHJvcGVydHlFeGlzdHMgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBEaXNwbGF5ICYgVmlzaWJpbGl0eSBUb2dnbGluZ1xuXHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdC8qIElmIHRoZSBkaXNwbGF5IG9wdGlvbiBpcyBzZXQgdG8gbm9uLVwibm9uZVwiLCBzZXQgaXQgdXBmcm9udCBzbyB0aGF0IHRoZSBlbGVtZW50IGNhbiBiZWNvbWUgdmlzaWJsZSBiZWZvcmUgdHdlZW5pbmcgYmVnaW5zLlxuXHRcdFx0XHRcdFx0IChPdGhlcndpc2UsIGRpc3BsYXkncyBcIm5vbmVcIiB2YWx1ZSBpcyBzZXQgaW4gY29tcGxldGVDYWxsKCkgb25jZSB0aGUgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWQuKSAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIG9wdHMuZGlzcGxheSAhPT0gbnVsbCAmJiBvcHRzLmRpc3BsYXkgIT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRzLmRpc3BsYXkgPT09IFwiZmxleFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGZsZXhWYWx1ZXMgPSBbXCItd2Via2l0LWJveFwiLCBcIi1tb3otYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCItd2Via2l0LWZsZXhcIl07XG5cblx0XHRcdFx0XHRcdFx0XHQkLmVhY2goZmxleFZhbHVlcywgZnVuY3Rpb24oaSwgZmxleFZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImRpc3BsYXlcIiwgZmxleFZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdENTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiZGlzcGxheVwiLCBvcHRzLmRpc3BsYXkpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBTYW1lIGdvZXMgd2l0aCB0aGUgdmlzaWJpbGl0eSBvcHRpb24sIGJ1dCBpdHMgXCJub25lXCIgZXF1aXZhbGVudCBpcyBcImhpZGRlblwiLiAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMudmlzaWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmIG9wdHMudmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdFx0XHRDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInZpc2liaWxpdHlcIiwgb3B0cy52aXNpYmlsaXR5KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0IFByb3BlcnR5IEl0ZXJhdGlvblxuXHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0LyogRm9yIGV2ZXJ5IGVsZW1lbnQsIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHByb3BlcnR5LiAqL1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gdHdlZW5zQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IEluIGFkZGl0aW9uIHRvIHByb3BlcnR5IHR3ZWVuIGRhdGEsIHR3ZWVuc0NvbnRhaW5lciBjb250YWlucyBhIHJlZmVyZW5jZSB0byBpdHMgYXNzb2NpYXRlZCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAodHdlZW5zQ29udGFpbmVyLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiBwcm9wZXJ0eSAhPT0gXCJlbGVtZW50XCIpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNDb250YWluZXJbcHJvcGVydHldLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEVhc2luZyBjYW4gZWl0aGVyIGJlIGEgcHJlLWdlbmVyZWF0ZWQgZnVuY3Rpb24gb3IgYSBzdHJpbmcgdGhhdCByZWZlcmVuY2VzIGEgcHJlLXJlZ2lzdGVyZWQgZWFzaW5nXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCBvbiB0aGUgVmVsb2NpdHkuRWFzaW5ncyBvYmplY3QuIEluIGVpdGhlciBjYXNlLCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIGVhc2luZyAqZnVuY3Rpb24qLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlYXNpbmcgPSBUeXBlLmlzU3RyaW5nKHR3ZWVuLmVhc2luZykgPyBWZWxvY2l0eS5FYXNpbmdzW3R3ZWVuLmVhc2luZ10gOiB0d2Vlbi5lYXNpbmc7XG5cblx0XHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdFx0IEN1cnJlbnQgVmFsdWUgQ2FsY3VsYXRpb25cblx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNTdHJpbmcodHdlZW4ucGF0dGVybikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwYXR0ZXJuUmVwbGFjZSA9IHBlcmNlbnRDb21wbGV0ZSA9PT0gMSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oJDAsIGluZGV4LCByb3VuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJlc3VsdCA9IHR3ZWVuLmVuZFZhbHVlW2luZGV4XTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCQwLCBpbmRleCwgcm91bmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBzdGFydFZhbHVlID0gdHdlZW4uc3RhcnRWYWx1ZVtpbmRleF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHdlZW5EZWx0YSA9IHR3ZWVuLmVuZFZhbHVlW2luZGV4XSAtIHN0YXJ0VmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gc3RhcnRWYWx1ZSArICh0d2VlbkRlbHRhICogZWFzaW5nKHBlcmNlbnRDb21wbGV0ZSwgb3B0cywgdHdlZW5EZWx0YSkpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcm91bmQgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlID0gdHdlZW4ucGF0dGVybi5yZXBsYWNlKC97KFxcZCspKCEpP30vZywgcGF0dGVyblJlcGxhY2UpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocGVyY2VudENvbXBsZXRlID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRpY2sgcGFzcyAoaWYgd2UndmUgcmVhY2hlZCAxMDAlIGNvbXBsZXRpb24gZm9yIHRoaXMgdHdlZW4pLFxuXHRcdFx0XHRcdFx0XHRcdFx0IGVuc3VyZSB0aGF0IGN1cnJlbnRWYWx1ZSBpcyBleHBsaWNpdGx5IHNldCB0byBpdHMgdGFyZ2V0IGVuZFZhbHVlIHNvIHRoYXQgaXQncyBub3Qgc3ViamVjdGVkIHRvIGFueSByb3VuZGluZy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuLmVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBPdGhlcndpc2UsIGNhbGN1bGF0ZSBjdXJyZW50VmFsdWUgYmFzZWQgb24gdGhlIGN1cnJlbnQgZGVsdGEgZnJvbSBzdGFydFZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHR3ZWVuRGVsdGEgPSB0d2Vlbi5lbmRWYWx1ZSAtIHR3ZWVuLnN0YXJ0VmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuLnN0YXJ0VmFsdWUgKyAodHdlZW5EZWx0YSAqIGVhc2luZyhwZXJjZW50Q29tcGxldGUsIG9wdHMsIHR3ZWVuRGVsdGEpKTtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIG5vIHZhbHVlIGNoYW5nZSBpcyBvY2N1cnJpbmcsIGRvbid0IHByb2NlZWQgd2l0aCBET00gdXBkYXRpbmcuICovXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICghZmlyc3RUaWNrICYmIChjdXJyZW50VmFsdWUgPT09IHR3ZWVuLmN1cnJlbnRWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHR3ZWVuLmN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIElmIHdlJ3JlIHR3ZWVuaW5nIGEgZmFrZSAndHdlZW4nIHByb3BlcnR5IGluIG9yZGVyIHRvIGxvZyB0cmFuc2l0aW9uIHZhbHVlcywgdXBkYXRlIHRoZSBvbmUtcGVyLWNhbGwgdmFyaWFibGUgc28gdGhhdFxuXHRcdFx0XHRcdFx0XHRcdCBpdCBjYW4gYmUgcGFzc2VkIGludG8gdGhlIHByb2dyZXNzIGNhbGxiYWNrLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eSA9PT0gXCJ0d2VlblwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0d2VlbkR1bW15VmFsdWUgPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0XHRcdCBIb29rczogUGFydCBJXG5cdFx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGhvb2tSb290O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBGb3IgaG9va2VkIHByb3BlcnRpZXMsIHRoZSBuZXdseS11cGRhdGVkIHJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGUgaXMgY2FjaGVkIG9udG8gdGhlIGVsZW1lbnQgc28gdGhhdCBpdCBjYW4gYmUgdXNlZFxuXHRcdFx0XHRcdFx0XHRcdFx0IGZvciBzdWJzZXF1ZW50IGhvb2tzIGluIHRoaXMgY2FsbCB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNhbWUgcm9vdCBwcm9wZXJ0eS4gSWYgd2UgZGlkbid0IGNhY2hlIHRoZSB1cGRhdGVkXG5cdFx0XHRcdFx0XHRcdFx0XHQgcm9vdFByb3BlcnR5VmFsdWUsIGVhY2ggc3Vic2VxdWVudCB1cGRhdGUgdG8gdGhlIHJvb3QgcHJvcGVydHkgaW4gdGhpcyB0aWNrIHBhc3Mgd291bGQgcmVzZXQgdGhlIHByZXZpb3VzIGhvb2snc1xuXHRcdFx0XHRcdFx0XHRcdFx0IHVwZGF0ZXMgdG8gcm9vdFByb3BlcnR5VmFsdWUgcHJpb3IgdG8gaW5qZWN0aW9uLiBBIG5pY2UgcGVyZm9ybWFuY2UgYnlwcm9kdWN0IG9mIHJvb3RQcm9wZXJ0eVZhbHVlIGNhY2hpbmcgaXMgdGhhdFxuXHRcdFx0XHRcdFx0XHRcdFx0IHN1YnNlcXVlbnRseSBjaGFpbmVkIGFuaW1hdGlvbnMgdXNpbmcgdGhlIHNhbWUgaG9va1Jvb3QgYnV0IGEgZGlmZmVyZW50IGhvb2sgY2FuIHVzZSB0aGlzIGNhY2hlZCByb290UHJvcGVydHlWYWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChDU1MuSG9va3MucmVnaXN0ZXJlZFtwcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aG9va1Jvb3QgPSBDU1MuSG9va3MuZ2V0Um9vdChwcm9wZXJ0eSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGUgPSBEYXRhKGVsZW1lbnQpLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGVbaG9va1Jvb3RdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChyb290UHJvcGVydHlWYWx1ZUNhY2hlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHdlZW4ucm9vdFByb3BlcnR5VmFsdWUgPSByb290UHJvcGVydHlWYWx1ZUNhY2hlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdFx0IERPTSBVcGRhdGVcblx0XHRcdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHRcdFx0Lyogc2V0UHJvcGVydHlWYWx1ZSgpIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHByb3BlcnR5IG5hbWUgYW5kIHByb3BlcnR5IHZhbHVlIHBvc3QgYW55IG5vcm1hbGl6YXRpb24gdGhhdCBtYXkgaGF2ZSBiZWVuIHBlcmZvcm1lZC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IFRvIHNvbHZlIGFuIElFPD04IHBvc2l0aW9uaW5nIGJ1ZywgdGhlIHVuaXQgdHlwZSBpcyBkcm9wcGVkIHdoZW4gc2V0dGluZyBhIHByb3BlcnR5IHZhbHVlIG9mIDAuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgYWRqdXN0ZWRTZXREYXRhID0gQ1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgLyogU0VUICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHdlZW4uY3VycmVudFZhbHVlICsgKElFIDwgOSAmJiBwYXJzZUZsb2F0KGN1cnJlbnRWYWx1ZSkgPT09IDAgPyBcIlwiIDogdHdlZW4udW5pdFR5cGUpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR3ZWVuLnJvb3RQcm9wZXJ0eVZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR3ZWVuLnNjcm9sbERhdGEpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdFx0IEhvb2tzOiBQYXJ0IElJXG5cdFx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogTm93IHRoYXQgd2UgaGF2ZSB0aGUgaG9vaydzIHVwZGF0ZWQgcm9vdFByb3BlcnR5VmFsdWUgKHRoZSBwb3N0LXByb2Nlc3NlZCB2YWx1ZSBwcm92aWRlZCBieSBhZGp1c3RlZFNldERhdGEpLCBjYWNoZSBpdCBvbnRvIHRoZSBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5Ib29rcy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTaW5jZSBhZGp1c3RlZFNldERhdGEgY29udGFpbnMgbm9ybWFsaXplZCBkYXRhIHJlYWR5IGZvciBET00gdXBkYXRpbmcsIHRoZSByb290UHJvcGVydHlWYWx1ZSBuZWVkcyB0byBiZSByZS1leHRyYWN0ZWQgZnJvbSBpdHMgbm9ybWFsaXplZCBmb3JtLiA/PyAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbaG9va1Jvb3RdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0RGF0YShlbGVtZW50KS5yb290UHJvcGVydHlWYWx1ZUNhY2hlW2hvb2tSb290XSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW2hvb2tSb290XShcImV4dHJhY3RcIiwgbnVsbCwgYWRqdXN0ZWRTZXREYXRhWzFdKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGVbaG9va1Jvb3RdID0gYWRqdXN0ZWRTZXREYXRhWzFdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0XHRcdCBUcmFuc2Zvcm1zXG5cdFx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBGbGFnIHdoZXRoZXIgYSB0cmFuc2Zvcm0gcHJvcGVydHkgaXMgYmVpbmcgYW5pbWF0ZWQgc28gdGhhdCBmbHVzaFRyYW5zZm9ybUNhY2hlKCkgY2FuIGJlIHRyaWdnZXJlZCBvbmNlIHRoaXMgdGljayBwYXNzIGlzIGNvbXBsZXRlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFkanVzdGVkU2V0RGF0YVswXSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1Qcm9wZXJ0eUV4aXN0cyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBtb2JpbGVIQVxuXHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdC8qIElmIG1vYmlsZUhBIGlzIGVuYWJsZWQsIHNldCB0aGUgdHJhbnNsYXRlM2QgdHJhbnNmb3JtIHRvIG51bGwgdG8gZm9yY2UgaGFyZHdhcmUgYWNjZWxlcmF0aW9uLlxuXHRcdFx0XHRcdFx0IEl0J3Mgc2FmZSB0byBvdmVycmlkZSB0aGlzIHByb3BlcnR5IHNpbmNlIFZlbG9jaXR5IGRvZXNuJ3QgYWN0dWFsbHkgc3VwcG9ydCBpdHMgYW5pbWF0aW9uIChob29rcyBhcmUgdXNlZCBpbiBpdHMgcGxhY2UpLiAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMubW9iaWxlSEEpIHtcblx0XHRcdFx0XHRcdFx0LyogRG9uJ3Qgc2V0IHRoZSBudWxsIHRyYW5zZm9ybSBoYWNrIGlmIHdlJ3ZlIGFscmVhZHkgZG9uZSBzby4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGUudHJhbnNsYXRlM2QgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIEFsbCBlbnRyaWVzIG9uIHRoZSB0cmFuc2Zvcm1DYWNoZSBvYmplY3QgYXJlIGxhdGVyIGNvbmNhdGVuYXRlZCBpbnRvIGEgc2luZ2xlIHRyYW5zZm9ybSBzdHJpbmcgdmlhIGZsdXNoVHJhbnNmb3JtQ2FjaGUoKS4gKi9cblx0XHRcdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlLnRyYW5zbGF0ZTNkID0gXCIoMHB4LCAwcHgsIDBweClcIjtcblxuXHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybVByb3BlcnR5RXhpc3RzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodHJhbnNmb3JtUHJvcGVydHlFeGlzdHMpIHtcblx0XHRcdFx0XHRcdFx0Q1NTLmZsdXNoVHJhbnNmb3JtQ2FjaGUoZWxlbWVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogVGhlIG5vbi1cIm5vbmVcIiBkaXNwbGF5IHZhbHVlIGlzIG9ubHkgYXBwbGllZCB0byBhbiBlbGVtZW50IG9uY2UgLS0gd2hlbiBpdHMgYXNzb2NpYXRlZCBjYWxsIGlzIGZpcnN0IHRpY2tlZCB0aHJvdWdoLlxuXHRcdFx0XHRcdCBBY2NvcmRpbmdseSwgaXQncyBzZXQgdG8gZmFsc2Ugc28gdGhhdCBpdCBpc24ndCByZS1wcm9jZXNzZWQgYnkgdGhpcyBjYWxsIGluIHRoZSBuZXh0IHRpY2suICovXG5cdFx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIG9wdHMuZGlzcGxheSAhPT0gXCJub25lXCIpIHtcblx0XHRcdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmNhbGxzW2ldWzJdLmRpc3BsYXkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG9wdHMudmlzaWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmIG9wdHMudmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHNbaV1bMl0udmlzaWJpbGl0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIFBhc3MgdGhlIGVsZW1lbnRzIGFuZCB0aGUgdGltaW5nIGRhdGEgKHBlcmNlbnRDb21wbGV0ZSwgbXNSZW1haW5pbmcsIHRpbWVTdGFydCwgdHdlZW5EdW1teVZhbHVlKSBpbnRvIHRoZSBwcm9ncmVzcyBjYWxsYmFjay4gKi9cblx0XHRcdFx0XHRpZiAob3B0cy5wcm9ncmVzcykge1xuXHRcdFx0XHRcdFx0b3B0cy5wcm9ncmVzcy5jYWxsKGNhbGxDb250YWluZXJbMV0sXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbENvbnRhaW5lclsxXSxcblx0XHRcdFx0XHRcdFx0XHRwZXJjZW50Q29tcGxldGUsXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoMCwgKHRpbWVTdGFydCArIG9wdHMuZHVyYXRpb24pIC0gdGltZUN1cnJlbnQpLFxuXHRcdFx0XHRcdFx0XHRcdHRpbWVTdGFydCxcblx0XHRcdFx0XHRcdFx0XHR0d2VlbkR1bW15VmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIElmIHRoaXMgY2FsbCBoYXMgZmluaXNoZWQgdHdlZW5pbmcsIHBhc3MgaXRzIGluZGV4IHRvIGNvbXBsZXRlQ2FsbCgpIHRvIGhhbmRsZSBjYWxsIGNsZWFudXAuICovXG5cdFx0XHRcdFx0aWYgKHBlcmNlbnRDb21wbGV0ZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0Y29tcGxldGVDYWxsKGkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKiBOb3RlOiBjb21wbGV0ZUNhbGwoKSBzZXRzIHRoZSBpc1RpY2tpbmcgZmxhZyB0byBmYWxzZSB3aGVuIHRoZSBsYXN0IGNhbGwgb24gVmVsb2NpdHkuU3RhdGUuY2FsbHMgaGFzIGNvbXBsZXRlZC4gKi9cblx0XHRcdGlmIChWZWxvY2l0eS5TdGF0ZS5pc1RpY2tpbmcpIHtcblx0XHRcdFx0dGlja2VyKHRpY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKioqKioqKioqKioqKioqKioqKioqXG5cdFx0IENhbGwgQ29tcGxldGlvblxuXHRcdCAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogTm90ZTogVW5saWtlIHRpY2soKSwgd2hpY2ggcHJvY2Vzc2VzIGFsbCBhY3RpdmUgY2FsbHMgYXQgb25jZSwgY2FsbCBjb21wbGV0aW9uIGlzIGhhbmRsZWQgb24gYSBwZXItY2FsbCBiYXNpcy4gKi9cblx0XHRmdW5jdGlvbiBjb21wbGV0ZUNhbGwoY2FsbEluZGV4LCBpc1N0b3BwZWQpIHtcblx0XHRcdC8qIEVuc3VyZSB0aGUgY2FsbCBleGlzdHMuICovXG5cdFx0XHRpZiAoIVZlbG9jaXR5LlN0YXRlLmNhbGxzW2NhbGxJbmRleF0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBQdWxsIHRoZSBtZXRhZGF0YSBmcm9tIHRoZSBjYWxsLiAqL1xuXHRcdFx0dmFyIGNhbGwgPSBWZWxvY2l0eS5TdGF0ZS5jYWxsc1tjYWxsSW5kZXhdWzBdLFxuXHRcdFx0XHRcdGVsZW1lbnRzID0gVmVsb2NpdHkuU3RhdGUuY2FsbHNbY2FsbEluZGV4XVsxXSxcblx0XHRcdFx0XHRvcHRzID0gVmVsb2NpdHkuU3RhdGUuY2FsbHNbY2FsbEluZGV4XVsyXSxcblx0XHRcdFx0XHRyZXNvbHZlciA9IFZlbG9jaXR5LlN0YXRlLmNhbGxzW2NhbGxJbmRleF1bNF07XG5cblx0XHRcdHZhciByZW1haW5pbmdDYWxsc0V4aXN0ID0gZmFsc2U7XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgRWxlbWVudCBGaW5hbGl6YXRpb25cblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgY2FsbExlbmd0aCA9IGNhbGwubGVuZ3RoOyBpIDwgY2FsbExlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gY2FsbFtpXS5lbGVtZW50O1xuXG5cdFx0XHRcdC8qIElmIHRoZSB1c2VyIHNldCBkaXNwbGF5IHRvIFwibm9uZVwiIChpbnRlbmRpbmcgdG8gaGlkZSB0aGUgZWxlbWVudCksIHNldCBpdCBub3cgdGhhdCB0aGUgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWQuICovXG5cdFx0XHRcdC8qIE5vdGU6IGRpc3BsYXk6bm9uZSBpc24ndCBzZXQgd2hlbiBjYWxscyBhcmUgbWFudWFsbHkgc3RvcHBlZCAodmlhIFZlbG9jaXR5KFwic3RvcFwiKS4gKi9cblx0XHRcdFx0LyogTm90ZTogRGlzcGxheSBnZXRzIGlnbm9yZWQgd2l0aCBcInJldmVyc2VcIiBjYWxscyBhbmQgaW5maW5pdGUgbG9vcHMsIHNpbmNlIHRoaXMgYmVoYXZpb3Igd291bGQgYmUgdW5kZXNpcmFibGUuICovXG5cdFx0XHRcdGlmICghaXNTdG9wcGVkICYmICFvcHRzLmxvb3ApIHtcblx0XHRcdFx0XHRpZiAob3B0cy5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIsIG9wdHMuZGlzcGxheSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG9wdHMudmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJ2aXNpYmlsaXR5XCIsIG9wdHMudmlzaWJpbGl0eSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQncyBxdWV1ZSBpcyBlbXB0eSAoaWYgb25seSB0aGUgXCJpbnByb2dyZXNzXCIgaXRlbSBpcyBsZWZ0IGF0IHBvc2l0aW9uIDApIG9yIGlmIGl0cyBxdWV1ZSBpcyBhYm91dCB0byBydW5cblx0XHRcdFx0IGEgbm9uLVZlbG9jaXR5LWluaXRpYXRlZCBlbnRyeSwgdHVybiBvZmYgdGhlIGlzQW5pbWF0aW5nIGZsYWcuIEEgbm9uLVZlbG9jaXR5LWluaXRpYXRpZWQgcXVldWUgZW50cnkncyBsb2dpYyBtaWdodCBhbHRlclxuXHRcdFx0XHQgYW4gZWxlbWVudCdzIENTUyB2YWx1ZXMgYW5kIHRoZXJlYnkgY2F1c2UgVmVsb2NpdHkncyBjYWNoZWQgdmFsdWUgZGF0YSB0byBnbyBzdGFsZS4gVG8gZGV0ZWN0IGlmIGEgcXVldWUgZW50cnkgd2FzIGluaXRpYXRlZCBieSBWZWxvY2l0eSxcblx0XHRcdFx0IHdlIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIG91ciBzcGVjaWFsIFZlbG9jaXR5LnF1ZXVlRW50cnlGbGFnIGRlY2xhcmF0aW9uLCB3aGljaCBtaW5pZmllcnMgd29uJ3QgcmVuYW1lIHNpbmNlIHRoZSBmbGFnXG5cdFx0XHRcdCBpcyBhc3NpZ25lZCB0byBqUXVlcnkncyBnbG9iYWwgJCBvYmplY3QgYW5kIHRodXMgZXhpc3RzIG91dCBvZiBWZWxvY2l0eSdzIG93biBzY29wZS4gKi9cblx0XHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXG5cdFx0XHRcdGlmIChvcHRzLmxvb3AgIT09IHRydWUgJiYgKCQucXVldWUoZWxlbWVudClbMV0gPT09IHVuZGVmaW5lZCB8fCAhL1xcLnZlbG9jaXR5UXVldWVFbnRyeUZsYWcvaS50ZXN0KCQucXVldWUoZWxlbWVudClbMV0pKSkge1xuXHRcdFx0XHRcdC8qIFRoZSBlbGVtZW50IG1heSBoYXZlIGJlZW4gZGVsZXRlZC4gRW5zdXJlIHRoYXQgaXRzIGRhdGEgY2FjaGUgc3RpbGwgZXhpc3RzIGJlZm9yZSBhY3Rpbmcgb24gaXQuICovXG5cdFx0XHRcdFx0aWYgKGRhdGEpIHtcblx0XHRcdFx0XHRcdGRhdGEuaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdC8qIENsZWFyIHRoZSBlbGVtZW50J3Mgcm9vdFByb3BlcnR5VmFsdWVDYWNoZSwgd2hpY2ggd2lsbCBiZWNvbWUgc3RhbGUuICovXG5cdFx0XHRcdFx0XHRkYXRhLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGUgPSB7fTtcblxuXHRcdFx0XHRcdFx0dmFyIHRyYW5zZm9ybUhBUHJvcGVydHlFeGlzdHMgPSBmYWxzZTtcblx0XHRcdFx0XHRcdC8qIElmIGFueSAzRCB0cmFuc2Zvcm0gc3VicHJvcGVydHkgaXMgYXQgaXRzIGRlZmF1bHQgdmFsdWUgKHJlZ2FyZGxlc3Mgb2YgdW5pdCB0eXBlKSwgcmVtb3ZlIGl0LiAqL1xuXHRcdFx0XHRcdFx0JC5lYWNoKENTUy5MaXN0cy50cmFuc2Zvcm1zM0QsIGZ1bmN0aW9uKGksIHRyYW5zZm9ybU5hbWUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRlZmF1bHRWYWx1ZSA9IC9ec2NhbGUvLnRlc3QodHJhbnNmb3JtTmFtZSkgPyAxIDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGRhdGEudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV07XG5cblx0XHRcdFx0XHRcdFx0aWYgKGRhdGEudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV0gIT09IHVuZGVmaW5lZCAmJiBuZXcgUmVnRXhwKFwiXlxcXFwoXCIgKyBkZWZhdWx0VmFsdWUgKyBcIlteLl1cIikudGVzdChjdXJyZW50VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtSEFQcm9wZXJ0eUV4aXN0cyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgZGF0YS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdC8qIE1vYmlsZSBkZXZpY2VzIGhhdmUgaGFyZHdhcmUgYWNjZWxlcmF0aW9uIHJlbW92ZWQgYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uIGluIG9yZGVyIHRvIGF2b2lkIGhvZ2dpbmcgdGhlIEdQVSdzIG1lbW9yeS4gKi9cblx0XHRcdFx0XHRcdGlmIChvcHRzLm1vYmlsZUhBKSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybUhBUHJvcGVydHlFeGlzdHMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgZGF0YS50cmFuc2Zvcm1DYWNoZS50cmFuc2xhdGUzZDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogRmx1c2ggdGhlIHN1YnByb3BlcnR5IHJlbW92YWxzIHRvIHRoZSBET00uICovXG5cdFx0XHRcdFx0XHRpZiAodHJhbnNmb3JtSEFQcm9wZXJ0eUV4aXN0cykge1xuXHRcdFx0XHRcdFx0XHRDU1MuZmx1c2hUcmFuc2Zvcm1DYWNoZShlbGVtZW50KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogUmVtb3ZlIHRoZSBcInZlbG9jaXR5LWFuaW1hdGluZ1wiIGluZGljYXRvciBjbGFzcy4gKi9cblx0XHRcdFx0XHRcdENTUy5WYWx1ZXMucmVtb3ZlQ2xhc3MoZWxlbWVudCwgXCJ2ZWxvY2l0eS1hbmltYXRpbmdcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgT3B0aW9uOiBDb21wbGV0ZVxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qIENvbXBsZXRlIGlzIGZpcmVkIG9uY2UgcGVyIGNhbGwgKG5vdCBvbmNlIHBlciBlbGVtZW50KSBhbmQgaXMgcGFzc2VkIHRoZSBmdWxsIHJhdyBET00gZWxlbWVudCBzZXQgYXMgYm90aCBpdHMgY29udGV4dCBhbmQgaXRzIGZpcnN0IGFyZ3VtZW50LiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBDYWxsYmFja3MgYXJlbid0IGZpcmVkIHdoZW4gY2FsbHMgYXJlIG1hbnVhbGx5IHN0b3BwZWQgKHZpYSBWZWxvY2l0eShcInN0b3BcIikuICovXG5cdFx0XHRcdGlmICghaXNTdG9wcGVkICYmIG9wdHMuY29tcGxldGUgJiYgIW9wdHMubG9vcCAmJiAoaSA9PT0gY2FsbExlbmd0aCAtIDEpKSB7XG5cdFx0XHRcdFx0LyogV2UgdGhyb3cgY2FsbGJhY2tzIGluIGEgc2V0VGltZW91dCBzbyB0aGF0IHRocm93biBlcnJvcnMgZG9uJ3QgaGFsdCB0aGUgZXhlY3V0aW9uIG9mIFZlbG9jaXR5IGl0c2VsZi4gKi9cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0b3B0cy5jb21wbGV0ZS5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cyk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XHRcdFx0fSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IFByb21pc2UgUmVzb2x2aW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qIE5vdGU6IEluZmluaXRlIGxvb3BzIGRvbid0IHJldHVybiBwcm9taXNlcy4gKi9cblx0XHRcdFx0aWYgKHJlc29sdmVyICYmIG9wdHMubG9vcCAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHJlc29sdmVyKGVsZW1lbnRzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBPcHRpb246IExvb3AgKEluZmluaXRlKVxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRpZiAoZGF0YSAmJiBvcHRzLmxvb3AgPT09IHRydWUgJiYgIWlzU3RvcHBlZCkge1xuXHRcdFx0XHRcdC8qIElmIGEgcm90YXRlWC9ZL1ogcHJvcGVydHkgaXMgYmVpbmcgYW5pbWF0ZWQgYnkgMzYwIGRlZyB3aXRoIGxvb3A6dHJ1ZSwgc3dhcCB0d2VlbiBzdGFydC9lbmQgdmFsdWVzIHRvIGVuYWJsZVxuXHRcdFx0XHRcdCBjb250aW51b3VzIGl0ZXJhdGl2ZSByb3RhdGlvbiBsb29waW5nLiAoT3RoZXJpc2UsIHRoZSBlbGVtZW50IHdvdWxkIGp1c3Qgcm90YXRlIGJhY2sgYW5kIGZvcnRoLikgKi9cblx0XHRcdFx0XHQkLmVhY2goZGF0YS50d2VlbnNDb250YWluZXIsIGZ1bmN0aW9uKHByb3BlcnR5TmFtZSwgdHdlZW5Db250YWluZXIpIHtcblx0XHRcdFx0XHRcdGlmICgvXnJvdGF0ZS8udGVzdChwcm9wZXJ0eU5hbWUpICYmICgocGFyc2VGbG9hdCh0d2VlbkNvbnRhaW5lci5zdGFydFZhbHVlKSAtIHBhcnNlRmxvYXQodHdlZW5Db250YWluZXIuZW5kVmFsdWUpKSAlIDM2MCA9PT0gMCkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG9sZFN0YXJ0VmFsdWUgPSB0d2VlbkNvbnRhaW5lci5zdGFydFZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdHR3ZWVuQ29udGFpbmVyLnN0YXJ0VmFsdWUgPSB0d2VlbkNvbnRhaW5lci5lbmRWYWx1ZTtcblx0XHRcdFx0XHRcdFx0dHdlZW5Db250YWluZXIuZW5kVmFsdWUgPSBvbGRTdGFydFZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoL15iYWNrZ3JvdW5kUG9zaXRpb24vLnRlc3QocHJvcGVydHlOYW1lKSAmJiBwYXJzZUZsb2F0KHR3ZWVuQ29udGFpbmVyLmVuZFZhbHVlKSA9PT0gMTAwICYmIHR3ZWVuQ29udGFpbmVyLnVuaXRUeXBlID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0XHR0d2VlbkNvbnRhaW5lci5lbmRWYWx1ZSA9IDA7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuQ29udGFpbmVyLnN0YXJ0VmFsdWUgPSAxMDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRWZWxvY2l0eShlbGVtZW50LCBcInJldmVyc2VcIiwge2xvb3A6IHRydWUsIGRlbGF5OiBvcHRzLmRlbGF5fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBEZXF1ZXVlaW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogRmlyZSB0aGUgbmV4dCBjYWxsIGluIHRoZSBxdWV1ZSBzbyBsb25nIGFzIHRoaXMgY2FsbCdzIHF1ZXVlIHdhc24ndCBzZXQgdG8gZmFsc2UgKHRvIHRyaWdnZXIgYSBwYXJhbGxlbCBhbmltYXRpb24pLFxuXHRcdFx0XHQgd2hpY2ggd291bGQgaGF2ZSBhbHJlYWR5IGNhdXNlZCB0aGUgbmV4dCBjYWxsIHRvIGZpcmUuIE5vdGU6IEV2ZW4gaWYgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uIHF1ZXVlIGhhcyBiZWVuIHJlYWNoZWQsXG5cdFx0XHRcdCAkLmRlcXVldWUoKSBtdXN0IHN0aWxsIGJlIGNhbGxlZCBpbiBvcmRlciB0byBjb21wbGV0ZWx5IGNsZWFyIGpRdWVyeSdzIGFuaW1hdGlvbiBxdWV1ZS4gKi9cblx0XHRcdFx0aWYgKG9wdHMucXVldWUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0JC5kZXF1ZXVlKGVsZW1lbnQsIG9wdHMucXVldWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdCBDYWxscyBBcnJheSBDbGVhbnVwXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBTaW5jZSB0aGlzIGNhbGwgaXMgY29tcGxldGUsIHNldCBpdCB0byBmYWxzZSBzbyB0aGF0IHRoZSByQUYgdGljayBza2lwcyBpdC4gVGhpcyBhcnJheSBpcyBsYXRlciBjb21wYWN0ZWQgdmlhIGNvbXBhY3RTcGFyc2VBcnJheSgpLlxuXHRcdFx0IChGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgdGhlIGNhbGwgaXMgc2V0IHRvIGZhbHNlIGluc3RlYWQgb2YgYmVpbmcgZGVsZXRlZCBmcm9tIHRoZSBhcnJheTogaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvc3BlZWQvdjgvKSAqL1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHNbY2FsbEluZGV4XSA9IGZhbHNlO1xuXG5cdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGNhbGxzIGFycmF5IHRvIGRldGVybWluZSBpZiB0aGlzIHdhcyB0aGUgZmluYWwgaW4tcHJvZ3Jlc3MgYW5pbWF0aW9uLlxuXHRcdFx0IElmIHNvLCBzZXQgYSBmbGFnIHRvIGVuZCB0aWNraW5nIGFuZCBjbGVhciB0aGUgY2FsbHMgYXJyYXkuICovXG5cdFx0XHRmb3IgKHZhciBqID0gMCwgY2FsbHNMZW5ndGggPSBWZWxvY2l0eS5TdGF0ZS5jYWxscy5sZW5ndGg7IGogPCBjYWxsc0xlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmIChWZWxvY2l0eS5TdGF0ZS5jYWxsc1tqXSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZW1haW5pbmdDYWxsc0V4aXN0ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZW1haW5pbmdDYWxsc0V4aXN0ID09PSBmYWxzZSkge1xuXHRcdFx0XHQvKiB0aWNrKCkgd2lsbCBkZXRlY3QgdGhpcyBmbGFnIHVwb24gaXRzIG5leHQgaXRlcmF0aW9uIGFuZCBzdWJzZXF1ZW50bHkgdHVybiBpdHNlbGYgb2ZmLiAqL1xuXHRcdFx0XHRWZWxvY2l0eS5TdGF0ZS5pc1RpY2tpbmcgPSBmYWxzZTtcblxuXHRcdFx0XHQvKiBDbGVhciB0aGUgY2FsbHMgYXJyYXkgc28gdGhhdCBpdHMgbGVuZ3RoIGlzIHJlc2V0LiAqL1xuXHRcdFx0XHRkZWxldGUgVmVsb2NpdHkuU3RhdGUuY2FsbHM7XG5cdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmNhbGxzID0gW107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqKioqKioqKioqKioqKioqKlxuXHRcdCBGcmFtZXdvcmtzXG5cdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdC8qIEJvdGggalF1ZXJ5IGFuZCBaZXB0byBhbGxvdyB0aGVpciAkLmZuIG9iamVjdCB0byBiZSBleHRlbmRlZCB0byBhbGxvdyB3cmFwcGVkIGVsZW1lbnRzIHRvIGJlIHN1YmplY3RlZCB0byBwbHVnaW4gY2FsbHMuXG5cdFx0IElmIGVpdGhlciBmcmFtZXdvcmsgaXMgbG9hZGVkLCByZWdpc3RlciBhIFwidmVsb2NpdHlcIiBleHRlbnNpb24gcG9pbnRpbmcgdG8gVmVsb2NpdHkncyBjb3JlIGFuaW1hdGUoKSBtZXRob2QuICBWZWxvY2l0eVxuXHRcdCBhbHNvIHJlZ2lzdGVycyBpdHNlbGYgb250byBhIGdsb2JhbCBjb250YWluZXIgKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvIHx8IHdpbmRvdykgc28gdGhhdCBjZXJ0YWluIGZlYXR1cmVzIGFyZVxuXHRcdCBhY2Nlc3NpYmxlIGJleW9uZCBqdXN0IGEgcGVyLWVsZW1lbnQgc2NvcGUuIFRoaXMgbWFzdGVyIG9iamVjdCBjb250YWlucyBhbiAuYW5pbWF0ZSgpIG1ldGhvZCwgd2hpY2ggaXMgbGF0ZXIgYXNzaWduZWQgdG8gJC5mblxuXHRcdCAoaWYgalF1ZXJ5IG9yIFplcHRvIGFyZSBwcmVzZW50KS4gQWNjb3JkaW5nbHksIFZlbG9jaXR5IGNhbiBib3RoIGFjdCBvbiB3cmFwcGVkIERPTSBlbGVtZW50cyBhbmQgc3RhbmQgYWxvbmUgZm9yIHRhcmdldGluZyByYXcgRE9NIGVsZW1lbnRzLiAqL1xuXHRcdGdsb2JhbC5WZWxvY2l0eSA9IFZlbG9jaXR5O1xuXG5cdFx0aWYgKGdsb2JhbCAhPT0gd2luZG93KSB7XG5cdFx0XHQvKiBBc3NpZ24gdGhlIGVsZW1lbnQgZnVuY3Rpb24gdG8gVmVsb2NpdHkncyBjb3JlIGFuaW1hdGUoKSBtZXRob2QuICovXG5cdFx0XHRnbG9iYWwuZm4udmVsb2NpdHkgPSBhbmltYXRlO1xuXHRcdFx0LyogQXNzaWduIHRoZSBvYmplY3QgZnVuY3Rpb24ncyBkZWZhdWx0cyB0byBWZWxvY2l0eSdzIGdsb2JhbCBkZWZhdWx0cyBvYmplY3QuICovXG5cdFx0XHRnbG9iYWwuZm4udmVsb2NpdHkuZGVmYXVsdHMgPSBWZWxvY2l0eS5kZWZhdWx0cztcblx0XHR9XG5cblx0XHQvKioqKioqKioqKioqKioqKioqKioqKipcblx0XHQgUGFja2FnZWQgUmVkaXJlY3RzXG5cdFx0ICoqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0Lyogc2xpZGVVcCwgc2xpZGVEb3duICovXG5cdFx0JC5lYWNoKFtcIkRvd25cIiwgXCJVcFwiXSwgZnVuY3Rpb24oaSwgZGlyZWN0aW9uKSB7XG5cdFx0XHRWZWxvY2l0eS5SZWRpcmVjdHNbXCJzbGlkZVwiICsgZGlyZWN0aW9uXSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGVsZW1lbnRzSW5kZXgsIGVsZW1lbnRzU2l6ZSwgZWxlbWVudHMsIHByb21pc2VEYXRhKSB7XG5cdFx0XHRcdHZhciBvcHRzID0gJC5leHRlbmQoe30sIG9wdGlvbnMpLFxuXHRcdFx0XHRcdFx0YmVnaW4gPSBvcHRzLmJlZ2luLFxuXHRcdFx0XHRcdFx0Y29tcGxldGUgPSBvcHRzLmNvbXBsZXRlLFxuXHRcdFx0XHRcdFx0aW5saW5lVmFsdWVzID0ge30sXG5cdFx0XHRcdFx0XHRjb21wdXRlZFZhbHVlcyA9IHtoZWlnaHQ6IFwiXCIsIG1hcmdpblRvcDogXCJcIiwgbWFyZ2luQm90dG9tOiBcIlwiLCBwYWRkaW5nVG9wOiBcIlwiLCBwYWRkaW5nQm90dG9tOiBcIlwifTtcblxuXHRcdFx0XHRpZiAob3B0cy5kaXNwbGF5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvKiBTaG93IHRoZSBlbGVtZW50IGJlZm9yZSBzbGlkZURvd24gYmVnaW5zIGFuZCBoaWRlIHRoZSBlbGVtZW50IGFmdGVyIHNsaWRlVXAgY29tcGxldGVzLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IElubGluZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSBkaW1lbnNpb25zIGFuaW1hdGVkLCBzbyB0aGV5J3JlIHJldmVydGVkIHRvIGlubGluZS1ibG9jay4gKi9cblx0XHRcdFx0XHRvcHRzLmRpc3BsYXkgPSAoZGlyZWN0aW9uID09PSBcIkRvd25cIiA/IChWZWxvY2l0eS5DU1MuVmFsdWVzLmdldERpc3BsYXlUeXBlKGVsZW1lbnQpID09PSBcImlubGluZVwiID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwiYmxvY2tcIikgOiBcIm5vbmVcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvcHRzLmJlZ2luID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0LyogSWYgdGhlIHVzZXIgcGFzc2VkIGluIGEgYmVnaW4gY2FsbGJhY2ssIGZpcmUgaXQgbm93LiAqL1xuXHRcdFx0XHRcdGlmIChlbGVtZW50c0luZGV4ID09PSAwICYmIGJlZ2luKSB7XG5cdFx0XHRcdFx0XHRiZWdpbi5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogQ2FjaGUgdGhlIGVsZW1lbnRzJyBvcmlnaW5hbCB2ZXJ0aWNhbCBkaW1lbnNpb25hbCBwcm9wZXJ0eSB2YWx1ZXMgc28gdGhhdCB3ZSBjYW4gYW5pbWF0ZSBiYWNrIHRvIHRoZW0uICovXG5cdFx0XHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gY29tcHV0ZWRWYWx1ZXMpIHtcblx0XHRcdFx0XHRcdGlmICghY29tcHV0ZWRWYWx1ZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW5saW5lVmFsdWVzW3Byb3BlcnR5XSA9IGVsZW1lbnQuc3R5bGVbcHJvcGVydHldO1xuXG5cdFx0XHRcdFx0XHQvKiBGb3Igc2xpZGVEb3duLCB1c2UgZm9yY2VmZWVkaW5nIHRvIGFuaW1hdGUgYWxsIHZlcnRpY2FsIHByb3BlcnRpZXMgZnJvbSAwLiBGb3Igc2xpZGVVcCxcblx0XHRcdFx0XHRcdCB1c2UgZm9yY2VmZWVkaW5nIHRvIHN0YXJ0IGZyb20gY29tcHV0ZWQgdmFsdWVzIGFuZCBhbmltYXRlIGRvd24gdG8gMC4gKi9cblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eVZhbHVlID0gQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHkpO1xuXHRcdFx0XHRcdFx0Y29tcHV0ZWRWYWx1ZXNbcHJvcGVydHldID0gKGRpcmVjdGlvbiA9PT0gXCJEb3duXCIpID8gW3Byb3BlcnR5VmFsdWUsIDBdIDogWzAsIHByb3BlcnR5VmFsdWVdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIEZvcmNlIHZlcnRpY2FsIG92ZXJmbG93IGNvbnRlbnQgdG8gY2xpcCBzbyB0aGF0IHNsaWRpbmcgd29ya3MgYXMgZXhwZWN0ZWQuICovXG5cdFx0XHRcdFx0aW5saW5lVmFsdWVzLm92ZXJmbG93ID0gZWxlbWVudC5zdHlsZS5vdmVyZmxvdztcblx0XHRcdFx0XHRlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRvcHRzLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0LyogUmVzZXQgZWxlbWVudCB0byBpdHMgcHJlLXNsaWRlIGlubGluZSB2YWx1ZXMgb25jZSBpdHMgc2xpZGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLiAqL1xuXHRcdFx0XHRcdGZvciAodmFyIHByb3BlcnR5IGluIGlubGluZVZhbHVlcykge1xuXHRcdFx0XHRcdFx0aWYgKGlubGluZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBpbmxpbmVWYWx1ZXNbcHJvcGVydHldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIElmIHRoZSB1c2VyIHBhc3NlZCBpbiBhIGNvbXBsZXRlIGNhbGxiYWNrLCBmaXJlIGl0IG5vdy4gKi9cblx0XHRcdFx0XHRpZiAoZWxlbWVudHNJbmRleCA9PT0gZWxlbWVudHNTaXplIC0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChwcm9taXNlRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZXNvbHZlcihlbGVtZW50cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdFZlbG9jaXR5KGVsZW1lbnQsIGNvbXB1dGVkVmFsdWVzLCBvcHRzKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHQvKiBmYWRlSW4sIGZhZGVPdXQgKi9cblx0XHQkLmVhY2goW1wiSW5cIiwgXCJPdXRcIl0sIGZ1bmN0aW9uKGksIGRpcmVjdGlvbikge1xuXHRcdFx0VmVsb2NpdHkuUmVkaXJlY3RzW1wiZmFkZVwiICsgZGlyZWN0aW9uXSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGVsZW1lbnRzSW5kZXgsIGVsZW1lbnRzU2l6ZSwgZWxlbWVudHMsIHByb21pc2VEYXRhKSB7XG5cdFx0XHRcdHZhciBvcHRzID0gJC5leHRlbmQoe30sIG9wdGlvbnMpLFxuXHRcdFx0XHRcdFx0Y29tcGxldGUgPSBvcHRzLmNvbXBsZXRlLFxuXHRcdFx0XHRcdFx0cHJvcGVydGllc01hcCA9IHtvcGFjaXR5OiAoZGlyZWN0aW9uID09PSBcIkluXCIpID8gMSA6IDB9O1xuXG5cdFx0XHRcdC8qIFNpbmNlIHJlZGlyZWN0cyBhcmUgdHJpZ2dlcmVkIGluZGl2aWR1YWxseSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhbmltYXRlZCBzZXQsIGF2b2lkIHJlcGVhdGVkbHkgdHJpZ2dlcmluZ1xuXHRcdFx0XHQgY2FsbGJhY2tzIGJ5IGZpcmluZyB0aGVtIG9ubHkgd2hlbiB0aGUgZmluYWwgZWxlbWVudCBoYXMgYmVlbiByZWFjaGVkLiAqL1xuXHRcdFx0XHRpZiAoZWxlbWVudHNJbmRleCAhPT0gMCkge1xuXHRcdFx0XHRcdG9wdHMuYmVnaW4gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbGVtZW50c0luZGV4ICE9PSBlbGVtZW50c1NpemUgLSAxKSB7XG5cdFx0XHRcdFx0b3B0cy5jb21wbGV0ZSA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3B0cy5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChwcm9taXNlRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZXNvbHZlcihlbGVtZW50cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIElmIGEgZGlzcGxheSB3YXMgcGFzc2VkIGluLCB1c2UgaXQuIE90aGVyd2lzZSwgZGVmYXVsdCB0byBcIm5vbmVcIiBmb3IgZmFkZU91dCBvciB0aGUgZWxlbWVudC1zcGVjaWZpYyBkZWZhdWx0IGZvciBmYWRlSW4uICovXG5cdFx0XHRcdC8qIE5vdGU6IFdlIGFsbG93IHVzZXJzIHRvIHBhc3MgaW4gXCJudWxsXCIgdG8gc2tpcCBkaXNwbGF5IHNldHRpbmcgYWx0b2dldGhlci4gKi9cblx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0b3B0cy5kaXNwbGF5ID0gKGRpcmVjdGlvbiA9PT0gXCJJblwiID8gXCJhdXRvXCIgOiBcIm5vbmVcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRWZWxvY2l0eSh0aGlzLCBwcm9wZXJ0aWVzTWFwLCBvcHRzKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gVmVsb2NpdHk7XG5cdH0oKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvIHx8IHdpbmRvdyksIHdpbmRvdywgKHdpbmRvdyA/IHdpbmRvdy5kb2N1bWVudCA6IHVuZGVmaW5lZCkpO1xufSkpO1xuXG4vKioqKioqKioqKioqKioqKioqXG4gS25vd24gSXNzdWVzXG4gKioqKioqKioqKioqKioqKioqL1xuXG4vKiBUaGUgQ1NTIHNwZWMgbWFuZGF0ZXMgdGhhdCB0aGUgdHJhbnNsYXRlWC9ZL1ogdHJhbnNmb3JtcyBhcmUgJS1yZWxhdGl2ZSB0byB0aGUgZWxlbWVudCBpdHNlbGYgLS0gbm90IGl0cyBwYXJlbnQuXG4gVmVsb2NpdHksIGhvd2V2ZXIsIGRvZXNuJ3QgbWFrZSB0aGlzIGRpc3RpbmN0aW9uLiBUaHVzLCBjb252ZXJ0aW5nIHRvIG9yIGZyb20gdGhlICUgdW5pdCB3aXRoIHRoZXNlIHN1YnByb3BlcnRpZXNcbiB3aWxsIHByb2R1Y2UgYW4gaW5hY2N1cmF0ZSBjb252ZXJzaW9uIHZhbHVlLiBUaGUgc2FtZSBpc3N1ZSBleGlzdHMgd2l0aCB0aGUgY3gvY3kgYXR0cmlidXRlcyBvZiBTVkcgY2lyY2xlcyBhbmQgZWxsaXBzZXMuICovXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92ZWxvY2l0eS1hbmltYXRlL3ZlbG9jaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qXG4gKiBkZWJvdW5jZWRyZXNpemU6IHNwZWNpYWwgalF1ZXJ5IGV2ZW50IHRoYXQgaGFwcGVucyBvbmNlIGFmdGVyIGEgd2luZG93IHJlc2l6ZVxuICpcbiAqIGxhdGVzdCB2ZXJzaW9uIGFuZCBjb21wbGV0ZSBSRUFETUUgYXZhaWxhYmxlIG9uIEdpdGh1YjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9sb3Vpc3JlbWkvanF1ZXJ5LXNtYXJ0cmVzaXplXG4gKlxuICogQ29weXJpZ2h0IDIwMTIgQGxvdWlzX3JlbWlcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKiBUaGlzIHNhdmVkIHlvdSBhbiBob3VyIG9mIHdvcms/IFxuICogU2VuZCBtZSBtdXNpYyBodHRwOi8vd3d3LmFtYXpvbi5jby51ay93aXNobGlzdC9ITlRVMDQ2OExRT05cbiAqL1xuKGZ1bmN0aW9uKCQpIHtcblxudmFyICRldmVudCA9ICQuZXZlbnQsXG4gICAgJHNwZWNpYWwsXG4gICAgcmVzaXplVGltZW91dDtcblxuJHNwZWNpYWwgPSAkZXZlbnQuc3BlY2lhbC5kZWJvdW5jZWRyZXNpemUgPSB7XG4gICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkKCB0aGlzICkub24oIFwicmVzaXplXCIsICRzcGVjaWFsLmhhbmRsZXIgKTtcbiAgICB9LFxuICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJCggdGhpcyApLm9mZiggXCJyZXNpemVcIiwgJHNwZWNpYWwuaGFuZGxlciApO1xuICAgIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50LCBleGVjQXNhcCApIHtcbiAgICAgICAgLy8gU2F2ZSB0aGUgY29udGV4dFxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgZGlzcGF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgY29ycmVjdCBldmVudCB0eXBlXG4gICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IFwiZGVib3VuY2VkcmVzaXplXCI7XG4gICAgICAgICAgICAgICAgJGV2ZW50LmRpc3BhdGNoLmFwcGx5KCBjb250ZXh0LCBhcmdzICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICggcmVzaXplVGltZW91dCApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCggcmVzaXplVGltZW91dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhlY0FzYXAgP1xuICAgICAgICAgICAgZGlzcGF0Y2goKSA6XG4gICAgICAgICAgICByZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCggZGlzcGF0Y2gsICRzcGVjaWFsLnRocmVzaG9sZCApO1xuICAgIH0sXG4gICAgdGhyZXNob2xkOiAxNTBcbn07XG5cbn0pKGpRdWVyeSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92ZW5kb3IvanF1ZXJ5LmRlYm91bmNlZHJlc2l6ZS5qcyIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VuaWNvZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1VuaWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qXG4gKiBidWlsZElucHV0cyBtZXRob2QgdXNlcyBpbnB1dCBmb3VuZCBpblxuICogcmVzb3VyY2VzID4gdmlld3MgPiBmb3JtcyA+IGNvbXBvbmVudHMgPiBzdGFuZGFyZC1pbnB1dC5ibGFkZVxuICovXG5cbmltcG9ydCBzZWxlY3RDb21wb25lbnQgZnJvbSAndXRpbGl0aWVzL3NlbGVjdC1jb21wb25lbnQnXG5pbXBvcnQgYXV0b3NpemUgZnJvbSAnYXV0b3NpemUnXG5cbmNvbnN0IGJhc2VDbGFzcyA9ICdpbnB1dCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tSW5wdXQge1xuICAgIFxuICAgIGFjdGl2ZUNsYXNzID0gYmFzZUNsYXNzICsgJy0taXMtYWN0aXZlJ1xuICAgIGZpbGxlZENsYXNzID0gYmFzZUNsYXNzICsgJy0taXMtZmlsbGVkJ1xuICAgIGRpc2FibGVkQ2xhc3MgPSBiYXNlQ2xhc3MgKyAnLS1pcy1kaXNhYmxlZCdcbiAgICBlcnJvckNsYXNzID0gYmFzZUNsYXNzICsgJy0taGFzLWVycm9yJ1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuJGNvbXBvbmVudCA9IHNlbGVjdENvbXBvbmVudChlbGVtZW50KVxuICAgICAgICB0aGlzLiRmaWVsZCA9IHRoaXMuJGNvbXBvbmVudC5lbGVtZW50cy5maWVsZFxuXG5cbiAgICAgICAgdGhpcy5hdHRhY2hFdmVudHMob3B0aW9ucylcbiAgICAgICAgdGhpcy5oYW5kbGVJbnB1dEZpbGwoKVxuICAgICAgICBcbiAgICAgICAgaWYgKCF0aGlzLiRjb21wb25lbnQuZWxlbWVudHMuZXJyb3JMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVFcnJvckxhYmVsKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGF0dGFjaEV2ZW50cyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSB0aGlzLiRmaWVsZFswXS50YWdOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgICAgICBpZiAodGhpcy4kZmllbGQuYXR0cigndHlwZScpID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbXBvbmVudC5vbignY2hhbmdlJywgdGhpcy5oYW5kbGVGaWxlQ2hhbmdlKVxuXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0geyAuLi5vcHRpb25zIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuJGNvbXBvbmVudC5hdHRyKCdkYXRhLWFjdGlvbicpID09ICdmaWx0ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29tcG9uZW50Lm9uKCdjaGFuZ2UnLCB0aGlzLmhhbmRsZUZpbHRlckV2ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgICAgIGF1dG9zaXplKHRoaXMuJGZpZWxkWzBdKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kZmllbGQub24oJ2ZvY3VzIGJsdXInLCB0aGlzLmhhbmRsZUlucHV0RmlsbClcbiAgICB9XG5cbiAgICBjcmVhdGVFcnJvckxhYmVsKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGNvbXBvbmVudC5lbGVtZW50cy5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy4kY29tcG9uZW50LnByZXBlbmQoXG4gICAgICAgICAgICAgICAgJCgnPGxhYmVsIC8+Jywge1xuICAgICAgICAgICAgICAgICAgICAnZm9yJzogdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLmZpZWxkLmF0dHIoJ25hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2lucHV0X19lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICdkYXRhLWVsZW1lbnQnOiAnZXJyb3InXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgdGhpcy4kY29tcG9uZW50LnJlZnJlc2goKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy4kY29tcG9uZW50LmFkZENsYXNzKHRoaXMuZGlzYWJsZWRDbGFzcylcbiAgICAgICAgdGhpcy4kZmllbGQuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKVxuICAgIH1cblxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy4kY29tcG9uZW50LnJlbW92ZUNsYXNzKHRoaXMuZGlzYWJsZWRDbGFzcylcbiAgICAgICAgdGhpcy4kZmllbGQucmVtb3ZlQXR0cignZGlzYWJsZWQnKVxuICAgIH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLiRjb21wb25lbnQuZWxlbWVudHMuZmllbGQuZm9jdXMoKVxuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLiRjb21wb25lbnQuZWxlbWVudHMuZmllbGQudmFsKCcnKVxuICAgIH1cblxuICAgIHNldEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy4kY29tcG9uZW50LmFkZENsYXNzKHRoaXMuZXJyb3JDbGFzcylcbiAgICAgICAgdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLmVycm9yXG4gICAgICAgICAgICAuaHRtbChtZXNzYWdlKVxuICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuYWN0aXZlQ2xhc3MpXG4gICAgfVxuXG4gICAgcmVtb3ZlRXJyb3IoKSB7XG4gICAgICAgIHRoaXMuJGNvbXBvbmVudC5yZW1vdmVDbGFzcyh0aGlzLmVycm9yQ2xhc3MpXG4gICAgICAgIHRoaXMuJGNvbXBvbmVudC5lbGVtZW50cy5lcnJvclxuICAgICAgICAgICAgLmh0bWwoJycpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhpcy5hY3RpdmVDbGFzcylcbiAgICB9XG5cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLmZpZWxkLmF0dHIoJ25hbWUnKVxuICAgIH1cblxuICAgIGhhbmRsZUZpbGVDaGFuZ2UgPSBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzXG4gICAgICAgICAgICAuZmllbGRbMF1cbiAgICAgICAgICAgIC5maWxlc1swXVxuICAgICAgICAgICAgLm5hbWVcblxuICAgICAgICB0aGlzLiRjb21wb25lbnQuZWxlbWVudHNcbiAgICAgICAgICAgIC5sYWJlbFxuICAgICAgICAgICAgLnRleHQoZmlsZU5hbWUpXG4gICAgfTtcblxuICAgIGhhbmRsZUZpbHRlckV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuJGNvbXBvbmVudC5maW5kKCdvcHRpb246c2VsZWN0ZWQnKS52YWwoKVxuXG4gICAgICAgIGlmICh1cmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaGFuZGxlSW5wdXRGaWxsID0gZXZlbnQgPT4ge1xuICAgICAgICBpZiAodGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLmZpZWxkLnZhbCgpKSB7XG4gICAgICAgICAgICB0aGlzLiRjb21wb25lbnQuYWRkQ2xhc3ModGhpcy5maWxsZWRDbGFzcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbXBvbmVudC5yZW1vdmVDbGFzcyh0aGlzLmZpbGxlZENsYXNzKVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudC9jdXN0b20taW5wdXQuanMiLCJjb25zdCBERUZBVUxUID0ge1xuICAgIG5hbWU6ICdVbm5hbWVkIE1vZHVsZScsXG4gICAgZWw6ICdib2R5Jyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIGV4aXN0czogZmFsc2UsXG5cbiAgICBjb25zdHJ1Y3QobW9kdWxlRGVmYXVsdCwgYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhcmdzID0ge1xuICAgICAgICAgICAgICAgIGVsOiBhcmdzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFQsIG1vZHVsZURlZmF1bHQsIGFyZ3MpO1xuXG4gICAgICAgIGlmICgkKHNldHRpbmdzLmVsKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9LFxuXG4gICAgc3RhcnQoYXJncykge1xuICAgICAgICBpZiAodGhpcy5leGlzdHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb24oYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVGhlcmUgd2FzIGEgcHJvYmxlbSB3aXRoICR7REVGQVVMVC5uYW1lfS4gOihgKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFjdGlvbigpIHtcbiAgICAgICAgdGhyb3cgJ1RoZSBcXCdhY3Rpb25cXCcgbWV0aG9kIG11c3QgYmUgZGVmaW5lZCBpbiBhIGNvbmNyZXRlIG1vZHVsZSc7XG4gICAgfSxcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnQvYmFzZS5qcyIsIiFmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtcImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1hKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJ2ZWxvY2l0eVwiXSxhKTphKCl9KGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEuVmVsb2NpdHk7aWYoIWV8fCFlLlV0aWxpdGllcylyZXR1cm4gdm9pZChiLmNvbnNvbGUmJmNvbnNvbGUubG9nKFwiVmVsb2NpdHkgVUkgUGFjazogVmVsb2NpdHkgbXVzdCBiZSBsb2FkZWQgZmlyc3QuIEFib3J0aW5nLlwiKSk7dmFyIGY9ZS5VdGlsaXRpZXMsZz1lLnZlcnNpb24saD17bWFqb3I6MSxtaW5vcjoxLHBhdGNoOjB9O2lmKGZ1bmN0aW9uKGEsYil7dmFyIGM9W107cmV0dXJuISghYXx8IWIpJiYoZi5lYWNoKFthLGJdLGZ1bmN0aW9uKGEsYil7dmFyIGQ9W107Zi5lYWNoKGIsZnVuY3Rpb24oYSxiKXtmb3IoO2IudG9TdHJpbmcoKS5sZW5ndGg8NTspYj1cIjBcIitiO2QucHVzaChiKX0pLGMucHVzaChkLmpvaW4oXCJcIikpfSkscGFyc2VGbG9hdChjWzBdKT5wYXJzZUZsb2F0KGNbMV0pKX0oaCxnKSl7dmFyIGk9XCJWZWxvY2l0eSBVSSBQYWNrOiBZb3UgbmVlZCB0byB1cGRhdGUgVmVsb2NpdHkgKHZlbG9jaXR5LmpzKSB0byBhIG5ld2VyIHZlcnNpb24uIFZpc2l0IGh0dHA6Ly9naXRodWIuY29tL2p1bGlhbnNoYXBpcm8vdmVsb2NpdHkuXCI7dGhyb3cgYWxlcnQoaSksbmV3IEVycm9yKGkpfWUuUmVnaXN0ZXJFZmZlY3Q9ZS5SZWdpc3RlclVJPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsYyxkKXt2YXIgZyxoPTA7Zi5lYWNoKGEubm9kZVR5cGU/W2FdOmEsZnVuY3Rpb24oYSxiKXtkJiYoYys9YSpkKSxnPWIucGFyZW50Tm9kZTt2YXIgaT1bXCJoZWlnaHRcIixcInBhZGRpbmdUb3BcIixcInBhZGRpbmdCb3R0b21cIixcIm1hcmdpblRvcFwiLFwibWFyZ2luQm90dG9tXCJdO1wiYm9yZGVyLWJveFwiPT09ZS5DU1MuZ2V0UHJvcGVydHlWYWx1ZShiLFwiYm94U2l6aW5nXCIpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSYmKGk9W1wiaGVpZ2h0XCJdKSxmLmVhY2goaSxmdW5jdGlvbihhLGMpe2grPXBhcnNlRmxvYXQoZS5DU1MuZ2V0UHJvcGVydHlWYWx1ZShiLGMpKX0pfSksZS5hbmltYXRlKGcse2hlaWdodDooXCJJblwiPT09Yj9cIitcIjpcIi1cIikrXCI9XCIraH0se3F1ZXVlOiExLGVhc2luZzpcImVhc2UtaW4tb3V0XCIsZHVyYXRpb246YyooXCJJblwiPT09Yj8uNjoxKX0pfXJldHVybiBlLlJlZGlyZWN0c1thXT1mdW5jdGlvbihkLGcsaCxpLGosayxsKXt2YXIgbT1oPT09aS0xLG49MDtsPWx8fGIubG9vcCxcImZ1bmN0aW9uXCI9PXR5cGVvZiBiLmRlZmF1bHREdXJhdGlvbj9iLmRlZmF1bHREdXJhdGlvbj1iLmRlZmF1bHREdXJhdGlvbi5jYWxsKGosaik6Yi5kZWZhdWx0RHVyYXRpb249cGFyc2VGbG9hdChiLmRlZmF1bHREdXJhdGlvbik7Zm9yKHZhciBvPTA7bzxiLmNhbGxzLmxlbmd0aDtvKyspXCJudW1iZXJcIj09dHlwZW9mKHQ9Yi5jYWxsc1tvXVsxXSkmJihuKz10KTt2YXIgcD1uPj0xPzA6Yi5jYWxscy5sZW5ndGg/KDEtbikvYi5jYWxscy5sZW5ndGg6MTtmb3Iobz0wO288Yi5jYWxscy5sZW5ndGg7bysrKXt2YXIgcT1iLmNhbGxzW29dLHI9cVswXSxzPTFlMyx0PXFbMV0sdT1xWzJdfHx7fSx2PXt9O2lmKHZvaWQgMCE9PWcuZHVyYXRpb24/cz1nLmR1cmF0aW9uOnZvaWQgMCE9PWIuZGVmYXVsdER1cmF0aW9uJiYocz1iLmRlZmF1bHREdXJhdGlvbiksdi5kdXJhdGlvbj1zKihcIm51bWJlclwiPT10eXBlb2YgdD90OnApLHYucXVldWU9Zy5xdWV1ZXx8XCJcIix2LmVhc2luZz11LmVhc2luZ3x8XCJlYXNlXCIsdi5kZWxheT1wYXJzZUZsb2F0KHUuZGVsYXkpfHwwLHYubG9vcD0hYi5sb29wJiZ1Lmxvb3Asdi5fY2FjaGVWYWx1ZXM9dS5fY2FjaGVWYWx1ZXN8fCEwLDA9PT1vKXtpZih2LmRlbGF5Kz1wYXJzZUZsb2F0KGcuZGVsYXkpfHwwLDA9PT1oJiYodi5iZWdpbj1mdW5jdGlvbigpe2cuYmVnaW4mJmcuYmVnaW4uY2FsbChqLGopO3ZhciBiPWEubWF0Y2goLyhJbnxPdXQpJC8pO2ImJlwiSW5cIj09PWJbMF0mJnZvaWQgMCE9PXIub3BhY2l0eSYmZi5lYWNoKGoubm9kZVR5cGU/W2pdOmosZnVuY3Rpb24oYSxiKXtlLkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGIsXCJvcGFjaXR5XCIsMCl9KSxnLmFuaW1hdGVQYXJlbnRIZWlnaHQmJmImJmMoaixiWzBdLHMrdi5kZWxheSxnLnN0YWdnZXIpfSksbnVsbCE9PWcuZGlzcGxheSlpZih2b2lkIDAhPT1nLmRpc3BsYXkmJlwibm9uZVwiIT09Zy5kaXNwbGF5KXYuZGlzcGxheT1nLmRpc3BsYXk7ZWxzZSBpZigvSW4kLy50ZXN0KGEpKXt2YXIgdz1lLkNTUy5WYWx1ZXMuZ2V0RGlzcGxheVR5cGUoZCk7di5kaXNwbGF5PVwiaW5saW5lXCI9PT13P1wiaW5saW5lLWJsb2NrXCI6d31nLnZpc2liaWxpdHkmJlwiaGlkZGVuXCIhPT1nLnZpc2liaWxpdHkmJih2LnZpc2liaWxpdHk9Zy52aXNpYmlsaXR5KX1pZihvPT09Yi5jYWxscy5sZW5ndGgtMSl7dmFyIHg9ZnVuY3Rpb24oKXt2b2lkIDAhPT1nLmRpc3BsYXkmJlwibm9uZVwiIT09Zy5kaXNwbGF5fHwhL091dCQvLnRlc3QoYSl8fGYuZWFjaChqLm5vZGVUeXBlP1tqXTpqLGZ1bmN0aW9uKGEsYil7ZS5DU1Muc2V0UHJvcGVydHlWYWx1ZShiLFwiZGlzcGxheVwiLFwibm9uZVwiKX0pLGcuY29tcGxldGUmJmcuY29tcGxldGUuY2FsbChqLGopLGsmJmsucmVzb2x2ZXIoanx8ZCl9O3YuY29tcGxldGU9ZnVuY3Rpb24oKXtpZihsJiZlLlJlZGlyZWN0c1thXShkLGcsaCxpLGosayxsPT09ITB8fE1hdGgubWF4KDAsbC0xKSksYi5yZXNldCl7Zm9yKHZhciBjIGluIGIucmVzZXQpaWYoYi5yZXNldC5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGY9Yi5yZXNldFtjXTt2b2lkIDAhPT1lLkNTUy5Ib29rcy5yZWdpc3RlcmVkW2NdfHxcInN0cmluZ1wiIT10eXBlb2YgZiYmXCJudW1iZXJcIiE9dHlwZW9mIGZ8fChiLnJlc2V0W2NdPVtiLnJlc2V0W2NdLGIucmVzZXRbY11dKX12YXIgbj17ZHVyYXRpb246MCxxdWV1ZTohMX07bSYmKG4uY29tcGxldGU9eCksZS5hbmltYXRlKGQsYi5yZXNldCxuKX1lbHNlIG0mJngoKX0sXCJoaWRkZW5cIj09PWcudmlzaWJpbGl0eSYmKHYudmlzaWJpbGl0eT1nLnZpc2liaWxpdHkpfWUuYW5pbWF0ZShkLHIsdil9fSxlfSxlLlJlZ2lzdGVyRWZmZWN0LnBhY2thZ2VkRWZmZWN0cz17XCJjYWxsb3V0LmJvdW5jZVwiOntkZWZhdWx0RHVyYXRpb246NTUwLGNhbGxzOltbe3RyYW5zbGF0ZVk6LTMwfSwuMjVdLFt7dHJhbnNsYXRlWTowfSwuMTI1XSxbe3RyYW5zbGF0ZVk6LTE1fSwuMTI1XSxbe3RyYW5zbGF0ZVk6MH0sLjI1XV19LFwiY2FsbG91dC5zaGFrZVwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe3RyYW5zbGF0ZVg6LTExfV0sW3t0cmFuc2xhdGVYOjExfV0sW3t0cmFuc2xhdGVYOi0xMX1dLFt7dHJhbnNsYXRlWDoxMX1dLFt7dHJhbnNsYXRlWDotMTF9XSxbe3RyYW5zbGF0ZVg6MTF9XSxbe3RyYW5zbGF0ZVg6LTExfV0sW3t0cmFuc2xhdGVYOjB9XV19LFwiY2FsbG91dC5mbGFzaFwiOntkZWZhdWx0RHVyYXRpb246MTEwMCxjYWxsczpbW3tvcGFjaXR5OlswLFwiZWFzZUluT3V0UXVhZFwiLDFdfV0sW3tvcGFjaXR5OlsxLFwiZWFzZUluT3V0UXVhZFwiXX1dLFt7b3BhY2l0eTpbMCxcImVhc2VJbk91dFF1YWRcIl19XSxbe29wYWNpdHk6WzEsXCJlYXNlSW5PdXRRdWFkXCJdfV1dfSxcImNhbGxvdXQucHVsc2VcIjp7ZGVmYXVsdER1cmF0aW9uOjgyNSxjYWxsczpbW3tzY2FsZVg6MS4xLHNjYWxlWToxLjF9LC41LHtlYXNpbmc6XCJlYXNlSW5FeHBvXCJ9XSxbe3NjYWxlWDoxLHNjYWxlWToxfSwuNV1dfSxcImNhbGxvdXQuc3dpbmdcIjp7ZGVmYXVsdER1cmF0aW9uOjk1MCxjYWxsczpbW3tyb3RhdGVaOjE1fV0sW3tyb3RhdGVaOi0xMH1dLFt7cm90YXRlWjo1fV0sW3tyb3RhdGVaOi01fV0sW3tyb3RhdGVaOjB9XV19LFwiY2FsbG91dC50YWRhXCI6e2RlZmF1bHREdXJhdGlvbjoxZTMsY2FsbHM6W1t7c2NhbGVYOi45LHNjYWxlWTouOSxyb3RhdGVaOi0zfSwuMV0sW3tzY2FsZVg6MS4xLHNjYWxlWToxLjEscm90YXRlWjozfSwuMV0sW3tzY2FsZVg6MS4xLHNjYWxlWToxLjEscm90YXRlWjotM30sLjFdLFtcInJldmVyc2VcIiwuMTI1XSxbXCJyZXZlcnNlXCIsLjEyNV0sW1wicmV2ZXJzZVwiLC4xMjVdLFtcInJldmVyc2VcIiwuMTI1XSxbXCJyZXZlcnNlXCIsLjEyNV0sW3tzY2FsZVg6MSxzY2FsZVk6MSxyb3RhdGVaOjB9LC4yXV19LFwidHJhbnNpdGlvbi5mYWRlSW5cIjp7ZGVmYXVsdER1cmF0aW9uOjUwMCxjYWxsczpbW3tvcGFjaXR5OlsxLDBdfV1dfSxcInRyYW5zaXRpb24uZmFkZU91dFwiOntkZWZhdWx0RHVyYXRpb246NTAwLGNhbGxzOltbe29wYWNpdHk6WzAsMV19XV19LFwidHJhbnNpdGlvbi5mbGlwWEluXCI6e2RlZmF1bHREdXJhdGlvbjo3MDAsY2FsbHM6W1t7b3BhY2l0eTpbMSwwXSx0cmFuc2Zvcm1QZXJzcGVjdGl2ZTpbODAwLDgwMF0scm90YXRlWTpbMCwtNTVdfV1dLHJlc2V0Ont0cmFuc2Zvcm1QZXJzcGVjdGl2ZTowfX0sXCJ0cmFuc2l0aW9uLmZsaXBYT3V0XCI6e2RlZmF1bHREdXJhdGlvbjo3MDAsY2FsbHM6W1t7b3BhY2l0eTpbMCwxXSx0cmFuc2Zvcm1QZXJzcGVjdGl2ZTpbODAwLDgwMF0scm90YXRlWTo1NX1dXSxyZXNldDp7dHJhbnNmb3JtUGVyc3BlY3RpdmU6MCxyb3RhdGVZOjB9fSxcInRyYW5zaXRpb24uZmxpcFlJblwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNmb3JtUGVyc3BlY3RpdmU6WzgwMCw4MDBdLHJvdGF0ZVg6WzAsLTQ1XX1dXSxyZXNldDp7dHJhbnNmb3JtUGVyc3BlY3RpdmU6MH19LFwidHJhbnNpdGlvbi5mbGlwWU91dFwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe29wYWNpdHk6WzAsMV0sdHJhbnNmb3JtUGVyc3BlY3RpdmU6WzgwMCw4MDBdLHJvdGF0ZVg6MjV9XV0scmVzZXQ6e3RyYW5zZm9ybVBlcnNwZWN0aXZlOjAscm90YXRlWDowfX0sXCJ0cmFuc2l0aW9uLmZsaXBCb3VuY2VYSW5cIjp7ZGVmYXVsdER1cmF0aW9uOjkwMCxjYWxsczpbW3tvcGFjaXR5OlsuNzI1LDBdLHRyYW5zZm9ybVBlcnNwZWN0aXZlOls0MDAsNDAwXSxyb3RhdGVZOlstMTAsOTBdfSwuNV0sW3tvcGFjaXR5Oi44LHJvdGF0ZVk6MTB9LC4yNV0sW3tvcGFjaXR5OjEscm90YXRlWTowfSwuMjVdXSxyZXNldDp7dHJhbnNmb3JtUGVyc3BlY3RpdmU6MH19LFwidHJhbnNpdGlvbi5mbGlwQm91bmNlWE91dFwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe29wYWNpdHk6Wy45LDFdLHRyYW5zZm9ybVBlcnNwZWN0aXZlOls0MDAsNDAwXSxyb3RhdGVZOi0xMH1dLFt7b3BhY2l0eTowLHJvdGF0ZVk6OTB9XV0scmVzZXQ6e3RyYW5zZm9ybVBlcnNwZWN0aXZlOjAscm90YXRlWTowfX0sXCJ0cmFuc2l0aW9uLmZsaXBCb3VuY2VZSW5cIjp7ZGVmYXVsdER1cmF0aW9uOjg1MCxjYWxsczpbW3tvcGFjaXR5OlsuNzI1LDBdLHRyYW5zZm9ybVBlcnNwZWN0aXZlOls0MDAsNDAwXSxyb3RhdGVYOlstMTAsOTBdfSwuNV0sW3tvcGFjaXR5Oi44LHJvdGF0ZVg6MTB9LC4yNV0sW3tvcGFjaXR5OjEscm90YXRlWDowfSwuMjVdXSxyZXNldDp7dHJhbnNmb3JtUGVyc3BlY3RpdmU6MH19LFwidHJhbnNpdGlvbi5mbGlwQm91bmNlWU91dFwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe29wYWNpdHk6Wy45LDFdLHRyYW5zZm9ybVBlcnNwZWN0aXZlOls0MDAsNDAwXSxyb3RhdGVYOi0xNX1dLFt7b3BhY2l0eTowLHJvdGF0ZVg6OTB9XV0scmVzZXQ6e3RyYW5zZm9ybVBlcnNwZWN0aXZlOjAscm90YXRlWDowfX0sXCJ0cmFuc2l0aW9uLnN3b29wSW5cIjp7ZGVmYXVsdER1cmF0aW9uOjg1MCxjYWxsczpbW3tvcGFjaXR5OlsxLDBdLHRyYW5zZm9ybU9yaWdpblg6W1wiMTAwJVwiLFwiNTAlXCJdLHRyYW5zZm9ybU9yaWdpblk6W1wiMTAwJVwiLFwiMTAwJVwiXSxzY2FsZVg6WzEsMF0sc2NhbGVZOlsxLDBdLHRyYW5zbGF0ZVg6WzAsLTcwMF0sdHJhbnNsYXRlWjowfV1dLHJlc2V0Ont0cmFuc2Zvcm1PcmlnaW5YOlwiNTAlXCIsdHJhbnNmb3JtT3JpZ2luWTpcIjUwJVwifX0sXCJ0cmFuc2l0aW9uLnN3b29wT3V0XCI6e2RlZmF1bHREdXJhdGlvbjo4NTAsY2FsbHM6W1t7b3BhY2l0eTpbMCwxXSx0cmFuc2Zvcm1PcmlnaW5YOltcIjUwJVwiLFwiMTAwJVwiXSx0cmFuc2Zvcm1PcmlnaW5ZOltcIjEwMCVcIixcIjEwMCVcIl0sc2NhbGVYOjAsc2NhbGVZOjAsdHJhbnNsYXRlWDotNzAwLHRyYW5zbGF0ZVo6MH1dXSxyZXNldDp7dHJhbnNmb3JtT3JpZ2luWDpcIjUwJVwiLHRyYW5zZm9ybU9yaWdpblk6XCI1MCVcIixzY2FsZVg6MSxzY2FsZVk6MSx0cmFuc2xhdGVYOjB9fSxcInRyYW5zaXRpb24ud2hpcmxJblwiOntkZWZhdWx0RHVyYXRpb246ODUwLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNmb3JtT3JpZ2luWDpbXCI1MCVcIixcIjUwJVwiXSx0cmFuc2Zvcm1PcmlnaW5ZOltcIjUwJVwiLFwiNTAlXCJdLHNjYWxlWDpbMSwwXSxzY2FsZVk6WzEsMF0scm90YXRlWTpbMCwxNjBdfSwxLHtlYXNpbmc6XCJlYXNlSW5PdXRTaW5lXCJ9XV19LFwidHJhbnNpdGlvbi53aGlybE91dFwiOntkZWZhdWx0RHVyYXRpb246NzUwLGNhbGxzOltbe29wYWNpdHk6WzAsXCJlYXNlSW5PdXRRdWludFwiLDFdLHRyYW5zZm9ybU9yaWdpblg6W1wiNTAlXCIsXCI1MCVcIl0sdHJhbnNmb3JtT3JpZ2luWTpbXCI1MCVcIixcIjUwJVwiXSxzY2FsZVg6MCxzY2FsZVk6MCxyb3RhdGVZOjE2MH0sMSx7ZWFzaW5nOlwic3dpbmdcIn1dXSxyZXNldDp7c2NhbGVYOjEsc2NhbGVZOjEscm90YXRlWTowfX0sXCJ0cmFuc2l0aW9uLnNocmlua0luXCI6e2RlZmF1bHREdXJhdGlvbjo3NTAsY2FsbHM6W1t7b3BhY2l0eTpbMSwwXSx0cmFuc2Zvcm1PcmlnaW5YOltcIjUwJVwiLFwiNTAlXCJdLHRyYW5zZm9ybU9yaWdpblk6W1wiNTAlXCIsXCI1MCVcIl0sc2NhbGVYOlsxLDEuNV0sc2NhbGVZOlsxLDEuNV0sdHJhbnNsYXRlWjowfV1dfSxcInRyYW5zaXRpb24uc2hyaW5rT3V0XCI6e2RlZmF1bHREdXJhdGlvbjo2MDAsY2FsbHM6W1t7b3BhY2l0eTpbMCwxXSx0cmFuc2Zvcm1PcmlnaW5YOltcIjUwJVwiLFwiNTAlXCJdLHRyYW5zZm9ybU9yaWdpblk6W1wiNTAlXCIsXCI1MCVcIl0sc2NhbGVYOjEuMyxzY2FsZVk6MS4zLHRyYW5zbGF0ZVo6MH1dXSxyZXNldDp7c2NhbGVYOjEsc2NhbGVZOjF9fSxcInRyYW5zaXRpb24uZXhwYW5kSW5cIjp7ZGVmYXVsdER1cmF0aW9uOjcwMCxjYWxsczpbW3tvcGFjaXR5OlsxLDBdLHRyYW5zZm9ybU9yaWdpblg6W1wiNTAlXCIsXCI1MCVcIl0sdHJhbnNmb3JtT3JpZ2luWTpbXCI1MCVcIixcIjUwJVwiXSxzY2FsZVg6WzEsLjYyNV0sc2NhbGVZOlsxLC42MjVdLHRyYW5zbGF0ZVo6MH1dXX0sXCJ0cmFuc2l0aW9uLmV4cGFuZE91dFwiOntkZWZhdWx0RHVyYXRpb246NzAwLGNhbGxzOltbe29wYWNpdHk6WzAsMV0sdHJhbnNmb3JtT3JpZ2luWDpbXCI1MCVcIixcIjUwJVwiXSx0cmFuc2Zvcm1PcmlnaW5ZOltcIjUwJVwiLFwiNTAlXCJdLHNjYWxlWDouNSxzY2FsZVk6LjUsdHJhbnNsYXRlWjowfV1dLHJlc2V0OntzY2FsZVg6MSxzY2FsZVk6MX19LFwidHJhbnNpdGlvbi5ib3VuY2VJblwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sc2NhbGVYOlsxLjA1LC4zXSxzY2FsZVk6WzEuMDUsLjNdfSwuMzVdLFt7c2NhbGVYOi45LHNjYWxlWTouOSx0cmFuc2xhdGVaOjB9LC4yXSxbe3NjYWxlWDoxLHNjYWxlWToxfSwuNDVdXX0sXCJ0cmFuc2l0aW9uLmJvdW5jZU91dFwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe3NjYWxlWDouOTUsc2NhbGVZOi45NX0sLjM1XSxbe3NjYWxlWDoxLjEsc2NhbGVZOjEuMSx0cmFuc2xhdGVaOjB9LC4zNV0sW3tvcGFjaXR5OlswLDFdLHNjYWxlWDouMyxzY2FsZVk6LjN9LC4zXV0scmVzZXQ6e3NjYWxlWDoxLHNjYWxlWToxfX0sXCJ0cmFuc2l0aW9uLmJvdW5jZVVwSW5cIjp7ZGVmYXVsdER1cmF0aW9uOjgwMCxjYWxsczpbW3tvcGFjaXR5OlsxLDBdLHRyYW5zbGF0ZVk6Wy0zMCwxZTNdfSwuNix7ZWFzaW5nOlwiZWFzZU91dENpcmNcIn1dLFt7dHJhbnNsYXRlWToxMH0sLjJdLFt7dHJhbnNsYXRlWTowfSwuMl1dfSxcInRyYW5zaXRpb24uYm91bmNlVXBPdXRcIjp7ZGVmYXVsdER1cmF0aW9uOjFlMyxjYWxsczpbW3t0cmFuc2xhdGVZOjIwfSwuMl0sW3tvcGFjaXR5OlswLFwiZWFzZUluQ2lyY1wiLDFdLHRyYW5zbGF0ZVk6LTFlM30sLjhdXSxyZXNldDp7dHJhbnNsYXRlWTowfX0sXCJ0cmFuc2l0aW9uLmJvdW5jZURvd25JblwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNsYXRlWTpbMzAsLTFlM119LC42LHtlYXNpbmc6XCJlYXNlT3V0Q2lyY1wifV0sW3t0cmFuc2xhdGVZOi0xMH0sLjJdLFt7dHJhbnNsYXRlWTowfSwuMl1dfSxcInRyYW5zaXRpb24uYm91bmNlRG93bk91dFwiOntkZWZhdWx0RHVyYXRpb246MWUzLGNhbGxzOltbe3RyYW5zbGF0ZVk6LTIwfSwuMl0sW3tvcGFjaXR5OlswLFwiZWFzZUluQ2lyY1wiLDFdLHRyYW5zbGF0ZVk6MWUzfSwuOF1dLHJlc2V0Ont0cmFuc2xhdGVZOjB9fSxcInRyYW5zaXRpb24uYm91bmNlTGVmdEluXCI6e2RlZmF1bHREdXJhdGlvbjo3NTAsY2FsbHM6W1t7b3BhY2l0eTpbMSwwXSx0cmFuc2xhdGVYOlszMCwtMTI1MF19LC42LHtlYXNpbmc6XCJlYXNlT3V0Q2lyY1wifV0sW3t0cmFuc2xhdGVYOi0xMH0sLjJdLFt7dHJhbnNsYXRlWDowfSwuMl1dfSxcInRyYW5zaXRpb24uYm91bmNlTGVmdE91dFwiOntkZWZhdWx0RHVyYXRpb246NzUwLGNhbGxzOltbe3RyYW5zbGF0ZVg6MzB9LC4yXSxbe29wYWNpdHk6WzAsXCJlYXNlSW5DaXJjXCIsMV0sdHJhbnNsYXRlWDotMTI1MH0sLjhdXSxyZXNldDp7dHJhbnNsYXRlWDowfX0sXCJ0cmFuc2l0aW9uLmJvdW5jZVJpZ2h0SW5cIjp7ZGVmYXVsdER1cmF0aW9uOjc1MCxjYWxsczpbW3tvcGFjaXR5OlsxLDBdLHRyYW5zbGF0ZVg6Wy0zMCwxMjUwXX0sLjYse2Vhc2luZzpcImVhc2VPdXRDaXJjXCJ9XSxbe3RyYW5zbGF0ZVg6MTB9LC4yXSxbe3RyYW5zbGF0ZVg6MH0sLjJdXX0sXCJ0cmFuc2l0aW9uLmJvdW5jZVJpZ2h0T3V0XCI6e2RlZmF1bHREdXJhdGlvbjo3NTAsY2FsbHM6W1t7dHJhbnNsYXRlWDotMzB9LC4yXSxbe29wYWNpdHk6WzAsXCJlYXNlSW5DaXJjXCIsMV0sdHJhbnNsYXRlWDoxMjUwfSwuOF1dLHJlc2V0Ont0cmFuc2xhdGVYOjB9fSxcInRyYW5zaXRpb24uc2xpZGVVcEluXCI6e2RlZmF1bHREdXJhdGlvbjo5MDAsY2FsbHM6W1t7b3BhY2l0eTpbMSwwXSx0cmFuc2xhdGVZOlswLDIwXSx0cmFuc2xhdGVaOjB9XV19LFwidHJhbnNpdGlvbi5zbGlkZVVwT3V0XCI6e2RlZmF1bHREdXJhdGlvbjo5MDAsY2FsbHM6W1t7b3BhY2l0eTpbMCwxXSx0cmFuc2xhdGVZOi0yMCx0cmFuc2xhdGVaOjB9XV0scmVzZXQ6e3RyYW5zbGF0ZVk6MH19LFwidHJhbnNpdGlvbi5zbGlkZURvd25JblwiOntkZWZhdWx0RHVyYXRpb246OTAwLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNsYXRlWTpbMCwtMjBdLHRyYW5zbGF0ZVo6MH1dXX0sXCJ0cmFuc2l0aW9uLnNsaWRlRG93bk91dFwiOntkZWZhdWx0RHVyYXRpb246OTAwLGNhbGxzOltbe29wYWNpdHk6WzAsMV0sdHJhbnNsYXRlWToyMCx0cmFuc2xhdGVaOjB9XV0scmVzZXQ6e3RyYW5zbGF0ZVk6MH19LFwidHJhbnNpdGlvbi5zbGlkZUxlZnRJblwiOntkZWZhdWx0RHVyYXRpb246MWUzLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNsYXRlWDpbMCwtMjBdLHRyYW5zbGF0ZVo6MH1dXX0sXCJ0cmFuc2l0aW9uLnNsaWRlTGVmdE91dFwiOntkZWZhdWx0RHVyYXRpb246MTA1MCxjYWxsczpbW3tvcGFjaXR5OlswLDFdLHRyYW5zbGF0ZVg6LTIwLHRyYW5zbGF0ZVo6MH1dXSxyZXNldDp7dHJhbnNsYXRlWDowfX0sXCJ0cmFuc2l0aW9uLnNsaWRlUmlnaHRJblwiOntkZWZhdWx0RHVyYXRpb246MWUzLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNsYXRlWDpbMCwyMF0sdHJhbnNsYXRlWjowfV1dfSxcInRyYW5zaXRpb24uc2xpZGVSaWdodE91dFwiOntkZWZhdWx0RHVyYXRpb246MTA1MCxjYWxsczpbW3tvcGFjaXR5OlswLDFdLHRyYW5zbGF0ZVg6MjAsdHJhbnNsYXRlWjowfV1dLHJlc2V0Ont0cmFuc2xhdGVYOjB9fSxcInRyYW5zaXRpb24uc2xpZGVVcEJpZ0luXCI6e2RlZmF1bHREdXJhdGlvbjo4NTAsY2FsbHM6W1t7b3BhY2l0eTpbMSwwXSx0cmFuc2xhdGVZOlswLDc1XSx0cmFuc2xhdGVaOjB9XV19LFwidHJhbnNpdGlvbi5zbGlkZVVwQmlnT3V0XCI6e2RlZmF1bHREdXJhdGlvbjo4MDAsY2FsbHM6W1t7b3BhY2l0eTpbMCwxXSx0cmFuc2xhdGVZOi03NSx0cmFuc2xhdGVaOjB9XV0scmVzZXQ6e3RyYW5zbGF0ZVk6MH19LFwidHJhbnNpdGlvbi5zbGlkZURvd25CaWdJblwiOntkZWZhdWx0RHVyYXRpb246ODUwLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNsYXRlWTpbMCwtNzVdLHRyYW5zbGF0ZVo6MH1dXX0sXCJ0cmFuc2l0aW9uLnNsaWRlRG93bkJpZ091dFwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe29wYWNpdHk6WzAsMV0sdHJhbnNsYXRlWTo3NSx0cmFuc2xhdGVaOjB9XV0scmVzZXQ6e3RyYW5zbGF0ZVk6MH19LFwidHJhbnNpdGlvbi5zbGlkZUxlZnRCaWdJblwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNsYXRlWDpbMCwtNzVdLHRyYW5zbGF0ZVo6MH1dXX0sXCJ0cmFuc2l0aW9uLnNsaWRlTGVmdEJpZ091dFwiOntkZWZhdWx0RHVyYXRpb246NzUwLGNhbGxzOltbe29wYWNpdHk6WzAsMV0sdHJhbnNsYXRlWDotNzUsdHJhbnNsYXRlWjowfV1dLHJlc2V0Ont0cmFuc2xhdGVYOjB9fSxcInRyYW5zaXRpb24uc2xpZGVSaWdodEJpZ0luXCI6e2RlZmF1bHREdXJhdGlvbjo4MDAsY2FsbHM6W1t7b3BhY2l0eTpbMSwwXSx0cmFuc2xhdGVYOlswLDc1XSx0cmFuc2xhdGVaOjB9XV19LFwidHJhbnNpdGlvbi5zbGlkZVJpZ2h0QmlnT3V0XCI6e2RlZmF1bHREdXJhdGlvbjo3NTAsY2FsbHM6W1t7b3BhY2l0eTpbMCwxXSx0cmFuc2xhdGVYOjc1LHRyYW5zbGF0ZVo6MH1dXSxyZXNldDp7dHJhbnNsYXRlWDowfX0sXCJ0cmFuc2l0aW9uLnBlcnNwZWN0aXZlVXBJblwiOntkZWZhdWx0RHVyYXRpb246ODAwLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNmb3JtUGVyc3BlY3RpdmU6WzgwMCw4MDBdLHRyYW5zZm9ybU9yaWdpblg6WzAsMF0sdHJhbnNmb3JtT3JpZ2luWTpbXCIxMDAlXCIsXCIxMDAlXCJdLHJvdGF0ZVg6WzAsLTE4MF19XV0scmVzZXQ6e3RyYW5zZm9ybVBlcnNwZWN0aXZlOjAsdHJhbnNmb3JtT3JpZ2luWDpcIjUwJVwiLHRyYW5zZm9ybU9yaWdpblk6XCI1MCVcIn19LFwidHJhbnNpdGlvbi5wZXJzcGVjdGl2ZVVwT3V0XCI6e2RlZmF1bHREdXJhdGlvbjo4NTAsY2FsbHM6W1t7b3BhY2l0eTpbMCwxXSx0cmFuc2Zvcm1QZXJzcGVjdGl2ZTpbODAwLDgwMF0sdHJhbnNmb3JtT3JpZ2luWDpbMCwwXSx0cmFuc2Zvcm1PcmlnaW5ZOltcIjEwMCVcIixcIjEwMCVcIl0scm90YXRlWDotMTgwfV1dLHJlc2V0Ont0cmFuc2Zvcm1QZXJzcGVjdGl2ZTowLHRyYW5zZm9ybU9yaWdpblg6XCI1MCVcIix0cmFuc2Zvcm1PcmlnaW5ZOlwiNTAlXCIscm90YXRlWDowfX0sXCJ0cmFuc2l0aW9uLnBlcnNwZWN0aXZlRG93bkluXCI6e2RlZmF1bHREdXJhdGlvbjo4MDAsY2FsbHM6W1t7b3BhY2l0eTpbMSwwXSx0cmFuc2Zvcm1QZXJzcGVjdGl2ZTpbODAwLDgwMF0sdHJhbnNmb3JtT3JpZ2luWDpbMCwwXSx0cmFuc2Zvcm1PcmlnaW5ZOlswLDBdLHJvdGF0ZVg6WzAsMTgwXX1dXSxyZXNldDp7dHJhbnNmb3JtUGVyc3BlY3RpdmU6MCx0cmFuc2Zvcm1PcmlnaW5YOlwiNTAlXCIsdHJhbnNmb3JtT3JpZ2luWTpcIjUwJVwifX0sXCJ0cmFuc2l0aW9uLnBlcnNwZWN0aXZlRG93bk91dFwiOntkZWZhdWx0RHVyYXRpb246ODUwLGNhbGxzOltbe29wYWNpdHk6WzAsMV0sdHJhbnNmb3JtUGVyc3BlY3RpdmU6WzgwMCw4MDBdLHRyYW5zZm9ybU9yaWdpblg6WzAsMF0sdHJhbnNmb3JtT3JpZ2luWTpbMCwwXSxyb3RhdGVYOjE4MH1dXSxyZXNldDp7dHJhbnNmb3JtUGVyc3BlY3RpdmU6MCx0cmFuc2Zvcm1PcmlnaW5YOlwiNTAlXCIsdHJhbnNmb3JtT3JpZ2luWTpcIjUwJVwiLHJvdGF0ZVg6MH19LFwidHJhbnNpdGlvbi5wZXJzcGVjdGl2ZUxlZnRJblwiOntkZWZhdWx0RHVyYXRpb246OTUwLGNhbGxzOltbe29wYWNpdHk6WzEsMF0sdHJhbnNmb3JtUGVyc3BlY3RpdmU6WzJlMywyZTNdLHRyYW5zZm9ybU9yaWdpblg6WzAsMF0sdHJhbnNmb3JtT3JpZ2luWTpbMCwwXSxyb3RhdGVZOlswLC0xODBdfV1dLHJlc2V0Ont0cmFuc2Zvcm1QZXJzcGVjdGl2ZTowLHRyYW5zZm9ybU9yaWdpblg6XCI1MCVcIix0cmFuc2Zvcm1PcmlnaW5ZOlwiNTAlXCJ9fSxcInRyYW5zaXRpb24ucGVyc3BlY3RpdmVMZWZ0T3V0XCI6e2RlZmF1bHREdXJhdGlvbjo5NTAsY2FsbHM6W1t7b3BhY2l0eTpbMCwxXSx0cmFuc2Zvcm1QZXJzcGVjdGl2ZTpbMmUzLDJlM10sdHJhbnNmb3JtT3JpZ2luWDpbMCwwXSx0cmFuc2Zvcm1PcmlnaW5ZOlswLDBdLHJvdGF0ZVk6LTE4MH1dXSxyZXNldDp7dHJhbnNmb3JtUGVyc3BlY3RpdmU6MCx0cmFuc2Zvcm1PcmlnaW5YOlwiNTAlXCIsdHJhbnNmb3JtT3JpZ2luWTpcIjUwJVwiLHJvdGF0ZVk6MH19LFwidHJhbnNpdGlvbi5wZXJzcGVjdGl2ZVJpZ2h0SW5cIjp7ZGVmYXVsdER1cmF0aW9uOjk1MCxjYWxsczpbW3tvcGFjaXR5OlsxLDBdLHRyYW5zZm9ybVBlcnNwZWN0aXZlOlsyZTMsMmUzXSx0cmFuc2Zvcm1PcmlnaW5YOltcIjEwMCVcIixcIjEwMCVcIl0sdHJhbnNmb3JtT3JpZ2luWTpbMCwwXSxyb3RhdGVZOlswLDE4MF19XV0scmVzZXQ6e3RyYW5zZm9ybVBlcnNwZWN0aXZlOjAsdHJhbnNmb3JtT3JpZ2luWDpcIjUwJVwiLHRyYW5zZm9ybU9yaWdpblk6XCI1MCVcIn19LFwidHJhbnNpdGlvbi5wZXJzcGVjdGl2ZVJpZ2h0T3V0XCI6e2RlZmF1bHREdXJhdGlvbjo5NTAsY2FsbHM6W1t7b3BhY2l0eTpbMCwxXSx0cmFuc2Zvcm1QZXJzcGVjdGl2ZTpbMmUzLDJlM10sdHJhbnNmb3JtT3JpZ2luWDpbXCIxMDAlXCIsXCIxMDAlXCJdLHRyYW5zZm9ybU9yaWdpblk6WzAsMF0scm90YXRlWToxODB9XV0scmVzZXQ6e3RyYW5zZm9ybVBlcnNwZWN0aXZlOjAsdHJhbnNmb3JtT3JpZ2luWDpcIjUwJVwiLHRyYW5zZm9ybU9yaWdpblk6XCI1MCVcIixyb3RhdGVZOjB9fX07Zm9yKHZhciBqIGluIGUuUmVnaXN0ZXJFZmZlY3QucGFja2FnZWRFZmZlY3RzKWUuUmVnaXN0ZXJFZmZlY3QucGFja2FnZWRFZmZlY3RzLmhhc093blByb3BlcnR5KGopJiZlLlJlZ2lzdGVyRWZmZWN0KGosZS5SZWdpc3RlckVmZmVjdC5wYWNrYWdlZEVmZmVjdHNbal0pO2UuUnVuU2VxdWVuY2U9ZnVuY3Rpb24oYSl7dmFyIGI9Zi5leHRlbmQoITAsW10sYSk7Yi5sZW5ndGg+MSYmKGYuZWFjaChiLnJldmVyc2UoKSxmdW5jdGlvbihhLGMpe3ZhciBkPWJbYSsxXTtpZihkKXt2YXIgZz1jLm98fGMub3B0aW9ucyxoPWQub3x8ZC5vcHRpb25zLGk9ZyYmZy5zZXF1ZW5jZVF1ZXVlPT09ITE/XCJiZWdpblwiOlwiY29tcGxldGVcIixqPWgmJmhbaV0saz17fTtrW2ldPWZ1bmN0aW9uKCl7dmFyIGE9ZC5lfHxkLmVsZW1lbnRzLGI9YS5ub2RlVHlwZT9bYV06YTtqJiZqLmNhbGwoYixiKSxlKGMpfSxkLm8/ZC5vPWYuZXh0ZW5kKHt9LGgsayk6ZC5vcHRpb25zPWYuZXh0ZW5kKHt9LGgsayl9fSksYi5yZXZlcnNlKCkpLGUoYlswXSl9fSh3aW5kb3cualF1ZXJ5fHx3aW5kb3cuWmVwdG98fHdpbmRvdyx3aW5kb3csd2luZG93P3dpbmRvdy5kb2N1bWVudDp1bmRlZmluZWQpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdmVsb2NpdHktYW5pbWF0ZS92ZWxvY2l0eS51aS5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJleHBvcnQgY29uc3QgJGJwTW9iaWxlICAgICA9IHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXdpZHRoOiA0ODBweCknKVxuZXhwb3J0IGNvbnN0ICRicFRhYmxldCAgICAgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogNzY4cHgpJylcbmV4cG9ydCBjb25zdCAkYnBMYXB0b3AgICAgID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDEwMDBweCknKVxuZXhwb3J0IGNvbnN0ICRicExnICAgICAgICAgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogMTEwMHB4KScpXG5leHBvcnQgY29uc3QgJGJwWGwgICAgICAgICA9IHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXdpZHRoOiAxNDAwcHgpJylcbmV4cG9ydCBjb25zdCAkYnBYeGwgICAgICAgID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDE1NjBweCknKVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvdXRpbGl0aWVzL2dyaWQtc2V0dGluZ3MuanMiLCJpbXBvcnQgJ3ZlbG9jaXR5LWFuaW1hdGUnXG5pbXBvcnQgJ3ZlbG9jaXR5LWFuaW1hdGUvdmVsb2NpdHkudWknXG5pbXBvcnQgU2l0ZSBmcm9tICdzaXRlJ1xuXG4kKGRvY3VtZW50KS5yZWFkeSgoKSA9PiB7XG5cdFNpdGUoKS5pbml0KClcblxuXHQkLmFqYXhTZXR1cCh7XG5cdCAgICBoZWFkZXJzOiB7XG5cdCAgICAgICAgJ1gtQ1NSRi1UT0tFTic6ICQoJ21ldGFbbmFtZT1cImNzcmYtdG9rZW5cIl0nKS5hdHRyKCdjb250ZW50Jylcblx0ICAgIH1cblx0fSlcbn0pXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9tYWluLmpzIiwiLyoqKioqKioqKioqKioqKioqKioqKipcbiBWZWxvY2l0eSBVSSBQYWNrXG4gKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogVmVsb2NpdHlKUy5vcmcgVUkgUGFjayAoNS4yLjApLiAoQykgMjAxNCBKdWxpYW4gU2hhcGlyby4gTUlUIEBsaWNlbnNlOiBlbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UuIFBvcnRpb25zIGNvcHlyaWdodCBEYW5pZWwgRWRlbiwgQ2hyaXN0aWFuIFB1Y2NpLiAqL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0LyogQ29tbW9uSlMgbW9kdWxlLiAqL1xuXHRpZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRcdC8qIEFNRCBtb2R1bGUuICovXG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW1widmVsb2NpdHlcIl0sIGZhY3RvcnkpO1xuXHRcdC8qIEJyb3dzZXIgZ2xvYmFscy4gKi9cblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRyZXR1cm4gZnVuY3Rpb24oZ2xvYmFsLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuXHRcdC8qKioqKioqKioqKioqXG5cdFx0IENoZWNrc1xuXHRcdCAqKioqKioqKioqKioqL1xuXHRcdHZhciBWZWxvY2l0eSA9IGdsb2JhbC5WZWxvY2l0eTtcblxuXHRcdGlmICghVmVsb2NpdHkgfHwgIVZlbG9jaXR5LlV0aWxpdGllcykge1xuXHRcdFx0aWYgKHdpbmRvdy5jb25zb2xlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiVmVsb2NpdHkgVUkgUGFjazogVmVsb2NpdHkgbXVzdCBiZSBsb2FkZWQgZmlyc3QuIEFib3J0aW5nLlwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyICQgPSBWZWxvY2l0eS5VdGlsaXRpZXM7XG5cblx0XHR2YXIgdmVsb2NpdHlWZXJzaW9uID0gVmVsb2NpdHkudmVyc2lvbixcblx0XHRcdFx0cmVxdWlyZWRWZXJzaW9uID0ge21ham9yOiAxLCBtaW5vcjogMSwgcGF0Y2g6IDB9O1xuXG5cdFx0ZnVuY3Rpb24gZ3JlYXRlclNlbXZlcihwcmltYXJ5LCBzZWNvbmRhcnkpIHtcblx0XHRcdHZhciB2ZXJzaW9uSW50cyA9IFtdO1xuXG5cdFx0XHRpZiAoIXByaW1hcnkgfHwgIXNlY29uZGFyeSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdCQuZWFjaChbcHJpbWFyeSwgc2Vjb25kYXJ5XSwgZnVuY3Rpb24oaSwgdmVyc2lvbk9iamVjdCkge1xuXHRcdFx0XHR2YXIgdmVyc2lvbkludHNDb21wb25lbnRzID0gW107XG5cblx0XHRcdFx0JC5lYWNoKHZlcnNpb25PYmplY3QsIGZ1bmN0aW9uKGNvbXBvbmVudCwgdmFsdWUpIHtcblx0XHRcdFx0XHR3aGlsZSAodmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPCA1KSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IFwiMFwiICsgdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZlcnNpb25JbnRzQ29tcG9uZW50cy5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dmVyc2lvbkludHMucHVzaCh2ZXJzaW9uSW50c0NvbXBvbmVudHMuam9pbihcIlwiKSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIChwYXJzZUZsb2F0KHZlcnNpb25JbnRzWzBdKSA+IHBhcnNlRmxvYXQodmVyc2lvbkludHNbMV0pKTtcblx0XHR9XG5cblx0XHRpZiAoZ3JlYXRlclNlbXZlcihyZXF1aXJlZFZlcnNpb24sIHZlbG9jaXR5VmVyc2lvbikpIHtcblx0XHRcdHZhciBhYm9ydEVycm9yID0gXCJWZWxvY2l0eSBVSSBQYWNrOiBZb3UgbmVlZCB0byB1cGRhdGUgVmVsb2NpdHkgKHZlbG9jaXR5LmpzKSB0byBhIG5ld2VyIHZlcnNpb24uIFZpc2l0IGh0dHA6Ly9naXRodWIuY29tL2p1bGlhbnNoYXBpcm8vdmVsb2NpdHkuXCI7XG5cdFx0XHRhbGVydChhYm9ydEVycm9yKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihhYm9ydEVycm9yKTtcblx0XHR9XG5cblx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0IEVmZmVjdCBSZWdpc3RyYXRpb25cblx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogTm90ZTogUmVnaXN0ZXJVSSBpcyBhIGxlZ2FjeSBuYW1lLiAqL1xuXHRcdFZlbG9jaXR5LlJlZ2lzdGVyRWZmZWN0ID0gVmVsb2NpdHkuUmVnaXN0ZXJVSSA9IGZ1bmN0aW9uKGVmZmVjdE5hbWUsIHByb3BlcnRpZXMpIHtcblx0XHRcdC8qIEFuaW1hdGUgdGhlIGV4cGFuc2lvbi9jb250cmFjdGlvbiBvZiB0aGUgZWxlbWVudHMnIHBhcmVudCdzIGhlaWdodCBmb3IgSW4vT3V0IGVmZmVjdHMuICovXG5cdFx0XHRmdW5jdGlvbiBhbmltYXRlUGFyZW50SGVpZ2h0KGVsZW1lbnRzLCBkaXJlY3Rpb24sIHRvdGFsRHVyYXRpb24sIHN0YWdnZXIpIHtcblx0XHRcdFx0dmFyIHRvdGFsSGVpZ2h0RGVsdGEgPSAwLFxuXHRcdFx0XHRcdFx0cGFyZW50Tm9kZTtcblxuXHRcdFx0XHQvKiBTdW0gdGhlIHRvdGFsIGhlaWdodCAoaW5jbHVkaW5nIHBhZGRpbmcgYW5kIG1hcmdpbikgb2YgYWxsIHRhcmdldGVkIGVsZW1lbnRzLiAqL1xuXHRcdFx0XHQkLmVhY2goZWxlbWVudHMubm9kZVR5cGUgPyBbZWxlbWVudHNdIDogZWxlbWVudHMsIGZ1bmN0aW9uKGksIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRpZiAoc3RhZ2dlcikge1xuXHRcdFx0XHRcdFx0LyogSW5jcmVhc2UgdGhlIHRvdGFsRHVyYXRpb24gYnkgdGhlIHN1Y2Nlc3NpdmUgZGVsYXkgYW1vdW50cyBwcm9kdWNlZCBieSB0aGUgc3RhZ2dlciBvcHRpb24uICovXG5cdFx0XHRcdFx0XHR0b3RhbER1cmF0aW9uICs9IGkgKiBzdGFnZ2VyO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBhcmVudE5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cblx0XHRcdFx0XHR2YXIgcHJvcGVydGllc1RvU3VtID0gW1wiaGVpZ2h0XCIsIFwicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdCb3R0b21cIiwgXCJtYXJnaW5Ub3BcIiwgXCJtYXJnaW5Cb3R0b21cIl07XG5cblx0XHRcdFx0XHQvKiBJZiBib3gtc2l6aW5nIGlzIGJvcmRlci1ib3gsIHRoZSBoZWlnaHQgYWxyZWFkeSBpbmNsdWRlcyBwYWRkaW5nIGFuZCBtYXJnaW4gKi9cblx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJib3hTaXppbmdcIikudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBcImJvcmRlci1ib3hcIikge1xuXHRcdFx0XHRcdFx0cHJvcGVydGllc1RvU3VtID0gW1wiaGVpZ2h0XCJdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCQuZWFjaChwcm9wZXJ0aWVzVG9TdW0sIGZ1bmN0aW9uKGksIHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHR0b3RhbEhlaWdodERlbHRhICs9IHBhcnNlRmxvYXQoVmVsb2NpdHkuQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHkpKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0LyogQW5pbWF0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBoZWlnaHQgYWRqdXN0bWVudCAod2l0aCBhIHZhcnlpbmcgZHVyYXRpb24gbXVsdGlwbGllciBmb3IgYWVzdGhldGljIGJlbmVmaXRzKS4gKi9cblx0XHRcdFx0VmVsb2NpdHkuYW5pbWF0ZShcblx0XHRcdFx0XHRcdHBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHR7aGVpZ2h0OiAoZGlyZWN0aW9uID09PSBcIkluXCIgPyBcIitcIiA6IFwiLVwiKSArIFwiPVwiICsgdG90YWxIZWlnaHREZWx0YX0sXG5cdFx0XHRcdFx0XHR7cXVldWU6IGZhbHNlLCBlYXNpbmc6IFwiZWFzZS1pbi1vdXRcIiwgZHVyYXRpb246IHRvdGFsRHVyYXRpb24gKiAoZGlyZWN0aW9uID09PSBcIkluXCIgPyAwLjYgOiAxKX1cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0LyogUmVnaXN0ZXIgYSBjdXN0b20gcmVkaXJlY3QgZm9yIGVhY2ggZWZmZWN0LiAqL1xuXHRcdFx0VmVsb2NpdHkuUmVkaXJlY3RzW2VmZmVjdE5hbWVdID0gZnVuY3Rpb24oZWxlbWVudCwgcmVkaXJlY3RPcHRpb25zLCBlbGVtZW50c0luZGV4LCBlbGVtZW50c1NpemUsIGVsZW1lbnRzLCBwcm9taXNlRGF0YSwgbG9vcCkge1xuXHRcdFx0XHR2YXIgZmluYWxFbGVtZW50ID0gKGVsZW1lbnRzSW5kZXggPT09IGVsZW1lbnRzU2l6ZSAtIDEpLFxuXHRcdFx0XHRcdFx0dG90YWxEdXJhdGlvbiA9IDA7XG5cblx0XHRcdFx0bG9vcCA9IGxvb3AgfHwgcHJvcGVydGllcy5sb29wO1xuXHRcdFx0XHRpZiAodHlwZW9mIHByb3BlcnRpZXMuZGVmYXVsdER1cmF0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRwcm9wZXJ0aWVzLmRlZmF1bHREdXJhdGlvbiA9IHByb3BlcnRpZXMuZGVmYXVsdER1cmF0aW9uLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwcm9wZXJ0aWVzLmRlZmF1bHREdXJhdGlvbiA9IHBhcnNlRmxvYXQocHJvcGVydGllcy5kZWZhdWx0RHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogR2V0IHRoZSB0b3RhbCBkdXJhdGlvbiB1c2VkLCBzbyB3ZSBjYW4gc2hhcmUgaXQgb3V0IHdpdGggZXZlcnl0aGluZyB0aGF0IGRvZXNuJ3QgaGF2ZSBhIGR1cmF0aW9uICovXG5cdFx0XHRcdGZvciAodmFyIGNhbGxJbmRleCA9IDA7IGNhbGxJbmRleCA8IHByb3BlcnRpZXMuY2FsbHMubGVuZ3RoOyBjYWxsSW5kZXgrKykge1xuXHRcdFx0XHRcdGR1cmF0aW9uUGVyY2VudGFnZSA9IHByb3BlcnRpZXMuY2FsbHNbY2FsbEluZGV4XVsxXTtcblx0XHRcdFx0XHRpZiAodHlwZW9mIGR1cmF0aW9uUGVyY2VudGFnZSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0dG90YWxEdXJhdGlvbiArPSBkdXJhdGlvblBlcmNlbnRhZ2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzaGFyZUR1cmF0aW9uID0gdG90YWxEdXJhdGlvbiA+PSAxID8gMCA6IHByb3BlcnRpZXMuY2FsbHMubGVuZ3RoID8gKDEgLSB0b3RhbER1cmF0aW9uKSAvIHByb3BlcnRpZXMuY2FsbHMubGVuZ3RoIDogMTtcblxuXHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggZWFjaCBlZmZlY3QncyBjYWxsIGFycmF5LiAqL1xuXHRcdFx0XHRmb3IgKGNhbGxJbmRleCA9IDA7IGNhbGxJbmRleCA8IHByb3BlcnRpZXMuY2FsbHMubGVuZ3RoOyBjYWxsSW5kZXgrKykge1xuXHRcdFx0XHRcdHZhciBjYWxsID0gcHJvcGVydGllcy5jYWxsc1tjYWxsSW5kZXhdLFxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eU1hcCA9IGNhbGxbMF0sXG5cdFx0XHRcdFx0XHRcdHJlZGlyZWN0RHVyYXRpb24gPSAxMDAwLFxuXHRcdFx0XHRcdFx0XHRkdXJhdGlvblBlcmNlbnRhZ2UgPSBjYWxsWzFdLFxuXHRcdFx0XHRcdFx0XHRjYWxsT3B0aW9ucyA9IGNhbGxbMl0gfHwge30sXG5cdFx0XHRcdFx0XHRcdG9wdHMgPSB7fTtcblxuXHRcdFx0XHRcdGlmIChyZWRpcmVjdE9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0cmVkaXJlY3REdXJhdGlvbiA9IHJlZGlyZWN0T3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BlcnRpZXMuZGVmYXVsdER1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHJlZGlyZWN0RHVyYXRpb24gPSBwcm9wZXJ0aWVzLmRlZmF1bHREdXJhdGlvbjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBBc3NpZ24gdGhlIHdoaXRlbGlzdGVkIHBlci1jYWxsIG9wdGlvbnMuICovXG5cdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiA9IHJlZGlyZWN0RHVyYXRpb24gKiAodHlwZW9mIGR1cmF0aW9uUGVyY2VudGFnZSA9PT0gXCJudW1iZXJcIiA/IGR1cmF0aW9uUGVyY2VudGFnZSA6IHNoYXJlRHVyYXRpb24pO1xuXHRcdFx0XHRcdG9wdHMucXVldWUgPSByZWRpcmVjdE9wdGlvbnMucXVldWUgfHwgXCJcIjtcblx0XHRcdFx0XHRvcHRzLmVhc2luZyA9IGNhbGxPcHRpb25zLmVhc2luZyB8fCBcImVhc2VcIjtcblx0XHRcdFx0XHRvcHRzLmRlbGF5ID0gcGFyc2VGbG9hdChjYWxsT3B0aW9ucy5kZWxheSkgfHwgMDtcblx0XHRcdFx0XHRvcHRzLmxvb3AgPSAhcHJvcGVydGllcy5sb29wICYmIGNhbGxPcHRpb25zLmxvb3A7XG5cdFx0XHRcdFx0b3B0cy5fY2FjaGVWYWx1ZXMgPSBjYWxsT3B0aW9ucy5fY2FjaGVWYWx1ZXMgfHwgdHJ1ZTtcblxuXHRcdFx0XHRcdC8qIFNwZWNpYWwgcHJvY2Vzc2luZyBmb3IgdGhlIGZpcnN0IGVmZmVjdCBjYWxsLiAqL1xuXHRcdFx0XHRcdGlmIChjYWxsSW5kZXggPT09IDApIHtcblx0XHRcdFx0XHRcdC8qIElmIGEgZGVsYXkgd2FzIHBhc3NlZCBpbnRvIHRoZSByZWRpcmVjdCwgY29tYmluZSBpdCB3aXRoIHRoZSBmaXJzdCBjYWxsJ3MgZGVsYXkuICovXG5cdFx0XHRcdFx0XHRvcHRzLmRlbGF5ICs9IChwYXJzZUZsb2F0KHJlZGlyZWN0T3B0aW9ucy5kZWxheSkgfHwgMCk7XG5cblx0XHRcdFx0XHRcdGlmIChlbGVtZW50c0luZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdG9wdHMuYmVnaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBPbmx5IHRyaWdnZXIgYSBiZWdpbiBjYWxsYmFjayBvbiB0aGUgZmlyc3QgZWZmZWN0IGNhbGwgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChyZWRpcmVjdE9wdGlvbnMuYmVnaW4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlZGlyZWN0T3B0aW9ucy5iZWdpbi5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cyk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRpcmVjdGlvbiA9IGVmZmVjdE5hbWUubWF0Y2goLyhJbnxPdXQpJC8pO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogTWFrZSBcImluXCIgdHJhbnNpdGlvbmluZyBlbGVtZW50cyBpbnZpc2libGUgaW1tZWRpYXRlbHkgc28gdGhhdCB0aGVyZSdzIG5vIEZPVUMgYmV0d2VlbiBub3dcblx0XHRcdFx0XHRcdFx0XHQgYW5kIHRoZSBmaXJzdCBSQUYgdGljay4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoKGRpcmVjdGlvbiAmJiBkaXJlY3Rpb25bMF0gPT09IFwiSW5cIikgJiYgcHJvcGVydHlNYXAub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQkLmVhY2goZWxlbWVudHMubm9kZVR5cGUgPyBbZWxlbWVudHNdIDogZWxlbWVudHMsIGZ1bmN0aW9uKGksIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJvcGFjaXR5XCIsIDApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogT25seSB0cmlnZ2VyIGFuaW1hdGVQYXJlbnRIZWlnaHQoKSBpZiB3ZSdyZSB1c2luZyBhbiBJbi9PdXQgdHJhbnNpdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAocmVkaXJlY3RPcHRpb25zLmFuaW1hdGVQYXJlbnRIZWlnaHQgJiYgZGlyZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhbmltYXRlUGFyZW50SGVpZ2h0KGVsZW1lbnRzLCBkaXJlY3Rpb25bMF0sIHJlZGlyZWN0RHVyYXRpb24gKyBvcHRzLmRlbGF5LCByZWRpcmVjdE9wdGlvbnMuc3RhZ2dlcik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBJZiB0aGUgdXNlciBpc24ndCBvdmVycmlkaW5nIHRoZSBkaXNwbGF5IG9wdGlvbiwgZGVmYXVsdCB0byBcImF1dG9cIiBmb3IgXCJJblwiLXN1ZmZpeGVkIHRyYW5zaXRpb25zLiAqL1xuXHRcdFx0XHRcdFx0aWYgKHJlZGlyZWN0T3B0aW9ucy5kaXNwbGF5ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChyZWRpcmVjdE9wdGlvbnMuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIHJlZGlyZWN0T3B0aW9ucy5kaXNwbGF5ICE9PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdFx0XHRcdG9wdHMuZGlzcGxheSA9IHJlZGlyZWN0T3B0aW9ucy5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKC9JbiQvLnRlc3QoZWZmZWN0TmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBJbmxpbmUgZWxlbWVudHMgY2Fubm90IGJlIHN1YmplY3RlZCB0byB0cmFuc2Zvcm1zLCBzbyB3ZSBzd2l0Y2ggdGhlbSB0byBpbmxpbmUtYmxvY2suICovXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRlZmF1bHREaXNwbGF5ID0gVmVsb2NpdHkuQ1NTLlZhbHVlcy5nZXREaXNwbGF5VHlwZShlbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0XHRvcHRzLmRpc3BsYXkgPSAoZGVmYXVsdERpc3BsYXkgPT09IFwiaW5saW5lXCIpID8gXCJpbmxpbmUtYmxvY2tcIiA6IGRlZmF1bHREaXNwbGF5O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChyZWRpcmVjdE9wdGlvbnMudmlzaWJpbGl0eSAmJiByZWRpcmVjdE9wdGlvbnMudmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdFx0XHRvcHRzLnZpc2liaWxpdHkgPSByZWRpcmVjdE9wdGlvbnMudmlzaWJpbGl0eTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBTcGVjaWFsIHByb2Nlc3NpbmcgZm9yIHRoZSBsYXN0IGVmZmVjdCBjYWxsLiAqL1xuXHRcdFx0XHRcdGlmIChjYWxsSW5kZXggPT09IHByb3BlcnRpZXMuY2FsbHMubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0LyogQXBwZW5kIHByb21pc2UgcmVzb2x2aW5nIG9udG8gdGhlIHVzZXIncyByZWRpcmVjdCBjYWxsYmFjay4gKi9cblx0XHRcdFx0XHRcdHZhciBpbmplY3RGaW5hbENhbGxiYWNrcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoKHJlZGlyZWN0T3B0aW9ucy5kaXNwbGF5ID09PSB1bmRlZmluZWQgfHwgcmVkaXJlY3RPcHRpb25zLmRpc3BsYXkgPT09IFwibm9uZVwiKSAmJiAvT3V0JC8udGVzdChlZmZlY3ROYW1lKSkge1xuXHRcdFx0XHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cy5ub2RlVHlwZSA/IFtlbGVtZW50c10gOiBlbGVtZW50cywgZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAocmVkaXJlY3RPcHRpb25zLmNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVkaXJlY3RPcHRpb25zLmNvbXBsZXRlLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAocHJvbWlzZURhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZXNvbHZlcihlbGVtZW50cyB8fCBlbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0b3B0cy5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRpZiAobG9vcCkge1xuXHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LlJlZGlyZWN0c1tlZmZlY3ROYW1lXShlbGVtZW50LCByZWRpcmVjdE9wdGlvbnMsIGVsZW1lbnRzSW5kZXgsIGVsZW1lbnRzU2l6ZSwgZWxlbWVudHMsIHByb21pc2VEYXRhLCBsb29wID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KDAsIGxvb3AgLSAxKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHByb3BlcnRpZXMucmVzZXQpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciByZXNldFByb3BlcnR5IGluIHByb3BlcnRpZXMucmVzZXQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghcHJvcGVydGllcy5yZXNldC5oYXNPd25Qcm9wZXJ0eShyZXNldFByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXNldFZhbHVlID0gcHJvcGVydGllcy5yZXNldFtyZXNldFByb3BlcnR5XTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogRm9ybWF0IGVhY2ggbm9uLWFycmF5IHZhbHVlIGluIHRoZSByZXNldCBwcm9wZXJ0eSBtYXAgdG8gWyB2YWx1ZSwgdmFsdWUgXSBzbyB0aGF0IGNoYW5nZXMgYXBwbHlcblx0XHRcdFx0XHRcdFx0XHRcdCBpbW1lZGlhdGVseSBhbmQgRE9NIHF1ZXJ5aW5nIGlzIGF2b2lkZWQgKHZpYSBmb3JjZWZlZWRpbmcpLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogRG9uJ3QgZm9yY2VmZWVkIGhvb2tzLCBvdGhlcndpc2UgdGhlaXIgaG9vayByb290cyB3aWxsIGJlIGRlZmF1bHRlZCB0byB0aGVpciBudWxsIHZhbHVlcy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5DU1MuSG9va3MucmVnaXN0ZXJlZFtyZXNldFByb3BlcnR5XSA9PT0gdW5kZWZpbmVkICYmICh0eXBlb2YgcmVzZXRWYWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcmVzZXRWYWx1ZSA9PT0gXCJudW1iZXJcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydGllcy5yZXNldFtyZXNldFByb3BlcnR5XSA9IFtwcm9wZXJ0aWVzLnJlc2V0W3Jlc2V0UHJvcGVydHldLCBwcm9wZXJ0aWVzLnJlc2V0W3Jlc2V0UHJvcGVydHldXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBTbyB0aGF0IHRoZSByZXNldCB2YWx1ZXMgYXJlIGFwcGxpZWQgaW5zdGFudGx5IHVwb24gdGhlIG5leHQgckFGIHRpY2ssIHVzZSBhIHplcm8gZHVyYXRpb24gYW5kIHBhcmFsbGVsIHF1ZXVlaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXNldE9wdGlvbnMgPSB7ZHVyYXRpb246IDAsIHF1ZXVlOiBmYWxzZX07XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBTaW5jZSB0aGUgcmVzZXQgb3B0aW9uIHVzZXMgdXAgdGhlIGNvbXBsZXRlIGNhbGxiYWNrLCB3ZSB0cmlnZ2VyIHRoZSB1c2VyJ3MgY29tcGxldGUgY2FsbGJhY2sgYXQgdGhlIGVuZCBvZiBvdXJzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChmaW5hbEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc2V0T3B0aW9ucy5jb21wbGV0ZSA9IGluamVjdEZpbmFsQ2FsbGJhY2tzO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LmFuaW1hdGUoZWxlbWVudCwgcHJvcGVydGllcy5yZXNldCwgcmVzZXRPcHRpb25zKTtcblx0XHRcdFx0XHRcdFx0XHQvKiBPbmx5IHRyaWdnZXIgdGhlIHVzZXIncyBjb21wbGV0ZSBjYWxsYmFjayBvbiB0aGUgbGFzdCBlZmZlY3QgY2FsbCB3aXRoIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHNldC4gKi9cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChmaW5hbEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpbmplY3RGaW5hbENhbGxiYWNrcygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRpZiAocmVkaXJlY3RPcHRpb25zLnZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcblx0XHRcdFx0XHRcdFx0b3B0cy52aXNpYmlsaXR5ID0gcmVkaXJlY3RPcHRpb25zLnZpc2liaWxpdHk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0VmVsb2NpdHkuYW5pbWF0ZShlbGVtZW50LCBwcm9wZXJ0eU1hcCwgb3B0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8qIFJldHVybiB0aGUgVmVsb2NpdHkgb2JqZWN0IHNvIHRoYXQgUmVnaXN0ZXJVSSBjYWxscyBjYW4gYmUgY2hhaW5lZC4gKi9cblx0XHRcdHJldHVybiBWZWxvY2l0eTtcblx0XHR9O1xuXG5cdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdCBQYWNrYWdlZCBFZmZlY3RzXG5cdFx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdC8qIEV4dGVybmFsaXplIHRoZSBwYWNrYWdlZEVmZmVjdHMgZGF0YSBzbyB0aGF0IHRoZXkgY2FuIG9wdGlvbmFsbHkgYmUgbW9kaWZpZWQgYW5kIHJlLXJlZ2lzdGVyZWQuICovXG5cdFx0LyogU3VwcG9ydDogPD1JRTg6IENhbGxvdXRzIHdpbGwgaGF2ZSBubyBlZmZlY3QsIGFuZCB0cmFuc2l0aW9ucyB3aWxsIHNpbXBseSBmYWRlIGluL291dC4gSUU5L0FuZHJvaWQgMi4zOiBNb3N0IGVmZmVjdHMgYXJlIGZ1bGx5IHN1cHBvcnRlZCwgdGhlIHJlc3QgZmFkZSBpbi9vdXQuIEFsbCBvdGhlciBicm93c2VyczogZnVsbCBzdXBwb3J0LiAqL1xuXHRcdFZlbG9jaXR5LlJlZ2lzdGVyRWZmZWN0LnBhY2thZ2VkRWZmZWN0cyA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvKiBBbmltYXRlLmNzcyAqL1xuXHRcdFx0XHRcdFwiY2FsbG91dC5ib3VuY2VcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA1NTAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe3RyYW5zbGF0ZVk6IC0zMH0sIDAuMjVdLFxuXHRcdFx0XHRcdFx0XHRbe3RyYW5zbGF0ZVk6IDB9LCAwLjEyNV0sXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWTogLTE1fSwgMC4xMjVdLFxuXHRcdFx0XHRcdFx0XHRbe3RyYW5zbGF0ZVk6IDB9LCAwLjI1XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogQW5pbWF0ZS5jc3MgKi9cblx0XHRcdFx0XHRcImNhbGxvdXQuc2hha2VcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA4MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe3RyYW5zbGF0ZVg6IC0xMX1dLFxuXHRcdFx0XHRcdFx0XHRbe3RyYW5zbGF0ZVg6IDExfV0sXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWDogLTExfV0sXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWDogMTF9XSxcblx0XHRcdFx0XHRcdFx0W3t0cmFuc2xhdGVYOiAtMTF9XSxcblx0XHRcdFx0XHRcdFx0W3t0cmFuc2xhdGVYOiAxMX1dLFxuXHRcdFx0XHRcdFx0XHRbe3RyYW5zbGF0ZVg6IC0xMX1dLFxuXHRcdFx0XHRcdFx0XHRbe3RyYW5zbGF0ZVg6IDB9XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogQW5pbWF0ZS5jc3MgKi9cblx0XHRcdFx0XHRcImNhbGxvdXQuZmxhc2hcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiAxMTAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMCwgXCJlYXNlSW5PdXRRdWFkXCIsIDFdfV0sXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzEsIFwiZWFzZUluT3V0UXVhZFwiXX1dLFxuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCBcImVhc2VJbk91dFF1YWRcIl19XSxcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgXCJlYXNlSW5PdXRRdWFkXCJdfV1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIEFuaW1hdGUuY3NzICovXG5cdFx0XHRcdFx0XCJjYWxsb3V0LnB1bHNlXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogODI1LFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tzY2FsZVg6IDEuMSwgc2NhbGVZOiAxLjF9LCAwLjUwLCB7ZWFzaW5nOiBcImVhc2VJbkV4cG9cIn1dLFxuXHRcdFx0XHRcdFx0XHRbe3NjYWxlWDogMSwgc2NhbGVZOiAxfSwgMC41MF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIEFuaW1hdGUuY3NzICovXG5cdFx0XHRcdFx0XCJjYWxsb3V0LnN3aW5nXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogOTUwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tyb3RhdGVaOiAxNX1dLFxuXHRcdFx0XHRcdFx0XHRbe3JvdGF0ZVo6IC0xMH1dLFxuXHRcdFx0XHRcdFx0XHRbe3JvdGF0ZVo6IDV9XSxcblx0XHRcdFx0XHRcdFx0W3tyb3RhdGVaOiAtNX1dLFxuXHRcdFx0XHRcdFx0XHRbe3JvdGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogQW5pbWF0ZS5jc3MgKi9cblx0XHRcdFx0XHRcImNhbGxvdXQudGFkYVwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDEwMDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe3NjYWxlWDogMC45LCBzY2FsZVk6IDAuOSwgcm90YXRlWjogLTN9LCAwLjEwXSxcblx0XHRcdFx0XHRcdFx0W3tzY2FsZVg6IDEuMSwgc2NhbGVZOiAxLjEsIHJvdGF0ZVo6IDN9LCAwLjEwXSxcblx0XHRcdFx0XHRcdFx0W3tzY2FsZVg6IDEuMSwgc2NhbGVZOiAxLjEsIHJvdGF0ZVo6IC0zfSwgMC4xMF0sXG5cdFx0XHRcdFx0XHRcdFtcInJldmVyc2VcIiwgMC4xMjVdLFxuXHRcdFx0XHRcdFx0XHRbXCJyZXZlcnNlXCIsIDAuMTI1XSxcblx0XHRcdFx0XHRcdFx0W1wicmV2ZXJzZVwiLCAwLjEyNV0sXG5cdFx0XHRcdFx0XHRcdFtcInJldmVyc2VcIiwgMC4xMjVdLFxuXHRcdFx0XHRcdFx0XHRbXCJyZXZlcnNlXCIsIDAuMTI1XSxcblx0XHRcdFx0XHRcdFx0W3tzY2FsZVg6IDEsIHNjYWxlWTogMSwgcm90YXRlWjogMH0sIDAuMjBdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcInRyYW5zaXRpb24uZmFkZUluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogNTAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF19XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLmZhZGVPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA1MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCAxXX1dXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiBTdXBwb3J0OiBMb3NlcyByb3RhdGlvbiBpbiBJRTkvQW5kcm9pZCAyLjMgKGZhZGVzIG9ubHkpLiAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5mbGlwWEluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogNzAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBbODAwLCA4MDBdLCByb3RhdGVZOiBbMCwgLTU1XX1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogMH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIFN1cHBvcnQ6IExvc2VzIHJvdGF0aW9uIGluIElFOS9BbmRyb2lkIDIuMyAoZmFkZXMgb25seSkuICovXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLmZsaXBYT3V0XCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogNzAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMCwgMV0sIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBbODAwLCA4MDBdLCByb3RhdGVZOiA1NX1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogMCwgcm90YXRlWTogMH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIFN1cHBvcnQ6IExvc2VzIHJvdGF0aW9uIGluIElFOS9BbmRyb2lkIDIuMyAoZmFkZXMgb25seSkuICovXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLmZsaXBZSW5cIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA4MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFsxLCAwXSwgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFs4MDAsIDgwMF0sIHJvdGF0ZVg6IFswLCAtNDVdfV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zZm9ybVBlcnNwZWN0aXZlOiAwfVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogU3VwcG9ydDogTG9zZXMgcm90YXRpb24gaW4gSUU5L0FuZHJvaWQgMi4zIChmYWRlcyBvbmx5KS4gKi9cblx0XHRcdFx0XHRcInRyYW5zaXRpb24uZmxpcFlPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA4MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCAxXSwgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFs4MDAsIDgwMF0sIHJvdGF0ZVg6IDI1fV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zZm9ybVBlcnNwZWN0aXZlOiAwLCByb3RhdGVYOiAwfVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogQW5pbWF0ZS5jc3MgKi9cblx0XHRcdFx0XHQvKiBTdXBwb3J0OiBMb3NlcyByb3RhdGlvbiBpbiBJRTkvQW5kcm9pZCAyLjMgKGZhZGVzIG9ubHkpLiAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5mbGlwQm91bmNlWEluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogOTAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMC43MjUsIDBdLCB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogWzQwMCwgNDAwXSwgcm90YXRlWTogWy0xMCwgOTBdfSwgMC41MF0sXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogMC44MCwgcm90YXRlWTogMTB9LCAwLjI1XSxcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiAxLCByb3RhdGVZOiAwfSwgMC4yNV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zZm9ybVBlcnNwZWN0aXZlOiAwfVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogQW5pbWF0ZS5jc3MgKi9cblx0XHRcdFx0XHQvKiBTdXBwb3J0OiBMb3NlcyByb3RhdGlvbiBpbiBJRTkvQW5kcm9pZCAyLjMgKGZhZGVzIG9ubHkpLiAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5mbGlwQm91bmNlWE91dFwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDgwMCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzAuOSwgMV0sIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBbNDAwLCA0MDBdLCByb3RhdGVZOiAtMTB9XSxcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiAwLCByb3RhdGVZOiA5MH1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogMCwgcm90YXRlWTogMH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIEFuaW1hdGUuY3NzICovXG5cdFx0XHRcdFx0LyogU3VwcG9ydDogTG9zZXMgcm90YXRpb24gaW4gSUU5L0FuZHJvaWQgMi4zIChmYWRlcyBvbmx5KS4gKi9cblx0XHRcdFx0XHRcInRyYW5zaXRpb24uZmxpcEJvdW5jZVlJblwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDg1MCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzAuNzI1LCAwXSwgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFs0MDAsIDQwMF0sIHJvdGF0ZVg6IFstMTAsIDkwXX0sIDAuNTBdLFxuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IDAuODAsIHJvdGF0ZVg6IDEwfSwgMC4yNV0sXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogMSwgcm90YXRlWDogMH0sIDAuMjVdXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogMH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIEFuaW1hdGUuY3NzICovXG5cdFx0XHRcdFx0LyogU3VwcG9ydDogTG9zZXMgcm90YXRpb24gaW4gSUU5L0FuZHJvaWQgMi4zIChmYWRlcyBvbmx5KS4gKi9cblx0XHRcdFx0XHRcInRyYW5zaXRpb24uZmxpcEJvdW5jZVlPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA4MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLjksIDFdLCB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogWzQwMCwgNDAwXSwgcm90YXRlWDogLTE1fV0sXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogMCwgcm90YXRlWDogOTB9XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2V0OiB7dHJhbnNmb3JtUGVyc3BlY3RpdmU6IDAsIHJvdGF0ZVg6IDB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiBNYWdpYy5jc3MgKi9cblx0XHRcdFx0XHRcInRyYW5zaXRpb24uc3dvb3BJblwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDg1MCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzEsIDBdLCB0cmFuc2Zvcm1PcmlnaW5YOiBbXCIxMDAlXCIsIFwiNTAlXCJdLCB0cmFuc2Zvcm1PcmlnaW5ZOiBbXCIxMDAlXCIsIFwiMTAwJVwiXSwgc2NhbGVYOiBbMSwgMF0sIHNjYWxlWTogWzEsIDBdLCB0cmFuc2xhdGVYOiBbMCwgLTcwMF0sIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2V0OiB7dHJhbnNmb3JtT3JpZ2luWDogXCI1MCVcIiwgdHJhbnNmb3JtT3JpZ2luWTogXCI1MCVcIn1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIE1hZ2ljLmNzcyAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5zd29vcE91dFwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDg1MCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzAsIDFdLCB0cmFuc2Zvcm1PcmlnaW5YOiBbXCI1MCVcIiwgXCIxMDAlXCJdLCB0cmFuc2Zvcm1PcmlnaW5ZOiBbXCIxMDAlXCIsIFwiMTAwJVwiXSwgc2NhbGVYOiAwLCBzY2FsZVk6IDAsIHRyYW5zbGF0ZVg6IC03MDAsIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2V0OiB7dHJhbnNmb3JtT3JpZ2luWDogXCI1MCVcIiwgdHJhbnNmb3JtT3JpZ2luWTogXCI1MCVcIiwgc2NhbGVYOiAxLCBzY2FsZVk6IDEsIHRyYW5zbGF0ZVg6IDB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiBNYWdpYy5jc3MgKi9cblx0XHRcdFx0XHQvKiBTdXBwb3J0OiBMb3NlcyByb3RhdGlvbiBpbiBJRTkvQW5kcm9pZCAyLjMuIChGYWRlcyBhbmQgc2NhbGVzIG9ubHkuKSAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi53aGlybEluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogODUwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zZm9ybU9yaWdpblg6IFtcIjUwJVwiLCBcIjUwJVwiXSwgdHJhbnNmb3JtT3JpZ2luWTogW1wiNTAlXCIsIFwiNTAlXCJdLCBzY2FsZVg6IFsxLCAwXSwgc2NhbGVZOiBbMSwgMF0sIHJvdGF0ZVk6IFswLCAxNjBdfSwgMSwge2Vhc2luZzogXCJlYXNlSW5PdXRTaW5lXCJ9XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogTWFnaWMuY3NzICovXG5cdFx0XHRcdFx0LyogU3VwcG9ydDogTG9zZXMgcm90YXRpb24gaW4gSUU5L0FuZHJvaWQgMi4zLiAoRmFkZXMgYW5kIHNjYWxlcyBvbmx5LikgKi9cblx0XHRcdFx0XHRcInRyYW5zaXRpb24ud2hpcmxPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA3NTAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCBcImVhc2VJbk91dFF1aW50XCIsIDFdLCB0cmFuc2Zvcm1PcmlnaW5YOiBbXCI1MCVcIiwgXCI1MCVcIl0sIHRyYW5zZm9ybU9yaWdpblk6IFtcIjUwJVwiLCBcIjUwJVwiXSwgc2NhbGVYOiAwLCBzY2FsZVk6IDAsIHJvdGF0ZVk6IDE2MH0sIDEsIHtlYXNpbmc6IFwic3dpbmdcIn1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHtzY2FsZVg6IDEsIHNjYWxlWTogMSwgcm90YXRlWTogMH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5zaHJpbmtJblwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDc1MCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzEsIDBdLCB0cmFuc2Zvcm1PcmlnaW5YOiBbXCI1MCVcIiwgXCI1MCVcIl0sIHRyYW5zZm9ybU9yaWdpblk6IFtcIjUwJVwiLCBcIjUwJVwiXSwgc2NhbGVYOiBbMSwgMS41XSwgc2NhbGVZOiBbMSwgMS41XSwgdHJhbnNsYXRlWjogMH1dXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcInRyYW5zaXRpb24uc2hyaW5rT3V0XCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogNjAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMCwgMV0sIHRyYW5zZm9ybU9yaWdpblg6IFtcIjUwJVwiLCBcIjUwJVwiXSwgdHJhbnNmb3JtT3JpZ2luWTogW1wiNTAlXCIsIFwiNTAlXCJdLCBzY2FsZVg6IDEuMywgc2NhbGVZOiAxLjMsIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2V0OiB7c2NhbGVYOiAxLCBzY2FsZVk6IDF9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcInRyYW5zaXRpb24uZXhwYW5kSW5cIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA3MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFsxLCAwXSwgdHJhbnNmb3JtT3JpZ2luWDogW1wiNTAlXCIsIFwiNTAlXCJdLCB0cmFuc2Zvcm1PcmlnaW5ZOiBbXCI1MCVcIiwgXCI1MCVcIl0sIHNjYWxlWDogWzEsIDAuNjI1XSwgc2NhbGVZOiBbMSwgMC42MjVdLCB0cmFuc2xhdGVaOiAwfV1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5leHBhbmRPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA3MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCAxXSwgdHJhbnNmb3JtT3JpZ2luWDogW1wiNTAlXCIsIFwiNTAlXCJdLCB0cmFuc2Zvcm1PcmlnaW5ZOiBbXCI1MCVcIiwgXCI1MCVcIl0sIHNjYWxlWDogMC41LCBzY2FsZVk6IDAuNSwgdHJhbnNsYXRlWjogMH1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHtzY2FsZVg6IDEsIHNjYWxlWTogMX1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIEFuaW1hdGUuY3NzICovXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLmJvdW5jZUluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogODAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHNjYWxlWDogWzEuMDUsIDAuM10sIHNjYWxlWTogWzEuMDUsIDAuM119LCAwLjM1XSxcblx0XHRcdFx0XHRcdFx0W3tzY2FsZVg6IDAuOSwgc2NhbGVZOiAwLjksIHRyYW5zbGF0ZVo6IDB9LCAwLjIwXSxcblx0XHRcdFx0XHRcdFx0W3tzY2FsZVg6IDEsIHNjYWxlWTogMX0sIDAuNDVdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiBBbmltYXRlLmNzcyAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5ib3VuY2VPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA4MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe3NjYWxlWDogMC45NSwgc2NhbGVZOiAwLjk1fSwgMC4zNV0sXG5cdFx0XHRcdFx0XHRcdFt7c2NhbGVYOiAxLjEsIHNjYWxlWTogMS4xLCB0cmFuc2xhdGVaOiAwfSwgMC4zNV0sXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzAsIDFdLCBzY2FsZVg6IDAuMywgc2NhbGVZOiAwLjN9LCAwLjMwXVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2V0OiB7c2NhbGVYOiAxLCBzY2FsZVk6IDF9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiBBbmltYXRlLmNzcyAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5ib3VuY2VVcEluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogODAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zbGF0ZVk6IFstMzAsIDEwMDBdfSwgMC42MCwge2Vhc2luZzogXCJlYXNlT3V0Q2lyY1wifV0sXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWTogMTB9LCAwLjIwXSxcblx0XHRcdFx0XHRcdFx0W3t0cmFuc2xhdGVZOiAwfSwgMC4yMF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIEFuaW1hdGUuY3NzICovXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLmJvdW5jZVVwT3V0XCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogMTAwMCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWTogMjB9LCAwLjIwXSxcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMCwgXCJlYXNlSW5DaXJjXCIsIDFdLCB0cmFuc2xhdGVZOiAtMTAwMH0sIDAuODBdXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2xhdGVZOiAwfVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogQW5pbWF0ZS5jc3MgKi9cblx0XHRcdFx0XHRcInRyYW5zaXRpb24uYm91bmNlRG93bkluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogODAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zbGF0ZVk6IFszMCwgLTEwMDBdfSwgMC42MCwge2Vhc2luZzogXCJlYXNlT3V0Q2lyY1wifV0sXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWTogLTEwfSwgMC4yMF0sXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWTogMH0sIDAuMjBdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiBBbmltYXRlLmNzcyAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5ib3VuY2VEb3duT3V0XCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogMTAwMCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWTogLTIwfSwgMC4yMF0sXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzAsIFwiZWFzZUluQ2lyY1wiLCAxXSwgdHJhbnNsYXRlWTogMTAwMH0sIDAuODBdXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2xhdGVZOiAwfVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogQW5pbWF0ZS5jc3MgKi9cblx0XHRcdFx0XHRcInRyYW5zaXRpb24uYm91bmNlTGVmdEluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogNzUwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zbGF0ZVg6IFszMCwgLTEyNTBdfSwgMC42MCwge2Vhc2luZzogXCJlYXNlT3V0Q2lyY1wifV0sXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWDogLTEwfSwgMC4yMF0sXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWDogMH0sIDAuMjBdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiBBbmltYXRlLmNzcyAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5ib3VuY2VMZWZ0T3V0XCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogNzUwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3t0cmFuc2xhdGVYOiAzMH0sIDAuMjBdLFxuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCBcImVhc2VJbkNpcmNcIiwgMV0sIHRyYW5zbGF0ZVg6IC0xMjUwfSwgMC44MF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zbGF0ZVg6IDB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiBBbmltYXRlLmNzcyAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5ib3VuY2VSaWdodEluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogNzUwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zbGF0ZVg6IFstMzAsIDEyNTBdfSwgMC42MCwge2Vhc2luZzogXCJlYXNlT3V0Q2lyY1wifV0sXG5cdFx0XHRcdFx0XHRcdFt7dHJhbnNsYXRlWDogMTB9LCAwLjIwXSxcblx0XHRcdFx0XHRcdFx0W3t0cmFuc2xhdGVYOiAwfSwgMC4yMF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIEFuaW1hdGUuY3NzICovXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLmJvdW5jZVJpZ2h0T3V0XCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogNzUwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3t0cmFuc2xhdGVYOiAtMzB9LCAwLjIwXSxcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMCwgXCJlYXNlSW5DaXJjXCIsIDFdLCB0cmFuc2xhdGVYOiAxMjUwfSwgMC44MF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zbGF0ZVg6IDB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcInRyYW5zaXRpb24uc2xpZGVVcEluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogOTAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zbGF0ZVk6IFswLCAyMF0sIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnNsaWRlVXBPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA5MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCAxXSwgdHJhbnNsYXRlWTogLTIwLCB0cmFuc2xhdGVaOiAwfV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zbGF0ZVk6IDB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcInRyYW5zaXRpb24uc2xpZGVEb3duSW5cIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA5MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFsxLCAwXSwgdHJhbnNsYXRlWTogWzAsIC0yMF0sIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnNsaWRlRG93bk91dFwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDkwMCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzAsIDFdLCB0cmFuc2xhdGVZOiAyMCwgdHJhbnNsYXRlWjogMH1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2xhdGVZOiAwfVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnNsaWRlTGVmdEluXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogMTAwMCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzEsIDBdLCB0cmFuc2xhdGVYOiBbMCwgLTIwXSwgdHJhbnNsYXRlWjogMH1dXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcInRyYW5zaXRpb24uc2xpZGVMZWZ0T3V0XCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogMTA1MCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzAsIDFdLCB0cmFuc2xhdGVYOiAtMjAsIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2V0OiB7dHJhbnNsYXRlWDogMH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5zbGlkZVJpZ2h0SW5cIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiAxMDAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zbGF0ZVg6IFswLCAyMF0sIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnNsaWRlUmlnaHRPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiAxMDUwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMCwgMV0sIHRyYW5zbGF0ZVg6IDIwLCB0cmFuc2xhdGVaOiAwfV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zbGF0ZVg6IDB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcInRyYW5zaXRpb24uc2xpZGVVcEJpZ0luXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogODUwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zbGF0ZVk6IFswLCA3NV0sIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnNsaWRlVXBCaWdPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA4MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCAxXSwgdHJhbnNsYXRlWTogLTc1LCB0cmFuc2xhdGVaOiAwfV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zbGF0ZVk6IDB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcInRyYW5zaXRpb24uc2xpZGVEb3duQmlnSW5cIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA4NTAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFsxLCAwXSwgdHJhbnNsYXRlWTogWzAsIC03NV0sIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnNsaWRlRG93bkJpZ091dFwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDgwMCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzAsIDFdLCB0cmFuc2xhdGVZOiA3NSwgdHJhbnNsYXRlWjogMH1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2xhdGVZOiAwfVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnNsaWRlTGVmdEJpZ0luXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogODAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zbGF0ZVg6IFswLCAtNzVdLCB0cmFuc2xhdGVaOiAwfV1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5zbGlkZUxlZnRCaWdPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA3NTAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCAxXSwgdHJhbnNsYXRlWDogLTc1LCB0cmFuc2xhdGVaOiAwfV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zbGF0ZVg6IDB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcInRyYW5zaXRpb24uc2xpZGVSaWdodEJpZ0luXCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogODAwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMSwgMF0sIHRyYW5zbGF0ZVg6IFswLCA3NV0sIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnNsaWRlUmlnaHRCaWdPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA3NTAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCAxXSwgdHJhbnNsYXRlWDogNzUsIHRyYW5zbGF0ZVo6IDB9XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2V0OiB7dHJhbnNsYXRlWDogMH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIE1hZ2ljLmNzcyAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5wZXJzcGVjdGl2ZVVwSW5cIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA4MDAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFsxLCAwXSwgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFs4MDAsIDgwMF0sIHRyYW5zZm9ybU9yaWdpblg6IFswLCAwXSwgdHJhbnNmb3JtT3JpZ2luWTogW1wiMTAwJVwiLCBcIjEwMCVcIl0sIHJvdGF0ZVg6IFswLCAtMTgwXX1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogMCwgdHJhbnNmb3JtT3JpZ2luWDogXCI1MCVcIiwgdHJhbnNmb3JtT3JpZ2luWTogXCI1MCVcIn1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIE1hZ2ljLmNzcyAqL1xuXHRcdFx0XHRcdC8qIFN1cHBvcnQ6IExvc2VzIHJvdGF0aW9uIGluIElFOS9BbmRyb2lkIDIuMyAoZmFkZXMgb25seSkuICovXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnBlcnNwZWN0aXZlVXBPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA4NTAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCAxXSwgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFs4MDAsIDgwMF0sIHRyYW5zZm9ybU9yaWdpblg6IFswLCAwXSwgdHJhbnNmb3JtT3JpZ2luWTogW1wiMTAwJVwiLCBcIjEwMCVcIl0sIHJvdGF0ZVg6IC0xODB9XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2V0OiB7dHJhbnNmb3JtUGVyc3BlY3RpdmU6IDAsIHRyYW5zZm9ybU9yaWdpblg6IFwiNTAlXCIsIHRyYW5zZm9ybU9yaWdpblk6IFwiNTAlXCIsIHJvdGF0ZVg6IDB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiBNYWdpYy5jc3MgKi9cblx0XHRcdFx0XHQvKiBTdXBwb3J0OiBMb3NlcyByb3RhdGlvbiBpbiBJRTkvQW5kcm9pZCAyLjMgKGZhZGVzIG9ubHkpLiAqL1xuXHRcdFx0XHRcdFwidHJhbnNpdGlvbi5wZXJzcGVjdGl2ZURvd25JblwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDgwMCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzEsIDBdLCB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogWzgwMCwgODAwXSwgdHJhbnNmb3JtT3JpZ2luWDogWzAsIDBdLCB0cmFuc2Zvcm1PcmlnaW5ZOiBbMCwgMF0sIHJvdGF0ZVg6IFswLCAxODBdfV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zZm9ybVBlcnNwZWN0aXZlOiAwLCB0cmFuc2Zvcm1PcmlnaW5YOiBcIjUwJVwiLCB0cmFuc2Zvcm1PcmlnaW5ZOiBcIjUwJVwifVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogTWFnaWMuY3NzICovXG5cdFx0XHRcdFx0LyogU3VwcG9ydDogTG9zZXMgcm90YXRpb24gaW4gSUU5L0FuZHJvaWQgMi4zIChmYWRlcyBvbmx5KS4gKi9cblx0XHRcdFx0XHRcInRyYW5zaXRpb24ucGVyc3BlY3RpdmVEb3duT3V0XCI6IHtcblx0XHRcdFx0XHRcdGRlZmF1bHREdXJhdGlvbjogODUwLFxuXHRcdFx0XHRcdFx0Y2FsbHM6IFtcblx0XHRcdFx0XHRcdFx0W3tvcGFjaXR5OiBbMCwgMV0sIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBbODAwLCA4MDBdLCB0cmFuc2Zvcm1PcmlnaW5YOiBbMCwgMF0sIHRyYW5zZm9ybU9yaWdpblk6IFswLCAwXSwgcm90YXRlWDogMTgwfV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zZm9ybVBlcnNwZWN0aXZlOiAwLCB0cmFuc2Zvcm1PcmlnaW5YOiBcIjUwJVwiLCB0cmFuc2Zvcm1PcmlnaW5ZOiBcIjUwJVwiLCByb3RhdGVYOiAwfVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogTWFnaWMuY3NzICovXG5cdFx0XHRcdFx0LyogU3VwcG9ydDogTG9zZXMgcm90YXRpb24gaW4gSUU5L0FuZHJvaWQgMi4zIChmYWRlcyBvbmx5KS4gKi9cblx0XHRcdFx0XHRcInRyYW5zaXRpb24ucGVyc3BlY3RpdmVMZWZ0SW5cIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA5NTAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFsxLCAwXSwgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFsyMDAwLCAyMDAwXSwgdHJhbnNmb3JtT3JpZ2luWDogWzAsIDBdLCB0cmFuc2Zvcm1PcmlnaW5ZOiBbMCwgMF0sIHJvdGF0ZVk6IFswLCAtMTgwXX1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogMCwgdHJhbnNmb3JtT3JpZ2luWDogXCI1MCVcIiwgdHJhbnNmb3JtT3JpZ2luWTogXCI1MCVcIn1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIE1hZ2ljLmNzcyAqL1xuXHRcdFx0XHRcdC8qIFN1cHBvcnQ6IExvc2VzIHJvdGF0aW9uIGluIElFOS9BbmRyb2lkIDIuMyAoZmFkZXMgb25seSkuICovXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnBlcnNwZWN0aXZlTGVmdE91dFwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDk1MCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzAsIDFdLCB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogWzIwMDAsIDIwMDBdLCB0cmFuc2Zvcm1PcmlnaW5YOiBbMCwgMF0sIHRyYW5zZm9ybU9yaWdpblk6IFswLCAwXSwgcm90YXRlWTogLTE4MH1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogMCwgdHJhbnNmb3JtT3JpZ2luWDogXCI1MCVcIiwgdHJhbnNmb3JtT3JpZ2luWTogXCI1MCVcIiwgcm90YXRlWTogMH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIE1hZ2ljLmNzcyAqL1xuXHRcdFx0XHRcdC8qIFN1cHBvcnQ6IExvc2VzIHJvdGF0aW9uIGluIElFOS9BbmRyb2lkIDIuMyAoZmFkZXMgb25seSkuICovXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnBlcnNwZWN0aXZlUmlnaHRJblwiOiB7XG5cdFx0XHRcdFx0XHRkZWZhdWx0RHVyYXRpb246IDk1MCxcblx0XHRcdFx0XHRcdGNhbGxzOiBbXG5cdFx0XHRcdFx0XHRcdFt7b3BhY2l0eTogWzEsIDBdLCB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogWzIwMDAsIDIwMDBdLCB0cmFuc2Zvcm1PcmlnaW5YOiBbXCIxMDAlXCIsIFwiMTAwJVwiXSwgdHJhbnNmb3JtT3JpZ2luWTogWzAsIDBdLCByb3RhdGVZOiBbMCwgMTgwXX1dXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXQ6IHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogMCwgdHJhbnNmb3JtT3JpZ2luWDogXCI1MCVcIiwgdHJhbnNmb3JtT3JpZ2luWTogXCI1MCVcIn1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIE1hZ2ljLmNzcyAqL1xuXHRcdFx0XHRcdC8qIFN1cHBvcnQ6IExvc2VzIHJvdGF0aW9uIGluIElFOS9BbmRyb2lkIDIuMyAoZmFkZXMgb25seSkuICovXG5cdFx0XHRcdFx0XCJ0cmFuc2l0aW9uLnBlcnNwZWN0aXZlUmlnaHRPdXRcIjoge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdER1cmF0aW9uOiA5NTAsXG5cdFx0XHRcdFx0XHRjYWxsczogW1xuXHRcdFx0XHRcdFx0XHRbe29wYWNpdHk6IFswLCAxXSwgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFsyMDAwLCAyMDAwXSwgdHJhbnNmb3JtT3JpZ2luWDogW1wiMTAwJVwiLCBcIjEwMCVcIl0sIHRyYW5zZm9ybU9yaWdpblk6IFswLCAwXSwgcm90YXRlWTogMTgwfV1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNldDoge3RyYW5zZm9ybVBlcnNwZWN0aXZlOiAwLCB0cmFuc2Zvcm1PcmlnaW5YOiBcIjUwJVwiLCB0cmFuc2Zvcm1PcmlnaW5ZOiBcIjUwJVwiLCByb3RhdGVZOiAwfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdC8qIFJlZ2lzdGVyIHRoZSBwYWNrYWdlZCBlZmZlY3RzLiAqL1xuXHRcdGZvciAodmFyIGVmZmVjdE5hbWUgaW4gVmVsb2NpdHkuUmVnaXN0ZXJFZmZlY3QucGFja2FnZWRFZmZlY3RzKSB7XG5cdFx0XHRpZiAoVmVsb2NpdHkuUmVnaXN0ZXJFZmZlY3QucGFja2FnZWRFZmZlY3RzLmhhc093blByb3BlcnR5KGVmZmVjdE5hbWUpKSB7XG5cdFx0XHRcdFZlbG9jaXR5LlJlZ2lzdGVyRWZmZWN0KGVmZmVjdE5hbWUsIFZlbG9jaXR5LlJlZ2lzdGVyRWZmZWN0LnBhY2thZ2VkRWZmZWN0c1tlZmZlY3ROYW1lXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdCBTZXF1ZW5jZSBSdW5uaW5nXG5cdFx0ICoqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHQvKiBOb3RlOiBTZXF1ZW5jZSBjYWxscyBtdXN0IHVzZSBWZWxvY2l0eSdzIHNpbmdsZS1vYmplY3QgYXJndW1lbnRzIHN5bnRheC4gKi9cblx0XHRWZWxvY2l0eS5SdW5TZXF1ZW5jZSA9IGZ1bmN0aW9uKG9yaWdpbmFsU2VxdWVuY2UpIHtcblx0XHRcdHZhciBzZXF1ZW5jZSA9ICQuZXh0ZW5kKHRydWUsIFtdLCBvcmlnaW5hbFNlcXVlbmNlKTtcblxuXHRcdFx0aWYgKHNlcXVlbmNlLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0JC5lYWNoKHNlcXVlbmNlLnJldmVyc2UoKSwgZnVuY3Rpb24oaSwgY3VycmVudENhbGwpIHtcblx0XHRcdFx0XHR2YXIgbmV4dENhbGwgPSBzZXF1ZW5jZVtpICsgMV07XG5cblx0XHRcdFx0XHRpZiAobmV4dENhbGwpIHtcblx0XHRcdFx0XHRcdC8qIFBhcmFsbGVsIHNlcXVlbmNlIGNhbGxzIChpbmRpY2F0ZWQgdmlhIHNlcXVlbmNlUXVldWU6ZmFsc2UpIGFyZSB0cmlnZ2VyZWRcblx0XHRcdFx0XHRcdCBpbiB0aGUgcHJldmlvdXMgY2FsbCdzIGJlZ2luIGNhbGxiYWNrLiBPdGhlcndpc2UsIGNoYWluZWQgY2FsbHMgYXJlIG5vcm1hbGx5IHRyaWdnZXJlZFxuXHRcdFx0XHRcdFx0IGluIHRoZSBwcmV2aW91cyBjYWxsJ3MgY29tcGxldGUgY2FsbGJhY2suICovXG5cdFx0XHRcdFx0XHR2YXIgY3VycmVudENhbGxPcHRpb25zID0gY3VycmVudENhbGwubyB8fCBjdXJyZW50Q2FsbC5vcHRpb25zLFxuXHRcdFx0XHRcdFx0XHRcdG5leHRDYWxsT3B0aW9ucyA9IG5leHRDYWxsLm8gfHwgbmV4dENhbGwub3B0aW9ucztcblxuXHRcdFx0XHRcdFx0dmFyIHRpbWluZyA9IChjdXJyZW50Q2FsbE9wdGlvbnMgJiYgY3VycmVudENhbGxPcHRpb25zLnNlcXVlbmNlUXVldWUgPT09IGZhbHNlKSA/IFwiYmVnaW5cIiA6IFwiY29tcGxldGVcIixcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFja09yaWdpbmFsID0gbmV4dENhbGxPcHRpb25zICYmIG5leHRDYWxsT3B0aW9uc1t0aW1pbmddLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMgPSB7fTtcblxuXHRcdFx0XHRcdFx0b3B0aW9uc1t0aW1pbmddID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBuZXh0Q2FsbEVsZW1lbnRzID0gbmV4dENhbGwuZSB8fCBuZXh0Q2FsbC5lbGVtZW50cztcblx0XHRcdFx0XHRcdFx0dmFyIGVsZW1lbnRzID0gbmV4dENhbGxFbGVtZW50cy5ub2RlVHlwZSA/IFtuZXh0Q2FsbEVsZW1lbnRzXSA6IG5leHRDYWxsRWxlbWVudHM7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGNhbGxiYWNrT3JpZ2luYWwpIHtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFja09yaWdpbmFsLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRWZWxvY2l0eShjdXJyZW50Q2FsbCk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRpZiAobmV4dENhbGwubykge1xuXHRcdFx0XHRcdFx0XHRuZXh0Q2FsbC5vID0gJC5leHRlbmQoe30sIG5leHRDYWxsT3B0aW9ucywgb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRuZXh0Q2FsbC5vcHRpb25zID0gJC5leHRlbmQoe30sIG5leHRDYWxsT3B0aW9ucywgb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzZXF1ZW5jZS5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdFZlbG9jaXR5KHNlcXVlbmNlWzBdKTtcblx0XHR9O1xuXHR9KCh3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byB8fCB3aW5kb3cpLCB3aW5kb3csICh3aW5kb3cgPyB3aW5kb3cuZG9jdW1lbnQgOiB1bmRlZmluZWQpKTtcbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZlbG9jaXR5LWFuaW1hdGUvdmVsb2NpdHkudWkuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJpbXBvcnQgQWpheEZvcm0gZnJvbSAnY29tcG9uZW50L2FqYXgtZm9ybSdcbmltcG9ydCBDdXN0b21JbnB1dCBmcm9tICdjb21wb25lbnQvY3VzdG9tLWlucHV0J1xuaW1wb3J0IEdvb2dsZU1hcCBmcm9tICdjb21wb25lbnQvR29vZ2xlTWFwJ1xuaW1wb3J0IG1vZGFsTUZQIGZyb20gJ2NvbXBvbmVudC9tb2RhbC1tZnAnXG5pbXBvcnQgTWFpbk5hdiBmcm9tICdjb21wb25lbnQvbWFpbi1uYXYnXG5pbXBvcnQgUGhvdG9Td2lwZSBmcm9tICdjb21wb25lbnQvZ2FsbGVyeS1waG90b3N3aXBlJ1xuaW1wb3J0IHNlbGVjdENvbXBvbmVudCBmcm9tICd1dGlsaXRpZXMvc2VsZWN0LWNvbXBvbmVudCdcbmltcG9ydCBTaGFyZSBmcm9tICdjb21wb25lbnQvU2hhcmUnXG5pbXBvcnQgU3ViTmF2IGZyb20gJ2NvbXBvbmVudC9zdWJuYXYnXG5cbmNvbnN0IEFVVE9fTU9EVUxFUyA9IFtcbiAgICBQaG90b1N3aXBlXG5dXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNpdGUoKSB7XG5cbiAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgICAgICBzdGFydERlZmF1bHQoKVxuICAgICAgICBzdGFydEN1c3RvbSgpXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICQuZWFjaChBVVRPX01PRFVMRVMsIChrZXksIE1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBNb2R1bGUoKVxuICAgICAgICAgICAgaW5zdGFuY2Uuc3RhcnQoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0Q3VzdG9tID0gKCkgPT4ge1xuXG4gICAgICAgIHNlbGVjdENvbXBvbmVudCgnYWpheC1mb3JtJykuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IG5ldyBBamF4Rm9ybShlbGVtZW50KSlcblxuICAgICAgICBjb25zdCBtYXBJY29uID0ge1xuICAgICAgICAgICAgcGF0aDogJ00xMTUyIDY0MHEwLTEwNi03NS0xODF0LTE4MS03NS0xODEgNzUtNzUgMTgxIDc1IDE4MSAxODEgNzUgMTgxLTc1IDc1LTE4MXptMjU2IDBxMCAxMDktMzMgMTc5bC0zNjQgNzc0cS0xNiAzMy00Ny41IDUydC02Ny41IDE5LTY3LjUtMTktNDYuNS01MmwtMzY1LTc3NHEtMzMtNzAtMzMtMTc5IDAtMjEyIDE1MC0zNjJ0MzYyLTE1MCAzNjIgMTUwIDE1MCAzNjJ6JyxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgICAgICAgICAgc2NhbGU6IC4wMixcbiAgICAgICAgICAgIGFuY2hvcjogbmV3IGdvb2dsZS5tYXBzLlBvaW50KDg5NiwgMTc5MilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGltYWdlT3ZlcmxheXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9ydGhFYXN0OiB7XG4gICAgICAgICAgICAgICAgICAgIFwibGF0XCIgOiAzOC4yNjY1LFxuICAgICAgICAgICAgICAgICAgICBcImxuZ1wiIDogLTg1LjYyNzdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNvdXRoV2VzdDoge1xuICAgICAgICAgICAgICAgICAgICBcImxhdFwiIDogMzguMjI5NjA3LFxuICAgICAgICAgICAgICAgICAgICBcImxuZ1wiIDogLTg1LjcyMDYwN1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW1hZ2U6ICdodHRwOi8vdmlhLnBsYWNlaG9sZGVyLmNvbS80MDB4MjAwJyxcbiAgICAgICAgICAgICAgICBzaG93Qm91bmRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGltcG9ydFNWRzogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF1cblxuICAgICAgICBzZWxlY3RDb21wb25lbnQoJ2xvY2F0aW9ucy1tYXAnKS5lYWNoKChpbmRleCwgZWxlbWVudCkgPT4gbmV3IEdvb2dsZU1hcChpbmRleCwgZWxlbWVudCwge2xvY2F0aW9uczogd2luZG93LkxPQ0FUSU9OUywgaWNvbjogbWFwSWNvbiwgaW1hZ2VPdmVybGF5czogaW1hZ2VPdmVybGF5c30pKVxuXG4gICAgICAgIHNlbGVjdENvbXBvbmVudCgndG9nZ2xlLW5hdicpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiBuZXcgTmF2KGVsZW1lbnQpKVxuXG4gICAgICAgIHNlbGVjdENvbXBvbmVudCgnc2VsZWN0JykuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IG5ldyBDdXN0b21JbnB1dChlbGVtZW50KSlcblxuICAgICAgICBzZWxlY3RDb21wb25lbnQoJ2FqYXgtZm9ybScpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiBuZXcgQWpheEZvcm0oZWxlbWVudCkpXG5cbiAgICAgICAgc2VsZWN0Q29tcG9uZW50KCdtYWluLW5hdicpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiBuZXcgTWFpbk5hdihlbGVtZW50KSlcblxuICAgICAgICBzZWxlY3RDb21wb25lbnQoJ3NoYXJlJykuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IG5ldyBTaGFyZShlbGVtZW50KSlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpbml0XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvc2l0ZS5qcyIsImltcG9ydCBzZWxlY3RDb21wb25lbnQgZnJvbSAndXRpbGl0aWVzL3NlbGVjdC1jb21wb25lbnQnXG5pbXBvcnQgQ3VzdG9tSW5wdXQgZnJvbSAnY29tcG9uZW50L2N1c3RvbS1pbnB1dCdcblxuY29uc3QgYmFzZUNsYXNzID0gJ2Zvcm0nXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFqYXhGb3JtIHtcbiAgICBjb21wbGV0ZUNsYXNzID0gYmFzZUNsYXNzICsgJy0taXMtY29tcGxldGUnO1xuICAgIGRpc2FibGVkQ2xhc3MgPSBiYXNlQ2xhc3MgKyAnLS1pcy1kaXNhYmxlZCc7XG4gICAgYWN0aXZlQ2xhc3MgPSBiYXNlQ2xhc3MgKyAnLS1pcy1hY3RpdmUnO1xuICAgIGxvYWRpbmdDbGFzcyA9IGJhc2VDbGFzcyArICctLWlzLWxvYWRpbmcnO1xuICAgIGZpZWxkc1NlbGVjdG9yID0gJ1tkYXRhLWNvbXBvbmVudD1cImlucHV0XCJdJztcbiAgICBpbnB1dHMgPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy4kZm9ybSA9IHNlbGVjdENvbXBvbmVudChlbGVtZW50KVxuXG4gICAgICAgIHRoaXMuYnVpbGRJbnB1dHMoKVxuICAgICAgICB0aGlzLmNyZWF0ZVN1Y2Nlc3NFbGVtZW50KClcblxuICAgICAgICB0aGlzLiRmb3JtXG4gICAgICAgICAgICAuYXR0cignbm92YWxpZGF0ZScsIHRydWUpXG4gICAgICAgICAgICAub24oJ3N1Ym1pdCcsIHRoaXMuaGFuZGxlU3VibWl0KVxuICAgIH1cblxuICAgIGJ1aWxkSW5wdXRzKCkge1xuICAgICAgICB0aGlzLiRmb3JtLmZpbmQodGhpcy5maWVsZHNTZWxlY3RvcilcbiAgICAgICAgICAgIC5lYWNoKChpbmRleCwgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gbmV3IEN1c3RvbUlucHV0KGVsZW1lbnQpXG5cbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0c1tpbnB1dC5nZXROYW1lKCldID0gaW5wdXRcbiAgICAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgY3JlYXRlU3VjY2Vzc0VsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy4kZm9ybS5lbGVtZW50cy5zdWNjZXNzTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy4kZm9ybS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJCgnPGRpdiAvPicsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2Zvcm1fX3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAnZGF0YS1lbGVtZW50JzogJ3N1Y2Nlc3MtbWVzc2FnZSdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB0aGlzLiRmb3JtLnJlZnJlc2goKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3IgPSAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yT2JqZWN0ID0ganFYSFIucmVzcG9uc2VKU09OID8ganFYSFIucmVzcG9uc2VKU09OLmVycm9ycyA6IGZhbHNlXG5cbiAgICAgICAgaWYgKGVycm9yT2JqZWN0KSB7IFxuXG4gICAgICAgICAgICAkLmVhY2goZXJyb3JPYmplY3QsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCQudHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXVswXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzW2tleV0uc2V0RXJyb3IodmFsdWUuam9pbignPGJyIC8+JykpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCAkZmlyc3RFcnJvciA9IHRoaXMuJGZvcm1cbiAgICAgICAgICAgICAgICAuZmluZCgnLmlucHV0X19lcnJvcicpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihgLiR7dGhpcy5hY3RpdmVDbGFzc31gKVxuICAgICAgICAgICAgICAgIC5maXJzdCgpXG5cbiAgICAgICAgICAgIGlmICgkZmlyc3RFcnJvci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dE5hbWUgPSAkZmlyc3RFcnJvci5hdHRyKCdmb3InKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dHNbaW5wdXROYW1lXVxuICAgICAgICAgICAgICAgICAgICAuJGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAudmVsb2NpdHkoJ3Njcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAtMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAzNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoYCMke2lucHV0TmFtZX1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvY3VzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXNldEVycm9ycygpIHtcbiAgICAgICAgJC5lYWNoKHRoaXMuaW5wdXRzLCAobmFtZSwgZmllbGQpID0+IGZpZWxkLnJlbW92ZUVycm9yKCkpXG4gICAgfVxuXG4gICAgaGFuZGxlU3VjY2VzcyA9IChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikgPT4ge1xuICAgICAgICB0aGlzLiRmb3JtLmFkZENsYXNzKHRoaXMuY29tcGxldGVDbGFzcylcblxuICAgICAgICAkLmVhY2godGhpcy5pbnB1dHMsIChuYW1lLCBmaWVsZCkgPT4gZmllbGQuZGlzYWJsZSgpKVxuXG4gICAgICAgIHRoaXMuJGZvcm0uZWxlbWVudHMuc3VibWl0XG4gICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKVxuXG4gICAgICAgIHRoaXMuJGZvcm0uZWxlbWVudHMuc3VjY2Vzc01lc3NhZ2VcbiAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJCgnPHAgLz4nLCB7XG4gICAgICAgICAgICAgICAgICAgICd0ZXh0JzogZGF0YS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcblxuICAgICAgICB0aGlzLiRmb3JtXG4gICAgICAgICAgICAudmVsb2NpdHkoe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IC44XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDE1MDAsXG4gICAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dEN1YmljJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC52ZWxvY2l0eSh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGJlZ2luOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZWxlbWVudHMuc3VjY2Vzc01lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC52ZWxvY2l0eSgndHJhbnNpdGlvbi5zbGlkZVVwSW4nKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5yZW1vdmVBdHRyKCdzdHlsZXMnKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDc1MCxcbiAgICAgICAgICAgICAgICBlYXNpbmc6IFsxMDAwLCAyMF1cbiAgICAgICAgICAgIH0pXG4gICAgfTtcblxuICAgIGhhbmRsZVJlcXVlc3RTdGFydCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZXNldEVycm9ycygpXG5cbiAgICAgICAgdGhpcy4kZm9ybS5lbGVtZW50cy5zdWJtaXRcbiAgICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpXG4gICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5sb2FkaW5nQ2xhc3MpXG5cbiAgICAgICAgdGhpcy4kZm9ybS5hZGRDbGFzcyh0aGlzLmRpc2FibGVkQ2xhc3MpXG4gICAgfTtcblxuICAgIGhhbmRsZVJlcXVlc3RFbmQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGZvcm0uZWxlbWVudHMuc3VibWl0XG4gICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLCBmYWxzZSlcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmxvYWRpbmdDbGFzcylcblxuICAgICAgICB0aGlzLiRmb3JtLnJlbW92ZUNsYXNzKHRoaXMuZGlzYWJsZWRDbGFzcylcbiAgICB9O1xuXG4gICAgaGFuZGxlU3VibWl0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgICAgICBpZiAodGhpcy4kZm9ybS5oYXNDbGFzcyh0aGlzLmRpc2FibGVkQ2xhc3MpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRm9ybURhdGEodGhpcy4kZm9ybVswXSlcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy4kZm9ybS5hdHRyKCdhY3Rpb24nKVxuXG4gICAgICAgIHRoaXMuaGFuZGxlUmVxdWVzdFN0YXJ0KClcblxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICAgICAgLmFsd2F5cyh0aGlzLmhhbmRsZVJlcXVlc3RFbmQpXG4gICAgICAgIC50aGVuKHRoaXMuaGFuZGxlU3VjY2VzcylcbiAgICAgICAgLmZhaWwodGhpcy5oYW5kbGVFcnJvcilcbiAgICB9O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50L2FqYXgtZm9ybS5qcyIsInZhciBjYXBpdGFsaXplID0gcmVxdWlyZSgnLi9jYXBpdGFsaXplJyksXG4gICAgY3JlYXRlQ29tcG91bmRlciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUNvbXBvdW5kZXInKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKlxuICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICovXG52YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbENhc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2FtZWxDYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpLFxuICAgIHVwcGVyRmlyc3QgPSByZXF1aXJlKCcuL3VwcGVyRmlyc3QnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAqIHRvIGxvd2VyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXBpdGFsaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NhcGl0YWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBjcmVhdGVDYXNlRmlyc3QgPSByZXF1aXJlKCcuL19jcmVhdGVDYXNlRmlyc3QnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICogLy8gPT4gJ0ZyZWQnXG4gKlxuICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gKiAvLyA9PiAnRlJFRCdcbiAqL1xudmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdXBwZXJGaXJzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC91cHBlckZpcnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGNhc3RTbGljZSA9IHJlcXVpcmUoJy4vX2Nhc3RTbGljZScpLFxuICAgIGhhc1VuaWNvZGUgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlJyksXG4gICAgc3RyaW5nVG9BcnJheSA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvQXJyYXknKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNhc2VGaXJzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ2FzZUZpcnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RTbGljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFNsaWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICB9XG4gIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuZ3RoO1xuICB9XG4gIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTbGljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNsaWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGFzY2lpVG9BcnJheSA9IHJlcXVpcmUoJy4vX2FzY2lpVG9BcnJheScpLFxuICAgIGhhc1VuaWNvZGUgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlJyksXG4gICAgdW5pY29kZVRvQXJyYXkgPSByZXF1aXJlKCcuL191bmljb2RlVG9BcnJheScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXG4gKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc2NpaVRvQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpVG9BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaWNvZGVUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL191bmljb2RlVG9BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgZGVidXJyID0gcmVxdWlyZSgnLi9kZWJ1cnInKSxcbiAgICB3b3JkcyA9IHJlcXVpcmUoJy4vd29yZHMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiO1xuXG4vKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbnZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDb21wb3VuZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVDb21wb3VuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVJlZHVjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBkZWJ1cnJMZXR0ZXIgPSByZXF1aXJlKCcuL19kZWJ1cnJMZXR0ZXInKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG52YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICovXG52YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuLyoqXG4gKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAqIC8vID0+ICdkZWphIHZ1J1xuICovXG5mdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidXJyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYnVyci5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlUHJvcGVydHlPZiA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eU9mJyk7XG5cbi8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbnZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAnXFx4ZGYnOiAnc3MnLFxuICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAqL1xudmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidXJyTGV0dGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWJ1cnJMZXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5T2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eU9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGFzY2lpV29yZHMgPSByZXF1aXJlKCcuL19hc2NpaVdvcmRzJyksXG4gICAgaGFzVW5pY29kZVdvcmQgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlV29yZCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpLFxuICAgIHVuaWNvZGVXb3JkcyA9IHJlcXVpcmUoJy4vX3VuaWNvZGVXb3JkcycpO1xuXG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICovXG5mdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3b3JkcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC93b3Jkcy5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4vKipcbiAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzY2lpV29yZHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpV29yZHMuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG52YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZVdvcmQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1VuaWNvZGVXb3JkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc09yZExvd2VyID0gJ1xcXFxkKig/Oig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpXFxcXGIpJyxcbiAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/Oig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpXFxcXGIpJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG52YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICByc09yZFVwcGVyLFxuICByc09yZExvd2VyLFxuICByc0RpZ2l0cyxcbiAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlV29yZHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVXb3Jkcy5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qIVxuXHRBdXRvc2l6ZSAzLjAuMjFcblx0bGljZW5zZTogTUlUXG5cdGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vYXV0b3NpemVcbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKFsnZXhwb3J0cycsICdtb2R1bGUnXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ZmFjdG9yeShleHBvcnRzLCBtb2R1bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBtb2QgPSB7XG5cdFx0XHRleHBvcnRzOiB7fVxuXHRcdH07XG5cdFx0ZmFjdG9yeShtb2QuZXhwb3J0cywgbW9kKTtcblx0XHRnbG9iYWwuYXV0b3NpemUgPSBtb2QuZXhwb3J0cztcblx0fVxufSkodGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIG1vZHVsZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIG1hcCA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGtleXMgPSBbXTtcblx0XHR2YXIgdmFsdWVzID0gW107XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG5cdFx0XHRcdHJldHVybiBrZXlzLmluZGV4T2Yoa2V5KSA+IC0xO1xuXHRcdFx0fSxcblx0XHRcdGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVzW2tleXMuaW5kZXhPZihrZXkpXTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG5cdFx0XHRcdGlmIChrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcblx0XHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnZGVsZXRlJzogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcblx0XHRcdFx0dmFyIGluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG5cdFx0XHRcdGlmIChpbmRleCA+IC0xKSB7XG5cdFx0XHRcdFx0a2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdHZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoKTtcblxuXHR2YXIgY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiBjcmVhdGVFdmVudChuYW1lKSB7XG5cdFx0cmV0dXJuIG5ldyBFdmVudChuYW1lLCB7IGJ1YmJsZXM6IHRydWUgfSk7XG5cdH07XG5cdHRyeSB7XG5cdFx0bmV3IEV2ZW50KCd0ZXN0Jyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSBkb2VzIG5vdCBzdXBwb3J0IGBuZXcgRXZlbnQoKWBcblx0XHRjcmVhdGVFdmVudCA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHR2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG5cdFx0XHRldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIGZhbHNlKTtcblx0XHRcdHJldHVybiBldnQ7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzc2lnbih0YSkge1xuXHRcdGlmICghdGEgfHwgIXRhLm5vZGVOYW1lIHx8IHRhLm5vZGVOYW1lICE9PSAnVEVYVEFSRUEnIHx8IG1hcC5oYXModGEpKSByZXR1cm47XG5cblx0XHR2YXIgaGVpZ2h0T2Zmc2V0ID0gbnVsbDtcblx0XHR2YXIgY2xpZW50V2lkdGggPSB0YS5jbGllbnRXaWR0aDtcblx0XHR2YXIgY2FjaGVkSGVpZ2h0ID0gbnVsbDtcblxuXHRcdGZ1bmN0aW9uIGluaXQoKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YSwgbnVsbCk7XG5cblx0XHRcdGlmIChzdHlsZS5yZXNpemUgPT09ICd2ZXJ0aWNhbCcpIHtcblx0XHRcdFx0dGEuc3R5bGUucmVzaXplID0gJ25vbmUnO1xuXHRcdFx0fSBlbHNlIGlmIChzdHlsZS5yZXNpemUgPT09ICdib3RoJykge1xuXHRcdFx0XHR0YS5zdHlsZS5yZXNpemUgPSAnaG9yaXpvbnRhbCc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcblx0XHRcdFx0aGVpZ2h0T2Zmc2V0ID0gLShwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApICsgcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWlnaHRPZmZzZXQgPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKSArIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRml4IHdoZW4gYSB0ZXh0YXJlYSBpcyBub3Qgb24gZG9jdW1lbnQgYm9keSBhbmQgaGVpZ2h0T2Zmc2V0IGlzIE5vdCBhIE51bWJlclxuXHRcdFx0aWYgKGlzTmFOKGhlaWdodE9mZnNldCkpIHtcblx0XHRcdFx0aGVpZ2h0T2Zmc2V0ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hhbmdlT3ZlcmZsb3codmFsdWUpIHtcblx0XHRcdHtcblx0XHRcdFx0Ly8gQ2hyb21lL1NhZmFyaS1zcGVjaWZpYyBmaXg6XG5cdFx0XHRcdC8vIFdoZW4gdGhlIHRleHRhcmVhIHktb3ZlcmZsb3cgaXMgaGlkZGVuLCBDaHJvbWUvU2FmYXJpIGRvIG5vdCByZWZsb3cgdGhlIHRleHQgdG8gYWNjb3VudCBmb3IgdGhlIHNwYWNlXG5cdFx0XHRcdC8vIG1hZGUgYXZhaWxhYmxlIGJ5IHJlbW92aW5nIHRoZSBzY3JvbGxiYXIuIFRoZSBmb2xsb3dpbmcgZm9yY2VzIHRoZSBuZWNlc3NhcnkgdGV4dCByZWZsb3cuXG5cdFx0XHRcdHZhciB3aWR0aCA9IHRhLnN0eWxlLndpZHRoO1xuXHRcdFx0XHR0YS5zdHlsZS53aWR0aCA9ICcwcHgnO1xuXHRcdFx0XHQvLyBGb3JjZSByZWZsb3c6XG5cdFx0XHRcdC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblx0XHRcdFx0dGEub2Zmc2V0V2lkdGg7XG5cdFx0XHRcdC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cdFx0XHRcdHRhLnN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdHRhLnN0eWxlLm92ZXJmbG93WSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFBhcmVudE92ZXJmbG93cyhlbCkge1xuXHRcdFx0dmFyIGFyciA9IFtdO1xuXG5cdFx0XHR3aGlsZSAoZWwgJiYgZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWwucGFyZW50Tm9kZS5zY3JvbGxUb3ApIHtcblx0XHRcdFx0XHRhcnIucHVzaCh7XG5cdFx0XHRcdFx0XHRub2RlOiBlbC5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0c2Nyb2xsVG9wOiBlbC5wYXJlbnROb2RlLnNjcm9sbFRvcFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFycjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNpemUoKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxIZWlnaHQgPSB0YS5zdHlsZS5oZWlnaHQ7XG5cdFx0XHR2YXIgb3ZlcmZsb3dzID0gZ2V0UGFyZW50T3ZlcmZsb3dzKHRhKTtcblx0XHRcdHZhciBkb2NUb3AgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDsgLy8gTmVlZGVkIGZvciBNb2JpbGUgSUUgKHRpY2tldCAjMjQwKVxuXG5cdFx0XHR0YS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG5cblx0XHRcdHZhciBlbmRIZWlnaHQgPSB0YS5zY3JvbGxIZWlnaHQgKyBoZWlnaHRPZmZzZXQ7XG5cblx0XHRcdGlmICh0YS5zY3JvbGxIZWlnaHQgPT09IDApIHtcblx0XHRcdFx0Ly8gSWYgdGhlIHNjcm9sbEhlaWdodCBpcyAwLCB0aGVuIHRoZSBlbGVtZW50IHByb2JhYmx5IGhhcyBkaXNwbGF5Om5vbmUgb3IgaXMgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuXHRcdFx0XHR0YS5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0YS5zdHlsZS5oZWlnaHQgPSBlbmRIZWlnaHQgKyAncHgnO1xuXG5cdFx0XHQvLyB1c2VkIHRvIGNoZWNrIGlmIGFuIHVwZGF0ZSBpcyBhY3R1YWxseSBuZWNlc3Nhcnkgb24gd2luZG93LnJlc2l6ZVxuXHRcdFx0Y2xpZW50V2lkdGggPSB0YS5jbGllbnRXaWR0aDtcblxuXHRcdFx0Ly8gcHJldmVudHMgc2Nyb2xsLXBvc2l0aW9uIGp1bXBpbmdcblx0XHRcdG92ZXJmbG93cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0XHRlbC5ub2RlLnNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoZG9jVG9wKSB7XG5cdFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSBkb2NUb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlKCkge1xuXHRcdFx0cmVzaXplKCk7XG5cblx0XHRcdHZhciBzdHlsZUhlaWdodCA9IE1hdGgucm91bmQocGFyc2VGbG9hdCh0YS5zdHlsZS5oZWlnaHQpKTtcblx0XHRcdHZhciBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhLCBudWxsKTtcblxuXHRcdFx0Ly8gVXNpbmcgb2Zmc2V0SGVpZ2h0IGFzIGEgcmVwbGFjZW1lbnQgZm9yIGNvbXB1dGVkLmhlaWdodCBpbiBJRSwgYmVjYXVzZSBJRSBkb2VzIG5vdCBhY2NvdW50IHVzZSBvZiBib3JkZXItYm94XG5cdFx0XHR2YXIgYWN0dWFsSGVpZ2h0ID0gY29tcHV0ZWQuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnID8gTWF0aC5yb3VuZChwYXJzZUZsb2F0KGNvbXB1dGVkLmhlaWdodCkpIDogdGEub2Zmc2V0SGVpZ2h0O1xuXG5cdFx0XHQvLyBUaGUgYWN0dWFsIGhlaWdodCBub3QgbWF0Y2hpbmcgdGhlIHN0eWxlIGhlaWdodCAoc2V0IHZpYSB0aGUgcmVzaXplIG1ldGhvZCkgaW5kaWNhdGVzIHRoYXRcblx0XHRcdC8vIHRoZSBtYXgtaGVpZ2h0IGhhcyBiZWVuIGV4Y2VlZGVkLCBpbiB3aGljaCBjYXNlIHRoZSBvdmVyZmxvdyBzaG91bGQgYmUgYWxsb3dlZC5cblx0XHRcdGlmIChhY3R1YWxIZWlnaHQgIT09IHN0eWxlSGVpZ2h0KSB7XG5cdFx0XHRcdGlmIChjb21wdXRlZC5vdmVyZmxvd1kgPT09ICdoaWRkZW4nKSB7XG5cdFx0XHRcdFx0Y2hhbmdlT3ZlcmZsb3coJ3Njcm9sbCcpO1xuXHRcdFx0XHRcdHJlc2l6ZSgpO1xuXHRcdFx0XHRcdGFjdHVhbEhlaWdodCA9IGNvbXB1dGVkLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94JyA/IE1hdGgucm91bmQocGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YSwgbnVsbCkuaGVpZ2h0KSkgOiB0YS5vZmZzZXRIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE5vcm1hbGx5IGtlZXAgb3ZlcmZsb3cgc2V0IHRvIGhpZGRlbiwgdG8gYXZvaWQgZmxhc2ggb2Ygc2Nyb2xsYmFyIGFzIHRoZSB0ZXh0YXJlYSBleHBhbmRzLlxuXHRcdFx0XHRpZiAoY29tcHV0ZWQub3ZlcmZsb3dZICE9PSAnaGlkZGVuJykge1xuXHRcdFx0XHRcdGNoYW5nZU92ZXJmbG93KCdoaWRkZW4nKTtcblx0XHRcdFx0XHRyZXNpemUoKTtcblx0XHRcdFx0XHRhY3R1YWxIZWlnaHQgPSBjb21wdXRlZC5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcgPyBNYXRoLnJvdW5kKHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGEsIG51bGwpLmhlaWdodCkpIDogdGEub2Zmc2V0SGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYWNoZWRIZWlnaHQgIT09IGFjdHVhbEhlaWdodCkge1xuXHRcdFx0XHRjYWNoZWRIZWlnaHQgPSBhY3R1YWxIZWlnaHQ7XG5cdFx0XHRcdHZhciBldnQgPSBjcmVhdGVFdmVudCgnYXV0b3NpemU6cmVzaXplZCcpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRhLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0Ly8gRmlyZWZveCB3aWxsIHRocm93IGFuIGVycm9yIG9uIGRpc3BhdGNoRXZlbnQgZm9yIGEgZGV0YWNoZWQgZWxlbWVudFxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4OTM3NlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHBhZ2VSZXNpemUgPSBmdW5jdGlvbiBwYWdlUmVzaXplKCkge1xuXHRcdFx0aWYgKHRhLmNsaWVudFdpZHRoICE9PSBjbGllbnRXaWR0aCkge1xuXHRcdFx0XHR1cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIGRlc3Ryb3kgPSAoZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcGFnZVJlc2l6ZSwgZmFsc2UpO1xuXHRcdFx0dGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGUsIGZhbHNlKTtcblx0XHRcdHRhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXBkYXRlLCBmYWxzZSk7XG5cdFx0XHR0YS5yZW1vdmVFdmVudExpc3RlbmVyKCdhdXRvc2l6ZTpkZXN0cm95JywgZGVzdHJveSwgZmFsc2UpO1xuXHRcdFx0dGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignYXV0b3NpemU6dXBkYXRlJywgdXBkYXRlLCBmYWxzZSk7XG5cblx0XHRcdE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0dGEuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG5cdFx0XHR9KTtcblxuXHRcdFx0bWFwWydkZWxldGUnXSh0YSk7XG5cdFx0fSkuYmluZCh0YSwge1xuXHRcdFx0aGVpZ2h0OiB0YS5zdHlsZS5oZWlnaHQsXG5cdFx0XHRyZXNpemU6IHRhLnN0eWxlLnJlc2l6ZSxcblx0XHRcdG92ZXJmbG93WTogdGEuc3R5bGUub3ZlcmZsb3dZLFxuXHRcdFx0b3ZlcmZsb3dYOiB0YS5zdHlsZS5vdmVyZmxvd1gsXG5cdFx0XHR3b3JkV3JhcDogdGEuc3R5bGUud29yZFdyYXBcblx0XHR9KTtcblxuXHRcdHRhLmFkZEV2ZW50TGlzdGVuZXIoJ2F1dG9zaXplOmRlc3Ryb3knLCBkZXN0cm95LCBmYWxzZSk7XG5cblx0XHQvLyBJRTkgZG9lcyBub3QgZmlyZSBvbnByb3BlcnR5Y2hhbmdlIG9yIG9uaW5wdXQgZm9yIGRlbGV0aW9ucyxcblx0XHQvLyBzbyBiaW5kaW5nIHRvIG9ua2V5dXAgdG8gY2F0Y2ggbW9zdCBvZiB0aG9zZSBldmVudHMuXG5cdFx0Ly8gVGhlcmUgaXMgbm8gd2F5IHRoYXQgSSBrbm93IG9mIHRvIGRldGVjdCBzb21ldGhpbmcgbGlrZSAnY3V0JyBpbiBJRTkuXG5cdFx0aWYgKCdvbnByb3BlcnR5Y2hhbmdlJyBpbiB0YSAmJiAnb25pbnB1dCcgaW4gdGEpIHtcblx0XHRcdHRhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXBkYXRlLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHBhZ2VSZXNpemUsIGZhbHNlKTtcblx0XHR0YS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZSwgZmFsc2UpO1xuXHRcdHRhLmFkZEV2ZW50TGlzdGVuZXIoJ2F1dG9zaXplOnVwZGF0ZScsIHVwZGF0ZSwgZmFsc2UpO1xuXHRcdHRhLnN0eWxlLm92ZXJmbG93WCA9ICdoaWRkZW4nO1xuXHRcdHRhLnN0eWxlLndvcmRXcmFwID0gJ2JyZWFrLXdvcmQnO1xuXG5cdFx0bWFwLnNldCh0YSwge1xuXHRcdFx0ZGVzdHJveTogZGVzdHJveSxcblx0XHRcdHVwZGF0ZTogdXBkYXRlXG5cdFx0fSk7XG5cblx0XHRpbml0KCk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXN0cm95KHRhKSB7XG5cdFx0dmFyIG1ldGhvZHMgPSBtYXAuZ2V0KHRhKTtcblx0XHRpZiAobWV0aG9kcykge1xuXHRcdFx0bWV0aG9kcy5kZXN0cm95KCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlKHRhKSB7XG5cdFx0dmFyIG1ldGhvZHMgPSBtYXAuZ2V0KHRhKTtcblx0XHRpZiAobWV0aG9kcykge1xuXHRcdFx0bWV0aG9kcy51cGRhdGUoKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgYXV0b3NpemUgPSBudWxsO1xuXG5cdC8vIERvIG5vdGhpbmcgaW4gTm9kZS5qcyBlbnZpcm9ubWVudCBhbmQgSUU4IChvciBsb3dlcilcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdGF1dG9zaXplID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0XHRhdXRvc2l6ZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0XHRhdXRvc2l6ZS51cGRhdGUgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGF1dG9zaXplID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG5cdFx0XHRpZiAoZWwpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5sZW5ndGggPyBlbCA6IFtlbF0sIGZ1bmN0aW9uICh4KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFzc2lnbih4LCBvcHRpb25zKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0XHRhdXRvc2l6ZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRpZiAoZWwpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5sZW5ndGggPyBlbCA6IFtlbF0sIGRlc3Ryb3kpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdFx0YXV0b3NpemUudXBkYXRlID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRpZiAoZWwpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5sZW5ndGggPyBlbCA6IFtlbF0sIHVwZGF0ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gYXV0b3NpemU7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hdXRvc2l6ZS9kaXN0L2F1dG9zaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiaW1wb3J0IHNlbGVjdENvbXBvbmVudCBmcm9tICd1dGlsaXRpZXMvc2VsZWN0LWNvbXBvbmVudCdcbmltcG9ydCBCYXNlTWFwIGZyb20gJ2NvbXBvbmVudC9Hb29nbGVNYXAvQmFzZU1hcCdcbmltcG9ydCBHb29nbGVNYXBPdmVybGF5IGZyb20gJ2NvbXBvbmVudC9Hb29nbGVNYXAvT3ZlcmxheSdcbmltcG9ydCAndmVuZG9yL2pxdWVyeS5kZWJvdW5jZWRyZXNpemUnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvb2dsZU1hcCB7XG5cbiAgICAvLyBPcHRpb25hbCBhcnJheSBvZiBvYmplY3QgZm9yIGltYWdlIG92ZXJsYXlzXG4gICAgLy8gLSBzdXBwb3J0cyBTVkdzIG9yIGJpdG1hcCBpbWFnZXMsXG4gICAgLy8gICB1c2luZyBpbXBvcnRTVkcgdG8gZW1iZWQgdGhlIFNWRyBkaXJlY3RseVxuICAgIC8vIC0gb3B0aW9uYWwgc2hvd0JvdW5kcyB0byBwcm92aWRlIG91dGxpbmUgdG9cbiAgICAvLyAgIGhlbHAgd2l0aCBpbWFnZSBwbGFjZW1lbnRcbiAgICBcblxuICAgIGNvbnN0cnVjdG9yKGluZGV4ID0gMCwgZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuJGNvbXBvbmVudCA9IHNlbGVjdENvbXBvbmVudChlbGVtZW50KVxuICAgICAgICB0aGlzLiRtYXAgPSB0aGlzLiRjb21wb25lbnQuZWxlbWVudHMubWFwXG4gICAgICAgIHRoaXMuaWNvbiA9IG9wdGlvbnMuaWNvblxuICAgICAgICB0aGlzLmxvY2F0aW9ucyA9IG9wdGlvbnMubG9jYXRpb25zXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleFxuICAgICAgICB0aGlzLmltYWdlT3ZlcmxheXMgPSBvcHRpb25zLmltYWdlT3ZlcmxheXNcblxuICAgICAgICB0aGlzLm1hcERlZmF1bHRzID0ge1xuICAgICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICAgICAgbGF0OiBwYXJzZUZsb2F0KHRoaXMuJG1hcC5kYXRhKCdsYXQnKSksXG4gICAgICAgICAgICAgICAgbG5nOiBwYXJzZUZsb2F0KHRoaXMuJG1hcC5kYXRhKCdsbmcnKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXBUeXBlQ29udHJvbDogZmFsc2UsXG4gICAgICAgICAgICBzdHJlZXRWaWV3Q29udHJvbDogZmFsc2UsXG4gICAgICAgICAgICB6b29tOiBwYXJzZUZsb2F0KHRoaXMuJG1hcC5kYXRhKCd6b29tJykpLFxuICAgICAgICAgICAgem9vbUNvbnRyb2xPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGdvb2dsZS5tYXBzLkNvbnRyb2xQb3NpdGlvbi5MRUZUX0JPVFRPTVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMubWFwT3B0aW9ucyA9IHsuLi50aGlzLm1hcERlZmF1bHRzLCAuLi5vcHRpb25zLm1hcENvbmZpZ31cblxuICAgICAgICB0aGlzLmluaXRNYXAoKVxuICAgIH1cblxuICAgIGluaXRNYXAoKSB7XG4gICAgICAgIHRoaXMuZ29vZ2xlTWFwID0gbmV3IEJhc2VNYXAodGhpcy4kbWFwWzBdLCB0aGlzLm1hcE9wdGlvbnMpXG4gICAgICAgIHRoaXMuaW5mb1dpbmRvdyA9IG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KClcbiAgICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCh0aGlzLiRtYXAuZGF0YSgnbGF0JyksIHRoaXMuJG1hcC5kYXRhKCdsbmcnKSlcblxuICAgICAgICBpZiAodGhpcy5sb2NhdGlvbnMgJiYgdGhpcy5sb2NhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZExvY2F0aW9ucygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbWFnZU92ZXJsYXlzKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU92ZXJsYXlzKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpXG4gICAgfVxuXG4gICAgYmluZEV2ZW50cygpIHtcblxuICAgICAgICBpZiAodGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdEN1c3RvbUNvbnRyb2xzKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiRjb21wb25lbnQuZWxlbWVudHMuc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDdXN0b21TZWxlY3RzKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGNvbXBvbmVudC5vbignYWRkZWRPdmVybGF5JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kY29tcG9uZW50LnJlZnJlc2goKVxuICAgICAgICB9KVxuXG4gICAgICAgICQod2luZG93KS5vbignZGVib3VuY2VkcmVzaXplLmdvb2dsZU1hcC0nICsgdGhpcy5pbmRleCAsICgpID0+IHRoaXMucmVjZW50ZXJNYXAoKSlcbiAgICB9XG5cbiAgICB1bmJpbmRFdmVudHMoKSB7XG4gICAgICAgICQod2luZG93KS5vZmYoJy5nb29nbGVNYXAtJyArIHRoaXMuaW5kZXgpXG5cbiAgICAgICAgdGhpcy4kY29tcG9uZW50Lm9mZigpXG5cbiAgICAgICAgaWYgKHRoaXMuJGNvbXBvbmVudC5lbGVtZW50cy5jb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLiRjb21wb25lbnQuZWxlbWVudHMuY29udHJvbC5vZmYoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuJGNvbXBvbmVudC5lbGVtZW50cy5zZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbXBvbmVudC5lbGVtZW50cy5zZWxlY3Qub2ZmKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3lNYXAoKSB7XG4gICAgICAgIC8vIFRoaXMgZGVsZXRlcyB0aGUgbWFwIGFuZCB1bmJpbmRzIGl0cyBldmVudHMsIGJ1dCBkb2VzIG5vdCB1bmJpbmRcbiAgICAgICAgLy8gR29vZ2xlIE1hcCBBUEkgZXZlbnRzLCB0aGV5J2xsIHN0YXkgaW4gdGhlIG1lbW9yeSB1bnRpbCBKUyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgICAgLy8gcmVtb3ZlcyB0aGVtLiBUaGlzIGlzIGEga25vd24gaXNzdWUgd2l0aCBHb29nbGUgTWFwcy5cblxuICAgICAgICB0aGlzLnVuYmluZEV2ZW50cygpXG4gICAgICAgIHRoaXMuJGNvbXBvbmVudC5yZW1vdmUoKVxuICAgIH1cblxuICAgIHJlY2VudGVyTWFwKCkge1xuICAgICAgICB0aGlzLmdvb2dsZU1hcC5wYW5Ub0xvY2F0aW9uKHRoaXMuY2VudGVyUG9pbnQubGF0KCksIHRoaXMuY2VudGVyUG9pbnQubG5nKCkpXG4gICAgICAgIHRoaXMuJG1hcC5yZW1vdmVBdHRyKCdzdHlsZScpXG4gICAgICAgIHRoaXMuZ29vZ2xlTWFwLnJlZnJlc2goKVxuICAgIH1cblxuICAgIHNldENlbnRlclBvaW50KGxhdCwgbG5nKSB7XG4gICAgICAgIHRoaXMuY2VudGVyUG9pbnQgPSB0aGlzLmdvb2dsZU1hcC5zZXRMYXRMbmcocGFyc2VGbG9hdChsYXQpLCBwYXJzZUZsb2F0KGxuZykpXG4gICAgfVxuXG4gICAgYWRkTG9jYXRpb25zKCkge1xuICAgICAgICB0aGlzLmxvY2F0aW9ucy5mb3JFYWNoKGxvY2F0aW9uID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ29vZ2xlTWFwLmFkZE1hcmtlcih7XG4gICAgICAgICAgICAgICAgbGF0OiBsb2NhdGlvbi5sYXQsXG4gICAgICAgICAgICAgICAgbG5nOiBsb2NhdGlvbi5sbmcsXG4gICAgICAgICAgICAgICAgaWNvbjogdGhpcy5pY29uLFxuICAgICAgICAgICAgICAgIGluZm9XaW5kb3dUZW1wbGF0ZTogdGhpcy5pbmZvV2luZG93VGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgaW5mb1dpbmRvd0ZpZWxkczogbG9jYXRpb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgY3JlYXRlT3ZlcmxheXMoKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VPdmVybGF5cy5mb3JFYWNoKGxvY2F0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoXG4gICAgICAgICAgICAgICAgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsb2NhdGlvbi5zb3V0aFdlc3QubGF0LCBsb2NhdGlvbi5zb3V0aFdlc3QubG5nKSxcbiAgICAgICAgICAgICAgICBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxvY2F0aW9uLm5vcnRoRWFzdC5sYXQsIGxvY2F0aW9uLm5vcnRoRWFzdC5sbmcpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgR29vZ2xlTWFwT3ZlcmxheShib3VuZHMsIGxvY2F0aW9uLmltYWdlLCB0aGlzLmdvb2dsZU1hcCwgbG9jYXRpb24uc2hvd0JvdW5kcywgbG9jYXRpb24uaW1wb3J0U1ZHKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGluaXRDdXN0b21TZWxlY3RzKCkge1xuICAgICAgICB0aGlzLiRjb21wb25lbnQuZWxlbWVudHMuc2VsZWN0LmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCAkY29udHJvbCA9ICQoZWxlbWVudClcblxuICAgICAgICAgICAgJGNvbnRyb2wub24oJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCAkb3B0aW9uID0gJGNvbnRyb2wuZmluZCgnb3B0aW9uOnNlbGVjdGVkJylcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1hcFBvc2l0aW9uKCRvcHRpb24pXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250cm9sID0gJG9wdGlvbi52YWwoKS50cmltKClcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFjdGl2ZUNvbnRyb2xzKClcbiAgICAgICAgICAgICAgICB0aGlzLnNldENlbnRlclBvaW50KCRvcHRpb24uZGF0YSgnbGF0JyksICRvcHRpb24uZGF0YSgnbG5nJykpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGluaXRDdXN0b21Db250cm9scygpIHtcbiAgICAgICAgdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLmNvbnRyb2wuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0ICRjb250cm9sID0gJChlbGVtZW50KVxuXG4gICAgICAgICAgICAkY29udHJvbC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNYXBQb3NpdGlvbigkY29udHJvbClcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbnRyb2wgPSAkY29udHJvbC50ZXh0KCkudHJpbSgpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVDb250cm9scygpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgkY29udHJvbC5kYXRhKCdsYXQnKSwgJGNvbnRyb2wuZGF0YSgnbG5nJykpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHNldEFjdGl2ZUNvbnRyb2xzKCkge1xuICAgICAgICBjb25zdCAkY29udHJvbHMgPSB0aGlzLiRjb21wb25lbnQuZWxlbWVudHMuY29udHJvbFxuICAgICAgICBjb25zdCAkc2VsZWN0cyA9IHRoaXMuJGNvbXBvbmVudC5lbGVtZW50cy5zZWxlY3RcbiAgICAgICAgJGNvbnRyb2xzLmF0dHIoJ2RhdGEtc3RhdHVzJywgJ29mZicpXG5cbiAgICAgICAgaWYgKCRjb250cm9scykge1xuICAgICAgICAgICAgJGNvbnRyb2xzLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCQoZWxlbWVudCkudGV4dCgpLnRyaW0oKSA9PSB0aGlzLmFjdGl2ZUNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgJChlbGVtZW50KS5hdHRyKCdkYXRhLXN0YXR1cycsICdvbicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkc2VsZWN0cykge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gJHNlbGVjdHMuZmluZCgnb3B0aW9uOmNvbnRhaW5zKCcgKyB0aGlzLmFjdGl2ZUNvbnRyb2wgKyAnKScpXG4gICAgICAgICAgICBvcHRpb24ucGFyZW50KCdzZWxlY3QnKS52YWwodGhpcy5hY3RpdmVDb250cm9sKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0TWFwUG9zaXRpb24oY29udHJvbCkge1xuICAgICAgICBjb25zdCAkY29udHJvbCA9IGNvbnRyb2xcbiAgICAgICAgY29uc3QgY29udHJvbExhdCA9IHBhcnNlRmxvYXQoJGNvbnRyb2wuZGF0YSgnbGF0JykpXG4gICAgICAgIGNvbnN0IGNvbnRyb2xMbmcgPSBwYXJzZUZsb2F0KCRjb250cm9sLmRhdGEoJ2xuZycpKVxuICAgICAgICBsZXQgY29udHJvbFpvb20gPSB0aGlzLm1hcE9wdGlvbnMuem9vbVxuXG4gICAgICAgIGlmICgkY29udHJvbC5kYXRhKCd6b29tJykpIHtcbiAgICAgICAgICAgIGNvbnRyb2xab29tID0gJGNvbnRyb2wuZGF0YSgnem9vbScpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udHJvbExhdCAmJiBjb250cm9sTG5nKSB7XG4gICAgICAgICAgICB0aGlzLmdvb2dsZU1hcC5wYW5Ub0xvY2F0aW9uKGNvbnRyb2xMYXQsIGNvbnRyb2xMbmcpXG4gICAgICAgICAgICB0aGlzLmdvb2dsZU1hcC5zZXRab29tQW1vdW50KGNvbnRyb2xab29tKVxuICAgICAgICAgICAgdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLmNvbnRyb2wuYXR0cignZGF0YS1zdGF0dXMnLCAnb2ZmJylcbiAgICAgICAgICAgICRjb250cm9sLmF0dHIoJ2RhdGEtc3RhdHVzJywgJ29uJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluZm9XaW5kb3dUZW1wbGF0ZSA9IGxvY2F0aW9uID0+IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImluZm8td2luZG93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5mby13aW5kb3dfX2NvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJpbmZvLXdpbmRvd19fbG9jYXRpb25cIj4ke2xvY2F0aW9uLnRpdGxlfTwvaDQ+XG4gICAgICAgICAgICAgICAgJHsobG9jYXRpb24ucGhvbmUgfHwgbG9jYXRpb24uZmF4KSAmJiBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbmZvLXdpbmRvd19fbWV0YVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgJHtsb2NhdGlvbi5waG9uZSAmJiBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiaW5mby13aW5kb3dfX2xhYmVsXCI+VGVsPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidGVsOiR7bG9jYXRpb24ucGhvbmV9XCIgY2xhc3M9XCJpbmZvLXdpbmRvd19fcGhvbmVcIj4ke2xvY2F0aW9uLnBob25lfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgICAgICAke2xvY2F0aW9uLmZheCAmJiBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiaW5mby13aW5kb3dfX2xhYmVsXCI+RmF4PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidGVsOiR7bG9jYXRpb24uZmF4fVwiIGNsYXNzPVwiaW5mby13aW5kb3dfX3Bob25lXCI+JHtsb2NhdGlvbi5mYXh9PC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICA8YWRkcmVzcyBjbGFzcz1cImluZm8td2luZG93X19hZGRyZXNzXCI+XG4gICAgICAgICAgICAgICAgICAgICR7bG9jYXRpb24uYWRkcmVzczF9XG4gICAgICAgICAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgICAgICAgICAke2xvY2F0aW9uLmNpdHl9LCAke2xvY2F0aW9uLnN0YXRlfSAke2xvY2F0aW9uLnppcH1cbiAgICAgICAgICAgICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgICAgICAgICAgICR7bG9jYXRpb24uY291bnRyeX1cbiAgICAgICAgICAgICAgICA8L2FkZHJlc3M+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgYDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudC9Hb29nbGVNYXAvaW5kZXguanMiLCIvLyBDcmVhdGVzIEpTIGNsYXNzIG91dCBvZiBHb29nbGUgTWFwIEFQSVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlTWFwIHtcbiAgICBtYXJrZXJzID0gW11cbiAgICBtYXJrZXJCb3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKClcblxuICAgIG1hcE9wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICAgICAgem9vbSAgICAgICAgOiAxMixcbiAgICAgICAgc2Nyb2xsd2hlZWwgOiBmYWxzZVxuICAgIH1cblxuICAgIG1hcENlbnRlckRlZmF1bHRzID0ge1xuICAgICAgICBsYXQgOiAzOC4yMzIwNjksXG4gICAgICAgIGxuZyA6IC04NS43NDIwNTksXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IobWFwRWxlbWVudCwgbWFwT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMubWFwID0gdGhpcy5pbml0TWFwKG1hcEVsZW1lbnQsIG1hcE9wdGlvbnMpXG4gICAgICAgIHRoaXMuZ2V0TWFwID0gKCkgPT4gdGhpcy5tYXBcbiAgICB9XG5cbiAgICBpbml0TWFwKG1hcEVsZW1lbnQsIG1hcE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnb29nbGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIGlzIHJlcXVpcmVkLicpXG4gICAgICAgIH1cblxuICAgICAgICBtYXBPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5tYXBPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgICAgICAuLi5tYXBPcHRpb25zXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hcE9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NlbnRlcicpKSB7XG4gICAgICAgICAgICBtYXBPcHRpb25zLmNlbnRlciA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBDZW50ZXJEZWZhdWx0cy5sYXQsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBDZW50ZXJEZWZhdWx0cy5sbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTWFwKG1hcEVsZW1lbnQsIG1hcE9wdGlvbnMpXG4gICAgfVxuXG4gICAgc2V0U3R5bGVzKHN0eWxlcykge1xuICAgICAgICB0aGlzLm1hcC5tYXBUeXBlcy5zZXQoJ3N0eWxlZF9tYXAnLCBuZXcgZ29vZ2xlLm1hcHMuU3R5bGVkTWFwVHlwZShzdHlsZXMpKVxuICAgICAgICB0aGlzLm1hcC5zZXRNYXBUeXBlSWQoJ3N0eWxlZF9tYXAnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgbG9jYXRpb24gbWFya2VyIHRvIHRoZSBtYXAuIEN1c3RvbSBtYXJrdXAgZm9yIGluZm8gd2luZG93cyBzaG91bGQgYmUgcGFzc2VkIGluIGFzXG4gICAgICogYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZW1wbGF0ZSBsaXRlcmFsLlxuICAgICAqXG4gICAgICogRXhhbXBsZSBVc2FnZTpcbiAgICAgKlxuICAgICAqIHZhciBsb2NhdGlvbkZpZWxkcyA9IHtcbiAgICAgKiAgICAgIHRpdGxlOiAnTG9jYXRpb24gTmFtZScsXG4gICAgICogICAgICBtZXNzYWdlOiAnTG9jYXRpb24gaW5mb3JtYXRpb24nXG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGxvY2F0aW9uVGVtcGxhdGUgPSBmaWVsZHMgPT4gYFxuICAgICAqICAgICAgPGgyPiR7ZmllbGRzLnRpdGxlfTwvaDI+XG4gICAgICogICAgICA8cD4ke2ZpZWxkcy5tZXNzYWdlfTwvcD5cbiAgICAgKiBgXG4gICAgICpcbiAgICAgKiBnb29nbGVNYXBzLmFkZExvY2F0aW9uKDEyMywgNDU2LCBsb2NhdGlvblRlbXBsYXRlLCBsb2NhdGlvbkZpZWxkcywgJy9wYXRoL3RvL2ljb24ucG5nJylcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gKG9wdGlvbmFsKSBpbmZvV2luZG93VGVtcGxhdGUgLSBNdXN0YWNoZS5qcyBmb3JtYXR0ZWQgdGVtcGxhdGUgZm9yIGluZm8gd2luZG93IG1hcmt1cFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAob3B0aW9uYWwpIGluZm9XaW5kb3dGaWVsZHMgLSBvYmplY3QgdXNlZCB0byBmaWxsIGluIHRoZSB0ZW1wbGF0ZSdzIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gKG9wdGlvbmFsKSBpY29uIC0gVVJMIHBhdGggdG8gdGhlIGN1c3RvbSBtYXAgdGFjayBpY29uIGZvciB0aGlzIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIGFkZE1hcmtlcih7IGxhdCwgbG5nLCBpbmZvV2luZG93VGVtcGxhdGUsIGluZm9XaW5kb3dGaWVsZHMsIGljb24gfSkge1xuICAgICAgICBjb25zdCBtYXJrZXJDZW50ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdCwgbG5nKVxuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLm1hcFxuICAgICAgICBjb25zdCBtYXJrZXJQYXJhbXMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogbWFya2VyQ2VudGVyLFxuICAgICAgICAgICAgbWFwLFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgICAgIG1hcmtlclBhcmFtcy5pY29uID0gaWNvblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcihtYXJrZXJQYXJhbXMpXG5cbiAgICAgICAgLy8gQWRkIGFuIGluZm8gd2luZG93IG9ubHkgaWYgaW5mb1dpbmRvd1RlbXBsYXRlIGlzIGRlZmluZWRcbiAgICAgICAgaWYgKGluZm9XaW5kb3dUZW1wbGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgaW5mb1dpbmRvd01hcmt1cCA9IGluZm9XaW5kb3dUZW1wbGF0ZShpbmZvV2luZG93RmllbGRzKVxuICAgICAgICAgICAgY29uc3QgaW5mb1dpbmRvdyA9IG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBpbmZvV2luZG93TWFya3VwLFxuICAgICAgICAgICAgICAgIGVuYWJsZUV2ZW50UHJvcGFnYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUF1dG9QYW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1heFdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgekluZGV4OiBudWxsLFxuICAgICAgICAgICAgICAgIGNsb3NlQm94VVJMOiAnL2Fzc2V0cy9pbWFnZXMvaWNvbnMvY2xvc2Uuc3ZnJyxcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG1hcCwgbWFya2VyKVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXJrZXJCb3VuZHMuZXh0ZW5kKG1hcmtlci5wb3NpdGlvbilcbiAgICAgICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKVxuICAgIH1cblxuICAgIGZpdE1hcmtlckJvdW5kcygpIHtcbiAgICAgICAgdGhpcy5tYXAuZml0Qm91bmRzKHRoaXMubWFya2VyQm91bmRzKVxuICAgIH1cblxuICAgIHBhblRvTG9jYXRpb24obGF0LCBsbmcpIHtcbiAgICAgICAgY29uc3QgbWFya2VyTG9jYXRpb24gPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdCwgbG5nKVxuICAgICAgICB0aGlzLm1hcC5wYW5UbyhtYXJrZXJMb2NhdGlvbilcbiAgICB9XG5cbiAgICBzZXRab29tQW1vdW50KHpvb20pIHtcbiAgICAgICAgdGhpcy5tYXAuc2V0Wm9vbSh6b29tKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpdHMgdGhlIG1hcCBib3VuZHMgdG8gYSByYWRpdXMgKGluIG1pbGVzKSBhcm91bmQgYSBnaXZlbiBjZW50ZXIgcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIC0gbWFwIGJvdW5kcyByYWRpdXMgaW4gbWlsZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgZml0UmFkaXVzQm91bmRzKGxhdCwgbG5nLCBkaXN0YW5jZSkge1xuICAgICAgICBjb25zdCBjaXJjbGUgPSBuZXcgZ29vZ2xlLm1hcHMuQ2lyY2xlKHtcbiAgICAgICAgICAgIGNlbnRlcjogbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXQsIGxuZyksXG4gICAgICAgICAgICByYWRpdXM6IChkaXN0YW5jZSAqIDE2MDkuMzQgLyAyKSxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5tYXAuZml0Qm91bmRzKGNpcmNsZS5nZXRCb3VuZHMoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIG1hcmtlcnMgZnJvbSB0aGUgbWFwXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIGNsZWFyTWFya2VycygpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubWFya2Vyc1tpXS5zZXRNYXAobnVsbClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdXG4gICAgfVxuXG4gICAgZ2VvbG9jYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbil7XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbigocG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBieUlQOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtieUlQOiB0cnVlfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtieUlQOiB0cnVlfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjcmVhdGVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJGdW5jdGlvbikge1xuICAgICAgICB0aGlzLm1hcC5hZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJGdW5jdGlvbilcbiAgICB9XG5cbiAgICBnZW9sb2NhdGVCeUlQKGZhbGxiYWNrRW5kcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiBmYWxsYmFja0VuZHBvaW50LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogJC5wYXJzZUpTT04oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBnZW8tbG9jYXRpb24gdG8gZmluZCB0aGUgdXNlcidzIGxhdC9sbmcgY29vcmRpbmF0ZXMuIFVzZXMgYnJvd3Nlci1iYXNlZFxuICAgICAqIGxvY2F0aW9uIGlmIHBvc3NpYmxlLCBmYWxscyBiYWNrIHRvIHNlcnZlci1zaWRlIGdlby1sb2NhdGlvbiB1c2luZyBJUCBhZGRyZXNzLlxuICAgICAqXG4gICAgICogVGhlIG1ldGhvZCBleHBlY3RzIGEgY2FsbGJhY2sgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBoYW5kbGUgdGhlXG4gICAgICogdXNlcidzIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogRXhhbXBsZSBVc2FnZTpcbiAgICAgKlxuICAgICAqIGdvb2dsZU1hcHMuZ2V0VXNlckxhdExuZygnL3BhdGgvdG8vZmFsbGJhY2sucGhwJywgZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGNvb3Jkcy5sYXQpIC8vIDEyM1xuICAgICAqICAgICBjb25zb2xlLmxvZyhjb29yZHMubG5nKSAvLyA0NTZcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmFsbGJhY2tFbmRwb2ludCAgIC0gVVJMIHBhdGggdG8gc2VydmVyLXNpZGUgc2NyaXB0IHRoYXQgcHJvY2Vzc2VzIElQLWJhc2VkIGdlby1sb2NhdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9URTogdGhlIHNjcmlwdCBzaG91bGQgcmV0dXJuIGEgSlNPTiBvYmplY3QgaW4gdGhlIGZvcm1hdCB7ICdsYXQnOiAxMjMsICdsbmcnOiA0NTYgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc3VjY2Vzc0NhbGxiYWNrICAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGhhbmRsZSB1c2VyJ3MgY29vcmRpbmF0ZXMuIFJlY2VpdmVzIGEgY29vcmRpbmF0ZSBvYmplY3RcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGZvcm1hdCB7IGxhdDogMTIzLCBsbmc6IDQ1NiB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIGdldFVzZXJMYXRMbmcoZmFsbGJhY2tFbmRwb2ludCwgc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2VvbG9jYXRlKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEuYnlJUCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VvbG9jYXRlQnlJUChmYWxsYmFja0VuZHBvaW50KS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhkYXRhLmNvb3JkaW5hdGVzKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhkYXRhLmNvb3JkaW5hdGVzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBsYXQgYW5kIGxuZyB2YWx1ZXMgZnJvbSBhIGdpdmVuIGFkZHJlc3Mgb3IgcG9zdGFsIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIGV4cGVjdHMgYSBjYWxsYmFjayBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGhhbmRsZSB0aGVcbiAgICAgKiByZXRyaWV2ZWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIFVzYWdlOlxuICAgICAqXG4gICAgICogZ29vZ2xlTWFwcy5nZXRMYXRMbmdGcm9tQWRkcmVzcygnNDAyMTcnLCBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coY29vcmRzLmxhdCkgLy8gMzguMjEzMTg3NFxuICAgICAqICAgICBjb25zb2xlLmxvZyhjb29yZHMubG5nKSAvLyAtODUuNzQxMDI2MTk5OTk5OTZcbiAgICAgKiB9LCBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0Vycm9yIGZpbmRpbmcgY29vcmRpbmF0ZXMnKVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzICAgICAgICAgICAgLSBBZGRyZXNzIG9yIFpJUCBzdHJpbmcgdGhhdCBHb29nbGUgd2lsbCB1c2UgdG8gZGV0ZXJtaW5lIGNvb3JkaW5hdGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdWNjZXNzQ2FsbGJhY2sgIC0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gaGFuZGxlIGNvb3JkaW5hdGVzLiBQYXNzZWQgYSBjb29yZGluYXRlIG9iamVjdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgZm9ybWF0IHsgbGF0OiAxMjMsIGxuZzogNDU2IH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVycm9yQ2FsbGJhY2sgICAgLSBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2hlbiBnZW9jb2RlciBmYWlscyB0byBmaW5kIGxhdC9sbmcgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIGdldExhdExuZ0Zyb21BZGRyZXNzKGFkZHJlc3MsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBjb25zdCBnZW9jb2RlciA9IG5ldyBnb29nbGUubWFwcy5HZW9jb2RlclxuXG4gICAgICAgIGdlb2NvZGVyLmdlb2NvZGUoe1xuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzc1xuICAgICAgICB9LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXQgPSBkYXRhWzBdLmdlb21ldHJ5LmxvY2F0aW9uLmxhdCgpXG4gICAgICAgICAgICAgICAgY29uc3QgbG5nID0gZGF0YVswXS5nZW9tZXRyeS5sb2NhdGlvbi5sbmcoKVxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh7bGF0LCBsbmd9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYXJyYXkgb2YgYWRkcmVzc2VzIG5lYXIgYSBnaXZlbiBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIFVzYWdlOlxuICAgICAqXG4gICAgICogZ29vZ2xlTWFwcy5nZXRBZGRyZXNzZXNGcm9tTGF0TG5nKDM4LjIxMzE4NzQsIC04NS43NDEwMjYxOTk5OTk5NiwgZnVuY3Rpb24oYWRkcmVzc2VzKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGFkZHJlc3Nlcy5sZW5ndGgpIC8vIDEwXG4gICAgICogfSwgZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdObyBhZGRyZXNzZXMgZm91bmQnKVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc3VjY2Vzc0NhbGxiYWNrICAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGhhbmRsZSByZXRyaWV2ZWQgYWRkcmVzc2VzLiBQYXNzZWQgYW4gYXJyYXkgb2YgYWRkcmVzcyBkYXRhXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyb3JDYWxsYmFjayAgICAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGhhbmRsZSB3aGVuIG5vIGFkZHJlc3NlcyBhcmUgZm91bmQgYXQgZ2l2ZW4gY29vcmRpbmF0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgZ2V0QWRkcmVzc2VzRnJvbUxhdExuZyhsYXQsIGxuZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGdlb2NvZGVyID0gbmV3IGdvb2dsZS5tYXBzLkdlb2NvZGVyXG5cbiAgICAgICAgZ2VvY29kZXIuZ2VvY29kZSh7XG4gICAgICAgICAgICBsb2NhdGlvbjogbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXQsIGxuZylcbiAgICAgICAgfSwgZnVuY3Rpb24oYWRkcmVzc2VzKSB7XG4gICAgICAgICAgICBpZiAoYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhhZGRyZXNzZXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHNldFBvaW50KHgsIHkpIHtcbiAgICAgICAgY29uc3QgbmUgPSB0aGlzLm1hcC5nZXRCb3VuZHMoKS5nZXROb3J0aEVhc3QoKVxuICAgICAgICBjb25zdCBzdyA9IHRoaXMubWFwLmdldEJvdW5kcygpLmdldFNvdXRoV2VzdCgpXG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLm1hcC5nZXRQcm9qZWN0aW9uKClcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb1BvaW50KG5lKVxuICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9Qb2ludChzdylcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAxIDw8IHRoaXMubWFwLmdldFpvb20oKTtcblxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHByb2plY3Rpb24uZnJvbVBvaW50VG9MYXRMbmcobmV3IGdvb2dsZS5tYXBzLlBvaW50KHggLyBzY2FsZSArIGJvdHRvbUxlZnQueCwgeSAvIHNjYWxlICsgdG9wUmlnaHQueSkpXG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uXG4gICAgfVxuXG4gICAgc2V0TGF0TG5nKGxhdCwgbG5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdCwgbG5nKVxuICAgIH1cblxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcy5tYXAsICdyZXNpemUnKVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50L0dvb2dsZU1hcC9CYXNlTWFwLmpzIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgR29vZ2xlTWFwT3ZlcmxheSBleHRlbmRzIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3IHtcblxuICAgIGNvbnN0cnVjdG9yKGJvdW5kcywgaW1hZ2UsIG1hcE9iamVjdCwgc2hvd0JvdW5kcyA9IGZhbHNlLCBpbXBvcnRTVkcgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpXG5cbiAgICAgICAgdGhpcy5ib3VuZHMgPSBib3VuZHNcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlXG4gICAgICAgIHRoaXMubWFwID0gbWFwT2JqZWN0Lm1hcFxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGxcbiAgICAgICAgdGhpcy5zaG93Qm91bmRzID0gc2hvd0JvdW5kc1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvcmRlclxuICAgICAgICB0aGlzLmltcG9ydFNWRyA9IGltcG9ydFNWR1xuXG4gICAgICAgIHRoaXMuc2V0TWFwKHRoaXMubWFwKVxuICAgIH1cblxuICAgIG9uQWRkKCkge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMuZ2V0UGFuZXMoKVxuXG4gICAgICAgIHRoaXMuJGltYWdlQ29udGFpbmVyID0gJCgnPGRpdi8+JylcbiAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgJ3Bvc2l0aW9uJyA6ICdhYnNvbHV0ZSdcbiAgICAgICAgIH0pXG4gICAgICAgICAuYXBwZW5kVG8ocGFuZXMub3ZlcmxheU1vdXNlVGFyZ2V0KVxuXG4gICAgICAgIGlmICh0aGlzLnNob3dCb3VuZHMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ29udGFpbmVyQm9yZGVyKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmltcG9ydFNWRykge1xuICAgICAgICAgICAgY29uc3QgJGltYWdlID0gJCh0aGlzLmltYWdlLCB7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICd3aWR0aCcgICAgOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCcgICA6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAncG9zaXRpb24nIDogJ2Fic29sdXRlJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAuYXBwZW5kVG8odGhpcy4kaW1hZ2VDb250YWluZXIpXG4gICAgICAgICAgICAgLnRyaWdnZXIoJ2FkZGVkT3ZlcmxheScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCAkaW1hZ2UgPSAkKCc8aW1nLz4nLCB7XG4gICAgICAgICAgICAgICAgc3JjOiB0aGlzLmltYWdlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICd3aWR0aCcgICAgOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCcgICA6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAncG9zaXRpb24nIDogJ2Fic29sdXRlJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAuYXBwZW5kVG8odGhpcy4kaW1hZ2VDb250YWluZXIpXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFkZENvbnRhaW5lckJvcmRlcigpIHtcbiAgICAgICAgdGhpcy4kaW1hZ2VDb250YWluZXIuY3NzKHtcbiAgICAgICAgICAgICdib3JkZXInIDogJzFweCBzb2xpZCByZWQnXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZHJhdygpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmxheVByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKVxuICAgICAgICBjb25zdCBzdyA9IG92ZXJsYXlQcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKHRoaXMuYm91bmRzLmdldFNvdXRoV2VzdCgpKVxuICAgICAgICBjb25zdCBuZSA9IG92ZXJsYXlQcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKHRoaXMuYm91bmRzLmdldE5vcnRoRWFzdCgpKVxuXG4gICAgICAgIHRoaXMuJGltYWdlQ29udGFpbmVyXG4gICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICdsZWZ0JyAgIDogc3cueCArICdweCcsXG4gICAgICAgICAgICAndG9wJyAgICA6IG5lLnkgKyAncHgnLFxuICAgICAgICAgICAgJ3dpZHRoJyAgOiAobmUueCAtIHN3LngpICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQnIDogKHN3LnkgLSBuZS55KSArICdweCdcbiAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgb25SZW1vdmUoKSB7XG4gICAgICAgIHRoaXMuJGltYWdlQ29udGFpbmVyWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kaW1hZ2VDb250YWluZXJbMF0pXG4gICAgICAgIHRoaXMuJGltYWdlQ29udGFpbmVyID0gbnVsbFxuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudC9Hb29nbGVNYXAvT3ZlcmxheS5qcyIsIi8qKlxuICogTW9kYWxzIHVzaW5nIE1hZ25pZmljIFBvcHVwLlxuICpcbiAqIEFKQVggTU9EQUxTOlxuICogV2lsbCBjcmVhdGUgQWpheC1iYXNlZCBtb2RhbHMgZnJvbSBsaW5rcyBieSBkZWZhdWx0LiBDdXJyZW50bHksIGRlZmF1bHQgSFRNTCB3b3VsZCBiZTpcbiAqIDxhIGhyZWY9XCIvcGF0aC90by9wYWdlXCIgZGF0YS1hY3Rpb249XCJtb2RhbC1tZnBcIiBkYXRhLWZyYWdtZW50PVwiI2ZyYWdtZW50XCI+Rm9vPC9hPlxuICpcbiAqIElOTElORSBNT0RBTFM6XG4gKiBNb2RhbHMgZnJvbSBpbi1wYWdlIGNvbnRlbnQgY2FuIGJlIGNyZWF0ZWQgYnkgdXNpbmcgdHlwZTogJ2lubGluZScuXG4gKiBEZWZhdWx0IEhUTUwgd291bGQgYmU6XG4gKiA8YSBocmVmPVwiL3BhdGgvdG8vZmFsbGJhY2svcGFnZVwiIGRhdGEtYWN0aW9uPVwibW9kYWwtbWZwXCIgZGF0YS1tZnAtc3JjPVwiI2lkLW9mLWNvbnRlbnRcIj5cbiAqXG4gKiBJTUFHRSBNT0RBTFM6XG4gKiBVc2UgdHlwZTogaW1hZ2VcbiAqIDxhIGhyZWY9XCIvcGF0aC90by9pbWFnZVwiIGRhdGEtYWN0aW9uPVwibW9kYWwtbWZwXCI+SW1hZ2UgdHlwZTwvYT5cbiAqXG4gKiBHQUxMRVJZIE1PREFMOlxuICogVXNlIHR5cGU6IGdhbGxlcnlcbiAqIDxkaXYgY2xhc3M9XCJnYWxsZXJ5XCI+XG4gKiBcdCAgIDxhIGRhdGEtYWN0aW9uPVwibW9kYWwtbWZwXCIgaHJlZj1cIi9wYXRoL3RvL2Z1bGwvaW1hZ2UvMVwiPjxpbWcgc3JjPVwiL3BhdGgvdG8vdGh1bWJuYWlsL2ltYWdlLzFcIiBhbHQ9XCIxXCI+PC9hPlxuICogXHQgICA8YSBkYXRhLWFjdGlvbj1cIm1vZGFsLW1mcFwiIGhyZWY9XCIvcGF0aC90by9mdWxsL2ltYWdlLzJcIj48aW1nIHNyYz1cIi9wYXRoL3RvL3RodW1ibmFpbC9pbWFnZS8yXCIgYWx0PVwiMlwiPjwvYT5cbiAqIFx0ICAgPGEgZGF0YS1hY3Rpb249XCJtb2RhbC1tZnBcIiBocmVmPVwiL3BhdGgvdG8vZnVsbC9pbWFnZS8zXCI+PGltZyBzcmM9XCIvcGF0aC90by90aHVtYm5haWwvaW1hZ2UvM1wiIGFsdD1cIjNcIj48L2E+XG4gKiBcdCAgIDxhIGRhdGEtYWN0aW9uPVwibW9kYWwtbWZwXCIgaHJlZj1cIi9wYXRoL3RvL2Z1bGwvaW1hZ2UvNFwiPjxpbWcgc3JjPVwiL3BhdGgvdG8vdGh1bWJuYWlsL2ltYWdlLzRcIiBhbHQ9XCI0XCI+PC9hPlxuICogXHQgICA8YSBkYXRhLWFjdGlvbj1cIm1vZGFsLW1mcFwiIGhyZWY9XCIvcGF0aC90by9mdWxsL2ltYWdlLzVcIj48aW1nIHNyYz1cIi9wYXRoL3RvL3RodW1ibmFpbC9pbWFnZS81XCIgYWx0PVwiNVwiPjwvYT5cbiAqIDwvZGl2PlxuICpcbiAqIEZvciBhbGwgb3RoZXIgdHlwZXMsIHBhc3MgeW91ciBjdXN0b20gTUZQIG9wdGlvbnMgdG8gdGhlIG1vZHVsZSdzIGluaXQoKSBmdW5jdGlvbi5cbiAqXG4gKiBAdG9kbyBhZGQgYmVmb3JlT3BlbiBjYWxsYmFjayBzbyBlZmZlY3QgY291bGQgYmUgYSBkYXRhIGF0dHJpYnV0ZVxuICogQG1vZHVsZSBtb2RhbC1tZnBcbiAqL1xuXG5pbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0ICd2ZW5kb3IvbWFnbmlmaWMtcG9wdXAvanF1ZXJ5Lm1hZ25pZmljLXBvcHVwLm1pbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vZGFsTUZQKGFyZ3Mpe1xuXHRcblx0LyoqXG5cdCAqIFBsdWdpbiBkZWZhdWx0cyAvIEJhc2UgY29uc3RydWN0b3Jcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0Y29uc3QgREVGQVVMVCA9IHtcblx0XHRuYW1lXHQ6ICdNb2RhbCAoTWFnbmlmaWMgUG9wdXApJyxcblx0XHRlbFx0XHQ6ICdbZGF0YS1hY3Rpb249XCJtb2RhbC1tZnBcIl0nLFxuXHRcdHR5cGVcdDogJ2FqYXgnXG4gICAgfTtcblxuICAgIGxldCBzZXR0aW5ncyA9IEJhc2UuY29uc3RydWN0KERFRkFVTFQsIGFyZ3MpO1xuXHRcblx0bGV0IGFjdGlvbiA9IGZ1bmN0aW9uKCl7XG5cdFx0Ly9jb25zb2xlLmxvZyhzZXR0aW5ncy50eXBlKTtcblxuXHRcdFxuXHRcdGlmIChzZXR0aW5ncy50eXBlID09ICdhamF4Jyl7XG5cdFx0XHR0aGlzLmFyZ3MgPSB7XG5cdFx0XHRcdHR5cGUgXHRcdFx0OiAnYWpheCcsXG5cdFx0XHRcdHNyYyAgXHRcdFx0OiAkKHRoaXMpLmF0dHIoJ2hyZWYnKSxcblx0XHRcdFx0Y2FsbGJhY2tzIFx0XHQ6IHtcblx0XHRcdFx0XHRwYXJzZUFqYXggXHQ6IGZ1bmN0aW9uKHIpe1xuXHRcdFx0XHRcdFx0Ly9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4MjY1Mjk0L21hZ25pZmljLXBvcHVwLWFqYXgtY2FsbC1mb3ItaHRtbC1mcmFnbWVudFxuXHRcdFx0XHRcdFx0dmFyIG1wIFx0XHRcdD0gJC5tYWduaWZpY1BvcHVwLmluc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHQkdHJpZ2dlclx0PSAkKG1wLmN1cnJJdGVtLmVsWzBdKSxcblx0XHRcdFx0XHRcdFx0ZnJhZ21lbnRcdD0gJHRyaWdnZXIuYXR0cignZGF0YS1mcmFnbWVudCcpO1xuXG5cdFx0XHRcdFx0XHRpZiAoZnJhZ21lbnQgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdFx0XHRcdHIuZGF0YSA9ICQoci5kYXRhKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHIuZGF0YSA9ICQoci5kYXRhKS5maWx0ZXIoZnJhZ21lbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0cmVtb3ZhbERlbGF5IFx0OiA1MDAsXG5cdFx0XHRcdG1haW5DbGFzcyBcdFx0OiAnbWZwLXpvb20taW4nLFxuXHRcdFx0XHRjbG9zZUJ0bkluc2lkZSBcdDogdHJ1ZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoc2V0dGluZ3MudHlwZSA9PSAnaW5saW5lJykge1xuXHRcdFx0dGhpcy5hcmdzID0ge1xuXHRcdFx0XHR0eXBlICAgICAgICAgICAgOiAnaW5saW5lJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoc2V0dGluZ3MudHlwZSA9PSAnaW1hZ2UnKSB7XG5cdFx0XHR0aGlzLmFyZ3MgPSB7XG5cdFx0XHRcdHR5cGUgICAgICAgICAgICA6ICdpbWFnZSdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKHNldHRpbmdzLnR5cGUgPT0gJ2dhbGxlcnknKSB7XG5cdFx0XHR0aGlzLmFyZ3MgPSB7XG5cdFx0XHRcdHR5cGUgICAgICAgICAgICA6ICdpbWFnZScsXG5cdFx0XHRcdGdhbGxlcnkgICAgICAgICA6IHtcblx0XHRcdFx0XHRlbmFibGVkOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG4gICAgICAgICQoc2V0dGluZ3MuZWwpLm1hZ25pZmljUG9wdXAodGhpcy5hcmdzKTtcblxuICAgIH1cblx0XG4gICAgXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGV4cG9ydGVyXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICBsZXQgcHVibGljRXhwb3J0cyA9IHtcbiAgICAgICAgYWN0aW9uLFxuICAgIH07XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihCYXNlLCBwdWJsaWNFeHBvcnRzKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnQvbW9kYWwtbWZwLmpzIiwiLyohIE1hZ25pZmljIFBvcHVwIC0gdjEuMC4wIC0gMjAxNC0xMi0xMlxuKiBodHRwOi8vZGltc2VtZW5vdi5jb20vcGx1Z2lucy9tYWduaWZpYy1wb3B1cC9cbiogQ29weXJpZ2h0IChjKSAyMDE0IERtaXRyeSBTZW1lbm92OyAqL1xuKGZ1bmN0aW9uKGUpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wianF1ZXJ5XCJdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2UocmVxdWlyZShcImpxdWVyeVwiKSk6ZSh3aW5kb3cualF1ZXJ5fHx3aW5kb3cuWmVwdG8pfSkoZnVuY3Rpb24oZSl7dmFyIHQsbixpLG8scixhLHMsbD1cIkNsb3NlXCIsYz1cIkJlZm9yZUNsb3NlXCIsZD1cIkFmdGVyQ2xvc2VcIix1PVwiQmVmb3JlQXBwZW5kXCIscD1cIk1hcmt1cFBhcnNlXCIsZj1cIk9wZW5cIixtPVwiQ2hhbmdlXCIsZz1cIm1mcFwiLGg9XCIuXCIrZyx2PVwibWZwLXJlYWR5XCIsQz1cIm1mcC1yZW1vdmluZ1wiLHk9XCJtZnAtcHJldmVudC1jbG9zZVwiLHc9ZnVuY3Rpb24oKXt9LGI9ISF3aW5kb3cualF1ZXJ5LEk9ZSh3aW5kb3cpLHg9ZnVuY3Rpb24oZSxuKXt0LmV2Lm9uKGcrZStoLG4pfSxrPWZ1bmN0aW9uKHQsbixpLG8pe3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIHIuY2xhc3NOYW1lPVwibWZwLVwiK3QsaSYmKHIuaW5uZXJIVE1MPWkpLG8/biYmbi5hcHBlbmRDaGlsZChyKToocj1lKHIpLG4mJnIuYXBwZW5kVG8obikpLHJ9LFQ9ZnVuY3Rpb24obixpKXt0LmV2LnRyaWdnZXJIYW5kbGVyKGcrbixpKSx0LnN0LmNhbGxiYWNrcyYmKG49bi5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKStuLnNsaWNlKDEpLHQuc3QuY2FsbGJhY2tzW25dJiZ0LnN0LmNhbGxiYWNrc1tuXS5hcHBseSh0LGUuaXNBcnJheShpKT9pOltpXSkpfSxFPWZ1bmN0aW9uKG4pe3JldHVybiBuPT09cyYmdC5jdXJyVGVtcGxhdGUuY2xvc2VCdG58fCh0LmN1cnJUZW1wbGF0ZS5jbG9zZUJ0bj1lKHQuc3QuY2xvc2VNYXJrdXAucmVwbGFjZShcIiV0aXRsZSVcIix0LnN0LnRDbG9zZSkpLHM9biksdC5jdXJyVGVtcGxhdGUuY2xvc2VCdG59LF89ZnVuY3Rpb24oKXtlLm1hZ25pZmljUG9wdXAuaW5zdGFuY2V8fCh0PW5ldyB3LHQuaW5pdCgpLGUubWFnbmlmaWNQb3B1cC5pbnN0YW5jZT10KX0sUz1mdW5jdGlvbigpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpLnN0eWxlLHQ9W1wibXNcIixcIk9cIixcIk1velwiLFwiV2Via2l0XCJdO2lmKHZvaWQgMCE9PWUudHJhbnNpdGlvbilyZXR1cm4hMDtmb3IoO3QubGVuZ3RoOylpZih0LnBvcCgpK1wiVHJhbnNpdGlvblwiaW4gZSlyZXR1cm4hMDtyZXR1cm4hMX07dy5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOncsaW5pdDpmdW5jdGlvbigpe3ZhciBuPW5hdmlnYXRvci5hcHBWZXJzaW9uO3QuaXNJRTc9LTEhPT1uLmluZGV4T2YoXCJNU0lFIDcuXCIpLHQuaXNJRTg9LTEhPT1uLmluZGV4T2YoXCJNU0lFIDguXCIpLHQuaXNMb3dJRT10LmlzSUU3fHx0LmlzSUU4LHQuaXNBbmRyb2lkPS9hbmRyb2lkL2dpLnRlc3QobiksdC5pc0lPUz0vaXBob25lfGlwYWR8aXBvZC9naS50ZXN0KG4pLHQuc3VwcG9ydHNUcmFuc2l0aW9uPVMoKSx0LnByb2JhYmx5TW9iaWxlPXQuaXNBbmRyb2lkfHx0LmlzSU9TfHwvKE9wZXJhIE1pbmkpfEtpbmRsZXx3ZWJPU3xCbGFja0JlcnJ5fChPcGVyYSBNb2JpKXwoV2luZG93cyBQaG9uZSl8SUVNb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLG89ZShkb2N1bWVudCksdC5wb3B1cHNDYWNoZT17fX0sb3BlbjpmdW5jdGlvbihuKXtpfHwoaT1lKGRvY3VtZW50LmJvZHkpKTt2YXIgcjtpZihuLmlzT2JqPT09ITEpe3QuaXRlbXM9bi5pdGVtcy50b0FycmF5KCksdC5pbmRleD0wO3ZhciBzLGw9bi5pdGVtcztmb3Iocj0wO2wubGVuZ3RoPnI7cisrKWlmKHM9bFtyXSxzLnBhcnNlZCYmKHM9cy5lbFswXSkscz09PW4uZWxbMF0pe3QuaW5kZXg9cjticmVha319ZWxzZSB0Lml0ZW1zPWUuaXNBcnJheShuLml0ZW1zKT9uLml0ZW1zOltuLml0ZW1zXSx0LmluZGV4PW4uaW5kZXh8fDA7aWYodC5pc09wZW4pcmV0dXJuIHQudXBkYXRlSXRlbUhUTUwoKSx2b2lkIDA7dC50eXBlcz1bXSxhPVwiXCIsdC5ldj1uLm1haW5FbCYmbi5tYWluRWwubGVuZ3RoP24ubWFpbkVsLmVxKDApOm8sbi5rZXk/KHQucG9wdXBzQ2FjaGVbbi5rZXldfHwodC5wb3B1cHNDYWNoZVtuLmtleV09e30pLHQuY3VyclRlbXBsYXRlPXQucG9wdXBzQ2FjaGVbbi5rZXldKTp0LmN1cnJUZW1wbGF0ZT17fSx0LnN0PWUuZXh0ZW5kKCEwLHt9LGUubWFnbmlmaWNQb3B1cC5kZWZhdWx0cyxuKSx0LmZpeGVkQ29udGVudFBvcz1cImF1dG9cIj09PXQuc3QuZml4ZWRDb250ZW50UG9zPyF0LnByb2JhYmx5TW9iaWxlOnQuc3QuZml4ZWRDb250ZW50UG9zLHQuc3QubW9kYWwmJih0LnN0LmNsb3NlT25Db250ZW50Q2xpY2s9ITEsdC5zdC5jbG9zZU9uQmdDbGljaz0hMSx0LnN0LnNob3dDbG9zZUJ0bj0hMSx0LnN0LmVuYWJsZUVzY2FwZUtleT0hMSksdC5iZ092ZXJsYXl8fCh0LmJnT3ZlcmxheT1rKFwiYmdcIikub24oXCJjbGlja1wiK2gsZnVuY3Rpb24oKXt0LmNsb3NlKCl9KSx0LndyYXA9ayhcIndyYXBcIikuYXR0cihcInRhYmluZGV4XCIsLTEpLm9uKFwiY2xpY2tcIitoLGZ1bmN0aW9uKGUpe3QuX2NoZWNrSWZDbG9zZShlLnRhcmdldCkmJnQuY2xvc2UoKX0pLHQuY29udGFpbmVyPWsoXCJjb250YWluZXJcIix0LndyYXApKSx0LmNvbnRlbnRDb250YWluZXI9ayhcImNvbnRlbnRcIiksdC5zdC5wcmVsb2FkZXImJih0LnByZWxvYWRlcj1rKFwicHJlbG9hZGVyXCIsdC5jb250YWluZXIsdC5zdC50TG9hZGluZykpO3ZhciBjPWUubWFnbmlmaWNQb3B1cC5tb2R1bGVzO2ZvcihyPTA7Yy5sZW5ndGg+cjtyKyspe3ZhciBkPWNbcl07ZD1kLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Quc2xpY2UoMSksdFtcImluaXRcIitkXS5jYWxsKHQpfVQoXCJCZWZvcmVPcGVuXCIpLHQuc3Quc2hvd0Nsb3NlQnRuJiYodC5zdC5jbG9zZUJ0bkluc2lkZT8oeChwLGZ1bmN0aW9uKGUsdCxuLGkpe24uY2xvc2VfcmVwbGFjZVdpdGg9RShpLnR5cGUpfSksYSs9XCIgbWZwLWNsb3NlLWJ0bi1pblwiKTp0LndyYXAuYXBwZW5kKEUoKSkpLHQuc3QuYWxpZ25Ub3AmJihhKz1cIiBtZnAtYWxpZ24tdG9wXCIpLHQuZml4ZWRDb250ZW50UG9zP3Qud3JhcC5jc3Moe292ZXJmbG93OnQuc3Qub3ZlcmZsb3dZLG92ZXJmbG93WDpcImhpZGRlblwiLG92ZXJmbG93WTp0LnN0Lm92ZXJmbG93WX0pOnQud3JhcC5jc3Moe3RvcDpJLnNjcm9sbFRvcCgpLHBvc2l0aW9uOlwiYWJzb2x1dGVcIn0pLCh0LnN0LmZpeGVkQmdQb3M9PT0hMXx8XCJhdXRvXCI9PT10LnN0LmZpeGVkQmdQb3MmJiF0LmZpeGVkQ29udGVudFBvcykmJnQuYmdPdmVybGF5LmNzcyh7aGVpZ2h0Om8uaGVpZ2h0KCkscG9zaXRpb246XCJhYnNvbHV0ZVwifSksdC5zdC5lbmFibGVFc2NhcGVLZXkmJm8ub24oXCJrZXl1cFwiK2gsZnVuY3Rpb24oZSl7Mjc9PT1lLmtleUNvZGUmJnQuY2xvc2UoKX0pLEkub24oXCJyZXNpemVcIitoLGZ1bmN0aW9uKCl7dC51cGRhdGVTaXplKCl9KSx0LnN0LmNsb3NlT25Db250ZW50Q2xpY2t8fChhKz1cIiBtZnAtYXV0by1jdXJzb3JcIiksYSYmdC53cmFwLmFkZENsYXNzKGEpO3ZhciB1PXQud0g9SS5oZWlnaHQoKSxtPXt9O2lmKHQuZml4ZWRDb250ZW50UG9zJiZ0Ll9oYXNTY3JvbGxCYXIodSkpe3ZhciBnPXQuX2dldFNjcm9sbGJhclNpemUoKTtnJiYobS5tYXJnaW5SaWdodD1nKX10LmZpeGVkQ29udGVudFBvcyYmKHQuaXNJRTc/ZShcImJvZHksIGh0bWxcIikuY3NzKFwib3ZlcmZsb3dcIixcImhpZGRlblwiKTptLm92ZXJmbG93PVwiaGlkZGVuXCIpO3ZhciBDPXQuc3QubWFpbkNsYXNzO3JldHVybiB0LmlzSUU3JiYoQys9XCIgbWZwLWllN1wiKSxDJiZ0Ll9hZGRDbGFzc1RvTUZQKEMpLHQudXBkYXRlSXRlbUhUTUwoKSxUKFwiQnVpbGRDb250cm9sc1wiKSxlKFwiaHRtbFwiKS5jc3MobSksdC5iZ092ZXJsYXkuYWRkKHQud3JhcCkucHJlcGVuZFRvKHQuc3QucHJlcGVuZFRvfHxpKSx0Ll9sYXN0Rm9jdXNlZEVsPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsc2V0VGltZW91dChmdW5jdGlvbigpe3QuY29udGVudD8odC5fYWRkQ2xhc3NUb01GUCh2KSx0Ll9zZXRGb2N1cygpKTp0LmJnT3ZlcmxheS5hZGRDbGFzcyh2KSxvLm9uKFwiZm9jdXNpblwiK2gsdC5fb25Gb2N1c0luKX0sMTYpLHQuaXNPcGVuPSEwLHQudXBkYXRlU2l6ZSh1KSxUKGYpLG59LGNsb3NlOmZ1bmN0aW9uKCl7dC5pc09wZW4mJihUKGMpLHQuaXNPcGVuPSExLHQuc3QucmVtb3ZhbERlbGF5JiYhdC5pc0xvd0lFJiZ0LnN1cHBvcnRzVHJhbnNpdGlvbj8odC5fYWRkQ2xhc3NUb01GUChDKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5fY2xvc2UoKX0sdC5zdC5yZW1vdmFsRGVsYXkpKTp0Ll9jbG9zZSgpKX0sX2Nsb3NlOmZ1bmN0aW9uKCl7VChsKTt2YXIgbj1DK1wiIFwiK3YrXCIgXCI7aWYodC5iZ092ZXJsYXkuZGV0YWNoKCksdC53cmFwLmRldGFjaCgpLHQuY29udGFpbmVyLmVtcHR5KCksdC5zdC5tYWluQ2xhc3MmJihuKz10LnN0Lm1haW5DbGFzcytcIiBcIiksdC5fcmVtb3ZlQ2xhc3NGcm9tTUZQKG4pLHQuZml4ZWRDb250ZW50UG9zKXt2YXIgaT17bWFyZ2luUmlnaHQ6XCJcIn07dC5pc0lFNz9lKFwiYm9keSwgaHRtbFwiKS5jc3MoXCJvdmVyZmxvd1wiLFwiXCIpOmkub3ZlcmZsb3c9XCJcIixlKFwiaHRtbFwiKS5jc3MoaSl9by5vZmYoXCJrZXl1cFwiK2grXCIgZm9jdXNpblwiK2gpLHQuZXYub2ZmKGgpLHQud3JhcC5hdHRyKFwiY2xhc3NcIixcIm1mcC13cmFwXCIpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKSx0LmJnT3ZlcmxheS5hdHRyKFwiY2xhc3NcIixcIm1mcC1iZ1wiKSx0LmNvbnRhaW5lci5hdHRyKFwiY2xhc3NcIixcIm1mcC1jb250YWluZXJcIiksIXQuc3Quc2hvd0Nsb3NlQnRufHx0LnN0LmNsb3NlQnRuSW5zaWRlJiZ0LmN1cnJUZW1wbGF0ZVt0LmN1cnJJdGVtLnR5cGVdIT09ITB8fHQuY3VyclRlbXBsYXRlLmNsb3NlQnRuJiZ0LmN1cnJUZW1wbGF0ZS5jbG9zZUJ0bi5kZXRhY2goKSx0Ll9sYXN0Rm9jdXNlZEVsJiZlKHQuX2xhc3RGb2N1c2VkRWwpLmZvY3VzKCksdC5jdXJySXRlbT1udWxsLHQuY29udGVudD1udWxsLHQuY3VyclRlbXBsYXRlPW51bGwsdC5wcmV2SGVpZ2h0PTAsVChkKX0sdXBkYXRlU2l6ZTpmdW5jdGlvbihlKXtpZih0LmlzSU9TKXt2YXIgbj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgvd2luZG93LmlubmVyV2lkdGgsaT13aW5kb3cuaW5uZXJIZWlnaHQqbjt0LndyYXAuY3NzKFwiaGVpZ2h0XCIsaSksdC53SD1pfWVsc2UgdC53SD1lfHxJLmhlaWdodCgpO3QuZml4ZWRDb250ZW50UG9zfHx0LndyYXAuY3NzKFwiaGVpZ2h0XCIsdC53SCksVChcIlJlc2l6ZVwiKX0sdXBkYXRlSXRlbUhUTUw6ZnVuY3Rpb24oKXt2YXIgbj10Lml0ZW1zW3QuaW5kZXhdO3QuY29udGVudENvbnRhaW5lci5kZXRhY2goKSx0LmNvbnRlbnQmJnQuY29udGVudC5kZXRhY2goKSxuLnBhcnNlZHx8KG49dC5wYXJzZUVsKHQuaW5kZXgpKTt2YXIgaT1uLnR5cGU7aWYoVChcIkJlZm9yZUNoYW5nZVwiLFt0LmN1cnJJdGVtP3QuY3Vyckl0ZW0udHlwZTpcIlwiLGldKSx0LmN1cnJJdGVtPW4sIXQuY3VyclRlbXBsYXRlW2ldKXt2YXIgbz10LnN0W2ldP3Quc3RbaV0ubWFya3VwOiExO1QoXCJGaXJzdE1hcmt1cFBhcnNlXCIsbyksdC5jdXJyVGVtcGxhdGVbaV09bz9lKG8pOiEwfXImJnIhPT1uLnR5cGUmJnQuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwibWZwLVwiK3IrXCItaG9sZGVyXCIpO3ZhciBhPXRbXCJnZXRcIitpLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2kuc2xpY2UoMSldKG4sdC5jdXJyVGVtcGxhdGVbaV0pO3QuYXBwZW5kQ29udGVudChhLGkpLG4ucHJlbG9hZGVkPSEwLFQobSxuKSxyPW4udHlwZSx0LmNvbnRhaW5lci5wcmVwZW5kKHQuY29udGVudENvbnRhaW5lciksVChcIkFmdGVyQ2hhbmdlXCIpfSxhcHBlbmRDb250ZW50OmZ1bmN0aW9uKGUsbil7dC5jb250ZW50PWUsZT90LnN0LnNob3dDbG9zZUJ0biYmdC5zdC5jbG9zZUJ0bkluc2lkZSYmdC5jdXJyVGVtcGxhdGVbbl09PT0hMD90LmNvbnRlbnQuZmluZChcIi5tZnAtY2xvc2VcIikubGVuZ3RofHx0LmNvbnRlbnQuYXBwZW5kKEUoKSk6dC5jb250ZW50PWU6dC5jb250ZW50PVwiXCIsVCh1KSx0LmNvbnRhaW5lci5hZGRDbGFzcyhcIm1mcC1cIituK1wiLWhvbGRlclwiKSx0LmNvbnRlbnRDb250YWluZXIuYXBwZW5kKHQuY29udGVudCl9LHBhcnNlRWw6ZnVuY3Rpb24obil7dmFyIGksbz10Lml0ZW1zW25dO2lmKG8udGFnTmFtZT9vPXtlbDplKG8pfTooaT1vLnR5cGUsbz17ZGF0YTpvLHNyYzpvLnNyY30pLG8uZWwpe2Zvcih2YXIgcj10LnR5cGVzLGE9MDtyLmxlbmd0aD5hO2ErKylpZihvLmVsLmhhc0NsYXNzKFwibWZwLVwiK3JbYV0pKXtpPXJbYV07YnJlYWt9by5zcmM9by5lbC5hdHRyKFwiZGF0YS1tZnAtc3JjXCIpLG8uc3JjfHwoby5zcmM9by5lbC5hdHRyKFwiaHJlZlwiKSl9cmV0dXJuIG8udHlwZT1pfHx0LnN0LnR5cGV8fFwiaW5saW5lXCIsby5pbmRleD1uLG8ucGFyc2VkPSEwLHQuaXRlbXNbbl09byxUKFwiRWxlbWVudFBhcnNlXCIsbyksdC5pdGVtc1tuXX0sYWRkR3JvdXA6ZnVuY3Rpb24oZSxuKXt2YXIgaT1mdW5jdGlvbihpKXtpLm1mcEVsPXRoaXMsdC5fb3BlbkNsaWNrKGksZSxuKX07bnx8KG49e30pO3ZhciBvPVwiY2xpY2subWFnbmlmaWNQb3B1cFwiO24ubWFpbkVsPWUsbi5pdGVtcz8obi5pc09iaj0hMCxlLm9mZihvKS5vbihvLGkpKToobi5pc09iaj0hMSxuLmRlbGVnYXRlP2Uub2ZmKG8pLm9uKG8sbi5kZWxlZ2F0ZSxpKToobi5pdGVtcz1lLGUub2ZmKG8pLm9uKG8saSkpKX0sX29wZW5DbGljazpmdW5jdGlvbihuLGksbyl7dmFyIHI9dm9pZCAwIT09by5taWRDbGljaz9vLm1pZENsaWNrOmUubWFnbmlmaWNQb3B1cC5kZWZhdWx0cy5taWRDbGljaztpZihyfHwyIT09bi53aGljaCYmIW4uY3RybEtleSYmIW4ubWV0YUtleSl7dmFyIGE9dm9pZCAwIT09by5kaXNhYmxlT24/by5kaXNhYmxlT246ZS5tYWduaWZpY1BvcHVwLmRlZmF1bHRzLmRpc2FibGVPbjtpZihhKWlmKGUuaXNGdW5jdGlvbihhKSl7aWYoIWEuY2FsbCh0KSlyZXR1cm4hMH1lbHNlIGlmKGE+SS53aWR0aCgpKXJldHVybiEwO24udHlwZSYmKG4ucHJldmVudERlZmF1bHQoKSx0LmlzT3BlbiYmbi5zdG9wUHJvcGFnYXRpb24oKSksby5lbD1lKG4ubWZwRWwpLG8uZGVsZWdhdGUmJihvLml0ZW1zPWkuZmluZChvLmRlbGVnYXRlKSksdC5vcGVuKG8pfX0sdXBkYXRlU3RhdHVzOmZ1bmN0aW9uKGUsaSl7aWYodC5wcmVsb2FkZXIpe24hPT1lJiZ0LmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcIm1mcC1zLVwiK24pLGl8fFwibG9hZGluZ1wiIT09ZXx8KGk9dC5zdC50TG9hZGluZyk7dmFyIG89e3N0YXR1czplLHRleHQ6aX07VChcIlVwZGF0ZVN0YXR1c1wiLG8pLGU9by5zdGF0dXMsaT1vLnRleHQsdC5wcmVsb2FkZXIuaHRtbChpKSx0LnByZWxvYWRlci5maW5kKFwiYVwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oZSl7ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKX0pLHQuY29udGFpbmVyLmFkZENsYXNzKFwibWZwLXMtXCIrZSksbj1lfX0sX2NoZWNrSWZDbG9zZTpmdW5jdGlvbihuKXtpZighZShuKS5oYXNDbGFzcyh5KSl7dmFyIGk9dC5zdC5jbG9zZU9uQ29udGVudENsaWNrLG89dC5zdC5jbG9zZU9uQmdDbGljaztpZihpJiZvKXJldHVybiEwO2lmKCF0LmNvbnRlbnR8fGUobikuaGFzQ2xhc3MoXCJtZnAtY2xvc2VcIil8fHQucHJlbG9hZGVyJiZuPT09dC5wcmVsb2FkZXJbMF0pcmV0dXJuITA7aWYobj09PXQuY29udGVudFswXXx8ZS5jb250YWlucyh0LmNvbnRlbnRbMF0sbikpe2lmKGkpcmV0dXJuITB9ZWxzZSBpZihvJiZlLmNvbnRhaW5zKGRvY3VtZW50LG4pKXJldHVybiEwO3JldHVybiExfX0sX2FkZENsYXNzVG9NRlA6ZnVuY3Rpb24oZSl7dC5iZ092ZXJsYXkuYWRkQ2xhc3MoZSksdC53cmFwLmFkZENsYXNzKGUpfSxfcmVtb3ZlQ2xhc3NGcm9tTUZQOmZ1bmN0aW9uKGUpe3RoaXMuYmdPdmVybGF5LnJlbW92ZUNsYXNzKGUpLHQud3JhcC5yZW1vdmVDbGFzcyhlKX0sX2hhc1Njcm9sbEJhcjpmdW5jdGlvbihlKXtyZXR1cm4odC5pc0lFNz9vLmhlaWdodCgpOmRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0KT4oZXx8SS5oZWlnaHQoKSl9LF9zZXRGb2N1czpmdW5jdGlvbigpeyh0LnN0LmZvY3VzP3QuY29udGVudC5maW5kKHQuc3QuZm9jdXMpLmVxKDApOnQud3JhcCkuZm9jdXMoKX0sX29uRm9jdXNJbjpmdW5jdGlvbihuKXtyZXR1cm4gbi50YXJnZXQ9PT10LndyYXBbMF18fGUuY29udGFpbnModC53cmFwWzBdLG4udGFyZ2V0KT92b2lkIDA6KHQuX3NldEZvY3VzKCksITEpfSxfcGFyc2VNYXJrdXA6ZnVuY3Rpb24odCxuLGkpe3ZhciBvO2kuZGF0YSYmKG49ZS5leHRlbmQoaS5kYXRhLG4pKSxUKHAsW3QsbixpXSksZS5lYWNoKG4sZnVuY3Rpb24oZSxuKXtpZih2b2lkIDA9PT1ufHxuPT09ITEpcmV0dXJuITA7aWYobz1lLnNwbGl0KFwiX1wiKSxvLmxlbmd0aD4xKXt2YXIgaT10LmZpbmQoaCtcIi1cIitvWzBdKTtpZihpLmxlbmd0aD4wKXt2YXIgcj1vWzFdO1wicmVwbGFjZVdpdGhcIj09PXI/aVswXSE9PW5bMF0mJmkucmVwbGFjZVdpdGgobik6XCJpbWdcIj09PXI/aS5pcyhcImltZ1wiKT9pLmF0dHIoXCJzcmNcIixuKTppLnJlcGxhY2VXaXRoKCc8aW1nIHNyYz1cIicrbisnXCIgY2xhc3M9XCInK2kuYXR0cihcImNsYXNzXCIpKydcIiAvPicpOmkuYXR0cihvWzFdLG4pfX1lbHNlIHQuZmluZChoK1wiLVwiK2UpLmh0bWwobil9KX0sX2dldFNjcm9sbGJhclNpemU6ZnVuY3Rpb24oKXtpZih2b2lkIDA9PT10LnNjcm9sbGJhclNpemUpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5zdHlsZS5jc3NUZXh0PVwid2lkdGg6IDk5cHg7IGhlaWdodDogOTlweDsgb3ZlcmZsb3c6IHNjcm9sbDsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IC05OTk5cHg7XCIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKSx0LnNjcm9sbGJhclNpemU9ZS5vZmZzZXRXaWR0aC1lLmNsaWVudFdpZHRoLGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZSl9cmV0dXJuIHQuc2Nyb2xsYmFyU2l6ZX19LGUubWFnbmlmaWNQb3B1cD17aW5zdGFuY2U6bnVsbCxwcm90bzp3LnByb3RvdHlwZSxtb2R1bGVzOltdLG9wZW46ZnVuY3Rpb24odCxuKXtyZXR1cm4gXygpLHQ9dD9lLmV4dGVuZCghMCx7fSx0KTp7fSx0LmlzT2JqPSEwLHQuaW5kZXg9bnx8MCx0aGlzLmluc3RhbmNlLm9wZW4odCl9LGNsb3NlOmZ1bmN0aW9uKCl7cmV0dXJuIGUubWFnbmlmaWNQb3B1cC5pbnN0YW5jZSYmZS5tYWduaWZpY1BvcHVwLmluc3RhbmNlLmNsb3NlKCl9LHJlZ2lzdGVyTW9kdWxlOmZ1bmN0aW9uKHQsbil7bi5vcHRpb25zJiYoZS5tYWduaWZpY1BvcHVwLmRlZmF1bHRzW3RdPW4ub3B0aW9ucyksZS5leHRlbmQodGhpcy5wcm90byxuLnByb3RvKSx0aGlzLm1vZHVsZXMucHVzaCh0KX0sZGVmYXVsdHM6e2Rpc2FibGVPbjowLGtleTpudWxsLG1pZENsaWNrOiExLG1haW5DbGFzczpcIlwiLHByZWxvYWRlcjohMCxmb2N1czpcIlwiLGNsb3NlT25Db250ZW50Q2xpY2s6ITEsY2xvc2VPbkJnQ2xpY2s6ITAsY2xvc2VCdG5JbnNpZGU6ITAsc2hvd0Nsb3NlQnRuOiEwLGVuYWJsZUVzY2FwZUtleTohMCxtb2RhbDohMSxhbGlnblRvcDohMSxyZW1vdmFsRGVsYXk6MCxwcmVwZW5kVG86bnVsbCxmaXhlZENvbnRlbnRQb3M6XCJhdXRvXCIsZml4ZWRCZ1BvczpcImF1dG9cIixvdmVyZmxvd1k6XCJhdXRvXCIsY2xvc2VNYXJrdXA6JzxidXR0b24gdGl0bGU9XCIldGl0bGUlXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwibWZwLWNsb3NlXCI+JnRpbWVzOzwvYnV0dG9uPicsdENsb3NlOlwiQ2xvc2UgKEVzYylcIix0TG9hZGluZzpcIkxvYWRpbmcuLi5cIn19LGUuZm4ubWFnbmlmaWNQb3B1cD1mdW5jdGlvbihuKXtfKCk7dmFyIGk9ZSh0aGlzKTtpZihcInN0cmluZ1wiPT10eXBlb2YgbilpZihcIm9wZW5cIj09PW4pe3ZhciBvLHI9Yj9pLmRhdGEoXCJtYWduaWZpY1BvcHVwXCIpOmlbMF0ubWFnbmlmaWNQb3B1cCxhPXBhcnNlSW50KGFyZ3VtZW50c1sxXSwxMCl8fDA7ci5pdGVtcz9vPXIuaXRlbXNbYV06KG89aSxyLmRlbGVnYXRlJiYobz1vLmZpbmQoci5kZWxlZ2F0ZSkpLG89by5lcShhKSksdC5fb3BlbkNsaWNrKHttZnBFbDpvfSxpLHIpfWVsc2UgdC5pc09wZW4mJnRbbl0uYXBwbHkodCxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO2Vsc2Ugbj1lLmV4dGVuZCghMCx7fSxuKSxiP2kuZGF0YShcIm1hZ25pZmljUG9wdXBcIixuKTppWzBdLm1hZ25pZmljUG9wdXA9bix0LmFkZEdyb3VwKGksbik7cmV0dXJuIGl9O3ZhciBQLE8seixNPVwiaW5saW5lXCIsQj1mdW5jdGlvbigpe3omJihPLmFmdGVyKHouYWRkQ2xhc3MoUCkpLmRldGFjaCgpLHo9bnVsbCl9O2UubWFnbmlmaWNQb3B1cC5yZWdpc3Rlck1vZHVsZShNLHtvcHRpb25zOntoaWRkZW5DbGFzczpcImhpZGVcIixtYXJrdXA6XCJcIix0Tm90Rm91bmQ6XCJDb250ZW50IG5vdCBmb3VuZFwifSxwcm90bzp7aW5pdElubGluZTpmdW5jdGlvbigpe3QudHlwZXMucHVzaChNKSx4KGwrXCIuXCIrTSxmdW5jdGlvbigpe0IoKX0pfSxnZXRJbmxpbmU6ZnVuY3Rpb24obixpKXtpZihCKCksbi5zcmMpe3ZhciBvPXQuc3QuaW5saW5lLHI9ZShuLnNyYyk7aWYoci5sZW5ndGgpe3ZhciBhPXJbMF0ucGFyZW50Tm9kZTthJiZhLnRhZ05hbWUmJihPfHwoUD1vLmhpZGRlbkNsYXNzLE89ayhQKSxQPVwibWZwLVwiK1ApLHo9ci5hZnRlcihPKS5kZXRhY2goKS5yZW1vdmVDbGFzcyhQKSksdC51cGRhdGVTdGF0dXMoXCJyZWFkeVwiKX1lbHNlIHQudXBkYXRlU3RhdHVzKFwiZXJyb3JcIixvLnROb3RGb3VuZCkscj1lKFwiPGRpdj5cIik7cmV0dXJuIG4uaW5saW5lRWxlbWVudD1yLHJ9cmV0dXJuIHQudXBkYXRlU3RhdHVzKFwicmVhZHlcIiksdC5fcGFyc2VNYXJrdXAoaSx7fSxuKSxpfX19KTt2YXIgRixIPVwiYWpheFwiLEw9ZnVuY3Rpb24oKXtGJiZpLnJlbW92ZUNsYXNzKEYpfSxBPWZ1bmN0aW9uKCl7TCgpLHQucmVxJiZ0LnJlcS5hYm9ydCgpfTtlLm1hZ25pZmljUG9wdXAucmVnaXN0ZXJNb2R1bGUoSCx7b3B0aW9uczp7c2V0dGluZ3M6bnVsbCxjdXJzb3I6XCJtZnAtYWpheC1jdXJcIix0RXJyb3I6JzxhIGhyZWY9XCIldXJsJVwiPlRoZSBjb250ZW50PC9hPiBjb3VsZCBub3QgYmUgbG9hZGVkLid9LHByb3RvOntpbml0QWpheDpmdW5jdGlvbigpe3QudHlwZXMucHVzaChIKSxGPXQuc3QuYWpheC5jdXJzb3IseChsK1wiLlwiK0gsQSkseChcIkJlZm9yZUNoYW5nZS5cIitILEEpfSxnZXRBamF4OmZ1bmN0aW9uKG4pe0YmJmkuYWRkQ2xhc3MoRiksdC51cGRhdGVTdGF0dXMoXCJsb2FkaW5nXCIpO3ZhciBvPWUuZXh0ZW5kKHt1cmw6bi5zcmMsc3VjY2VzczpmdW5jdGlvbihpLG8scil7dmFyIGE9e2RhdGE6aSx4aHI6cn07VChcIlBhcnNlQWpheFwiLGEpLHQuYXBwZW5kQ29udGVudChlKGEuZGF0YSksSCksbi5maW5pc2hlZD0hMCxMKCksdC5fc2V0Rm9jdXMoKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC53cmFwLmFkZENsYXNzKHYpfSwxNiksdC51cGRhdGVTdGF0dXMoXCJyZWFkeVwiKSxUKFwiQWpheENvbnRlbnRBZGRlZFwiKX0sZXJyb3I6ZnVuY3Rpb24oKXtMKCksbi5maW5pc2hlZD1uLmxvYWRFcnJvcj0hMCx0LnVwZGF0ZVN0YXR1cyhcImVycm9yXCIsdC5zdC5hamF4LnRFcnJvci5yZXBsYWNlKFwiJXVybCVcIixuLnNyYykpfX0sdC5zdC5hamF4LnNldHRpbmdzKTtyZXR1cm4gdC5yZXE9ZS5hamF4KG8pLFwiXCJ9fX0pO3ZhciBqLE49ZnVuY3Rpb24obil7aWYobi5kYXRhJiZ2b2lkIDAhPT1uLmRhdGEudGl0bGUpcmV0dXJuIG4uZGF0YS50aXRsZTt2YXIgaT10LnN0LmltYWdlLnRpdGxlU3JjO2lmKGkpe2lmKGUuaXNGdW5jdGlvbihpKSlyZXR1cm4gaS5jYWxsKHQsbik7aWYobi5lbClyZXR1cm4gbi5lbC5hdHRyKGkpfHxcIlwifXJldHVyblwiXCJ9O2UubWFnbmlmaWNQb3B1cC5yZWdpc3Rlck1vZHVsZShcImltYWdlXCIse29wdGlvbnM6e21hcmt1cDonPGRpdiBjbGFzcz1cIm1mcC1maWd1cmVcIj48ZGl2IGNsYXNzPVwibWZwLWNsb3NlXCI+PC9kaXY+PGZpZ3VyZT48ZGl2IGNsYXNzPVwibWZwLWltZ1wiPjwvZGl2PjxmaWdjYXB0aW9uPjxkaXYgY2xhc3M9XCJtZnAtYm90dG9tLWJhclwiPjxkaXYgY2xhc3M9XCJtZnAtdGl0bGVcIj48L2Rpdj48ZGl2IGNsYXNzPVwibWZwLWNvdW50ZXJcIj48L2Rpdj48L2Rpdj48L2ZpZ2NhcHRpb24+PC9maWd1cmU+PC9kaXY+JyxjdXJzb3I6XCJtZnAtem9vbS1vdXQtY3VyXCIsdGl0bGVTcmM6XCJ0aXRsZVwiLHZlcnRpY2FsRml0OiEwLHRFcnJvcjonPGEgaHJlZj1cIiV1cmwlXCI+VGhlIGltYWdlPC9hPiBjb3VsZCBub3QgYmUgbG9hZGVkLid9LHByb3RvOntpbml0SW1hZ2U6ZnVuY3Rpb24oKXt2YXIgZT10LnN0LmltYWdlLG49XCIuaW1hZ2VcIjt0LnR5cGVzLnB1c2goXCJpbWFnZVwiKSx4KGYrbixmdW5jdGlvbigpe1wiaW1hZ2VcIj09PXQuY3Vyckl0ZW0udHlwZSYmZS5jdXJzb3ImJmkuYWRkQ2xhc3MoZS5jdXJzb3IpfSkseChsK24sZnVuY3Rpb24oKXtlLmN1cnNvciYmaS5yZW1vdmVDbGFzcyhlLmN1cnNvciksSS5vZmYoXCJyZXNpemVcIitoKX0pLHgoXCJSZXNpemVcIituLHQucmVzaXplSW1hZ2UpLHQuaXNMb3dJRSYmeChcIkFmdGVyQ2hhbmdlXCIsdC5yZXNpemVJbWFnZSl9LHJlc2l6ZUltYWdlOmZ1bmN0aW9uKCl7dmFyIGU9dC5jdXJySXRlbTtpZihlJiZlLmltZyYmdC5zdC5pbWFnZS52ZXJ0aWNhbEZpdCl7dmFyIG49MDt0LmlzTG93SUUmJihuPXBhcnNlSW50KGUuaW1nLmNzcyhcInBhZGRpbmctdG9wXCIpLDEwKStwYXJzZUludChlLmltZy5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiKSwxMCkpLGUuaW1nLmNzcyhcIm1heC1oZWlnaHRcIix0LndILW4pfX0sX29uSW1hZ2VIYXNTaXplOmZ1bmN0aW9uKGUpe2UuaW1nJiYoZS5oYXNTaXplPSEwLGomJmNsZWFySW50ZXJ2YWwoaiksZS5pc0NoZWNraW5nSW1nU2l6ZT0hMSxUKFwiSW1hZ2VIYXNTaXplXCIsZSksZS5pbWdIaWRkZW4mJih0LmNvbnRlbnQmJnQuY29udGVudC5yZW1vdmVDbGFzcyhcIm1mcC1sb2FkaW5nXCIpLGUuaW1nSGlkZGVuPSExKSl9LGZpbmRJbWFnZVNpemU6ZnVuY3Rpb24oZSl7dmFyIG49MCxpPWUuaW1nWzBdLG89ZnVuY3Rpb24ocil7aiYmY2xlYXJJbnRlcnZhbChqKSxqPXNldEludGVydmFsKGZ1bmN0aW9uKCl7cmV0dXJuIGkubmF0dXJhbFdpZHRoPjA/KHQuX29uSW1hZ2VIYXNTaXplKGUpLHZvaWQgMCk6KG4+MjAwJiZjbGVhckludGVydmFsKGopLG4rKywzPT09bj9vKDEwKTo0MD09PW4/byg1MCk6MTAwPT09biYmbyg1MDApLHZvaWQgMCl9LHIpfTtvKDEpfSxnZXRJbWFnZTpmdW5jdGlvbihuLGkpe3ZhciBvPTAscj1mdW5jdGlvbigpe24mJihuLmltZ1swXS5jb21wbGV0ZT8obi5pbWcub2ZmKFwiLm1mcGxvYWRlclwiKSxuPT09dC5jdXJySXRlbSYmKHQuX29uSW1hZ2VIYXNTaXplKG4pLHQudXBkYXRlU3RhdHVzKFwicmVhZHlcIikpLG4uaGFzU2l6ZT0hMCxuLmxvYWRlZD0hMCxUKFwiSW1hZ2VMb2FkQ29tcGxldGVcIikpOihvKyssMjAwPm8/c2V0VGltZW91dChyLDEwMCk6YSgpKSl9LGE9ZnVuY3Rpb24oKXtuJiYobi5pbWcub2ZmKFwiLm1mcGxvYWRlclwiKSxuPT09dC5jdXJySXRlbSYmKHQuX29uSW1hZ2VIYXNTaXplKG4pLHQudXBkYXRlU3RhdHVzKFwiZXJyb3JcIixzLnRFcnJvci5yZXBsYWNlKFwiJXVybCVcIixuLnNyYykpKSxuLmhhc1NpemU9ITAsbi5sb2FkZWQ9ITAsbi5sb2FkRXJyb3I9ITApfSxzPXQuc3QuaW1hZ2UsbD1pLmZpbmQoXCIubWZwLWltZ1wiKTtpZihsLmxlbmd0aCl7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtjLmNsYXNzTmFtZT1cIm1mcC1pbWdcIixuLmVsJiZuLmVsLmZpbmQoXCJpbWdcIikubGVuZ3RoJiYoYy5hbHQ9bi5lbC5maW5kKFwiaW1nXCIpLmF0dHIoXCJhbHRcIikpLG4uaW1nPWUoYykub24oXCJsb2FkLm1mcGxvYWRlclwiLHIpLm9uKFwiZXJyb3IubWZwbG9hZGVyXCIsYSksYy5zcmM9bi5zcmMsbC5pcyhcImltZ1wiKSYmKG4uaW1nPW4uaW1nLmNsb25lKCkpLGM9bi5pbWdbMF0sYy5uYXR1cmFsV2lkdGg+MD9uLmhhc1NpemU9ITA6Yy53aWR0aHx8KG4uaGFzU2l6ZT0hMSl9cmV0dXJuIHQuX3BhcnNlTWFya3VwKGkse3RpdGxlOk4obiksaW1nX3JlcGxhY2VXaXRoOm4uaW1nfSxuKSx0LnJlc2l6ZUltYWdlKCksbi5oYXNTaXplPyhqJiZjbGVhckludGVydmFsKGopLG4ubG9hZEVycm9yPyhpLmFkZENsYXNzKFwibWZwLWxvYWRpbmdcIiksdC51cGRhdGVTdGF0dXMoXCJlcnJvclwiLHMudEVycm9yLnJlcGxhY2UoXCIldXJsJVwiLG4uc3JjKSkpOihpLnJlbW92ZUNsYXNzKFwibWZwLWxvYWRpbmdcIiksdC51cGRhdGVTdGF0dXMoXCJyZWFkeVwiKSksaSk6KHQudXBkYXRlU3RhdHVzKFwibG9hZGluZ1wiKSxuLmxvYWRpbmc9ITAsbi5oYXNTaXplfHwobi5pbWdIaWRkZW49ITAsaS5hZGRDbGFzcyhcIm1mcC1sb2FkaW5nXCIpLHQuZmluZEltYWdlU2l6ZShuKSksaSl9fX0pO3ZhciBXLFI9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09VyYmKFc9dm9pZCAwIT09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikuc3R5bGUuTW96VHJhbnNmb3JtKSxXfTtlLm1hZ25pZmljUG9wdXAucmVnaXN0ZXJNb2R1bGUoXCJ6b29tXCIse29wdGlvbnM6e2VuYWJsZWQ6ITEsZWFzaW5nOlwiZWFzZS1pbi1vdXRcIixkdXJhdGlvbjozMDAsb3BlbmVyOmZ1bmN0aW9uKGUpe3JldHVybiBlLmlzKFwiaW1nXCIpP2U6ZS5maW5kKFwiaW1nXCIpfX0scHJvdG86e2luaXRab29tOmZ1bmN0aW9uKCl7dmFyIGUsbj10LnN0Lnpvb20saT1cIi56b29tXCI7aWYobi5lbmFibGVkJiZ0LnN1cHBvcnRzVHJhbnNpdGlvbil7dmFyIG8scixhPW4uZHVyYXRpb24scz1mdW5jdGlvbihlKXt2YXIgdD1lLmNsb25lKCkucmVtb3ZlQXR0cihcInN0eWxlXCIpLnJlbW92ZUF0dHIoXCJjbGFzc1wiKS5hZGRDbGFzcyhcIm1mcC1hbmltYXRlZC1pbWFnZVwiKSxpPVwiYWxsIFwiK24uZHVyYXRpb24vMWUzK1wicyBcIituLmVhc2luZyxvPXtwb3NpdGlvbjpcImZpeGVkXCIsekluZGV4Ojk5OTksbGVmdDowLHRvcDowLFwiLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5XCI6XCJoaWRkZW5cIn0scj1cInRyYW5zaXRpb25cIjtyZXR1cm4gb1tcIi13ZWJraXQtXCIrcl09b1tcIi1tb3otXCIrcl09b1tcIi1vLVwiK3JdPW9bcl09aSx0LmNzcyhvKSx0fSxkPWZ1bmN0aW9uKCl7dC5jb250ZW50LmNzcyhcInZpc2liaWxpdHlcIixcInZpc2libGVcIil9O3goXCJCdWlsZENvbnRyb2xzXCIraSxmdW5jdGlvbigpe2lmKHQuX2FsbG93Wm9vbSgpKXtpZihjbGVhclRpbWVvdXQobyksdC5jb250ZW50LmNzcyhcInZpc2liaWxpdHlcIixcImhpZGRlblwiKSxlPXQuX2dldEl0ZW1Ub1pvb20oKSwhZSlyZXR1cm4gZCgpLHZvaWQgMDtyPXMoZSksci5jc3ModC5fZ2V0T2Zmc2V0KCkpLHQud3JhcC5hcHBlbmQociksbz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ci5jc3ModC5fZ2V0T2Zmc2V0KCEwKSksbz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZCgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyLnJlbW92ZSgpLGU9cj1udWxsLFQoXCJab29tQW5pbWF0aW9uRW5kZWRcIil9LDE2KX0sYSl9LDE2KX19KSx4KGMraSxmdW5jdGlvbigpe2lmKHQuX2FsbG93Wm9vbSgpKXtpZihjbGVhclRpbWVvdXQobyksdC5zdC5yZW1vdmFsRGVsYXk9YSwhZSl7aWYoZT10Ll9nZXRJdGVtVG9ab29tKCksIWUpcmV0dXJuO3I9cyhlKX1yLmNzcyh0Ll9nZXRPZmZzZXQoITApKSx0LndyYXAuYXBwZW5kKHIpLHQuY29udGVudC5jc3MoXCJ2aXNpYmlsaXR5XCIsXCJoaWRkZW5cIiksc2V0VGltZW91dChmdW5jdGlvbigpe3IuY3NzKHQuX2dldE9mZnNldCgpKX0sMTYpfX0pLHgobCtpLGZ1bmN0aW9uKCl7dC5fYWxsb3dab29tKCkmJihkKCksciYmci5yZW1vdmUoKSxlPW51bGwpfSl9fSxfYWxsb3dab29tOmZ1bmN0aW9uKCl7cmV0dXJuXCJpbWFnZVwiPT09dC5jdXJySXRlbS50eXBlfSxfZ2V0SXRlbVRvWm9vbTpmdW5jdGlvbigpe3JldHVybiB0LmN1cnJJdGVtLmhhc1NpemU/dC5jdXJySXRlbS5pbWc6ITF9LF9nZXRPZmZzZXQ6ZnVuY3Rpb24obil7dmFyIGk7aT1uP3QuY3Vyckl0ZW0uaW1nOnQuc3Quem9vbS5vcGVuZXIodC5jdXJySXRlbS5lbHx8dC5jdXJySXRlbSk7dmFyIG89aS5vZmZzZXQoKSxyPXBhcnNlSW50KGkuY3NzKFwicGFkZGluZy10b3BcIiksMTApLGE9cGFyc2VJbnQoaS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiKSwxMCk7by50b3AtPWUod2luZG93KS5zY3JvbGxUb3AoKS1yO3ZhciBzPXt3aWR0aDppLndpZHRoKCksaGVpZ2h0OihiP2kuaW5uZXJIZWlnaHQoKTppWzBdLm9mZnNldEhlaWdodCktYS1yfTtyZXR1cm4gUigpP3NbXCItbW96LXRyYW5zZm9ybVwiXT1zLnRyYW5zZm9ybT1cInRyYW5zbGF0ZShcIitvLmxlZnQrXCJweCxcIitvLnRvcCtcInB4KVwiOihzLmxlZnQ9by5sZWZ0LHMudG9wPW8udG9wKSxzfX19KTt2YXIgWj1cImlmcmFtZVwiLHE9XCIvL2Fib3V0OmJsYW5rXCIsRD1mdW5jdGlvbihlKXtpZih0LmN1cnJUZW1wbGF0ZVtaXSl7dmFyIG49dC5jdXJyVGVtcGxhdGVbWl0uZmluZChcImlmcmFtZVwiKTtuLmxlbmd0aCYmKGV8fChuWzBdLnNyYz1xKSx0LmlzSUU4JiZuLmNzcyhcImRpc3BsYXlcIixlP1wiYmxvY2tcIjpcIm5vbmVcIikpfX07ZS5tYWduaWZpY1BvcHVwLnJlZ2lzdGVyTW9kdWxlKFose29wdGlvbnM6e21hcmt1cDonPGRpdiBjbGFzcz1cIm1mcC1pZnJhbWUtc2NhbGVyXCI+PGRpdiBjbGFzcz1cIm1mcC1jbG9zZVwiPjwvZGl2PjxpZnJhbWUgY2xhc3M9XCJtZnAtaWZyYW1lXCIgc3JjPVwiLy9hYm91dDpibGFua1wiIGZyYW1lYm9yZGVyPVwiMFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT48L2Rpdj4nLHNyY0FjdGlvbjpcImlmcmFtZV9zcmNcIixwYXR0ZXJuczp7eW91dHViZTp7aW5kZXg6XCJ5b3V0dWJlLmNvbVwiLGlkOlwidj1cIixzcmM6XCIvL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8laWQlP2F1dG9wbGF5PTFcIn0sdmltZW86e2luZGV4OlwidmltZW8uY29tL1wiLGlkOlwiL1wiLHNyYzpcIi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8laWQlP2F1dG9wbGF5PTFcIn0sZ21hcHM6e2luZGV4OlwiLy9tYXBzLmdvb2dsZS5cIixzcmM6XCIlaWQlJm91dHB1dD1lbWJlZFwifX19LHByb3RvOntpbml0SWZyYW1lOmZ1bmN0aW9uKCl7dC50eXBlcy5wdXNoKFopLHgoXCJCZWZvcmVDaGFuZ2VcIixmdW5jdGlvbihlLHQsbil7dCE9PW4mJih0PT09Wj9EKCk6bj09PVomJkQoITApKX0pLHgobCtcIi5cIitaLGZ1bmN0aW9uKCl7RCgpfSl9LGdldElmcmFtZTpmdW5jdGlvbihuLGkpe3ZhciBvPW4uc3JjLHI9dC5zdC5pZnJhbWU7ZS5lYWNoKHIucGF0dGVybnMsZnVuY3Rpb24oKXtyZXR1cm4gby5pbmRleE9mKHRoaXMuaW5kZXgpPi0xPyh0aGlzLmlkJiYobz1cInN0cmluZ1wiPT10eXBlb2YgdGhpcy5pZD9vLnN1YnN0cihvLmxhc3RJbmRleE9mKHRoaXMuaWQpK3RoaXMuaWQubGVuZ3RoLG8ubGVuZ3RoKTp0aGlzLmlkLmNhbGwodGhpcyxvKSksbz10aGlzLnNyYy5yZXBsYWNlKFwiJWlkJVwiLG8pLCExKTp2b2lkIDB9KTt2YXIgYT17fTtyZXR1cm4gci5zcmNBY3Rpb24mJihhW3Iuc3JjQWN0aW9uXT1vKSx0Ll9wYXJzZU1hcmt1cChpLGEsbiksdC51cGRhdGVTdGF0dXMoXCJyZWFkeVwiKSxpfX19KTt2YXIgSz1mdW5jdGlvbihlKXt2YXIgbj10Lml0ZW1zLmxlbmd0aDtyZXR1cm4gZT5uLTE/ZS1uOjA+ZT9uK2U6ZX0sWT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGUucmVwbGFjZSgvJWN1cnIlL2dpLHQrMSkucmVwbGFjZSgvJXRvdGFsJS9naSxuKX07ZS5tYWduaWZpY1BvcHVwLnJlZ2lzdGVyTW9kdWxlKFwiZ2FsbGVyeVwiLHtvcHRpb25zOntlbmFibGVkOiExLGFycm93TWFya3VwOic8YnV0dG9uIHRpdGxlPVwiJXRpdGxlJVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm1mcC1hcnJvdyBtZnAtYXJyb3ctJWRpciVcIj48L2J1dHRvbj4nLHByZWxvYWQ6WzAsMl0sbmF2aWdhdGVCeUltZ0NsaWNrOiEwLGFycm93czohMCx0UHJldjpcIlByZXZpb3VzIChMZWZ0IGFycm93IGtleSlcIix0TmV4dDpcIk5leHQgKFJpZ2h0IGFycm93IGtleSlcIix0Q291bnRlcjpcIiVjdXJyJSBvZiAldG90YWwlXCJ9LHByb3RvOntpbml0R2FsbGVyeTpmdW5jdGlvbigpe3ZhciBuPXQuc3QuZ2FsbGVyeSxpPVwiLm1mcC1nYWxsZXJ5XCIscj1Cb29sZWFuKGUuZm4ubWZwRmFzdENsaWNrKTtyZXR1cm4gdC5kaXJlY3Rpb249ITAsbiYmbi5lbmFibGVkPyhhKz1cIiBtZnAtZ2FsbGVyeVwiLHgoZitpLGZ1bmN0aW9uKCl7bi5uYXZpZ2F0ZUJ5SW1nQ2xpY2smJnQud3JhcC5vbihcImNsaWNrXCIraSxcIi5tZnAtaW1nXCIsZnVuY3Rpb24oKXtyZXR1cm4gdC5pdGVtcy5sZW5ndGg+MT8odC5uZXh0KCksITEpOnZvaWQgMH0pLG8ub24oXCJrZXlkb3duXCIraSxmdW5jdGlvbihlKXszNz09PWUua2V5Q29kZT90LnByZXYoKTozOT09PWUua2V5Q29kZSYmdC5uZXh0KCl9KX0pLHgoXCJVcGRhdGVTdGF0dXNcIitpLGZ1bmN0aW9uKGUsbil7bi50ZXh0JiYobi50ZXh0PVkobi50ZXh0LHQuY3Vyckl0ZW0uaW5kZXgsdC5pdGVtcy5sZW5ndGgpKX0pLHgocCtpLGZ1bmN0aW9uKGUsaSxvLHIpe3ZhciBhPXQuaXRlbXMubGVuZ3RoO28uY291bnRlcj1hPjE/WShuLnRDb3VudGVyLHIuaW5kZXgsYSk6XCJcIn0pLHgoXCJCdWlsZENvbnRyb2xzXCIraSxmdW5jdGlvbigpe2lmKHQuaXRlbXMubGVuZ3RoPjEmJm4uYXJyb3dzJiYhdC5hcnJvd0xlZnQpe3ZhciBpPW4uYXJyb3dNYXJrdXAsbz10LmFycm93TGVmdD1lKGkucmVwbGFjZSgvJXRpdGxlJS9naSxuLnRQcmV2KS5yZXBsYWNlKC8lZGlyJS9naSxcImxlZnRcIikpLmFkZENsYXNzKHkpLGE9dC5hcnJvd1JpZ2h0PWUoaS5yZXBsYWNlKC8ldGl0bGUlL2dpLG4udE5leHQpLnJlcGxhY2UoLyVkaXIlL2dpLFwicmlnaHRcIikpLmFkZENsYXNzKHkpLHM9cj9cIm1mcEZhc3RDbGlja1wiOlwiY2xpY2tcIjtvW3NdKGZ1bmN0aW9uKCl7dC5wcmV2KCl9KSxhW3NdKGZ1bmN0aW9uKCl7dC5uZXh0KCl9KSx0LmlzSUU3JiYoayhcImJcIixvWzBdLCExLCEwKSxrKFwiYVwiLG9bMF0sITEsITApLGsoXCJiXCIsYVswXSwhMSwhMCksayhcImFcIixhWzBdLCExLCEwKSksdC5jb250YWluZXIuYXBwZW5kKG8uYWRkKGEpKX19KSx4KG0raSxmdW5jdGlvbigpe3QuX3ByZWxvYWRUaW1lb3V0JiZjbGVhclRpbWVvdXQodC5fcHJlbG9hZFRpbWVvdXQpLHQuX3ByZWxvYWRUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LnByZWxvYWROZWFyYnlJbWFnZXMoKSx0Ll9wcmVsb2FkVGltZW91dD1udWxsfSwxNil9KSx4KGwraSxmdW5jdGlvbigpe28ub2ZmKGkpLHQud3JhcC5vZmYoXCJjbGlja1wiK2kpLHQuYXJyb3dMZWZ0JiZyJiZ0LmFycm93TGVmdC5hZGQodC5hcnJvd1JpZ2h0KS5kZXN0cm95TWZwRmFzdENsaWNrKCksdC5hcnJvd1JpZ2h0PXQuYXJyb3dMZWZ0PW51bGx9KSx2b2lkIDApOiExfSxuZXh0OmZ1bmN0aW9uKCl7dC5kaXJlY3Rpb249ITAsdC5pbmRleD1LKHQuaW5kZXgrMSksdC51cGRhdGVJdGVtSFRNTCgpfSxwcmV2OmZ1bmN0aW9uKCl7dC5kaXJlY3Rpb249ITEsdC5pbmRleD1LKHQuaW5kZXgtMSksdC51cGRhdGVJdGVtSFRNTCgpfSxnb1RvOmZ1bmN0aW9uKGUpe3QuZGlyZWN0aW9uPWU+PXQuaW5kZXgsdC5pbmRleD1lLHQudXBkYXRlSXRlbUhUTUwoKX0scHJlbG9hZE5lYXJieUltYWdlczpmdW5jdGlvbigpe3ZhciBlLG49dC5zdC5nYWxsZXJ5LnByZWxvYWQsaT1NYXRoLm1pbihuWzBdLHQuaXRlbXMubGVuZ3RoKSxvPU1hdGgubWluKG5bMV0sdC5pdGVtcy5sZW5ndGgpO2ZvcihlPTE7KHQuZGlyZWN0aW9uP286aSk+PWU7ZSsrKXQuX3ByZWxvYWRJdGVtKHQuaW5kZXgrZSk7Zm9yKGU9MTsodC5kaXJlY3Rpb24/aTpvKT49ZTtlKyspdC5fcHJlbG9hZEl0ZW0odC5pbmRleC1lKX0sX3ByZWxvYWRJdGVtOmZ1bmN0aW9uKG4pe2lmKG49SyhuKSwhdC5pdGVtc1tuXS5wcmVsb2FkZWQpe3ZhciBpPXQuaXRlbXNbbl07aS5wYXJzZWR8fChpPXQucGFyc2VFbChuKSksVChcIkxhenlMb2FkXCIsaSksXCJpbWFnZVwiPT09aS50eXBlJiYoaS5pbWc9ZSgnPGltZyBjbGFzcz1cIm1mcC1pbWdcIiAvPicpLm9uKFwibG9hZC5tZnBsb2FkZXJcIixmdW5jdGlvbigpe2kuaGFzU2l6ZT0hMH0pLm9uKFwiZXJyb3IubWZwbG9hZGVyXCIsZnVuY3Rpb24oKXtpLmhhc1NpemU9ITAsaS5sb2FkRXJyb3I9ITAsVChcIkxhenlMb2FkRXJyb3JcIixpKX0pLmF0dHIoXCJzcmNcIixpLnNyYykpLGkucHJlbG9hZGVkPSEwfX19fSk7dmFyIFU9XCJyZXRpbmFcIjtlLm1hZ25pZmljUG9wdXAucmVnaXN0ZXJNb2R1bGUoVSx7b3B0aW9uczp7cmVwbGFjZVNyYzpmdW5jdGlvbihlKXtyZXR1cm4gZS5zcmMucmVwbGFjZSgvXFwuXFx3KyQvLGZ1bmN0aW9uKGUpe3JldHVyblwiQDJ4XCIrZX0pfSxyYXRpbzoxfSxwcm90bzp7aW5pdFJldGluYTpmdW5jdGlvbigpe2lmKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvPjEpe3ZhciBlPXQuc3QucmV0aW5hLG49ZS5yYXRpbztuPWlzTmFOKG4pP24oKTpuLG4+MSYmKHgoXCJJbWFnZUhhc1NpemUuXCIrVSxmdW5jdGlvbihlLHQpe3QuaW1nLmNzcyh7XCJtYXgtd2lkdGhcIjp0LmltZ1swXS5uYXR1cmFsV2lkdGgvbix3aWR0aDpcIjEwMCVcIn0pfSkseChcIkVsZW1lbnRQYXJzZS5cIitVLGZ1bmN0aW9uKHQsaSl7aS5zcmM9ZS5yZXBsYWNlU3JjKGksbil9KSl9fX19KSxmdW5jdGlvbigpe3ZhciB0PTFlMyxuPVwib250b3VjaHN0YXJ0XCJpbiB3aW5kb3csaT1mdW5jdGlvbigpe0kub2ZmKFwidG91Y2htb3ZlXCIrcitcIiB0b3VjaGVuZFwiK3IpfSxvPVwibWZwRmFzdENsaWNrXCIscj1cIi5cIitvO2UuZm4ubWZwRmFzdENsaWNrPWZ1bmN0aW9uKG8pe3JldHVybiBlKHRoaXMpLmVhY2goZnVuY3Rpb24oKXt2YXIgYSxzPWUodGhpcyk7aWYobil7dmFyIGwsYyxkLHUscCxmO3Mub24oXCJ0b3VjaHN0YXJ0XCIrcixmdW5jdGlvbihlKXt1PSExLGY9MSxwPWUub3JpZ2luYWxFdmVudD9lLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXTplLnRvdWNoZXNbMF0sYz1wLmNsaWVudFgsZD1wLmNsaWVudFksSS5vbihcInRvdWNobW92ZVwiK3IsZnVuY3Rpb24oZSl7cD1lLm9yaWdpbmFsRXZlbnQ/ZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXM6ZS50b3VjaGVzLGY9cC5sZW5ndGgscD1wWzBdLChNYXRoLmFicyhwLmNsaWVudFgtYyk+MTB8fE1hdGguYWJzKHAuY2xpZW50WS1kKT4xMCkmJih1PSEwLGkoKSl9KS5vbihcInRvdWNoZW5kXCIrcixmdW5jdGlvbihlKXtpKCksdXx8Zj4xfHwoYT0hMCxlLnByZXZlbnREZWZhdWx0KCksY2xlYXJUaW1lb3V0KGwpLGw9c2V0VGltZW91dChmdW5jdGlvbigpe2E9ITF9LHQpLG8oKSl9KX0pfXMub24oXCJjbGlja1wiK3IsZnVuY3Rpb24oKXthfHxvKCl9KX0pfSxlLmZuLmRlc3Ryb3lNZnBGYXN0Q2xpY2s9ZnVuY3Rpb24oKXtlKHRoaXMpLm9mZihcInRvdWNoc3RhcnRcIityK1wiIGNsaWNrXCIrciksbiYmSS5vZmYoXCJ0b3VjaG1vdmVcIityK1wiIHRvdWNoZW5kXCIrcil9fSgpLF8oKX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL21hZ25pZmljLXBvcHVwL2pxdWVyeS5tYWduaWZpYy1wb3B1cC5taW4uanMiLCJpbXBvcnQgJ3ZlbG9jaXR5LWFuaW1hdGUnXG5pbXBvcnQgJ3ZlbG9jaXR5LWFuaW1hdGUvdmVsb2NpdHkudWkubWluJ1xuaW1wb3J0IHNlbGVjdENvbXBvbmVudCBmcm9tICd1dGlsaXRpZXMvc2VsZWN0LWNvbXBvbmVudCdcbmltcG9ydCB7ICRicExnIH0gZnJvbSAndXRpbGl0aWVzL2dyaWQtc2V0dGluZ3MnXG5pbXBvcnQgJ3ZlbmRvci9qcXVlcnkuZGVib3VuY2VkcmVzaXplJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluTmF2IHtcbiAgICBib2R5T3BlbkNsYXNzID0gJy1uYXYtb3BlbidcbiAgICBtb2JpbGVUb2dnbGVBY3RpdmVDbGFzcyA9ICdpcy1hY3RpdmUnXG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy4kY29tcG9uZW50ID0gc2VsZWN0Q29tcG9uZW50KGVsZW1lbnQpXG4gICAgICAgIHRoaXMuJG5hdiA9IHRoaXMuJGNvbXBvbmVudC5lbGVtZW50cy5saXN0XG4gICAgICAgIHRoaXMuJHRvZ2dsZSA9IHRoaXMuJGNvbXBvbmVudC5lbGVtZW50cy50b2dnbGVcbiAgICAgICAgdGhpcy5hdHRhY2hFdmVudHMoKVxuICAgIH1cblxuICAgIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5jaGVja1RvZ2dsZSgpXG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdkZWJvdW5jZWRyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrVG9nZ2xlKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjaGVja1RvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy5zdG9wVG9nZ2xlKClcblxuICAgICAgICBpZighJGJwTGcubWF0Y2hlcykge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRvZ2dsZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydFRvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy4kdG9nZ2xlLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0b2dnbGUuYXR0cignZGF0YS1wcm9wZXJ0eScpID09ICdvcGVuJykge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRvZ2dsZS5hdHRyKCdkYXRhLXByb3BlcnR5JywgJ2Nsb3NlZCcpXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZU5hdigpXG4gICAgICAgICAgICAgICAgdGhpcy4kdG9nZ2xlLnJlbW92ZUNsYXNzKHRoaXMubW9iaWxlVG9nZ2xlQWN0aXZlQ2xhc3MpXG4gICAgICAgICAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKHRoaXMuYm9keU9wZW5DbGFzcylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdG9nZ2xlLmF0dHIoJ2RhdGEtcHJvcGVydHknLCAnb3BlbicpXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuTmF2KClcbiAgICAgICAgICAgICAgICB0aGlzLiR0b2dnbGUuYWRkQ2xhc3ModGhpcy5tb2JpbGVUb2dnbGVBY3RpdmVDbGFzcylcbiAgICAgICAgICAgICAgICAkKCdib2R5JykuYWRkQ2xhc3ModGhpcy5ib2R5T3BlbkNsYXNzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHN0b3BUb2dnbGUoKSB7XG4gICAgICAgIHRoaXMuJHRvZ2dsZS5vZmYoKVxuICAgIH1cblxuICAgIG9wZW5OYXYoKSB7XG4gICAgICAgIHRoaXMuJG5hdi52ZWxvY2l0eSgnc2xpZGVEb3duJywge1xuICAgICAgICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbmF2LnJlbW92ZUF0dHIoJ3N0eWxlJylcbiAgICAgICAgICAgICAgICB0aGlzLiRuYXYuYXR0cignZGF0YS1wcm9wZXJ0eScsICdvcGVuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjbG9zZU5hdigpIHtcbiAgICAgICAgdGhpcy4kbmF2LnZlbG9jaXR5KCdzbGlkZVVwJywge1xuICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbmF2LnJlbW92ZUF0dHIoJ3N0eWxlJylcbiAgICAgICAgICAgICAgICB0aGlzLiRuYXYuYXR0cignZGF0YS1wcm9wZXJ0eScsICdjbG9zZWQnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudC9tYWluLW5hdi5qcyIsIi8qKlxuICogR2FsbGVyeSAtIFBob3Rvc3dpcGVcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogRGVzY3JpcHRpb246ICBBbiBpbWFnZSBnYWxsZXJ5IGltcGxlbWVudGVkIHdpdGggdGhlIFBob3Rvc3dpcGUgamF2YXNjcmlwdCBsaWJyYXJ5LlxuICpcbiAqIEluc3RydWN0aW9uczogR2FsbGVyeSBjb250YWluZXIgZWxlbWVudCBtdXN0IGJlIHRoZSBwYXJlbnQgbm9kZSBvZiA8YT4gZWxlbWVudHNcbiAqICAgICAgICAgICAgICAgdGhhdCBsaW5rIHRvIHRoZSBmdWxsLXNpemUgdmVyc2lvbiBvZiB0aGUgdGh1bWJuYWlsIGltYWdlLiBUaGUgYW5jaG9yIGNvbnRhaW5zXG4gKiAgICAgICAgICAgICAgIGEgY2hpbGQgPGltZz4gdGFnLiBNYXJrdXAgdG8gYmUgdXNlZCBmb3IgdGhlIGZ1bGwtc2l6ZSBpbWFnZSBjYXB0aW9uIHNob3VsZCBiZSBhIGNoaWxkXG4gKiAgICAgICAgICAgICAgIGVsZW1lbnQgb2YgdGhlIDxhPiB0YWcgYW5kIGluY2x1ZGUgdGhlIHNlbGVjdG9yIHNwZWNpZmllZCBpbiBzZXR0aW5ncy50aXRsZUVsLiBUaGUgPGE+XG4gKiAgICAgICAgICAgICAgIGVsZW1lbnQgbXVzdCBjb250YWluIGEgZGF0YS1zaXplIGF0dHJpYnV0ZSB3aXRoIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBmdWxsIHNpemUgaW1hZ2UuXG4gKlxuICogICAgICAgICAgICAgICBFeGFtcGxlOlxuICogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGRhdGEtZWxlbWVudD1cImdhbGxlcnktcGhvdG9zd2lwZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIi9wYXRoL3RvL2Z1bGwvaW1hZ2UuanBnXCIgZGF0YS1zaXplPVwiNjQweDQ4MFwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIvcGF0aC90by90aHVtYi5qcGdcIiBhbHQ9XCJUaHVtbmFpbCBJbWFnZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBkYXRhLWVsZW1lbnQ9XCJ0aXRsZVwiPkltYWdlIENhcHRpb248L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsuLi5dXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICpcbiAqICAgICAgICAgICAgICAgVGhlIHRlbXBsYXRlIGZvciB0aGUgcGhvdG9zd2lwZSBmdWxsLWltYWdlIFVJIGlzIGluIC9UZW1wbGF0ZXMvaW5jbHVkZXMvcGhvdG9zd2lwZS1lbGVtZW50LnBocFxuICogICAgICAgICAgICAgICBhbmQgbXVzdCBiZSBpbmNsdWRlZCBvbiB0aGUgc2FtZSBwYWdlIGFzIHRoZSBnYWxsZXJ5LlxuICpcbiAqXG4gKiBQYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICBlbDogICAgICAgW2RhdGEtYWN0aW9uPVwiZ2FsbGVyeS1waG90b3N3aXBlXCJdICAgICAgICAgLy8gQW5jaG9yIGVsZW1lbnRzIHRoYXQgdHJpZ2dlciBzY3JvbGwgd2hlbiBjbGlja2VkXG4gKiAgICAgICAgICAgICAgIHRpdGxlRWw6ICBbZGF0YS1lbGVtZW50PVwidGl0bGVcIl0gICAgICAgICAgICAgICAgICAgICAvLyBNYXJrdXAgdG8gYmUgdXNlZCBpbiBmdWxsLXNpemUgY2FwdGlvblxuICoqL1xuaW1wb3J0IEJhc2UgZnJvbSAnY29tcG9uZW50L2Jhc2UnXG5pbXBvcnQgUGhvdG9Td2lwZSBmcm9tICAndmVuZG9yL3Bob3Rvc3dpcGUnXG5pbXBvcnQgUGhvdG9Td2lwZVVpIGZyb20gJ3ZlbmRvci9waG90b3N3aXBlLXVpLWRlZmF1bHQnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdhbGxlcnlQaG90b1N3aXBlRmFjdG9yeShhcmdzKSB7XG4gICAgLyoqXG4gICAgICAgICAqIFBsdWdpbiBkZWZhdWx0cyAvIEJhc2UgY29uc3RydWN0b3JcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICBjb25zdCBERUZBVUxUID0ge1xuICAgICAgICBuYW1lOiAnR2FsbGVyeSAtIFBob3Rvc3dpcGUnLFxuICAgICAgICBlbDogJ1tkYXRhLWFjdGlvbj1cImdhbGxlcnktcGhvdG9zd2lwZVwiXScsXG4gICAgICAgIHRpdGxlRWw6ICdbZGF0YS1lbGVtZW50PVwidGl0bGVcIl0nLFxuICAgIH07XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBCYXNlLmNvbnN0cnVjdChERUZBVUxULCBhcmdzKVxuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBhbmQgcHVibGljIG1ldGhvZHNcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgIGxldCBhY3Rpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBsZXQgaW5pdFBob3RvU3dpcGVGcm9tRE9NID0gZnVuY3Rpb24oZ2FsbGVyeVNlbGVjdG9yKSB7XG5cbiAgICAgICAgICAgIC8vIHBhcnNlIHNsaWRlIGRhdGEgKHVybCwgdGl0bGUsIHNpemUgLi4uKSBmcm9tIERPTSBlbGVtZW50cyAobGlua3MpXG4gICAgICAgICAgICBsZXQgcGFyc2VUaHVtYm5haWxFbGVtZW50cyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRodW1iRWxlbWVudHMgPSBlbC5jaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBudW1Ob2RlcyA9IHRodW1iRWxlbWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZEVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWxFbCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlbCA9IHRodW1iRWxlbWVudHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBvbmx5IGVsZW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5rRWxcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuY2hpbGRyZW5bMF0udGFnTmFtZS50b1VwcGVyQ2FzZSgpID09ICdBJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua0VsID0gZWwuY2hpbGRyZW5bMF1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtFbCA9IGVsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGlsZEVsZW1lbnRzID0gbGlua0VsLmNoaWxkcmVuO1xuXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBsaW5rRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNpemUnKS5zcGxpdCgneCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBzbGlkZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogbGlua0VsLmdldEF0dHJpYnV0ZSgnaHJlZicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdzogcGFyc2VJbnQoc2l6ZVswXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaDogcGFyc2VJbnQoc2l6ZVsxXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxmaWdjYXB0aW9uPiBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRpdGxlID0gZWwuY2hpbGRyZW5bMV0uaW5uZXJIVE1MOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKGxpbmtFbC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW1nPiB0aHVtYm5haWwgZWxlbWVudCwgcmV0cmlldmluZyB0aHVtYm5haWwgdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm1zcmMgPSBsaW5rRWwuY2hpbGRyZW5bMF0uZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZWwgPSBsaW5rRWw7IC8vIHNhdmUgbGluayB0byBlbGVtZW50IGZvciBnZXRUaHVtYkJvdW5kc0ZuXG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBmaW5kIG5lYXJlc3QgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgIGxldCBjbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdChlbCwgZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwgJiYgKGZuKGVsKSA/IGVsIDogY2xvc2VzdChlbC5wYXJlbnROb2RlLCBmbikpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gdHJpZ2dlcnMgd2hlbiB1c2VyIGNsaWNrcyBvbiB0aHVtYm5haWxcbiAgICAgICAgICAgIGxldCBvblRodW1ibmFpbHNDbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA/IGUucHJldmVudERlZmF1bHQoKSA6IGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGxldCBlVGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgbGV0IGNsaWNrZWRMaXN0SXRlbSA9IGNsb3Nlc3QoZVRhcmdldCwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0ZJR1VSRScpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjbGlja2VkTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBjbGlja2VkR2FsbGVyeSA9IGNsaWNrZWRMaXN0SXRlbS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSBjbGlja2VkTGlzdEl0ZW0ucGFyZW50Tm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBudW1DaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4O1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaGlsZE5vZGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNbaV0gPT09IGNsaWNrZWRMaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBub2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5QaG90b1N3aXBlKGluZGV4LCBjbGlja2VkR2FsbGVyeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gcGFyc2UgcGljdHVyZSBpbmRleCBhbmQgZ2FsbGVyeSBpbmRleCBmcm9tIFVSTCAoIyZwaWQ9MSZnaWQ9MilcbiAgICAgICAgICAgIGxldCBwaG90b3N3aXBlUGFyc2VIYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICAgICAgcGFyYW1zID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzaC5sZW5ndGggPCA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHZhcnMgPSBoYXNoLnNwbGl0KCcmJyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFpciA9IHZhcnNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZ2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5naWQgPSBwYXJzZUludChwYXJhbXMuZ2lkLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxldCBvcGVuUGhvdG9Td2lwZSA9IGZ1bmN0aW9uKGluZGV4LCBnYWxsZXJ5RWxlbWVudCwgZGlzYWJsZUFuaW1hdGlvbiwgZnJvbVVSTCkge1xuICAgICAgICAgICAgICAgIGxldCBwc3dwRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wc3dwJylbMF0sXG4gICAgICAgICAgICAgICAgICAgIGdhbGxlcnksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zO1xuXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBwYXJzZVRodW1ibmFpbEVsZW1lbnRzKGdhbGxlcnlFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBvcHRpb25zIChpZiBuZWVkZWQpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBmdWxsc2NyZWVuRWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUVsOiBmYWxzZSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZpbmUgZ2FsbGVyeSBpbmRleCAoZm9yIFVSTClcbiAgICAgICAgICAgICAgICAgICAgZ2FsbGVyeVVJRDogZ2FsbGVyeUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBzd3AtdWlkJyksXG5cbiAgICAgICAgICAgICAgICAgICAgZ2V0VGh1bWJCb3VuZHNGbjogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSBPcHRpb25zIC0+IGdldFRodW1iQm91bmRzRm4gc2VjdGlvbiBvZiBkb2NzIGZvciBtb3JlIGluZm9cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRodW1ibmFpbCA9IGl0ZW1zW2luZGV4XS5lbC5jaGlsZHJlblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlWVNjcm9sbCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QgPSB0aHVtYm5haWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7eDpyZWN0LmxlZnQsIHk6cmVjdC50b3AgKyBwYWdlWVNjcm9sbCwgdzpyZWN0LndpZHRofTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZihmcm9tVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdGlvbnMuZ2FsbGVyeVBJRHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHJlYWwgaW5kZXggd2hlbiBjdXN0b20gUElEcyBhcmUgdXNlZCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9waG90b3N3aXBlLmNvbS9kb2N1bWVudGF0aW9uL2ZhcS5odG1sI2N1c3RvbS1waWQtaW4tdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtc1tqXS5waWQgPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIFVSTCBpbmRleGVzIHN0YXJ0IGZyb20gMVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIGlzTmFOKG9wdGlvbnMuaW5kZXgpICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaG93QW5pbWF0aW9uRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFBhc3MgZGF0YSB0byBQaG90b1N3aXBlIGFuZCBpbml0aWFsaXplIGl0XG4gICAgICAgICAgICAgICAgZ2FsbGVyeSA9IG5ldyBQaG90b1N3aXBlKHBzd3BFbGVtZW50LCBQaG90b1N3aXBlVWksIGl0ZW1zLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBnYWxsZXJ5LmluaXQoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgZ2FsbGVyeSBlbGVtZW50cyBhbmQgYmluZCBldmVudHNcbiAgICAgICAgICAgIGxldCBnYWxsZXJ5RWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGdhbGxlcnlTZWxlY3Rvcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGdhbGxlcnlFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBnYWxsZXJ5RWxlbWVudHNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLXBzd3AtdWlkJywgaSsxKTtcbiAgICAgICAgICAgICAgICBnYWxsZXJ5RWxlbWVudHNbaV0ub25jbGljayA9IG9uVGh1bWJuYWlsc0NsaWNrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQYXJzZSBVUkwgYW5kIG9wZW4gZ2FsbGVyeSBpZiBpdCBjb250YWlucyAjJnBpZD0zJmdpZD0xXG4gICAgICAgICAgICBsZXQgaGFzaERhdGEgPSBwaG90b3N3aXBlUGFyc2VIYXNoKCk7XG4gICAgICAgICAgICBpZiAoaGFzaERhdGEucGlkICYmIGhhc2hEYXRhLmdpZCkge1xuICAgICAgICAgICAgICAgIG9wZW5QaG90b1N3aXBlKCBoYXNoRGF0YS5waWQgLCAgZ2FsbGVyeUVsZW1lbnRzWyBoYXNoRGF0YS5naWQgLSAxIF0sIHRydWUsIHRydWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBleGVjdXRlIGFib3ZlIGZ1bmN0aW9uXG4gICAgICAgIGluaXRQaG90b1N3aXBlRnJvbURPTShzZXR0aW5ncy5lbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBleHBvcnRlclxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgbGV0IHB1YmxpY0V4cG9ydHMgPSB7XG4gICAgICAgIGFjdGlvbixcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oQmFzZSwgcHVibGljRXhwb3J0cyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnQvZ2FsbGVyeS1waG90b3N3aXBlLmpzIiwiLyohIFBob3RvU3dpcGUgLSB2NC4xLjEgLSAyMDE1LTEyLTI0XG4qIGh0dHA6Ly9waG90b3N3aXBlLmNvbVxuKiBDb3B5cmlnaHQgKGMpIDIwMTUgRG1pdHJ5IFNlbWVub3Y7ICovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHsgXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5QaG90b1N3aXBlID0gZmFjdG9yeSgpO1xuICAgIH1cbn0pKHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgUGhvdG9Td2lwZSA9IGZ1bmN0aW9uKHRlbXBsYXRlLCBVaUNsYXNzLCBpdGVtcywgb3B0aW9ucyl7XG5cbi8qPj5mcmFtZXdvcmstYnJpZGdlKi9cbi8qKlxuICpcbiAqIFNldCBvZiBnZW5lcmljIGZ1bmN0aW9ucyB1c2VkIGJ5IGdhbGxlcnkuXG4gKiBcbiAqIFlvdSdyZSBmcmVlIHRvIG1vZGlmeSBhbnl0aGluZyBoZXJlIGFzIGxvbmcgYXMgZnVuY3Rpb25hbGl0eSBpcyBrZXB0LlxuICogXG4gKi9cbnZhciBmcmFtZXdvcmsgPSB7XG4gICAgZmVhdHVyZXM6IG51bGwsXG4gICAgYmluZDogZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgdW5iaW5kKSB7XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gKHVuYmluZCA/ICdyZW1vdmUnIDogJ2FkZCcpICsgJ0V2ZW50TGlzdGVuZXInO1xuICAgICAgICB0eXBlID0gdHlwZS5zcGxpdCgnICcpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYodHlwZVtpXSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFttZXRob2ROYW1lXSggdHlwZVtpXSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXNBcnJheTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgQXJyYXkpO1xuICAgIH0sXG4gICAgY3JlYXRlRWw6IGZ1bmN0aW9uKGNsYXNzZXMsIHRhZykge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyB8fCAnZGl2Jyk7XG4gICAgICAgIGlmKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG4gICAgZ2V0U2Nyb2xsWTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICByZXR1cm4geU9mZnNldCAhPT0gdW5kZWZpbmVkID8geU9mZnNldCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgfSxcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgZnJhbWV3b3JrLmJpbmQodGFyZ2V0LHR5cGUsbGlzdGVuZXIsdHJ1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgnKFxcXFxzfF4pJyArIGNsYXNzTmFtZSArICcoXFxcXHN8JCknKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UocmVnLCAnICcpLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpOyBcbiAgICB9LFxuICAgIGFkZENsYXNzOiBmdW5jdGlvbihlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmKCAhZnJhbWV3b3JrLmhhc0NsYXNzKGVsLGNsYXNzTmFtZSkgKSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gKGVsLmNsYXNzTmFtZSA/ICcgJyA6ICcnKSArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsYXNzTmFtZSAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NOYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoZWwuY2xhc3NOYW1lKTtcbiAgICB9LFxuICAgIGdldENoaWxkQnlDbGFzczogZnVuY3Rpb24ocGFyZW50RWwsIGNoaWxkQ2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBub2RlID0gcGFyZW50RWwuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUobm9kZSkge1xuICAgICAgICAgICAgaWYoIGZyYW1ld29yay5oYXNDbGFzcyhub2RlLCBjaGlsZENsYXNzTmFtZSkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYXJyYXlTZWFyY2g6IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBpID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZShpLS0pIHtcbiAgICAgICAgICAgIGlmKGFycmF5W2ldW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIGV4dGVuZDogZnVuY3Rpb24obzEsIG8yLCBwcmV2ZW50T3ZlcndyaXRlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gbzIpIHtcbiAgICAgICAgICAgIGlmIChvMi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmKHByZXZlbnRPdmVyd3JpdGUgJiYgbzEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG8xW3Byb3BdID0gbzJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVhc2luZzoge1xuICAgICAgICBzaW5lOiB7XG4gICAgICAgICAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oayAqIChNYXRoLlBJIC8gMikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluT3V0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0gKE1hdGguY29zKE1hdGguUEkgKiBrKSAtIDEpIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3ViaWM6IHtcbiAgICAgICAgICAgIG91dDogZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICAgIGVsYXN0aWM6IHtcbiAgICAgICAgICAgICAgICBvdXQ6IGZ1bmN0aW9uICggayApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcywgYSA9IDAuMSwgcCA9IDAuNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBrID09PSAwICkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICggayA9PT0gMSApIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFhIHx8IGEgPCAxICkgeyBhID0gMTsgcyA9IHAgLyA0OyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcyA9IHAgKiBNYXRoLmFzaW4oIDEgLyBhICkgLyAoIDIgKiBNYXRoLlBJICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIGEgKiBNYXRoLnBvdyggMiwgLSAxMCAqIGspICogTWF0aC5zaW4oICggayAtIHMgKSAqICggMiAqIE1hdGguUEkgKSAvIHAgKSArIDEgKTtcblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFjazoge1xuICAgICAgICAgICAgICAgIG91dDogZnVuY3Rpb24gKCBrICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogKCAoIHMgKyAxICkgKiBrICsgcyApICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICovXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBcbiAgICAgKiB7XG4gICAgICogIHJhZiA6IHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lIGZ1bmN0aW9uXG4gICAgICogIGNhZiA6IGNhbmNlbCBhbmltYXRpb24gZnJhbWUgZnVuY3Rpb25cbiAgICAgKiAgdHJhbnNmcm9tIDogdHJhbnNmb3JtIHByb3BlcnR5IGtleSAod2l0aCB2ZW5kb3IpLCBvciBudWxsIGlmIG5vdCBzdXBwb3J0ZWRcbiAgICAgKiAgb2xkSUUgOiBJRTggb3IgYmVsb3dcbiAgICAgKiB9XG4gICAgICogXG4gICAgICovXG4gICAgZGV0ZWN0RmVhdHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihmcmFtZXdvcmsuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFtZXdvcmsuZmVhdHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlbHBlckVsID0gZnJhbWV3b3JrLmNyZWF0ZUVsKCksXG4gICAgICAgICAgICBoZWxwZXJTdHlsZSA9IGhlbHBlckVsLnN0eWxlLFxuICAgICAgICAgICAgdmVuZG9yID0gJycsXG4gICAgICAgICAgICBmZWF0dXJlcyA9IHt9O1xuXG4gICAgICAgIC8vIElFOCBhbmQgYmVsb3dcbiAgICAgICAgZmVhdHVyZXMub2xkSUUgPSBkb2N1bWVudC5hbGwgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgICAgICAgZmVhdHVyZXMudG91Y2ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG5cbiAgICAgICAgaWYod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgZmVhdHVyZXMucmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgICAgIGZlYXR1cmVzLmNhZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZlYXR1cmVzLnBvaW50ZXJFdmVudCA9IG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZDtcblxuICAgICAgICAvLyBmaXggZmFsc2UtcG9zaXRpdmUgZGV0ZWN0aW9uIG9mIG9sZCBBbmRyb2lkIGluIG5ldyBJRVxuICAgICAgICAvLyAoSUUxMSB1YSBzdHJpbmcgY29udGFpbnMgXCJBbmRyb2lkIDQuMFwiKVxuICAgICAgICBcbiAgICAgICAgaWYoIWZlYXR1cmVzLnBvaW50ZXJFdmVudCkgeyBcblxuICAgICAgICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICAgICAgICAgICAgLy8gRGV0ZWN0IGlmIGRldmljZSBpcyBpUGhvbmUgb3IgaVBvZCBhbmQgaWYgaXQncyBvbGRlciB0aGFuIGlPUyA4XG4gICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDIyMzkyMFxuICAgICAgICAgICAgLy8gXG4gICAgICAgICAgICAvLyBUaGlzIGRldGVjdGlvbiBpcyBtYWRlIGJlY2F1c2Ugb2YgYnVnZ3kgdG9wL2JvdHRvbSB0b29sYmFyc1xuICAgICAgICAgICAgLy8gdGhhdCBkb24ndCB0cmlnZ2VyIHdpbmRvdy5yZXNpemUgZXZlbnQuXG4gICAgICAgICAgICAvLyBGb3IgbW9yZSBpbmZvIHJlZmVyIHRvIF9pc0ZpeGVkUG9zaXRpb24gdmFyaWFibGUgaW4gY29yZS5qc1xuXG4gICAgICAgICAgICBpZiAoL2lQKGhvbmV8b2QpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IChuYXZpZ2F0b3IuYXBwVmVyc2lvbikubWF0Y2goL09TIChcXGQrKV8oXFxkKylfPyhcXGQrKT8vKTtcbiAgICAgICAgICAgICAgICBpZih2ICYmIHYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gcGFyc2VJbnQodlsxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBpZih2ID49IDEgJiYgdiA8IDggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5pc09sZElPU1Bob25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGV0ZWN0IG9sZCBBbmRyb2lkIChiZWZvcmUgS2l0S2F0KVxuICAgICAgICAgICAgLy8gZHVlIHRvIGJ1Z3MgcmVsYXRlZCB0byBwb3NpdGlvbjpmaXhlZFxuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MTg0NTczL3BpY2stdXAtdGhlLWFuZHJvaWQtdmVyc2lvbi1pbi10aGUtYnJvd3Nlci1ieS1qYXZhc2NyaXB0XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHVhLm1hdGNoKC9BbmRyb2lkXFxzKFswLTlcXC5dKikvKTtcbiAgICAgICAgICAgIHZhciBhbmRyb2lkdmVyc2lvbiA9ICBtYXRjaCA/IG1hdGNoWzFdIDogMDtcbiAgICAgICAgICAgIGFuZHJvaWR2ZXJzaW9uID0gcGFyc2VGbG9hdChhbmRyb2lkdmVyc2lvbik7XG4gICAgICAgICAgICBpZihhbmRyb2lkdmVyc2lvbiA+PSAxICkge1xuICAgICAgICAgICAgICAgIGlmKGFuZHJvaWR2ZXJzaW9uIDwgNC40KSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzLmlzT2xkQW5kcm9pZCA9IHRydWU7IC8vIGZvciBmaXhlZCBwb3NpdGlvbiBidWcgJiBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5hbmRyb2lkVmVyc2lvbiA9IGFuZHJvaWR2ZXJzaW9uOyAvLyBmb3IgdG91Y2hlbmQgYnVnXG4gICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICBmZWF0dXJlcy5pc01vYmlsZU9wZXJhID0gL29wZXJhIG1pbml8b3BlcmEgbW9iaS9pLnRlc3QodWEpO1xuXG4gICAgICAgICAgICAvLyBwLnMuIHllcywgeWVzLCBVQSBzbmlmZmluZyBpcyBiYWQsIHByb3Bvc2UgeW91ciBzb2x1dGlvbiBmb3IgYWJvdmUgYnVncy5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHN0eWxlQ2hlY2tzID0gWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnLCAnYW5pbWF0aW9uTmFtZSddLFxuICAgICAgICAgICAgdmVuZG9ycyA9IFsnJywgJ3dlYmtpdCcsJ01veicsJ21zJywnTyddLFxuICAgICAgICAgICAgc3R5bGVDaGVja0l0ZW0sXG4gICAgICAgICAgICBzdHlsZU5hbWU7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdmVuZG9yID0gdmVuZG9yc1tpXTtcblxuICAgICAgICAgICAgZm9yKHZhciBhID0gMDsgYSA8IDM7IGErKykge1xuICAgICAgICAgICAgICAgIHN0eWxlQ2hlY2tJdGVtID0gc3R5bGVDaGVja3NbYV07XG5cbiAgICAgICAgICAgICAgICAvLyB1cHBlcmNhc2UgZmlyc3QgbGV0dGVyIG9mIHByb3BlcnR5IG5hbWUsIGlmIHZlbmRvciBpcyBwcmVzZW50XG4gICAgICAgICAgICAgICAgc3R5bGVOYW1lID0gdmVuZG9yICsgKHZlbmRvciA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlQ2hlY2tJdGVtLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3R5bGVDaGVja0l0ZW0uc2xpY2UoMSkgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUNoZWNrSXRlbSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZighZmVhdHVyZXNbc3R5bGVDaGVja0l0ZW1dICYmIHN0eWxlTmFtZSBpbiBoZWxwZXJTdHlsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXNbc3R5bGVDaGVja0l0ZW1dID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodmVuZG9yICYmICFmZWF0dXJlcy5yYWYpIHtcbiAgICAgICAgICAgICAgICB2ZW5kb3IgPSB2ZW5kb3IudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5yYWYgPSB3aW5kb3dbdmVuZG9yKydSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgICAgICAgICAgICBpZihmZWF0dXJlcy5yYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMuY2FmID0gd2luZG93W3ZlbmRvcisnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1t2ZW5kb3IrJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIGlmKCFmZWF0dXJlcy5yYWYpIHtcbiAgICAgICAgICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgICAgICAgICBmZWF0dXJlcy5yYWYgPSBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmbihjdXJyVGltZSArIHRpbWVUb0NhbGwpOyB9LCB0aW1lVG9DYWxsKTtcbiAgICAgICAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmVhdHVyZXMuY2FmID0gZnVuY3Rpb24oaWQpIHsgY2xlYXJUaW1lb3V0KGlkKTsgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVjdCBTVkcgc3VwcG9ydFxuICAgICAgICBmZWF0dXJlcy5zdmcgPSAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKS5jcmVhdGVTVkdSZWN0O1xuXG4gICAgICAgIGZyYW1ld29yay5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuXG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG59O1xuXG5mcmFtZXdvcmsuZGV0ZWN0RmVhdHVyZXMoKTtcblxuLy8gT3ZlcnJpZGUgYWRkRXZlbnRMaXN0ZW5lciBmb3Igb2xkIHZlcnNpb25zIG9mIElFXG5pZihmcmFtZXdvcmsuZmVhdHVyZXMub2xkSUUpIHtcblxuICAgIGZyYW1ld29yay5iaW5kID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgdW5iaW5kKSB7XG4gICAgICAgIFxuICAgICAgICB0eXBlID0gdHlwZS5zcGxpdCgnICcpO1xuXG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gKHVuYmluZCA/ICdkZXRhY2gnIDogJ2F0dGFjaCcpICsgJ0V2ZW50JyxcbiAgICAgICAgICAgIGV2TmFtZSxcbiAgICAgICAgICAgIF9oYW5kbGVFdiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwobGlzdGVuZXIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXZOYW1lID0gdHlwZVtpXTtcbiAgICAgICAgICAgIGlmKGV2TmFtZSkge1xuXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAmJiBsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZighdW5iaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclsnb2xkSUUnICsgZXZOYW1lXSA9IF9oYW5kbGVFdjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFsaXN0ZW5lclsnb2xkSUUnICsgZXZOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFttZXRob2ROYW1lXSggJ29uJyArIGV2TmFtZSwgbGlzdGVuZXJbJ29sZElFJyArIGV2TmFtZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFttZXRob2ROYW1lXSggJ29uJyArIGV2TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbn1cblxuLyo+PmZyYW1ld29yay1icmlkZ2UqL1xuXG4vKj4+Y29yZSovXG4vL2Z1bmN0aW9uKHRlbXBsYXRlLCBVaUNsYXNzLCBpdGVtcywgb3B0aW9ucylcblxudmFyIHNlbGYgPSB0aGlzO1xuXG4vKipcbiAqIFN0YXRpYyB2YXJzLCBkb24ndCBjaGFuZ2UgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICovXG52YXIgRE9VQkxFX1RBUF9SQURJVVMgPSAyNSwgXG4gICAgTlVNX0hPTERFUlMgPSAzO1xuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xudmFyIF9vcHRpb25zID0ge1xuICAgIGFsbG93UGFuVG9OZXh0OnRydWUsXG4gICAgc3BhY2luZzogMC4xMixcbiAgICBiZ09wYWNpdHk6IDEsXG4gICAgbW91c2VVc2VkOiBmYWxzZSxcbiAgICBsb29wOiB0cnVlLFxuICAgIHBpbmNoVG9DbG9zZTogdHJ1ZSxcbiAgICBjbG9zZU9uU2Nyb2xsOiB0cnVlLFxuICAgIGNsb3NlT25WZXJ0aWNhbERyYWc6IHRydWUsXG4gICAgdmVydGljYWxEcmFnUmFuZ2U6IDAuNzUsXG4gICAgaGlkZUFuaW1hdGlvbkR1cmF0aW9uOiAzMzMsXG4gICAgc2hvd0FuaW1hdGlvbkR1cmF0aW9uOiAzMzMsXG4gICAgc2hvd0hpZGVPcGFjaXR5OiBmYWxzZSxcbiAgICBmb2N1czogdHJ1ZSxcbiAgICBlc2NLZXk6IHRydWUsXG4gICAgYXJyb3dLZXlzOiB0cnVlLFxuICAgIG1haW5TY3JvbGxFbmRGcmljdGlvbjogMC4zNSxcbiAgICBwYW5FbmRGcmljdGlvbjogMC4zNSxcbiAgICBpc0NsaWNrYWJsZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC50YWdOYW1lID09PSAnQSc7XG4gICAgfSxcbiAgICBnZXREb3VibGVUYXBab29tOiBmdW5jdGlvbihpc01vdXNlQ2xpY2ssIGl0ZW0pIHtcbiAgICAgICAgaWYoaXNNb3VzZUNsaWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmluaXRpYWxab29tTGV2ZWwgPCAwLjcgPyAxIDogMS4zMztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWF4U3ByZWFkWm9vbTogMS4zMyxcbiAgICBtb2RhbDogdHJ1ZSxcblxuICAgIC8vIG5vdCBmdWxseSBpbXBsZW1lbnRlZCB5ZXRcbiAgICBzY2FsZU1vZGU6ICdmaXQnIC8vIFRPRE9cbn07XG5mcmFtZXdvcmsuZXh0ZW5kKF9vcHRpb25zLCBvcHRpb25zKTtcblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHZhcmlhYmxlcyAmIGZ1bmN0aW9uc1xuICovXG5cbnZhciBfZ2V0RW1wdHlQb2ludCA9IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgcmV0dXJuIHt4OjAseTowfTsgXG4gICAgfTtcblxudmFyIF9pc09wZW4sXG4gICAgX2lzRGVzdHJveWluZyxcbiAgICBfY2xvc2VkQnlTY3JvbGwsXG4gICAgX2N1cnJlbnRJdGVtSW5kZXgsXG4gICAgX2NvbnRhaW5lclN0eWxlLFxuICAgIF9jb250YWluZXJTaGlmdEluZGV4LFxuICAgIF9jdXJyUGFuRGlzdCA9IF9nZXRFbXB0eVBvaW50KCksXG4gICAgX3N0YXJ0UGFuT2Zmc2V0ID0gX2dldEVtcHR5UG9pbnQoKSxcbiAgICBfcGFuT2Zmc2V0ID0gX2dldEVtcHR5UG9pbnQoKSxcbiAgICBfdXBNb3ZlRXZlbnRzLCAvLyBkcmFnIG1vdmUsIGRyYWcgZW5kICYgZHJhZyBjYW5jZWwgZXZlbnRzIGFycmF5XG4gICAgX2Rvd25FdmVudHMsIC8vIGRyYWcgc3RhcnQgZXZlbnRzIGFycmF5XG4gICAgX2dsb2JhbEV2ZW50SGFuZGxlcnMsXG4gICAgX3ZpZXdwb3J0U2l6ZSA9IHt9LFxuICAgIF9jdXJyWm9vbUxldmVsLFxuICAgIF9zdGFydFpvb21MZXZlbCxcbiAgICBfdHJhbnNsYXRlUHJlZml4LFxuICAgIF90cmFuc2xhdGVTdWZpeCxcbiAgICBfdXBkYXRlU2l6ZUludGVydmFsLFxuICAgIF9pdGVtc05lZWRVcGRhdGUsXG4gICAgX2N1cnJQb3NpdGlvbkluZGV4ID0gMCxcbiAgICBfb2Zmc2V0ID0ge30sXG4gICAgX3NsaWRlU2l6ZSA9IF9nZXRFbXB0eVBvaW50KCksIC8vIHNpemUgb2Ygc2xpZGUgYXJlYSwgaW5jbHVkaW5nIHNwYWNpbmdcbiAgICBfaXRlbUhvbGRlcnMsXG4gICAgX3ByZXZJdGVtSW5kZXgsXG4gICAgX2luZGV4RGlmZiA9IDAsIC8vIGRpZmZlcmVuY2Ugb2YgaW5kZXhlcyBzaW5jZSBsYXN0IGNvbnRlbnQgdXBkYXRlXG4gICAgX2RyYWdTdGFydEV2ZW50LFxuICAgIF9kcmFnTW92ZUV2ZW50LFxuICAgIF9kcmFnRW5kRXZlbnQsXG4gICAgX2RyYWdDYW5jZWxFdmVudCxcbiAgICBfdHJhbnNmb3JtS2V5LFxuICAgIF9wb2ludGVyRXZlbnRFbmFibGVkLFxuICAgIF9pc0ZpeGVkUG9zaXRpb24gPSB0cnVlLFxuICAgIF9saWtlbHlUb3VjaERldmljZSxcbiAgICBfbW9kdWxlcyA9IFtdLFxuICAgIF9yZXF1ZXN0QUYsXG4gICAgX2NhbmNlbEFGLFxuICAgIF9pbml0YWxDbGFzc05hbWUsXG4gICAgX2luaXRhbFdpbmRvd1Njcm9sbFksXG4gICAgX29sZElFLFxuICAgIF9jdXJyZW50V2luZG93U2Nyb2xsWSxcbiAgICBfZmVhdHVyZXMsXG4gICAgX3dpbmRvd1Zpc2libGVTaXplID0ge30sXG4gICAgX3JlbmRlck1heFJlc29sdXRpb24gPSBmYWxzZSxcblxuICAgIC8vIFJlZ2lzdGVycyBQaG90b1NXaXBlIG1vZHVsZSAoSGlzdG9yeSwgQ29udHJvbGxlciAuLi4pXG4gICAgX3JlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24obmFtZSwgbW9kdWxlKSB7XG4gICAgICAgIGZyYW1ld29yay5leHRlbmQoc2VsZiwgbW9kdWxlLnB1YmxpY01ldGhvZHMpO1xuICAgICAgICBfbW9kdWxlcy5wdXNoKG5hbWUpO1xuICAgIH0sXG5cbiAgICBfZ2V0TG9vcGVkSWQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgbnVtU2xpZGVzID0gX2dldE51bUl0ZW1zKCk7XG4gICAgICAgIGlmKGluZGV4ID4gbnVtU2xpZGVzIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4IC0gbnVtU2xpZGVzO1xuICAgICAgICB9IGVsc2UgIGlmKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVNsaWRlcyArIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuICAgIFxuICAgIC8vIE1pY3JvIGJpbmQvdHJpZ2dlclxuICAgIF9saXN0ZW5lcnMgPSB7fSxcbiAgICBfbGlzdGVuID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICAgICAgaWYoIV9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIF9saXN0ZW5lcnNbbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGZuKTtcbiAgICB9LFxuICAgIF9zaG91dCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IF9saXN0ZW5lcnNbbmFtZV07XG5cbiAgICAgICAgaWYobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9LFxuICAgIF9hcHBseUJnT3BhY2l0eSA9IGZ1bmN0aW9uKG9wYWNpdHkpIHtcbiAgICAgICAgX2JnT3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIHNlbGYuYmcuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHkgKiBfb3B0aW9ucy5iZ09wYWNpdHk7XG4gICAgfSxcblxuICAgIF9hcHBseVpvb21UcmFuc2Zvcm0gPSBmdW5jdGlvbihzdHlsZU9iaix4LHksem9vbSxpdGVtKSB7XG4gICAgICAgIGlmKCFfcmVuZGVyTWF4UmVzb2x1dGlvbiB8fCAoaXRlbSAmJiBpdGVtICE9PSBzZWxmLmN1cnJJdGVtKSApIHtcbiAgICAgICAgICAgIHpvb20gPSB6b29tIC8gKGl0ZW0gPyBpdGVtLmZpdFJhdGlvIDogc2VsZi5jdXJySXRlbS5maXRSYXRpbyk7ICBcbiAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIHN0eWxlT2JqW190cmFuc2Zvcm1LZXldID0gX3RyYW5zbGF0ZVByZWZpeCArIHggKyAncHgsICcgKyB5ICsgJ3B4JyArIF90cmFuc2xhdGVTdWZpeCArICcgc2NhbGUoJyArIHpvb20gKyAnKSc7XG4gICAgfSxcbiAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbiA9IGZ1bmN0aW9uKCBhbGxvd1JlbmRlclJlc29sdXRpb24gKSB7XG4gICAgICAgIGlmKF9jdXJyWm9vbUVsZW1lbnRTdHlsZSkge1xuXG4gICAgICAgICAgICBpZihhbGxvd1JlbmRlclJlc29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZihfY3Vyclpvb21MZXZlbCA+IHNlbGYuY3Vyckl0ZW0uZml0UmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIV9yZW5kZXJNYXhSZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc2V0SW1hZ2VTaXplKHNlbGYuY3Vyckl0ZW0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZW5kZXJNYXhSZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKF9yZW5kZXJNYXhSZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc2V0SW1hZ2VTaXplKHNlbGYuY3Vyckl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlbmRlck1heFJlc29sdXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBfYXBwbHlab29tVHJhbnNmb3JtKF9jdXJyWm9vbUVsZW1lbnRTdHlsZSwgX3Bhbk9mZnNldC54LCBfcGFuT2Zmc2V0LnksIF9jdXJyWm9vbUxldmVsKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2FwcGx5Wm9vbVBhblRvSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYoaXRlbS5jb250YWluZXIpIHtcblxuICAgICAgICAgICAgX2FwcGx5Wm9vbVRyYW5zZm9ybShpdGVtLmNvbnRhaW5lci5zdHlsZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaW5pdGlhbFBvc2l0aW9uLngsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmluaXRpYWxQb3NpdGlvbi55LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5pbml0aWFsWm9vbUxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3NldFRyYW5zbGF0ZVggPSBmdW5jdGlvbih4LCBlbFN0eWxlKSB7XG4gICAgICAgIGVsU3R5bGVbX3RyYW5zZm9ybUtleV0gPSBfdHJhbnNsYXRlUHJlZml4ICsgeCArICdweCwgMHB4JyArIF90cmFuc2xhdGVTdWZpeDtcbiAgICB9LFxuICAgIF9tb3ZlTWFpblNjcm9sbCA9IGZ1bmN0aW9uKHgsIGRyYWdnaW5nKSB7XG5cbiAgICAgICAgaWYoIV9vcHRpb25zLmxvb3AgJiYgZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZhciBuZXdTbGlkZUluZGV4T2Zmc2V0ID0gX2N1cnJlbnRJdGVtSW5kZXggKyAoX3NsaWRlU2l6ZS54ICogX2N1cnJQb3NpdGlvbkluZGV4IC0geCkgLyBfc2xpZGVTaXplLngsXG4gICAgICAgICAgICAgICAgZGVsdGEgPSBNYXRoLnJvdW5kKHggLSBfbWFpblNjcm9sbFBvcy54KTtcblxuICAgICAgICAgICAgaWYoIChuZXdTbGlkZUluZGV4T2Zmc2V0IDwgMCAmJiBkZWx0YSA+IDApIHx8IFxuICAgICAgICAgICAgICAgIChuZXdTbGlkZUluZGV4T2Zmc2V0ID49IF9nZXROdW1JdGVtcygpIC0gMSAmJiBkZWx0YSA8IDApICkge1xuICAgICAgICAgICAgICAgIHggPSBfbWFpblNjcm9sbFBvcy54ICsgZGVsdGEgKiBfb3B0aW9ucy5tYWluU2Nyb2xsRW5kRnJpY3Rpb247XG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBfbWFpblNjcm9sbFBvcy54ID0geDtcbiAgICAgICAgX3NldFRyYW5zbGF0ZVgoeCwgX2NvbnRhaW5lclN0eWxlKTtcbiAgICB9LFxuICAgIF9jYWxjdWxhdGVQYW5PZmZzZXQgPSBmdW5jdGlvbihheGlzLCB6b29tTGV2ZWwpIHtcbiAgICAgICAgdmFyIG0gPSBfbWlkWm9vbVBvaW50W2F4aXNdIC0gX29mZnNldFtheGlzXTtcbiAgICAgICAgcmV0dXJuIF9zdGFydFBhbk9mZnNldFtheGlzXSArIF9jdXJyUGFuRGlzdFtheGlzXSArIG0gLSBtICogKCB6b29tTGV2ZWwgLyBfc3RhcnRab29tTGV2ZWwgKTtcbiAgICB9LFxuICAgIFxuICAgIF9lcXVhbGl6ZVBvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgICAgICBwMS54ID0gcDIueDtcbiAgICAgICAgcDEueSA9IHAyLnk7XG4gICAgICAgIGlmKHAyLmlkKSB7XG4gICAgICAgICAgICBwMS5pZCA9IHAyLmlkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcm91bmRQb2ludCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcC54ID0gTWF0aC5yb3VuZChwLngpO1xuICAgICAgICBwLnkgPSBNYXRoLnJvdW5kKHAueSk7XG4gICAgfSxcblxuICAgIF9tb3VzZU1vdmVUaW1lb3V0ID0gbnVsbCxcbiAgICBfb25GaXJzdE1vdXNlTW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBXYWl0IHVudGlsIG1vdXNlIG1vdmUgZXZlbnQgaXMgZmlyZWQgYXQgbGVhc3QgdHdpY2UgZHVyaW5nIDEwMG1zXG4gICAgICAgIC8vIFdlIGRvIHRoaXMsIGJlY2F1c2Ugc29tZSBtb2JpbGUgYnJvd3NlcnMgdHJpZ2dlciBpdCBvbiB0b3VjaHN0YXJ0XG4gICAgICAgIGlmKF9tb3VzZU1vdmVUaW1lb3V0ICkgeyBcbiAgICAgICAgICAgIGZyYW1ld29yay51bmJpbmQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfb25GaXJzdE1vdXNlTW92ZSk7XG4gICAgICAgICAgICBmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1oYXNfbW91c2UnKTtcbiAgICAgICAgICAgIF9vcHRpb25zLm1vdXNlVXNlZCA9IHRydWU7XG4gICAgICAgICAgICBfc2hvdXQoJ21vdXNlVXNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIF9tb3VzZU1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9tb3VzZU1vdmVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgX2JpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnJhbWV3b3JrLmJpbmQoZG9jdW1lbnQsICdrZXlkb3duJywgc2VsZik7XG5cbiAgICAgICAgaWYoX2ZlYXR1cmVzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgYmluZCBjbGljayBldmVudCBpbiBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdHJhbnNmb3JtIChtb3N0bHkgSUU4KVxuICAgICAgICAgICAgZnJhbWV3b3JrLmJpbmQoc2VsZi5zY3JvbGxXcmFwLCAnY2xpY2snLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBcblxuICAgICAgICBpZighX29wdGlvbnMubW91c2VVc2VkKSB7XG4gICAgICAgICAgICBmcmFtZXdvcmsuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIF9vbkZpcnN0TW91c2VNb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1ld29yay5iaW5kKHdpbmRvdywgJ3Jlc2l6ZSBzY3JvbGwnLCBzZWxmKTtcblxuICAgICAgICBfc2hvdXQoJ2JpbmRFdmVudHMnKTtcbiAgICB9LFxuXG4gICAgX3VuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmcmFtZXdvcmsudW5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIHNlbGYpO1xuICAgICAgICBmcmFtZXdvcmsudW5iaW5kKHdpbmRvdywgJ3Njcm9sbCcsIF9nbG9iYWxFdmVudEhhbmRsZXJzLnNjcm9sbCk7XG4gICAgICAgIGZyYW1ld29yay51bmJpbmQoZG9jdW1lbnQsICdrZXlkb3duJywgc2VsZik7XG4gICAgICAgIGZyYW1ld29yay51bmJpbmQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfb25GaXJzdE1vdXNlTW92ZSk7XG5cbiAgICAgICAgaWYoX2ZlYXR1cmVzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgZnJhbWV3b3JrLnVuYmluZChzZWxmLnNjcm9sbFdyYXAsICdjbGljaycsIHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoX2lzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGZyYW1ld29yay51bmJpbmQod2luZG93LCBfdXBNb3ZlRXZlbnRzLCBzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zaG91dCgndW5iaW5kRXZlbnRzJyk7XG4gICAgfSxcbiAgICBcbiAgICBfY2FsY3VsYXRlUGFuQm91bmRzID0gZnVuY3Rpb24oem9vbUxldmVsLCB1cGRhdGUpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IF9jYWxjdWxhdGVJdGVtU2l6ZSggc2VsZi5jdXJySXRlbSwgX3ZpZXdwb3J0U2l6ZSwgem9vbUxldmVsICk7XG4gICAgICAgIGlmKHVwZGF0ZSkge1xuICAgICAgICAgICAgX2N1cnJQYW5Cb3VuZHMgPSBib3VuZHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9LFxuICAgIFxuICAgIF9nZXRNaW5ab29tTGV2ZWwgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmKCFpdGVtKSB7XG4gICAgICAgICAgICBpdGVtID0gc2VsZi5jdXJySXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS5pbml0aWFsWm9vbUxldmVsO1xuICAgIH0sXG4gICAgX2dldE1heFpvb21MZXZlbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYoIWl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSBzZWxmLmN1cnJJdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLncgPiAwID8gX29wdGlvbnMubWF4U3ByZWFkWm9vbSA6IDE7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0cnVlIGlmIG9mZnNldCBpcyBvdXQgb2YgdGhlIGJvdW5kc1xuICAgIF9tb2RpZnlEZXN0UGFuT2Zmc2V0ID0gZnVuY3Rpb24oYXhpcywgZGVzdFBhbkJvdW5kcywgZGVzdFBhbk9mZnNldCwgZGVzdFpvb21MZXZlbCkge1xuICAgICAgICBpZihkZXN0Wm9vbUxldmVsID09PSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpIHtcbiAgICAgICAgICAgIGRlc3RQYW5PZmZzZXRbYXhpc10gPSBzZWxmLmN1cnJJdGVtLmluaXRpYWxQb3NpdGlvbltheGlzXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdFBhbk9mZnNldFtheGlzXSA9IF9jYWxjdWxhdGVQYW5PZmZzZXQoYXhpcywgZGVzdFpvb21MZXZlbCk7IFxuXG4gICAgICAgICAgICBpZihkZXN0UGFuT2Zmc2V0W2F4aXNdID4gZGVzdFBhbkJvdW5kcy5taW5bYXhpc10pIHtcbiAgICAgICAgICAgICAgICBkZXN0UGFuT2Zmc2V0W2F4aXNdID0gZGVzdFBhbkJvdW5kcy5taW5bYXhpc107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYoZGVzdFBhbk9mZnNldFtheGlzXSA8IGRlc3RQYW5Cb3VuZHMubWF4W2F4aXNdICkge1xuICAgICAgICAgICAgICAgIGRlc3RQYW5PZmZzZXRbYXhpc10gPSBkZXN0UGFuQm91bmRzLm1heFtheGlzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIF9zZXR1cFRyYW5zZm9ybXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZihfdHJhbnNmb3JtS2V5KSB7XG4gICAgICAgICAgICAvLyBzZXR1cCAzZCB0cmFuc2Zvcm1zXG4gICAgICAgICAgICB2YXIgYWxsb3czZFRyYW5zZm9ybSA9IF9mZWF0dXJlcy5wZXJzcGVjdGl2ZSAmJiAhX2xpa2VseVRvdWNoRGV2aWNlO1xuICAgICAgICAgICAgX3RyYW5zbGF0ZVByZWZpeCA9ICd0cmFuc2xhdGUnICsgKGFsbG93M2RUcmFuc2Zvcm0gPyAnM2QoJyA6ICcoJyk7XG4gICAgICAgICAgICBfdHJhbnNsYXRlU3VmaXggPSBfZmVhdHVyZXMucGVyc3BlY3RpdmUgPyAnLCAwcHgpJyA6ICcpJzsgICBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE92ZXJyaWRlIHpvb20vcGFuL21vdmUgZnVuY3Rpb25zIGluIGNhc2Ugb2xkIGJyb3dzZXIgaXMgdXNlZCAobW9zdCBsaWtlbHkgSUUpXG4gICAgICAgIC8vIChzbyB0aGV5IHVzZSBsZWZ0L3RvcC93aWR0aC9oZWlnaHQsIGluc3RlYWQgb2YgQ1NTIHRyYW5zZm9ybSlcbiAgICBcbiAgICAgICAgX3RyYW5zZm9ybUtleSA9ICdsZWZ0JztcbiAgICAgICAgZnJhbWV3b3JrLmFkZENsYXNzKHRlbXBsYXRlLCAncHN3cC0taWUnKTtcblxuICAgICAgICBfc2V0VHJhbnNsYXRlWCA9IGZ1bmN0aW9uKHgsIGVsU3R5bGUpIHtcbiAgICAgICAgICAgIGVsU3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICB9O1xuICAgICAgICBfYXBwbHlab29tUGFuVG9JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuXG4gICAgICAgICAgICB2YXIgem9vbVJhdGlvID0gaXRlbS5maXRSYXRpbyA+IDEgPyAxIDogaXRlbS5maXRSYXRpbyxcbiAgICAgICAgICAgICAgICBzID0gaXRlbS5jb250YWluZXIuc3R5bGUsXG4gICAgICAgICAgICAgICAgdyA9IHpvb21SYXRpbyAqIGl0ZW0udyxcbiAgICAgICAgICAgICAgICBoID0gem9vbVJhdGlvICogaXRlbS5oO1xuXG4gICAgICAgICAgICBzLndpZHRoID0gdyArICdweCc7XG4gICAgICAgICAgICBzLmhlaWdodCA9IGggKyAncHgnO1xuICAgICAgICAgICAgcy5sZWZ0ID0gaXRlbS5pbml0aWFsUG9zaXRpb24ueCArICdweCc7XG4gICAgICAgICAgICBzLnRvcCA9IGl0ZW0uaW5pdGlhbFBvc2l0aW9uLnkgKyAncHgnO1xuXG4gICAgICAgIH07XG4gICAgICAgIF9hcHBseUN1cnJlbnRab29tUGFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZihfY3Vyclpvb21FbGVtZW50U3R5bGUpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzID0gX2N1cnJab29tRWxlbWVudFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBpdGVtID0gc2VsZi5jdXJySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgem9vbVJhdGlvID0gaXRlbS5maXRSYXRpbyA+IDEgPyAxIDogaXRlbS5maXRSYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgdyA9IHpvb21SYXRpbyAqIGl0ZW0udyxcbiAgICAgICAgICAgICAgICAgICAgaCA9IHpvb21SYXRpbyAqIGl0ZW0uaDtcblxuICAgICAgICAgICAgICAgIHMud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzLmhlaWdodCA9IGggKyAncHgnO1xuXG5cbiAgICAgICAgICAgICAgICBzLmxlZnQgPSBfcGFuT2Zmc2V0LnggKyAncHgnO1xuICAgICAgICAgICAgICAgIHMudG9wID0gX3Bhbk9mZnNldC55ICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfb25LZXlEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIga2V5ZG93bkFjdGlvbiA9ICcnO1xuICAgICAgICBpZihfb3B0aW9ucy5lc2NLZXkgJiYgZS5rZXlDb2RlID09PSAyNykgeyBcbiAgICAgICAgICAgIGtleWRvd25BY3Rpb24gPSAnY2xvc2UnO1xuICAgICAgICB9IGVsc2UgaWYoX29wdGlvbnMuYXJyb3dLZXlzKSB7XG4gICAgICAgICAgICBpZihlLmtleUNvZGUgPT09IDM3KSB7XG4gICAgICAgICAgICAgICAga2V5ZG93bkFjdGlvbiA9ICdwcmV2JztcbiAgICAgICAgICAgIH0gZWxzZSBpZihlLmtleUNvZGUgPT09IDM5KSB7IFxuICAgICAgICAgICAgICAgIGtleWRvd25BY3Rpb24gPSAnbmV4dCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihrZXlkb3duQWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBzcGVjaWFsIGtleSBwcmVzc2VkIHRvIHByZXZlbnQgZnJvbSBvdmVycmlkaW5nIGRlZmF1bHQgYnJvd3NlciBhY3Rpb25zXG4gICAgICAgICAgICAvLyBlLmcuIGluIENocm9tZSBvbiBNYWMgY21kK2Fycm93LWxlZnQgcmV0dXJucyB0byBwcmV2aW91cyBwYWdlXG4gICAgICAgICAgICBpZiggIWUuY3RybEtleSAmJiAhZS5hbHRLZXkgJiYgIWUuc2hpZnRLZXkgJiYgIWUubWV0YUtleSApIHtcbiAgICAgICAgICAgICAgICBpZihlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBzZWxmW2tleWRvd25BY3Rpb25dKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uR2xvYmFsQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmKCFlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb24ndCBhbGxvdyBjbGljayBldmVudCB0byBwYXNzIHRocm91Z2ggd2hlbiB0cmlnZ2VyaW5nIGFmdGVyIGRyYWcgb3Igc29tZSBvdGhlciBnZXN0dXJlXG4gICAgICAgIGlmKF9tb3ZlZCB8fCBfem9vbVN0YXJ0ZWQgfHwgX21haW5TY3JvbGxBbmltYXRpbmcgfHwgX3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlUGFnZVNjcm9sbE9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnNldFNjcm9sbE9mZnNldCgwLCBmcmFtZXdvcmsuZ2V0U2Nyb2xsWSgpKTsgICAgICAgIFxuICAgIH07XG4gICAgXG5cblxuICAgIFxuXG5cblxuLy8gTWljcm8gYW5pbWF0aW9uIGVuZ2luZVxudmFyIF9hbmltYXRpb25zID0ge30sXG4gICAgX251bUFuaW1hdGlvbnMgPSAwLFxuICAgIF9zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZihfYW5pbWF0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgaWYoX2FuaW1hdGlvbnNbbmFtZV0ucmFmKSB7XG4gICAgICAgICAgICAgICAgX2NhbmNlbEFGKCBfYW5pbWF0aW9uc1tuYW1lXS5yYWYgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9udW1BbmltYXRpb25zLS07XG4gICAgICAgICAgICBkZWxldGUgX2FuaW1hdGlvbnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9yZWdpc3RlclN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZihfYW5pbWF0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgX3N0b3BBbmltYXRpb24obmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIV9hbmltYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICBfbnVtQW5pbWF0aW9ucysrO1xuICAgICAgICAgICAgX2FuaW1hdGlvbnNbbmFtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3N0b3BBbGxBbmltYXRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gX2FuaW1hdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYoIF9hbmltYXRpb25zLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG4gICAgICAgICAgICAgICAgX3N0b3BBbmltYXRpb24ocHJvcCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9hbmltYXRlUHJvcCA9IGZ1bmN0aW9uKG5hbWUsIGIsIGVuZFByb3AsIGQsIGVhc2luZ0ZuLCBvblVwZGF0ZSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgc3RhcnRBbmltVGltZSA9IF9nZXRDdXJyZW50VGltZSgpLCB0O1xuICAgICAgICBfcmVnaXN0ZXJTdGFydEFuaW1hdGlvbihuYW1lKTtcblxuICAgICAgICB2YXIgYW5pbWxvb3AgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKCBfYW5pbWF0aW9uc1tuYW1lXSApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0ID0gX2dldEN1cnJlbnRUaW1lKCkgLSBzdGFydEFuaW1UaW1lOyAvLyB0aW1lIGRpZmZcbiAgICAgICAgICAgICAgICAvL2IgLSBiZWdpbm5pbmcgKHN0YXJ0IHByb3ApXG4gICAgICAgICAgICAgICAgLy9kIC0gYW5pbSBkdXJhdGlvblxuXG4gICAgICAgICAgICAgICAgaWYgKCB0ID49IGQgKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zdG9wQW5pbWF0aW9uKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZShlbmRQcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25VcGRhdGUoIChlbmRQcm9wIC0gYikgKiBlYXNpbmdGbih0L2QpICsgYiApO1xuXG4gICAgICAgICAgICAgICAgX2FuaW1hdGlvbnNbbmFtZV0ucmFmID0gX3JlcXVlc3RBRihhbmltbG9vcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFuaW1sb29wKCk7XG4gICAgfTtcbiAgICBcblxuXG52YXIgcHVibGljTWV0aG9kcyA9IHtcblxuICAgIC8vIG1ha2UgYSBmZXcgbG9jYWwgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnMgcHVibGljXG4gICAgc2hvdXQ6IF9zaG91dCxcbiAgICBsaXN0ZW46IF9saXN0ZW4sXG4gICAgdmlld3BvcnRTaXplOiBfdmlld3BvcnRTaXplLFxuICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuXG4gICAgaXNNYWluU2Nyb2xsQW5pbWF0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9tYWluU2Nyb2xsQW5pbWF0aW5nO1xuICAgIH0sXG4gICAgZ2V0Wm9vbUxldmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jdXJyWm9vbUxldmVsO1xuICAgIH0sXG4gICAgZ2V0Q3VycmVudEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jdXJyZW50SXRlbUluZGV4O1xuICAgIH0sXG4gICAgaXNEcmFnZ2luZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaXNEcmFnZ2luZztcbiAgICB9LCAgXG4gICAgaXNab29taW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9pc1pvb21pbmc7XG4gICAgfSxcbiAgICBzZXRTY3JvbGxPZmZzZXQ6IGZ1bmN0aW9uKHgseSkge1xuICAgICAgICBfb2Zmc2V0LnggPSB4O1xuICAgICAgICBfY3VycmVudFdpbmRvd1Njcm9sbFkgPSBfb2Zmc2V0LnkgPSB5O1xuICAgICAgICBfc2hvdXQoJ3VwZGF0ZVNjcm9sbE9mZnNldCcsIF9vZmZzZXQpO1xuICAgIH0sXG4gICAgYXBwbHlab29tUGFuOiBmdW5jdGlvbih6b29tTGV2ZWwscGFuWCxwYW5ZLGFsbG93UmVuZGVyUmVzb2x1dGlvbikge1xuICAgICAgICBfcGFuT2Zmc2V0LnggPSBwYW5YO1xuICAgICAgICBfcGFuT2Zmc2V0LnkgPSBwYW5ZO1xuICAgICAgICBfY3Vyclpvb21MZXZlbCA9IHpvb21MZXZlbDtcbiAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4oIGFsbG93UmVuZGVyUmVzb2x1dGlvbiApO1xuICAgIH0sXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZihfaXNPcGVuIHx8IF9pc0Rlc3Ryb3lpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIHNlbGYuZnJhbWV3b3JrID0gZnJhbWV3b3JrOyAvLyBiYXNpYyBmdW5jdGlvbmFsaXR5XG4gICAgICAgIHNlbGYudGVtcGxhdGUgPSB0ZW1wbGF0ZTsgLy8gcm9vdCBET00gZWxlbWVudCBvZiBQaG90b1N3aXBlXG4gICAgICAgIHNlbGYuYmcgPSBmcmFtZXdvcmsuZ2V0Q2hpbGRCeUNsYXNzKHRlbXBsYXRlLCAncHN3cF9fYmcnKTtcblxuICAgICAgICBfaW5pdGFsQ2xhc3NOYW1lID0gdGVtcGxhdGUuY2xhc3NOYW1lO1xuICAgICAgICBfaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgX2ZlYXR1cmVzID0gZnJhbWV3b3JrLmRldGVjdEZlYXR1cmVzKCk7XG4gICAgICAgIF9yZXF1ZXN0QUYgPSBfZmVhdHVyZXMucmFmO1xuICAgICAgICBfY2FuY2VsQUYgPSBfZmVhdHVyZXMuY2FmO1xuICAgICAgICBfdHJhbnNmb3JtS2V5ID0gX2ZlYXR1cmVzLnRyYW5zZm9ybTtcbiAgICAgICAgX29sZElFID0gX2ZlYXR1cmVzLm9sZElFO1xuICAgICAgICBcbiAgICAgICAgc2VsZi5zY3JvbGxXcmFwID0gZnJhbWV3b3JrLmdldENoaWxkQnlDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3BfX3Njcm9sbC13cmFwJyk7XG4gICAgICAgIHNlbGYuY29udGFpbmVyID0gZnJhbWV3b3JrLmdldENoaWxkQnlDbGFzcyhzZWxmLnNjcm9sbFdyYXAsICdwc3dwX19jb250YWluZXInKTtcblxuICAgICAgICBfY29udGFpbmVyU3R5bGUgPSBzZWxmLmNvbnRhaW5lci5zdHlsZTsgLy8gZm9yIGZhc3QgYWNjZXNzXG5cbiAgICAgICAgLy8gT2JqZWN0cyB0aGF0IGhvbGQgc2xpZGVzICh0aGVyZSBhcmUgb25seSAzIGluIERPTSlcbiAgICAgICAgc2VsZi5pdGVtSG9sZGVycyA9IF9pdGVtSG9sZGVycyA9IFtcbiAgICAgICAgICAgIHtlbDpzZWxmLmNvbnRhaW5lci5jaGlsZHJlblswXSAsIHdyYXA6MCwgaW5kZXg6IC0xfSxcbiAgICAgICAgICAgIHtlbDpzZWxmLmNvbnRhaW5lci5jaGlsZHJlblsxXSAsIHdyYXA6MCwgaW5kZXg6IC0xfSxcbiAgICAgICAgICAgIHtlbDpzZWxmLmNvbnRhaW5lci5jaGlsZHJlblsyXSAsIHdyYXA6MCwgaW5kZXg6IC0xfVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIGhpZGUgbmVhcmJ5IGl0ZW0gaG9sZGVycyB1bnRpbCBpbml0aWFsIHpvb20gYW5pbWF0aW9uIGZpbmlzaGVzICh0byBhdm9pZCBleHRyYSBQYWludHMpXG4gICAgICAgIF9pdGVtSG9sZGVyc1swXS5lbC5zdHlsZS5kaXNwbGF5ID0gX2l0ZW1Ib2xkZXJzWzJdLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgX3NldHVwVHJhbnNmb3JtcygpO1xuXG4gICAgICAgIC8vIFNldHVwIGdsb2JhbCBldmVudHNcbiAgICAgICAgX2dsb2JhbEV2ZW50SGFuZGxlcnMgPSB7XG4gICAgICAgICAgICByZXNpemU6IHNlbGYudXBkYXRlU2l6ZSxcbiAgICAgICAgICAgIHNjcm9sbDogX3VwZGF0ZVBhZ2VTY3JvbGxPZmZzZXQsXG4gICAgICAgICAgICBrZXlkb3duOiBfb25LZXlEb3duLFxuICAgICAgICAgICAgY2xpY2s6IF9vbkdsb2JhbENsaWNrXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaG93L2hpZGUgZWZmZWN0cyBvbiBvbGQgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IENTUyBhbmltYXRpb25zIG9yIHRyYW5zZm9ybXMsIFxuICAgICAgICAvLyBvbGQgSU9TLCBBbmRyb2lkIGFuZCBPcGVyYSBtb2JpbGUuIEJsYWNrYmVycnkgc2VlbXMgdG8gd29yayBmaW5lLCBldmVuIG9sZGVyIG1vZGVscy5cbiAgICAgICAgdmFyIG9sZFBob25lID0gX2ZlYXR1cmVzLmlzT2xkSU9TUGhvbmUgfHwgX2ZlYXR1cmVzLmlzT2xkQW5kcm9pZCB8fCBfZmVhdHVyZXMuaXNNb2JpbGVPcGVyYTtcbiAgICAgICAgaWYoIV9mZWF0dXJlcy5hbmltYXRpb25OYW1lIHx8ICFfZmVhdHVyZXMudHJhbnNmb3JtIHx8IG9sZFBob25lKSB7XG4gICAgICAgICAgICBfb3B0aW9ucy5zaG93QW5pbWF0aW9uRHVyYXRpb24gPSBfb3B0aW9ucy5oaWRlQW5pbWF0aW9uRHVyYXRpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdCBtb2R1bGVzXG4gICAgICAgIGZvcihpID0gMDsgaSA8IF9tb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmWydpbml0JyArIF9tb2R1bGVzW2ldXSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBpbml0XG4gICAgICAgIGlmKFVpQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciB1aSA9IHNlbGYudWkgPSBuZXcgVWlDbGFzcyhzZWxmLCBmcmFtZXdvcmspO1xuICAgICAgICAgICAgdWkuaW5pdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Nob3V0KCdmaXJzdFVwZGF0ZScpO1xuICAgICAgICBfY3VycmVudEl0ZW1JbmRleCA9IF9jdXJyZW50SXRlbUluZGV4IHx8IF9vcHRpb25zLmluZGV4IHx8IDA7XG4gICAgICAgIC8vIHZhbGlkYXRlIGluZGV4XG4gICAgICAgIGlmKCBpc05hTihfY3VycmVudEl0ZW1JbmRleCkgfHwgX2N1cnJlbnRJdGVtSW5kZXggPCAwIHx8IF9jdXJyZW50SXRlbUluZGV4ID49IF9nZXROdW1JdGVtcygpICkge1xuICAgICAgICAgICAgX2N1cnJlbnRJdGVtSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY3Vyckl0ZW0gPSBfZ2V0SXRlbUF0KCBfY3VycmVudEl0ZW1JbmRleCApO1xuXG4gICAgICAgIFxuICAgICAgICBpZihfZmVhdHVyZXMuaXNPbGRJT1NQaG9uZSB8fCBfZmVhdHVyZXMuaXNPbGRBbmRyb2lkKSB7XG4gICAgICAgICAgICBfaXNGaXhlZFBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRlbXBsYXRlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcbiAgICAgICAgaWYoX29wdGlvbnMubW9kYWwpIHtcbiAgICAgICAgICAgIGlmKCFfaXNGaXhlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlLnN0eWxlLnRvcCA9IGZyYW1ld29yay5nZXRTY3JvbGxZKCkgKyAncHgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihfY3VycmVudFdpbmRvd1Njcm9sbFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3Nob3V0KCdpbml0aWFsTGF5b3V0Jyk7XG4gICAgICAgICAgICBfY3VycmVudFdpbmRvd1Njcm9sbFkgPSBfaW5pdGFsV2luZG93U2Nyb2xsWSA9IGZyYW1ld29yay5nZXRTY3JvbGxZKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGFkZCBjbGFzc2VzIHRvIHJvb3QgZWxlbWVudCBvZiBQaG90b1N3aXBlXG4gICAgICAgIHZhciByb290Q2xhc3NlcyA9ICdwc3dwLS1vcGVuICc7XG4gICAgICAgIGlmKF9vcHRpb25zLm1haW5DbGFzcykge1xuICAgICAgICAgICAgcm9vdENsYXNzZXMgKz0gX29wdGlvbnMubWFpbkNsYXNzICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmKF9vcHRpb25zLnNob3dIaWRlT3BhY2l0eSkge1xuICAgICAgICAgICAgcm9vdENsYXNzZXMgKz0gJ3Bzd3AtLWFuaW1hdGVfb3BhY2l0eSAnO1xuICAgICAgICB9XG4gICAgICAgIHJvb3RDbGFzc2VzICs9IF9saWtlbHlUb3VjaERldmljZSA/ICdwc3dwLS10b3VjaCcgOiAncHN3cC0tbm90b3VjaCc7XG4gICAgICAgIHJvb3RDbGFzc2VzICs9IF9mZWF0dXJlcy5hbmltYXRpb25OYW1lID8gJyBwc3dwLS1jc3NfYW5pbWF0aW9uJyA6ICcnO1xuICAgICAgICByb290Q2xhc3NlcyArPSBfZmVhdHVyZXMuc3ZnID8gJyBwc3dwLS1zdmcnIDogJyc7XG4gICAgICAgIGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgcm9vdENsYXNzZXMpO1xuXG4gICAgICAgIHNlbGYudXBkYXRlU2l6ZSgpO1xuXG4gICAgICAgIC8vIGluaXRpYWwgdXBkYXRlXG4gICAgICAgIF9jb250YWluZXJTaGlmdEluZGV4ID0gLTE7XG4gICAgICAgIF9pbmRleERpZmYgPSBudWxsO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBOVU1fSE9MREVSUzsgaSsrKSB7XG4gICAgICAgICAgICBfc2V0VHJhbnNsYXRlWCggKGkrX2NvbnRhaW5lclNoaWZ0SW5kZXgpICogX3NsaWRlU2l6ZS54LCBfaXRlbUhvbGRlcnNbaV0uZWwuc3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIV9vbGRJRSkge1xuICAgICAgICAgICAgZnJhbWV3b3JrLmJpbmQoc2VsZi5zY3JvbGxXcmFwLCBfZG93bkV2ZW50cywgc2VsZik7IC8vIG5vIGRyYWdnaW5nIGZvciBvbGQgSUVcbiAgICAgICAgfSAgIFxuXG4gICAgICAgIF9saXN0ZW4oJ2luaXRpYWxab29tSW5FbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudChfaXRlbUhvbGRlcnNbMF0sIF9jdXJyZW50SXRlbUluZGV4LTEpO1xuICAgICAgICAgICAgc2VsZi5zZXRDb250ZW50KF9pdGVtSG9sZGVyc1syXSwgX2N1cnJlbnRJdGVtSW5kZXgrMSk7XG5cbiAgICAgICAgICAgIF9pdGVtSG9sZGVyc1swXS5lbC5zdHlsZS5kaXNwbGF5ID0gX2l0ZW1Ib2xkZXJzWzJdLmVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgICAgICBpZihfb3B0aW9ucy5mb2N1cykge1xuICAgICAgICAgICAgICAgIC8vIGZvY3VzIGNhdXNlcyBsYXlvdXQsIFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGNhdXNlcyBsYWcgZHVyaW5nIHRoZSBhbmltYXRpb24sIFxuICAgICAgICAgICAgICAgIC8vIHRoYXQncyB3aHkgd2UgZGVsYXkgaXQgdW50aWxsIHRoZSBpbml0aWFsIHpvb20gdHJhbnNpdGlvbiBlbmRzXG4gICAgICAgICAgICAgICAgdGVtcGxhdGUuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBcblxuICAgICAgICAgICAgX2JpbmRFdmVudHMoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2V0IGNvbnRlbnQgZm9yIGNlbnRlciBzbGlkZSAoZmlyc3QgdGltZSlcbiAgICAgICAgc2VsZi5zZXRDb250ZW50KF9pdGVtSG9sZGVyc1sxXSwgX2N1cnJlbnRJdGVtSW5kZXgpO1xuICAgICAgICBcbiAgICAgICAgc2VsZi51cGRhdGVDdXJySXRlbSgpO1xuXG4gICAgICAgIF9zaG91dCgnYWZ0ZXJJbml0Jyk7XG5cbiAgICAgICAgaWYoIV9pc0ZpeGVkUG9zaXRpb24pIHtcblxuICAgICAgICAgICAgLy8gT24gYWxsIHZlcnNpb25zIG9mIGlPUyBsb3dlciB0aGFuIDguMCwgd2UgY2hlY2sgc2l6ZSBvZiB2aWV3cG9ydCBldmVyeSBzZWNvbmQuXG4gICAgICAgICAgICAvLyBcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBkZXRlY3Qgd2hlbiBTYWZhcmkgdG9wICYgYm90dG9tIGJhcnMgYXBwZWFyLCBcbiAgICAgICAgICAgIC8vIGFzIHRoaXMgYWN0aW9uIGRvZXNuJ3QgdHJpZ2dlciBhbnkgZXZlbnRzIChsaWtlIHJlc2l6ZSkuIFxuICAgICAgICAgICAgLy8gXG4gICAgICAgICAgICAvLyBPbiBpT1M4IHRoZXkgZml4ZWQgdGhpcy5cbiAgICAgICAgICAgIC8vIFxuICAgICAgICAgICAgLy8gMTAgTm92IDIwMTQ6IGlPUyA3IHVzYWdlIH40MCUuIGlPUyA4IHVzYWdlIDU2JS5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgX3VwZGF0ZVNpemVJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmKCFfbnVtQW5pbWF0aW9ucyAmJiAhX2lzRHJhZ2dpbmcgJiYgIV9pc1pvb21pbmcgJiYgKF9jdXJyWm9vbUxldmVsID09PSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS12aXNpYmxlJyk7XG4gICAgfSxcblxuICAgIC8vIENsb3NlIHRoZSBnYWxsZXJ5LCB0aGVuIGRlc3Ryb3kgaXRcbiAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKCFfaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIF9pc0Rlc3Ryb3lpbmcgPSB0cnVlO1xuICAgICAgICBfc2hvdXQoJ2Nsb3NlJyk7XG4gICAgICAgIF91bmJpbmRFdmVudHMoKTtcblxuICAgICAgICBfc2hvd09ySGlkZShzZWxmLmN1cnJJdGVtLCBudWxsLCB0cnVlLCBzZWxmLmRlc3Ryb3kpO1xuICAgIH0sXG5cbiAgICAvLyBkZXN0cm95cyB0aGUgZ2FsbGVyeSAodW5iaW5kcyBldmVudHMsIGNsZWFucyB1cCBpbnRlcnZhbHMgYW5kIHRpbWVvdXRzIHRvIGF2b2lkIG1lbW9yeSBsZWFrcylcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3Nob3V0KCdkZXN0cm95Jyk7XG5cbiAgICAgICAgaWYoX3Nob3dPckhpZGVUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3Nob3dPckhpZGVUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGVtcGxhdGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIHRlbXBsYXRlLmNsYXNzTmFtZSA9IF9pbml0YWxDbGFzc05hbWU7XG5cbiAgICAgICAgaWYoX3VwZGF0ZVNpemVJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfdXBkYXRlU2l6ZUludGVydmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1ld29yay51bmJpbmQoc2VsZi5zY3JvbGxXcmFwLCBfZG93bkV2ZW50cywgc2VsZik7XG5cbiAgICAgICAgLy8gd2UgdW5iaW5kIHNjcm9sbCBldmVudCBhdCB0aGUgZW5kLCBhcyBjbG9zaW5nIGFuaW1hdGlvbiBtYXkgZGVwZW5kIG9uIGl0XG4gICAgICAgIGZyYW1ld29yay51bmJpbmQod2luZG93LCAnc2Nyb2xsJywgc2VsZik7XG5cbiAgICAgICAgX3N0b3BEcmFnVXBkYXRlTG9vcCgpO1xuXG4gICAgICAgIF9zdG9wQWxsQW5pbWF0aW9ucygpO1xuXG4gICAgICAgIF9saXN0ZW5lcnMgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gaW1hZ2UgdG8gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAgICAgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgIFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgV2lsbCBpZ25vcmUgYm91bmRzIGlmIHNldCB0byB0cnVlLlxuICAgICAqL1xuICAgIHBhblRvOiBmdW5jdGlvbih4LHksZm9yY2UpIHtcbiAgICAgICAgaWYoIWZvcmNlKSB7XG4gICAgICAgICAgICBpZih4ID4gX2N1cnJQYW5Cb3VuZHMubWluLngpIHtcbiAgICAgICAgICAgICAgICB4ID0gX2N1cnJQYW5Cb3VuZHMubWluLng7XG4gICAgICAgICAgICB9IGVsc2UgaWYoeCA8IF9jdXJyUGFuQm91bmRzLm1heC54KSB7XG4gICAgICAgICAgICAgICAgeCA9IF9jdXJyUGFuQm91bmRzLm1heC54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih5ID4gX2N1cnJQYW5Cb3VuZHMubWluLnkpIHtcbiAgICAgICAgICAgICAgICB5ID0gX2N1cnJQYW5Cb3VuZHMubWluLnk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoeSA8IF9jdXJyUGFuQm91bmRzLm1heC55KSB7XG4gICAgICAgICAgICAgICAgeSA9IF9jdXJyUGFuQm91bmRzLm1heC55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBfcGFuT2Zmc2V0LnggPSB4O1xuICAgICAgICBfcGFuT2Zmc2V0LnkgPSB5O1xuICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgIH0sXG4gICAgXG4gICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgaWYoX2dsb2JhbEV2ZW50SGFuZGxlcnNbZS50eXBlXSkge1xuICAgICAgICAgICAgX2dsb2JhbEV2ZW50SGFuZGxlcnNbZS50eXBlXShlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIGdvVG86IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgaW5kZXggPSBfZ2V0TG9vcGVkSWQoaW5kZXgpO1xuXG4gICAgICAgIHZhciBkaWZmID0gaW5kZXggLSBfY3VycmVudEl0ZW1JbmRleDtcbiAgICAgICAgX2luZGV4RGlmZiA9IGRpZmY7XG5cbiAgICAgICAgX2N1cnJlbnRJdGVtSW5kZXggPSBpbmRleDtcbiAgICAgICAgc2VsZi5jdXJySXRlbSA9IF9nZXRJdGVtQXQoIF9jdXJyZW50SXRlbUluZGV4ICk7XG4gICAgICAgIF9jdXJyUG9zaXRpb25JbmRleCAtPSBkaWZmO1xuICAgICAgICBcbiAgICAgICAgX21vdmVNYWluU2Nyb2xsKF9zbGlkZVNpemUueCAqIF9jdXJyUG9zaXRpb25JbmRleCk7XG4gICAgICAgIFxuXG4gICAgICAgIF9zdG9wQWxsQW5pbWF0aW9ucygpO1xuICAgICAgICBfbWFpblNjcm9sbEFuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIHNlbGYudXBkYXRlQ3Vyckl0ZW0oKTtcbiAgICB9LFxuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmdvVG8oIF9jdXJyZW50SXRlbUluZGV4ICsgMSk7XG4gICAgfSxcbiAgICBwcmV2OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5nb1RvKCBfY3VycmVudEl0ZW1JbmRleCAtIDEpO1xuICAgIH0sXG5cbiAgICAvLyB1cGRhdGUgY3VycmVudCB6b29tL3BhbiBvYmplY3RzXG4gICAgdXBkYXRlQ3Vyclpvb21JdGVtOiBmdW5jdGlvbihlbXVsYXRlU2V0Q29udGVudCkge1xuICAgICAgICBpZihlbXVsYXRlU2V0Q29udGVudCkge1xuICAgICAgICAgICAgX3Nob3V0KCdiZWZvcmVDaGFuZ2UnLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0ZW1Ib2xkZXJbMV0gaXMgbWlkZGxlIChjdXJyZW50KSBpdGVtXG4gICAgICAgIGlmKF9pdGVtSG9sZGVyc1sxXS5lbC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB6b29tRWxlbWVudCA9IF9pdGVtSG9sZGVyc1sxXS5lbC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIGlmKCBmcmFtZXdvcmsuaGFzQ2xhc3Moem9vbUVsZW1lbnQsICdwc3dwX196b29tLXdyYXAnKSApIHtcbiAgICAgICAgICAgICAgICBfY3Vyclpvb21FbGVtZW50U3R5bGUgPSB6b29tRWxlbWVudC5zdHlsZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2N1cnJab29tRWxlbWVudFN0eWxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9jdXJyWm9vbUVsZW1lbnRTdHlsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIF9jdXJyUGFuQm91bmRzID0gc2VsZi5jdXJySXRlbS5ib3VuZHM7ICBcbiAgICAgICAgX3N0YXJ0Wm9vbUxldmVsID0gX2N1cnJab29tTGV2ZWwgPSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWw7XG5cbiAgICAgICAgX3Bhbk9mZnNldC54ID0gX2N1cnJQYW5Cb3VuZHMuY2VudGVyLng7XG4gICAgICAgIF9wYW5PZmZzZXQueSA9IF9jdXJyUGFuQm91bmRzLmNlbnRlci55O1xuXG4gICAgICAgIGlmKGVtdWxhdGVTZXRDb250ZW50KSB7XG4gICAgICAgICAgICBfc2hvdXQoJ2FmdGVyQ2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICBpbnZhbGlkYXRlQ3Vyckl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgX2l0ZW1zTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBOVU1fSE9MREVSUzsgaSsrKSB7XG4gICAgICAgICAgICBpZiggX2l0ZW1Ib2xkZXJzW2ldLml0ZW0gKSB7XG4gICAgICAgICAgICAgICAgX2l0ZW1Ib2xkZXJzW2ldLml0ZW0ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZUN1cnJJdGVtOiBmdW5jdGlvbihiZWZvcmVBbmltYXRpb24pIHtcblxuICAgICAgICBpZihfaW5kZXhEaWZmID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZkFicyA9IE1hdGguYWJzKF9pbmRleERpZmYpLFxuICAgICAgICAgICAgdGVtcEhvbGRlcjtcblxuICAgICAgICBpZihiZWZvcmVBbmltYXRpb24gJiYgZGlmZkFicyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc2VsZi5jdXJySXRlbSA9IF9nZXRJdGVtQXQoIF9jdXJyZW50SXRlbUluZGV4ICk7XG4gICAgICAgIF9yZW5kZXJNYXhSZXNvbHV0aW9uID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBfc2hvdXQoJ2JlZm9yZUNoYW5nZScsIF9pbmRleERpZmYpO1xuXG4gICAgICAgIGlmKGRpZmZBYnMgPj0gTlVNX0hPTERFUlMpIHtcbiAgICAgICAgICAgIF9jb250YWluZXJTaGlmdEluZGV4ICs9IF9pbmRleERpZmYgKyAoX2luZGV4RGlmZiA+IDAgPyAtTlVNX0hPTERFUlMgOiBOVU1fSE9MREVSUyk7XG4gICAgICAgICAgICBkaWZmQWJzID0gTlVNX0hPTERFUlM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRpZmZBYnM7IGkrKykge1xuICAgICAgICAgICAgaWYoX2luZGV4RGlmZiA+IDApIHtcbiAgICAgICAgICAgICAgICB0ZW1wSG9sZGVyID0gX2l0ZW1Ib2xkZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgX2l0ZW1Ib2xkZXJzW05VTV9IT0xERVJTLTFdID0gdGVtcEhvbGRlcjsgLy8gbW92ZSBmaXJzdCB0byBsYXN0XG5cbiAgICAgICAgICAgICAgICBfY29udGFpbmVyU2hpZnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIF9zZXRUcmFuc2xhdGVYKCAoX2NvbnRhaW5lclNoaWZ0SW5kZXgrMikgKiBfc2xpZGVTaXplLngsIHRlbXBIb2xkZXIuZWwuc3R5bGUpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudCh0ZW1wSG9sZGVyLCBfY3VycmVudEl0ZW1JbmRleCAtIGRpZmZBYnMgKyBpICsgMSArIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wSG9sZGVyID0gX2l0ZW1Ib2xkZXJzLnBvcCgpO1xuICAgICAgICAgICAgICAgIF9pdGVtSG9sZGVycy51bnNoaWZ0KCB0ZW1wSG9sZGVyICk7IC8vIG1vdmUgbGFzdCB0byBmaXJzdFxuXG4gICAgICAgICAgICAgICAgX2NvbnRhaW5lclNoaWZ0SW5kZXgtLTtcbiAgICAgICAgICAgICAgICBfc2V0VHJhbnNsYXRlWCggX2NvbnRhaW5lclNoaWZ0SW5kZXggKiBfc2xpZGVTaXplLngsIHRlbXBIb2xkZXIuZWwuc3R5bGUpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudCh0ZW1wSG9sZGVyLCBfY3VycmVudEl0ZW1JbmRleCArIGRpZmZBYnMgLSBpIC0gMSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB6b29tL3BhbiBvbiBwcmV2aW91cyBpdGVtXG4gICAgICAgIGlmKF9jdXJyWm9vbUVsZW1lbnRTdHlsZSAmJiBNYXRoLmFicyhfaW5kZXhEaWZmKSA9PT0gMSkge1xuXG4gICAgICAgICAgICB2YXIgcHJldkl0ZW0gPSBfZ2V0SXRlbUF0KF9wcmV2SXRlbUluZGV4KTtcbiAgICAgICAgICAgIGlmKHByZXZJdGVtLmluaXRpYWxab29tTGV2ZWwgIT09IF9jdXJyWm9vbUxldmVsKSB7XG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZUl0ZW1TaXplKHByZXZJdGVtICwgX3ZpZXdwb3J0U2l6ZSApO1xuICAgICAgICAgICAgICAgIF9zZXRJbWFnZVNpemUocHJldkl0ZW0pO1xuICAgICAgICAgICAgICAgIF9hcHBseVpvb21QYW5Ub0l0ZW0oIHByZXZJdGVtICk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCBkaWZmIGFmdGVyIHVwZGF0ZVxuICAgICAgICBfaW5kZXhEaWZmID0gMDtcblxuICAgICAgICBzZWxmLnVwZGF0ZUN1cnJab29tSXRlbSgpO1xuXG4gICAgICAgIF9wcmV2SXRlbUluZGV4ID0gX2N1cnJlbnRJdGVtSW5kZXg7XG5cbiAgICAgICAgX3Nob3V0KCdhZnRlckNoYW5nZScpO1xuICAgICAgICBcbiAgICB9LFxuXG5cblxuICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIFxuICAgICAgICBpZighX2lzRml4ZWRQb3NpdGlvbiAmJiBfb3B0aW9ucy5tb2RhbCkge1xuICAgICAgICAgICAgdmFyIHdpbmRvd1Njcm9sbFkgPSBmcmFtZXdvcmsuZ2V0U2Nyb2xsWSgpO1xuICAgICAgICAgICAgaWYoX2N1cnJlbnRXaW5kb3dTY3JvbGxZICE9PSB3aW5kb3dTY3JvbGxZKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUuc3R5bGUudG9wID0gd2luZG93U2Nyb2xsWSArICdweCc7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRXaW5kb3dTY3JvbGxZID0gd2luZG93U2Nyb2xsWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFmb3JjZSAmJiBfd2luZG93VmlzaWJsZVNpemUueCA9PT0gd2luZG93LmlubmVyV2lkdGggJiYgX3dpbmRvd1Zpc2libGVTaXplLnkgPT09IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF93aW5kb3dWaXNpYmxlU2l6ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICBfd2luZG93VmlzaWJsZVNpemUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgICAgICAgLy90ZW1wbGF0ZS5zdHlsZS53aWR0aCA9IF93aW5kb3dWaXNpYmxlU2l6ZS54ICsgJ3B4JztcbiAgICAgICAgICAgIHRlbXBsYXRlLnN0eWxlLmhlaWdodCA9IF93aW5kb3dWaXNpYmxlU2l6ZS55ICsgJ3B4JztcbiAgICAgICAgfVxuXG5cblxuICAgICAgICBfdmlld3BvcnRTaXplLnggPSBzZWxmLnNjcm9sbFdyYXAuY2xpZW50V2lkdGg7XG4gICAgICAgIF92aWV3cG9ydFNpemUueSA9IHNlbGYuc2Nyb2xsV3JhcC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgX3VwZGF0ZVBhZ2VTY3JvbGxPZmZzZXQoKTtcblxuICAgICAgICBfc2xpZGVTaXplLnggPSBfdmlld3BvcnRTaXplLnggKyBNYXRoLnJvdW5kKF92aWV3cG9ydFNpemUueCAqIF9vcHRpb25zLnNwYWNpbmcpO1xuICAgICAgICBfc2xpZGVTaXplLnkgPSBfdmlld3BvcnRTaXplLnk7XG5cbiAgICAgICAgX21vdmVNYWluU2Nyb2xsKF9zbGlkZVNpemUueCAqIF9jdXJyUG9zaXRpb25JbmRleCk7XG5cbiAgICAgICAgX3Nob3V0KCdiZWZvcmVSZXNpemUnKTsgLy8gZXZlbiBtYXkgYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBzd2l0Y2ggaW1hZ2Ugc291cmNlc1xuXG5cbiAgICAgICAgLy8gZG9uJ3QgcmUtY2FsY3VsYXRlIHNpemUgb24gaW5pdGFsIHNpemUgdXBkYXRlXG4gICAgICAgIGlmKF9jb250YWluZXJTaGlmdEluZGV4ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgdmFyIGhvbGRlcixcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIGhJbmRleDtcblxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IE5VTV9IT0xERVJTOyBpKyspIHtcbiAgICAgICAgICAgICAgICBob2xkZXIgPSBfaXRlbUhvbGRlcnNbaV07XG4gICAgICAgICAgICAgICAgX3NldFRyYW5zbGF0ZVgoIChpK19jb250YWluZXJTaGlmdEluZGV4KSAqIF9zbGlkZVNpemUueCwgaG9sZGVyLmVsLnN0eWxlKTtcblxuICAgICAgICAgICAgICAgIGhJbmRleCA9IF9jdXJyZW50SXRlbUluZGV4K2ktMTtcblxuICAgICAgICAgICAgICAgIGlmKF9vcHRpb25zLmxvb3AgJiYgX2dldE51bUl0ZW1zKCkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhJbmRleCA9IF9nZXRMb29wZWRJZChoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB6b29tIGxldmVsIG9uIGl0ZW1zIGFuZCByZWZyZXNoIHNvdXJjZSAoaWYgbmVlZHNVcGRhdGUpXG4gICAgICAgICAgICAgICAgaXRlbSA9IF9nZXRJdGVtQXQoIGhJbmRleCApO1xuXG4gICAgICAgICAgICAgICAgLy8gcmUtcmVuZGVyIGdhbGxlcnkgaXRlbSBpZiBgbmVlZHNVcGRhdGVgLFxuICAgICAgICAgICAgICAgIC8vIG9yIGRvZXNuJ3QgaGF2ZSBgYm91bmRzYCAoZW50aXJlbHkgbmV3IHNsaWRlIG9iamVjdClcbiAgICAgICAgICAgICAgICBpZiggaXRlbSAmJiAoX2l0ZW1zTmVlZFVwZGF0ZSB8fCBpdGVtLm5lZWRzVXBkYXRlIHx8ICFpdGVtLmJvdW5kcykgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhblNsaWRlKCBpdGVtICk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldENvbnRlbnQoIGhvbGRlciwgaEluZGV4ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgXCJjZW50ZXJcIiBzbGlkZVxuICAgICAgICAgICAgICAgICAgICBpZihpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQ3Vyclpvb21JdGVtKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGhvbGRlci5pbmRleCA9PT0gLTEgJiYgaEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGNvbnRlbnQgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldENvbnRlbnQoIGhvbGRlciwgaEluZGV4ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGl0ZW0gJiYgaXRlbS5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbGN1bGF0ZUl0ZW1TaXplKGl0ZW0sIF92aWV3cG9ydFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBfc2V0SW1hZ2VTaXplKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBfYXBwbHlab29tUGFuVG9JdGVtKCBpdGVtICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2l0ZW1zTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB9ICAgXG5cbiAgICAgICAgX3N0YXJ0Wm9vbUxldmVsID0gX2N1cnJab29tTGV2ZWwgPSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWw7XG4gICAgICAgIF9jdXJyUGFuQm91bmRzID0gc2VsZi5jdXJySXRlbS5ib3VuZHM7XG5cbiAgICAgICAgaWYoX2N1cnJQYW5Cb3VuZHMpIHtcbiAgICAgICAgICAgIF9wYW5PZmZzZXQueCA9IF9jdXJyUGFuQm91bmRzLmNlbnRlci54O1xuICAgICAgICAgICAgX3Bhbk9mZnNldC55ID0gX2N1cnJQYW5Cb3VuZHMuY2VudGVyLnk7XG4gICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbiggdHJ1ZSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBfc2hvdXQoJ3Jlc2l6ZScpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gWm9vbSBjdXJyZW50IGl0ZW0gdG9cbiAgICB6b29tVG86IGZ1bmN0aW9uKGRlc3Rab29tTGV2ZWwsIGNlbnRlclBvaW50LCBzcGVlZCwgZWFzaW5nRm4sIHVwZGF0ZUZuKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICBpZihkZXN0Wm9vbUxldmVsID09PSAnZml0Jykge1xuICAgICAgICAgICAgICAgIGRlc3Rab29tTGV2ZWwgPSBzZWxmLmN1cnJJdGVtLmZpdFJhdGlvO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGRlc3Rab29tTGV2ZWwgPT09ICdmaWxsJykge1xuICAgICAgICAgICAgICAgIGRlc3Rab29tTGV2ZWwgPSBzZWxmLmN1cnJJdGVtLmZpbGxSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICBpZihjZW50ZXJQb2ludCkge1xuICAgICAgICAgICAgX3N0YXJ0Wm9vbUxldmVsID0gX2N1cnJab29tTGV2ZWw7XG4gICAgICAgICAgICBfbWlkWm9vbVBvaW50LnggPSBNYXRoLmFicyhjZW50ZXJQb2ludC54KSAtIF9wYW5PZmZzZXQueCA7XG4gICAgICAgICAgICBfbWlkWm9vbVBvaW50LnkgPSBNYXRoLmFicyhjZW50ZXJQb2ludC55KSAtIF9wYW5PZmZzZXQueSA7XG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMoX3N0YXJ0UGFuT2Zmc2V0LCBfcGFuT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXN0UGFuQm91bmRzID0gX2NhbGN1bGF0ZVBhbkJvdW5kcyhkZXN0Wm9vbUxldmVsLCBmYWxzZSksXG4gICAgICAgICAgICBkZXN0UGFuT2Zmc2V0ID0ge307XG5cbiAgICAgICAgX21vZGlmeURlc3RQYW5PZmZzZXQoJ3gnLCBkZXN0UGFuQm91bmRzLCBkZXN0UGFuT2Zmc2V0LCBkZXN0Wm9vbUxldmVsKTtcbiAgICAgICAgX21vZGlmeURlc3RQYW5PZmZzZXQoJ3knLCBkZXN0UGFuQm91bmRzLCBkZXN0UGFuT2Zmc2V0LCBkZXN0Wm9vbUxldmVsKTtcblxuICAgICAgICB2YXIgaW5pdGlhbFpvb21MZXZlbCA9IF9jdXJyWm9vbUxldmVsO1xuICAgICAgICB2YXIgaW5pdGlhbFBhbk9mZnNldCA9IHtcbiAgICAgICAgICAgIHg6IF9wYW5PZmZzZXQueCxcbiAgICAgICAgICAgIHk6IF9wYW5PZmZzZXQueVxuICAgICAgICB9O1xuXG4gICAgICAgIF9yb3VuZFBvaW50KGRlc3RQYW5PZmZzZXQpO1xuXG4gICAgICAgIHZhciBvblVwZGF0ZSA9IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICAgICAgaWYobm93ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJab29tTGV2ZWwgPSBkZXN0Wm9vbUxldmVsO1xuICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueCA9IGRlc3RQYW5PZmZzZXQueDtcbiAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnkgPSBkZXN0UGFuT2Zmc2V0Lnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9jdXJyWm9vbUxldmVsID0gKGRlc3Rab29tTGV2ZWwgLSBpbml0aWFsWm9vbUxldmVsKSAqIG5vdyArIGluaXRpYWxab29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgX3Bhbk9mZnNldC54ID0gKGRlc3RQYW5PZmZzZXQueCAtIGluaXRpYWxQYW5PZmZzZXQueCkgKiBub3cgKyBpbml0aWFsUGFuT2Zmc2V0Lng7XG4gICAgICAgICAgICAgICAgX3Bhbk9mZnNldC55ID0gKGRlc3RQYW5PZmZzZXQueSAtIGluaXRpYWxQYW5PZmZzZXQueSkgKiBub3cgKyBpbml0aWFsUGFuT2Zmc2V0Lnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHVwZGF0ZUZuKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRm4obm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4oIG5vdyA9PT0gMSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKHNwZWVkKSB7XG4gICAgICAgICAgICBfYW5pbWF0ZVByb3AoJ2N1c3RvbVpvb21UbycsIDAsIDEsIHNwZWVkLCBlYXNpbmdGbiB8fCBmcmFtZXdvcmsuZWFzaW5nLnNpbmUuaW5PdXQsIG9uVXBkYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uVXBkYXRlKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn07XG5cblxuLyo+PmNvcmUqL1xuXG4vKj4+Z2VzdHVyZXMqL1xuLyoqXG4gKiBNb3VzZS90b3VjaC9wb2ludGVyIGV2ZW50IGhhbmRsZXJzLlxuICogXG4gKiBzZXBhcmF0ZWQgZnJvbSBAY29yZS5qcyBmb3IgcmVhZGFiaWxpdHlcbiAqL1xuXG52YXIgTUlOX1NXSVBFX0RJU1RBTkNFID0gMzAsXG4gICAgRElSRUNUSU9OX0NIRUNLX09GRlNFVCA9IDEwOyAvLyBhbW91bnQgb2YgcGl4ZWxzIHRvIGRyYWcgdG8gZGV0ZXJtaW5lIGRpcmVjdGlvbiBvZiBzd2lwZVxuXG52YXIgX2dlc3R1cmVTdGFydFRpbWUsXG4gICAgX2dlc3R1cmVDaGVja1NwZWVkVGltZSxcblxuICAgIC8vIHBvb2wgb2Ygb2JqZWN0cyB0aGF0IGFyZSB1c2VkIGR1cmluZyBkcmFnZ2luZyBvZiB6b29taW5nXG4gICAgcCA9IHt9LCAvLyBmaXJzdCBwb2ludFxuICAgIHAyID0ge30sIC8vIHNlY29uZCBwb2ludCAoZm9yIHpvb20gZ2VzdHVyZSlcbiAgICBkZWx0YSA9IHt9LFxuICAgIF9jdXJyUG9pbnQgPSB7fSxcbiAgICBfc3RhcnRQb2ludCA9IHt9LFxuICAgIF9jdXJyUG9pbnRlcnMgPSBbXSxcbiAgICBfc3RhcnRNYWluU2Nyb2xsUG9zID0ge30sXG4gICAgX3JlbGVhc2VBbmltRGF0YSxcbiAgICBfcG9zUG9pbnRzID0gW10sIC8vIGFycmF5IG9mIHBvaW50cyBkdXJpbmcgZHJhZ2dpbmcsIHVzZWQgdG8gZGV0ZXJtaW5lIHR5cGUgb2YgZ2VzdHVyZVxuICAgIF90ZW1wUG9pbnQgPSB7fSxcblxuICAgIF9pc1pvb21pbmdJbixcbiAgICBfdmVydGljYWxEcmFnSW5pdGlhdGVkLFxuICAgIF9vbGRBbmRyb2lkVG91Y2hFbmRUaW1lb3V0LFxuICAgIF9jdXJyWm9vbWVkSXRlbUluZGV4ID0gMCxcbiAgICBfY2VudGVyUG9pbnQgPSBfZ2V0RW1wdHlQb2ludCgpLFxuICAgIF9sYXN0UmVsZWFzZVRpbWUgPSAwLFxuICAgIF9pc0RyYWdnaW5nLCAvLyBhdCBsZWFzdCBvbmUgcG9pbnRlciBpcyBkb3duXG4gICAgX2lzTXVsdGl0b3VjaCwgLy8gYXQgbGVhc3QgdHdvIF9wb2ludGVycyBhcmUgZG93blxuICAgIF96b29tU3RhcnRlZCwgLy8gem9vbSBsZXZlbCBjaGFuZ2VkIGR1cmluZyB6b29tIGdlc3R1cmVcbiAgICBfbW92ZWQsXG4gICAgX2RyYWdBbmltRnJhbWUsXG4gICAgX21haW5TY3JvbGxTaGlmdGVkLFxuICAgIF9jdXJyZW50UG9pbnRzLCAvLyBhcnJheSBvZiBjdXJyZW50IHRvdWNoIHBvaW50c1xuICAgIF9pc1pvb21pbmcsXG4gICAgX2N1cnJQb2ludHNEaXN0YW5jZSxcbiAgICBfc3RhcnRQb2ludHNEaXN0YW5jZSxcbiAgICBfY3VyclBhbkJvdW5kcyxcbiAgICBfbWFpblNjcm9sbFBvcyA9IF9nZXRFbXB0eVBvaW50KCksXG4gICAgX2N1cnJab29tRWxlbWVudFN0eWxlLFxuICAgIF9tYWluU2Nyb2xsQW5pbWF0aW5nLCAvLyB0cnVlLCBpZiBhbmltYXRpb24gYWZ0ZXIgc3dpcGUgZ2VzdHVyZSBpcyBydW5uaW5nXG4gICAgX21pZFpvb21Qb2ludCA9IF9nZXRFbXB0eVBvaW50KCksXG4gICAgX2N1cnJDZW50ZXJQb2ludCA9IF9nZXRFbXB0eVBvaW50KCksXG4gICAgX2RpcmVjdGlvbixcbiAgICBfaXNGaXJzdE1vdmUsXG4gICAgX29wYWNpdHlDaGFuZ2VkLFxuICAgIF9iZ09wYWNpdHksXG4gICAgX3dhc092ZXJJbml0aWFsWm9vbSxcblxuICAgIF9pc0VxdWFsUG9pbnRzID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG4gICAgfSxcbiAgICBfaXNOZWFyYnlQb2ludHMgPSBmdW5jdGlvbih0b3VjaDAsIHRvdWNoMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModG91Y2gwLnggLSB0b3VjaDEueCkgPCBET1VCTEVfVEFQX1JBRElVUyAmJiBNYXRoLmFicyh0b3VjaDAueSAtIHRvdWNoMS55KSA8IERPVUJMRV9UQVBfUkFESVVTO1xuICAgIH0sXG4gICAgX2NhbGN1bGF0ZVBvaW50c0Rpc3RhbmNlID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgICAgIF90ZW1wUG9pbnQueCA9IE1hdGguYWJzKCBwMS54IC0gcDIueCApO1xuICAgICAgICBfdGVtcFBvaW50LnkgPSBNYXRoLmFicyggcDEueSAtIHAyLnkgKTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChfdGVtcFBvaW50LnggKiBfdGVtcFBvaW50LnggKyBfdGVtcFBvaW50LnkgKiBfdGVtcFBvaW50LnkpO1xuICAgIH0sXG4gICAgX3N0b3BEcmFnVXBkYXRlTG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihfZHJhZ0FuaW1GcmFtZSkge1xuICAgICAgICAgICAgX2NhbmNlbEFGKF9kcmFnQW5pbUZyYW1lKTtcbiAgICAgICAgICAgIF9kcmFnQW5pbUZyYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2RyYWdVcGRhdGVMb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKF9pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBfZHJhZ0FuaW1GcmFtZSA9IF9yZXF1ZXN0QUYoX2RyYWdVcGRhdGVMb29wKTtcbiAgICAgICAgICAgIF9yZW5kZXJNb3ZlbWVudCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfY2FuUGFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhKF9vcHRpb25zLnNjYWxlTW9kZSA9PT0gJ2ZpdCcgJiYgX2N1cnJab29tTGV2ZWwgPT09ICBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gZmluZCB0aGUgY2xvc2VzdCBwYXJlbnQgRE9NIGVsZW1lbnRcbiAgICBfY2xvc2VzdEVsZW1lbnQgPSBmdW5jdGlvbihlbCwgZm4pIHtcbiAgICAgICAgaWYoIWVsIHx8IGVsID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3Qgc2VhcmNoIGVsZW1lbnRzIGFib3ZlIHBzd3BfX3Njcm9sbC13cmFwXG4gICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykuaW5kZXhPZigncHN3cF9fc2Nyb2xsLXdyYXAnKSA+IC0xICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGZuKGVsKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfY2xvc2VzdEVsZW1lbnQoZWwucGFyZW50Tm9kZSwgZm4pO1xuICAgIH0sXG5cbiAgICBfcHJldmVudE9iaiA9IHt9LFxuICAgIF9wcmV2ZW50RGVmYXVsdEV2ZW50QmVoYXZpb3VyID0gZnVuY3Rpb24oZSwgaXNEb3duKSB7XG4gICAgICAgIF9wcmV2ZW50T2JqLnByZXZlbnQgPSAhX2Nsb3Nlc3RFbGVtZW50KGUudGFyZ2V0LCBfb3B0aW9ucy5pc0NsaWNrYWJsZUVsZW1lbnQpO1xuXG4gICAgICAgIF9zaG91dCgncHJldmVudERyYWdFdmVudCcsIGUsIGlzRG93biwgX3ByZXZlbnRPYmopO1xuICAgICAgICByZXR1cm4gX3ByZXZlbnRPYmoucHJldmVudDtcblxuICAgIH0sXG4gICAgX2NvbnZlcnRUb3VjaFRvUG9pbnQgPSBmdW5jdGlvbih0b3VjaCwgcCkge1xuICAgICAgICBwLnggPSB0b3VjaC5wYWdlWDtcbiAgICAgICAgcC55ID0gdG91Y2gucGFnZVk7XG4gICAgICAgIHAuaWQgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIF9maW5kQ2VudGVyT2ZQb2ludHMgPSBmdW5jdGlvbihwMSwgcDIsIHBDZW50ZXIpIHtcbiAgICAgICAgcENlbnRlci54ID0gKHAxLnggKyBwMi54KSAqIDAuNTtcbiAgICAgICAgcENlbnRlci55ID0gKHAxLnkgKyBwMi55KSAqIDAuNTtcbiAgICB9LFxuICAgIF9wdXNoUG9zUG9pbnQgPSBmdW5jdGlvbih0aW1lLCB4LCB5KSB7XG4gICAgICAgIGlmKHRpbWUgLSBfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lID4gNTApIHtcbiAgICAgICAgICAgIHZhciBvID0gX3Bvc1BvaW50cy5sZW5ndGggPiAyID8gX3Bvc1BvaW50cy5zaGlmdCgpIDoge307XG4gICAgICAgICAgICBvLnggPSB4O1xuICAgICAgICAgICAgby55ID0geTsgXG4gICAgICAgICAgICBfcG9zUG9pbnRzLnB1c2gobyk7XG4gICAgICAgICAgICBfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lID0gdGltZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2FsY3VsYXRlVmVydGljYWxEcmFnT3BhY2l0eVJhdGlvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gX3Bhbk9mZnNldC55IC0gc2VsZi5jdXJySXRlbS5pbml0aWFsUG9zaXRpb24ueTsgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIGluaXRpYWwgYW5kIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgcmV0dXJuIDEgLSAgTWF0aC5hYnMoIHlPZmZzZXQgLyAoX3ZpZXdwb3J0U2l6ZS55IC8gMikgICk7XG4gICAgfSxcblxuICAgIFxuICAgIC8vIHBvaW50cyBwb29sLCByZXVzZWQgZHVyaW5nIHRvdWNoIGV2ZW50c1xuICAgIF9lUG9pbnQxID0ge30sXG4gICAgX2VQb2ludDIgPSB7fSxcbiAgICBfdGVtcFBvaW50c0FyciA9IFtdLFxuICAgIF90ZW1wQ291bnRlcixcbiAgICBfZ2V0VG91Y2hQb2ludHMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIGNsZWFuIHVwIHByZXZpb3VzIHBvaW50cywgd2l0aG91dCByZWNyZWF0aW5nIGFycmF5XG4gICAgICAgIHdoaWxlKF90ZW1wUG9pbnRzQXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIF90ZW1wUG9pbnRzQXJyLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIV9wb2ludGVyRXZlbnRFbmFibGVkKSB7XG4gICAgICAgICAgICBpZihlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA+IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBpZihlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RlbXBQb2ludHNBcnJbMF0gPSBfY29udmVydFRvdWNoVG9Qb2ludChlLnRvdWNoZXNbMF0sIF9lUG9pbnQxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90ZW1wUG9pbnRzQXJyWzFdID0gX2NvbnZlcnRUb3VjaFRvUG9pbnQoZS50b3VjaGVzWzFdLCBfZVBvaW50Mik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9lUG9pbnQxLnggPSBlLnBhZ2VYO1xuICAgICAgICAgICAgICAgIF9lUG9pbnQxLnkgPSBlLnBhZ2VZO1xuICAgICAgICAgICAgICAgIF9lUG9pbnQxLmlkID0gJyc7XG4gICAgICAgICAgICAgICAgX3RlbXBQb2ludHNBcnJbMF0gPSBfZVBvaW50MTsvL19lUG9pbnQxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RlbXBDb3VudGVyID0gMDtcbiAgICAgICAgICAgIC8vIHdlIGNhbiB1c2UgZm9yRWFjaCwgYXMgcG9pbnRlciBldmVudHMgYXJlIHN1cHBvcnRlZCBvbmx5IGluIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAgICAgX2N1cnJQb2ludGVycy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICBpZihfdGVtcENvdW50ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RlbXBQb2ludHNBcnJbMF0gPSBwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihfdGVtcENvdW50ZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RlbXBQb2ludHNBcnJbMV0gPSBwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGVtcENvdW50ZXIrKztcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90ZW1wUG9pbnRzQXJyO1xuICAgIH0sXG5cbiAgICBfcGFuT3JNb3ZlTWFpblNjcm9sbCA9IGZ1bmN0aW9uKGF4aXMsIGRlbHRhKSB7XG5cbiAgICAgICAgdmFyIHBhbkZyaWN0aW9uLFxuICAgICAgICAgICAgb3ZlckRpZmYgPSAwLFxuICAgICAgICAgICAgbmV3T2Zmc2V0ID0gX3Bhbk9mZnNldFtheGlzXSArIGRlbHRhW2F4aXNdLFxuICAgICAgICAgICAgc3RhcnRPdmVyRGlmZixcbiAgICAgICAgICAgIGRpciA9IGRlbHRhW2F4aXNdID4gMCxcbiAgICAgICAgICAgIG5ld01haW5TY3JvbGxQb3NpdGlvbiA9IF9tYWluU2Nyb2xsUG9zLnggKyBkZWx0YS54LFxuICAgICAgICAgICAgbWFpblNjcm9sbERpZmYgPSBfbWFpblNjcm9sbFBvcy54IC0gX3N0YXJ0TWFpblNjcm9sbFBvcy54LFxuICAgICAgICAgICAgbmV3UGFuUG9zLFxuICAgICAgICAgICAgbmV3TWFpblNjcm9sbFBvcztcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmRpc3RhbmNlIG92ZXIgdGhlIGJvdW5kcyBhbmQgZnJpY3Rpb25cbiAgICAgICAgaWYobmV3T2Zmc2V0ID4gX2N1cnJQYW5Cb3VuZHMubWluW2F4aXNdIHx8IG5ld09mZnNldCA8IF9jdXJyUGFuQm91bmRzLm1heFtheGlzXSkge1xuICAgICAgICAgICAgcGFuRnJpY3Rpb24gPSBfb3B0aW9ucy5wYW5FbmRGcmljdGlvbjtcbiAgICAgICAgICAgIC8vIExpbmVhciBpbmNyZWFzaW5nIG9mIGZyaWN0aW9uLCBzbyBhdCAxLzQgb2Ygdmlld3BvcnQgaXQncyBhdCBtYXggdmFsdWUuIFxuICAgICAgICAgICAgLy8gTG9va3Mgbm90IGFzIG5pY2UgYXMgd2FzIGV4cGVjdGVkLiBMZWZ0IGZvciBoaXN0b3J5LlxuICAgICAgICAgICAgLy8gcGFuRnJpY3Rpb24gPSAoMSAtIChfcGFuT2Zmc2V0W2F4aXNdICsgZGVsdGFbYXhpc10gKyBwYW5Cb3VuZHMubWluW2F4aXNdKSAvIChfdmlld3BvcnRTaXplW2F4aXNdIC8gNCkgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhbkZyaWN0aW9uID0gMTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbmV3T2Zmc2V0ID0gX3Bhbk9mZnNldFtheGlzXSArIGRlbHRhW2F4aXNdICogcGFuRnJpY3Rpb247XG5cbiAgICAgICAgLy8gbW92ZSBtYWluIHNjcm9sbCBvciBzdGFydCBwYW5uaW5nXG4gICAgICAgIGlmKF9vcHRpb25zLmFsbG93UGFuVG9OZXh0IHx8IF9jdXJyWm9vbUxldmVsID09PSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpIHtcblxuXG4gICAgICAgICAgICBpZighX2N1cnJab29tRWxlbWVudFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV3TWFpblNjcm9sbFBvcyA9IG5ld01haW5TY3JvbGxQb3NpdGlvbjtcblxuICAgICAgICAgICAgfSBlbHNlIGlmKF9kaXJlY3Rpb24gPT09ICdoJyAmJiBheGlzID09PSAneCcgJiYgIV96b29tU3RhcnRlZCApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYobmV3T2Zmc2V0ID4gX2N1cnJQYW5Cb3VuZHMubWluW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5GcmljdGlvbiA9IF9vcHRpb25zLnBhbkVuZEZyaWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlckRpZmYgPSBfY3VyclBhbkJvdW5kcy5taW5bYXhpc10gLSBuZXdPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE92ZXJEaWZmID0gX2N1cnJQYW5Cb3VuZHMubWluW2F4aXNdIC0gX3N0YXJ0UGFuT2Zmc2V0W2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBkcmFnIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGlmKCAoc3RhcnRPdmVyRGlmZiA8PSAwIHx8IG1haW5TY3JvbGxEaWZmIDwgMCkgJiYgX2dldE51bUl0ZW1zKCkgPiAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWFpblNjcm9sbFBvcyA9IG5ld01haW5TY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1haW5TY3JvbGxEaWZmIDwgMCAmJiBuZXdNYWluU2Nyb2xsUG9zaXRpb24gPiBfc3RhcnRNYWluU2Nyb2xsUG9zLngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdNYWluU2Nyb2xsUG9zID0gX3N0YXJ0TWFpblNjcm9sbFBvcy54O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoX2N1cnJQYW5Cb3VuZHMubWluLnggIT09IF9jdXJyUGFuQm91bmRzLm1heC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFuUG9zID0gbmV3T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYobmV3T2Zmc2V0IDwgX2N1cnJQYW5Cb3VuZHMubWF4W2F4aXNdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuRnJpY3Rpb24gPV9vcHRpb25zLnBhbkVuZEZyaWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlckRpZmYgPSBuZXdPZmZzZXQgLSBfY3VyclBhbkJvdW5kcy5tYXhbYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE92ZXJEaWZmID0gX3N0YXJ0UGFuT2Zmc2V0W2F4aXNdIC0gX2N1cnJQYW5Cb3VuZHMubWF4W2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIChzdGFydE92ZXJEaWZmIDw9IDAgfHwgbWFpblNjcm9sbERpZmYgPiAwKSAmJiBfZ2V0TnVtSXRlbXMoKSA+IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdNYWluU2Nyb2xsUG9zID0gbmV3TWFpblNjcm9sbFBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtYWluU2Nyb2xsRGlmZiA+IDAgJiYgbmV3TWFpblNjcm9sbFBvc2l0aW9uIDwgX3N0YXJ0TWFpblNjcm9sbFBvcy54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWFpblNjcm9sbFBvcyA9IF9zdGFydE1haW5TY3JvbGxQb3MueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoX2N1cnJQYW5Cb3VuZHMubWluLnggIT09IF9jdXJyUGFuQm91bmRzLm1heC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFuUG9zID0gbmV3T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGF4aXMgPT09ICd4Jykge1xuXG4gICAgICAgICAgICAgICAgaWYobmV3TWFpblNjcm9sbFBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9tb3ZlTWFpblNjcm9sbChuZXdNYWluU2Nyb2xsUG9zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYobmV3TWFpblNjcm9sbFBvcyA9PT0gX3N0YXJ0TWFpblNjcm9sbFBvcy54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWFpblNjcm9sbFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tYWluU2Nyb2xsU2hpZnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihfY3VyclBhbkJvdW5kcy5taW4ueCAhPT0gX2N1cnJQYW5Cb3VuZHMubWF4LngpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYobmV3UGFuUG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueCA9IG5ld1BhblBvcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKCFfbWFpblNjcm9sbFNoaWZ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueCArPSBkZWx0YS54ICogcGFuRnJpY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3TWFpblNjcm9sbFBvcyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZighX21haW5TY3JvbGxBbmltYXRpbmcpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIV9tYWluU2Nyb2xsU2hpZnRlZCkge1xuICAgICAgICAgICAgICAgIGlmKF9jdXJyWm9vbUxldmVsID4gc2VsZi5jdXJySXRlbS5maXRSYXRpbykge1xuICAgICAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0W2F4aXNdICs9IGRlbHRhW2F4aXNdICogcGFuRnJpY3Rpb247XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9LFxuXG4gICAgLy8gUG9pbnRlcmRvd24vdG91Y2hzdGFydC9tb3VzZWRvd24gaGFuZGxlclxuICAgIF9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAvLyBBbGxvdyBkcmFnZ2luZyBvbmx5IHZpYSBsZWZ0IG1vdXNlIGJ1dHRvbi5cbiAgICAgICAgLy8gQXMgdGhpcyBoYW5kbGVyIGlzIG5vdCBhZGRlZCBpbiBJRTggLSB3ZSBpZ25vcmUgZS53aGljaFxuICAgICAgICAvLyBcbiAgICAgICAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ldmVudC5idXR0b25cbiAgICAgICAgaWYoZS50eXBlID09PSAnbW91c2Vkb3duJyAmJiBlLmJ1dHRvbiA+IDAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoX2luaXRpYWxab29tUnVubmluZykge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoX29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQgJiYgZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoX3ByZXZlbnREZWZhdWx0RXZlbnRCZWhhdmlvdXIoZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG5cblxuICAgICAgICBfc2hvdXQoJ3BvaW50ZXJEb3duJyk7XG5cbiAgICAgICAgaWYoX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBwb2ludGVySW5kZXggPSBmcmFtZXdvcmsuYXJyYXlTZWFyY2goX2N1cnJQb2ludGVycywgZS5wb2ludGVySWQsICdpZCcpO1xuICAgICAgICAgICAgaWYocG9pbnRlckluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJJbmRleCA9IF9jdXJyUG9pbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2N1cnJQb2ludGVyc1twb2ludGVySW5kZXhdID0ge3g6ZS5wYWdlWCwgeTplLnBhZ2VZLCBpZDogZS5wb2ludGVySWR9O1xuICAgICAgICB9XG4gICAgICAgIFxuXG5cbiAgICAgICAgdmFyIHN0YXJ0UG9pbnRzTGlzdCA9IF9nZXRUb3VjaFBvaW50cyhlKSxcbiAgICAgICAgICAgIG51bVBvaW50cyA9IHN0YXJ0UG9pbnRzTGlzdC5sZW5ndGg7XG5cbiAgICAgICAgX2N1cnJlbnRQb2ludHMgPSBudWxsO1xuXG4gICAgICAgIF9zdG9wQWxsQW5pbWF0aW9ucygpO1xuXG4gICAgICAgIC8vIGluaXQgZHJhZ1xuICAgICAgICBpZighX2lzRHJhZ2dpbmcgfHwgbnVtUG9pbnRzID09PSAxKSB7XG5cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBfaXNEcmFnZ2luZyA9IF9pc0ZpcnN0TW92ZSA9IHRydWU7XG4gICAgICAgICAgICBmcmFtZXdvcmsuYmluZCh3aW5kb3csIF91cE1vdmVFdmVudHMsIHNlbGYpO1xuXG4gICAgICAgICAgICBfaXNab29taW5nSW4gPSBcbiAgICAgICAgICAgICAgICBfd2FzT3ZlckluaXRpYWxab29tID0gXG4gICAgICAgICAgICAgICAgX29wYWNpdHlDaGFuZ2VkID0gXG4gICAgICAgICAgICAgICAgX3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCA9IFxuICAgICAgICAgICAgICAgIF9tYWluU2Nyb2xsU2hpZnRlZCA9IFxuICAgICAgICAgICAgICAgIF9tb3ZlZCA9IFxuICAgICAgICAgICAgICAgIF9pc011bHRpdG91Y2ggPSBcbiAgICAgICAgICAgICAgICBfem9vbVN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgX2RpcmVjdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgIF9zaG91dCgnZmlyc3RUb3VjaFN0YXJ0Jywgc3RhcnRQb2ludHNMaXN0KTtcblxuICAgICAgICAgICAgX2VxdWFsaXplUG9pbnRzKF9zdGFydFBhbk9mZnNldCwgX3Bhbk9mZnNldCk7XG5cbiAgICAgICAgICAgIF9jdXJyUGFuRGlzdC54ID0gX2N1cnJQYW5EaXN0LnkgPSAwO1xuICAgICAgICAgICAgX2VxdWFsaXplUG9pbnRzKF9jdXJyUG9pbnQsIHN0YXJ0UG9pbnRzTGlzdFswXSk7XG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMoX3N0YXJ0UG9pbnQsIF9jdXJyUG9pbnQpO1xuXG4gICAgICAgICAgICAvL19lcXVhbGl6ZVBvaW50cyhfc3RhcnRNYWluU2Nyb2xsUG9zLCBfbWFpblNjcm9sbFBvcyk7XG4gICAgICAgICAgICBfc3RhcnRNYWluU2Nyb2xsUG9zLnggPSBfc2xpZGVTaXplLnggKiBfY3VyclBvc2l0aW9uSW5kZXg7XG5cbiAgICAgICAgICAgIF9wb3NQb2ludHMgPSBbe1xuICAgICAgICAgICAgICAgIHg6IF9jdXJyUG9pbnQueCxcbiAgICAgICAgICAgICAgICB5OiBfY3VyclBvaW50LnlcbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICBfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lID0gX2dlc3R1cmVTdGFydFRpbWUgPSBfZ2V0Q3VycmVudFRpbWUoKTtcblxuICAgICAgICAgICAgLy9fbWFpblNjcm9sbEFuaW1hdGlvbkVuZCh0cnVlKTtcbiAgICAgICAgICAgIF9jYWxjdWxhdGVQYW5Cb3VuZHMoIF9jdXJyWm9vbUxldmVsLCB0cnVlICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN0YXJ0IHJlbmRlcmluZ1xuICAgICAgICAgICAgX3N0b3BEcmFnVXBkYXRlTG9vcCgpO1xuICAgICAgICAgICAgX2RyYWdVcGRhdGVMb29wKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXQgem9vbVxuICAgICAgICBpZighX2lzWm9vbWluZyAmJiBudW1Qb2ludHMgPiAxICYmICFfbWFpblNjcm9sbEFuaW1hdGluZyAmJiAhX21haW5TY3JvbGxTaGlmdGVkKSB7XG4gICAgICAgICAgICBfc3RhcnRab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbDtcbiAgICAgICAgICAgIF96b29tU3RhcnRlZCA9IGZhbHNlOyAvLyB0cnVlIGlmIHpvb20gY2hhbmdlZCBhdCBsZWFzdCBvbmNlXG5cbiAgICAgICAgICAgIF9pc1pvb21pbmcgPSBfaXNNdWx0aXRvdWNoID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jdXJyUGFuRGlzdC55ID0gX2N1cnJQYW5EaXN0LnggPSAwO1xuXG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMoX3N0YXJ0UGFuT2Zmc2V0LCBfcGFuT2Zmc2V0KTtcblxuICAgICAgICAgICAgX2VxdWFsaXplUG9pbnRzKHAsIHN0YXJ0UG9pbnRzTGlzdFswXSk7XG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMocDIsIHN0YXJ0UG9pbnRzTGlzdFsxXSk7XG5cbiAgICAgICAgICAgIF9maW5kQ2VudGVyT2ZQb2ludHMocCwgcDIsIF9jdXJyQ2VudGVyUG9pbnQpO1xuXG4gICAgICAgICAgICBfbWlkWm9vbVBvaW50LnggPSBNYXRoLmFicyhfY3VyckNlbnRlclBvaW50LngpIC0gX3Bhbk9mZnNldC54O1xuICAgICAgICAgICAgX21pZFpvb21Qb2ludC55ID0gTWF0aC5hYnMoX2N1cnJDZW50ZXJQb2ludC55KSAtIF9wYW5PZmZzZXQueTtcbiAgICAgICAgICAgIF9jdXJyUG9pbnRzRGlzdGFuY2UgPSBfc3RhcnRQb2ludHNEaXN0YW5jZSA9IF9jYWxjdWxhdGVQb2ludHNEaXN0YW5jZShwLCBwMik7XG4gICAgICAgIH1cblxuXG4gICAgfSxcblxuICAgIC8vIFBvaW50ZXJtb3ZlL3RvdWNobW92ZS9tb3VzZW1vdmUgaGFuZGxlclxuICAgIF9vbkRyYWdNb3ZlID0gZnVuY3Rpb24oZSkge1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZihfcG9pbnRlckV2ZW50RW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJJbmRleCA9IGZyYW1ld29yay5hcnJheVNlYXJjaChfY3VyclBvaW50ZXJzLCBlLnBvaW50ZXJJZCwgJ2lkJyk7XG4gICAgICAgICAgICBpZihwb2ludGVySW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gX2N1cnJQb2ludGVyc1twb2ludGVySW5kZXhdO1xuICAgICAgICAgICAgICAgIHAueCA9IGUucGFnZVg7XG4gICAgICAgICAgICAgICAgcC55ID0gZS5wYWdlWTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihfaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgdmFyIHRvdWNoZXNMaXN0ID0gX2dldFRvdWNoUG9pbnRzKGUpO1xuICAgICAgICAgICAgaWYoIV9kaXJlY3Rpb24gJiYgIV9tb3ZlZCAmJiAhX2lzWm9vbWluZykge1xuXG4gICAgICAgICAgICAgICAgaWYoX21haW5TY3JvbGxQb3MueCAhPT0gX3NsaWRlU2l6ZS54ICogX2N1cnJQb3NpdGlvbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG1haW4gc2Nyb2xsIHBvc2l0aW9uIGlzIHNoaWZ0ZWQg4oCTIGRpcmVjdGlvbiBpcyBhbHdheXMgaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICBfZGlyZWN0aW9uID0gJ2gnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnModG91Y2hlc0xpc3RbMF0ueCAtIF9jdXJyUG9pbnQueCkgLSBNYXRoLmFicyh0b3VjaGVzTGlzdFswXS55IC0gX2N1cnJQb2ludC55KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGRpcmVjdGlvbiBvZiBtb3ZlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhkaWZmKSA+PSBESVJFQ1RJT05fQ0hFQ0tfT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZGlyZWN0aW9uID0gZGlmZiA+IDAgPyAnaCcgOiAndic7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudFBvaW50cyA9IHRvdWNoZXNMaXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY3VycmVudFBvaW50cyA9IHRvdWNoZXNMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICAgXG4gICAgfSxcbiAgICAvLyBcbiAgICBfcmVuZGVyTW92ZW1lbnQgPSAgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYoIV9jdXJyZW50UG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnVtUG9pbnRzID0gX2N1cnJlbnRQb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIGlmKG51bVBvaW50cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX2VxdWFsaXplUG9pbnRzKHAsIF9jdXJyZW50UG9pbnRzWzBdKTtcblxuICAgICAgICBkZWx0YS54ID0gcC54IC0gX2N1cnJQb2ludC54O1xuICAgICAgICBkZWx0YS55ID0gcC55IC0gX2N1cnJQb2ludC55O1xuXG4gICAgICAgIGlmKF9pc1pvb21pbmcgJiYgbnVtUG9pbnRzID4gMSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGJlaGF2aW91ciBmb3IgbW9yZSB0aGFuIDEgcG9pbnRcblxuICAgICAgICAgICAgX2N1cnJQb2ludC54ID0gcC54O1xuICAgICAgICAgICAgX2N1cnJQb2ludC55ID0gcC55O1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG9uZSBvZiB0d28gcG9pbnRzIGNoYW5nZWRcbiAgICAgICAgICAgIGlmKCAhZGVsdGEueCAmJiAhZGVsdGEueSAmJiBfaXNFcXVhbFBvaW50cyhfY3VycmVudFBvaW50c1sxXSwgcDIpICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2VxdWFsaXplUG9pbnRzKHAyLCBfY3VycmVudFBvaW50c1sxXSk7XG5cblxuICAgICAgICAgICAgaWYoIV96b29tU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIF96b29tU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3Nob3V0KCd6b29tR2VzdHVyZVN0YXJ0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAgICAgICAgICB2YXIgcG9pbnRzRGlzdGFuY2UgPSBfY2FsY3VsYXRlUG9pbnRzRGlzdGFuY2UocCxwMik7XG5cbiAgICAgICAgICAgIHZhciB6b29tTGV2ZWwgPSBfY2FsY3VsYXRlWm9vbUxldmVsKHBvaW50c0Rpc3RhbmNlKTtcblxuICAgICAgICAgICAgLy8gc2xpZ2h0bHkgb3ZlciB0aGUgb2YgaW5pdGlhbCB6b29tIGxldmVsXG4gICAgICAgICAgICBpZih6b29tTGV2ZWwgPiBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwgKyBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwgLyAxNSkge1xuICAgICAgICAgICAgICAgIF93YXNPdmVySW5pdGlhbFpvb20gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgZnJpY3Rpb24gaWYgem9vbSBsZXZlbCBpcyBvdXQgb2YgdGhlIGJvdW5kc1xuICAgICAgICAgICAgdmFyIHpvb21GcmljdGlvbiA9IDEsXG4gICAgICAgICAgICAgICAgbWluWm9vbUxldmVsID0gX2dldE1pblpvb21MZXZlbCgpLFxuICAgICAgICAgICAgICAgIG1heFpvb21MZXZlbCA9IF9nZXRNYXhab29tTGV2ZWwoKTtcblxuICAgICAgICAgICAgaWYgKCB6b29tTGV2ZWwgPCBtaW5ab29tTGV2ZWwgKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoX29wdGlvbnMucGluY2hUb0Nsb3NlICYmICFfd2FzT3ZlckluaXRpYWxab29tICYmIF9zdGFydFpvb21MZXZlbCA8PSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFkZSBvdXQgYmFja2dyb3VuZCBpZiB6b29taW5nIG91dFxuICAgICAgICAgICAgICAgICAgICB2YXIgbWludXNEaWZmID0gbWluWm9vbUxldmVsIC0gem9vbUxldmVsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IDEgLSBtaW51c0RpZmYgLyAobWluWm9vbUxldmVsIC8gMS4yKTtcblxuICAgICAgICAgICAgICAgICAgICBfYXBwbHlCZ09wYWNpdHkocGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIF9zaG91dCgnb25QaW5jaENsb3NlJywgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIF9vcGFjaXR5Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbUZyaWN0aW9uID0gKG1pblpvb21MZXZlbCAtIHpvb21MZXZlbCkgLyBtaW5ab29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmKHpvb21GcmljdGlvbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb21GcmljdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgem9vbUxldmVsID0gbWluWm9vbUxldmVsIC0gem9vbUZyaWN0aW9uICogKG1pblpvb21MZXZlbCAvIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHpvb21MZXZlbCA+IG1heFpvb21MZXZlbCApIHtcbiAgICAgICAgICAgICAgICAvLyAxLjUgLSBleHRyYSB6b29tIGxldmVsIGFib3ZlIHRoZSBtYXguIEUuZy4gaWYgbWF4IGlzIHg2LCByZWFsIG1heCA2ICsgMS41ID0gNy41XG4gICAgICAgICAgICAgICAgem9vbUZyaWN0aW9uID0gKHpvb21MZXZlbCAtIG1heFpvb21MZXZlbCkgLyAoIG1pblpvb21MZXZlbCAqIDYgKTtcbiAgICAgICAgICAgICAgICBpZih6b29tRnJpY3Rpb24gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvb21GcmljdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHpvb21MZXZlbCA9IG1heFpvb21MZXZlbCArIHpvb21GcmljdGlvbiAqIG1pblpvb21MZXZlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoem9vbUZyaWN0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHpvb21GcmljdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gdG91Y2ggcG9pbnRzIGFmdGVyIGZyaWN0aW9uIGlzIGFwcGxpZWRcbiAgICAgICAgICAgIF9jdXJyUG9pbnRzRGlzdGFuY2UgPSBwb2ludHNEaXN0YW5jZTtcblxuICAgICAgICAgICAgLy8gX2NlbnRlclBvaW50IC0gVGhlIHBvaW50IGluIHRoZSBtaWRkbGUgb2YgdHdvIHBvaW50ZXJzXG4gICAgICAgICAgICBfZmluZENlbnRlck9mUG9pbnRzKHAsIHAyLCBfY2VudGVyUG9pbnQpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIHBhbmluZyB3aXRoIHR3byBwb2ludGVycyBwcmVzc2VkXG4gICAgICAgICAgICBfY3VyclBhbkRpc3QueCArPSBfY2VudGVyUG9pbnQueCAtIF9jdXJyQ2VudGVyUG9pbnQueDtcbiAgICAgICAgICAgIF9jdXJyUGFuRGlzdC55ICs9IF9jZW50ZXJQb2ludC55IC0gX2N1cnJDZW50ZXJQb2ludC55O1xuICAgICAgICAgICAgX2VxdWFsaXplUG9pbnRzKF9jdXJyQ2VudGVyUG9pbnQsIF9jZW50ZXJQb2ludCk7XG5cbiAgICAgICAgICAgIF9wYW5PZmZzZXQueCA9IF9jYWxjdWxhdGVQYW5PZmZzZXQoJ3gnLCB6b29tTGV2ZWwpO1xuICAgICAgICAgICAgX3Bhbk9mZnNldC55ID0gX2NhbGN1bGF0ZVBhbk9mZnNldCgneScsIHpvb21MZXZlbCk7XG5cbiAgICAgICAgICAgIF9pc1pvb21pbmdJbiA9IHpvb21MZXZlbCA+IF9jdXJyWm9vbUxldmVsO1xuICAgICAgICAgICAgX2N1cnJab29tTGV2ZWwgPSB6b29tTGV2ZWw7XG4gICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBiZWhhdmlvdXIgZm9yIG9uZSBwb2ludCAoZHJhZ2dpbmcgb3IgcGFubmluZylcblxuICAgICAgICAgICAgaWYoIV9kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKF9pc0ZpcnN0TW92ZSkge1xuICAgICAgICAgICAgICAgIF9pc0ZpcnN0TW92ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgZHJhZyBkaXN0YW5jZSB0aGF0IHdhcyB1c2VkIGR1cmluZyB0aGUgZGV0ZWN0aW9uIGRpcmVjdGlvbiAgXG5cbiAgICAgICAgICAgICAgICBpZiggTWF0aC5hYnMoZGVsdGEueCkgPj0gRElSRUNUSU9OX0NIRUNLX09GRlNFVCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YS54IC09IF9jdXJyZW50UG9pbnRzWzBdLnggLSBfc3RhcnRQb2ludC54O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggTWF0aC5hYnMoZGVsdGEueSkgPj0gRElSRUNUSU9OX0NIRUNLX09GRlNFVCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YS55IC09IF9jdXJyZW50UG9pbnRzWzBdLnkgLSBfc3RhcnRQb2ludC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2N1cnJQb2ludC54ID0gcC54O1xuICAgICAgICAgICAgX2N1cnJQb2ludC55ID0gcC55O1xuXG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHBvaW50ZXJzIHBvc2l0aW9uIGhhc24ndCBjaGFuZ2VkXG4gICAgICAgICAgICBpZihkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKF9kaXJlY3Rpb24gPT09ICd2JyAmJiBfb3B0aW9ucy5jbG9zZU9uVmVydGljYWxEcmFnKSB7XG4gICAgICAgICAgICAgICAgaWYoIV9jYW5QYW4oKSkge1xuICAgICAgICAgICAgICAgICAgICBfY3VyclBhbkRpc3QueSArPSBkZWx0YS55O1xuICAgICAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnkgKz0gZGVsdGEueTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eVJhdGlvID0gX2NhbGN1bGF0ZVZlcnRpY2FsRHJhZ09wYWNpdHlSYXRpbygpO1xuXG4gICAgICAgICAgICAgICAgICAgIF92ZXJ0aWNhbERyYWdJbml0aWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfc2hvdXQoJ29uVmVydGljYWxEcmFnJywgb3BhY2l0eVJhdGlvKTtcblxuICAgICAgICAgICAgICAgICAgICBfYXBwbHlCZ09wYWNpdHkob3BhY2l0eVJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9wdXNoUG9zUG9pbnQoX2dldEN1cnJlbnRUaW1lKCksIHAueCwgcC55KTtcblxuICAgICAgICAgICAgX21vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jdXJyUGFuQm91bmRzID0gc2VsZi5jdXJySXRlbS5ib3VuZHM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBtYWluU2Nyb2xsQ2hhbmdlZCA9IF9wYW5Pck1vdmVNYWluU2Nyb2xsKCd4JywgZGVsdGEpO1xuICAgICAgICAgICAgaWYoIW1haW5TY3JvbGxDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgX3Bhbk9yTW92ZU1haW5TY3JvbGwoJ3knLCBkZWx0YSk7XG5cbiAgICAgICAgICAgICAgICBfcm91bmRQb2ludChfcGFuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG4gICAgXG4gICAgLy8gUG9pbnRlcnVwL3BvaW50ZXJjYW5jZWwvdG91Y2hlbmQvdG91Y2hjYW5jZWwvbW91c2V1cCBldmVudCBoYW5kbGVyXG4gICAgX29uRHJhZ1JlbGVhc2UgPSBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgaWYoX2ZlYXR1cmVzLmlzT2xkQW5kcm9pZCApIHtcblxuICAgICAgICAgICAgaWYoX29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQgJiYgZS50eXBlID09PSAnbW91c2V1cCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9uIEFuZHJvaWQgKHY0LjEsIDQuMiwgNC4zICYgcG9zc2libHkgb2xkZXIpIFxuICAgICAgICAgICAgLy8gZ2hvc3QgbW91c2Vkb3duL3VwIGV2ZW50IGlzbid0IHByZXZlbnRhYmxlIHZpYSBlLnByZXZlbnREZWZhdWx0LFxuICAgICAgICAgICAgLy8gd2hpY2ggY2F1c2VzIGZha2UgbW91c2Vkb3duIGV2ZW50XG4gICAgICAgICAgICAvLyBzbyB3ZSBibG9jayBtb3VzZWRvd24vdXAgZm9yIDYwMG1zXG4gICAgICAgICAgICBpZiggZS50eXBlLmluZGV4T2YoJ3RvdWNoJykgPiAtMSApIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIF9vbGRBbmRyb2lkVG91Y2hFbmRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgX29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQgPSAwO1xuICAgICAgICAgICAgICAgIH0sIDYwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIF9zaG91dCgncG9pbnRlclVwJyk7XG5cbiAgICAgICAgaWYoX3ByZXZlbnREZWZhdWx0RXZlbnRCZWhhdmlvdXIoZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVsZWFzZVBvaW50O1xuXG4gICAgICAgIGlmKF9wb2ludGVyRXZlbnRFbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRlckluZGV4ID0gZnJhbWV3b3JrLmFycmF5U2VhcmNoKF9jdXJyUG9pbnRlcnMsIGUucG9pbnRlcklkLCAnaWQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYocG9pbnRlckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZWxlYXNlUG9pbnQgPSBfY3VyclBvaW50ZXJzLnNwbGljZShwb2ludGVySW5kZXgsIDEpWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VQb2ludC50eXBlID0gZS5wb2ludGVyVHlwZSB8fCAnbW91c2UnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBNU1BPSU5URVJfVFlQRVMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICA0OiAnbW91c2UnLCAvLyBldmVudC5NU1BPSU5URVJfVFlQRV9NT1VTRVxuICAgICAgICAgICAgICAgICAgICAgICAgMjogJ3RvdWNoJywgLy8gZXZlbnQuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggXG4gICAgICAgICAgICAgICAgICAgICAgICAzOiAncGVuJyAvLyBldmVudC5NU1BPSU5URVJfVFlQRV9QRU5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZVBvaW50LnR5cGUgPSBNU1BPSU5URVJfVFlQRVNbZS5wb2ludGVyVHlwZV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIXJlbGVhc2VQb2ludC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlUG9pbnQudHlwZSA9IGUucG9pbnRlclR5cGUgfHwgJ21vdXNlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoTGlzdCA9IF9nZXRUb3VjaFBvaW50cyhlKSxcbiAgICAgICAgICAgIGdlc3R1cmVUeXBlLFxuICAgICAgICAgICAgbnVtUG9pbnRzID0gdG91Y2hMaXN0Lmxlbmd0aDtcblxuICAgICAgICBpZihlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgICAgbnVtUG9pbnRzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlcmUgd2VyZSAzIHRvdWNoIHBvaW50cyBvciBtb3JlXG4gICAgICAgIGlmKG51bVBvaW50cyA9PT0gMikge1xuICAgICAgICAgICAgX2N1cnJlbnRQb2ludHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBzZWNvbmQgcG9pbnRlciByZWxlYXNlZFxuICAgICAgICBpZihudW1Qb2ludHMgPT09IDEpIHtcbiAgICAgICAgICAgIF9lcXVhbGl6ZVBvaW50cyhfc3RhcnRQb2ludCwgdG91Y2hMaXN0WzBdKTtcbiAgICAgICAgfSAgICAgICAgICAgICAgIFxuXG5cbiAgICAgICAgLy8gcG9pbnRlciBoYXNuJ3QgbW92ZWQsIHNlbmQgXCJ0YXAgcmVsZWFzZVwiIHBvaW50XG4gICAgICAgIGlmKG51bVBvaW50cyA9PT0gMCAmJiAhX2RpcmVjdGlvbiAmJiAhX21haW5TY3JvbGxBbmltYXRpbmcpIHtcbiAgICAgICAgICAgIGlmKCFyZWxlYXNlUG9pbnQpIHtcbiAgICAgICAgICAgICAgICBpZihlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlUG9pbnQgPSB7eDogZS5wYWdlWCwgeTogZS5wYWdlWSwgdHlwZTonbW91c2UnfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VQb2ludCA9IHt4OiBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYLCB5OiBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZLCB0eXBlOid0b3VjaCd9O1xuICAgICAgICAgICAgICAgIH0gICAgICAgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zaG91dCgndG91Y2hSZWxlYXNlJywgZSwgcmVsZWFzZVBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpZmZlcmVuY2UgaW4gdGltZSBiZXR3ZWVuIHJlbGVhc2luZyBvZiB0d28gbGFzdCB0b3VjaCBwb2ludHMgKHpvb20gZ2VzdHVyZSlcbiAgICAgICAgdmFyIHJlbGVhc2VUaW1lRGlmZiA9IC0xO1xuXG4gICAgICAgIC8vIEdlc3R1cmUgY29tcGxldGVkLCBubyBwb2ludGVycyBsZWZ0XG4gICAgICAgIGlmKG51bVBvaW50cyA9PT0gMCkge1xuICAgICAgICAgICAgX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZyYW1ld29yay51bmJpbmQod2luZG93LCBfdXBNb3ZlRXZlbnRzLCBzZWxmKTtcblxuICAgICAgICAgICAgX3N0b3BEcmFnVXBkYXRlTG9vcCgpO1xuXG4gICAgICAgICAgICBpZihfaXNab29taW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gVHdvIHBvaW50cyByZWxlYXNlZCBhdCB0aGUgc2FtZSB0aW1lXG4gICAgICAgICAgICAgICAgcmVsZWFzZVRpbWVEaWZmID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZihfbGFzdFJlbGVhc2VUaW1lICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VUaW1lRGlmZiA9IF9nZXRDdXJyZW50VGltZSgpIC0gX2xhc3RSZWxlYXNlVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfbGFzdFJlbGVhc2VUaW1lID0gbnVtUG9pbnRzID09PSAxID8gX2dldEN1cnJlbnRUaW1lKCkgOiAtMTtcbiAgICAgICAgXG4gICAgICAgIGlmKHJlbGVhc2VUaW1lRGlmZiAhPT0gLTEgJiYgcmVsZWFzZVRpbWVEaWZmIDwgMTUwKSB7XG4gICAgICAgICAgICBnZXN0dXJlVHlwZSA9ICd6b29tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlc3R1cmVUeXBlID0gJ3N3aXBlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKF9pc1pvb21pbmcgJiYgbnVtUG9pbnRzIDwgMikge1xuICAgICAgICAgICAgX2lzWm9vbWluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBPbmx5IHNlY29uZCBwb2ludCByZWxlYXNlZFxuICAgICAgICAgICAgaWYobnVtUG9pbnRzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVR5cGUgPSAnem9vbVBvaW50ZXJVcCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc2hvdXQoJ3pvb21HZXN0dXJlRW5kZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jdXJyZW50UG9pbnRzID0gbnVsbDtcbiAgICAgICAgaWYoIV9tb3ZlZCAmJiAhX3pvb21TdGFydGVkICYmICFfbWFpblNjcm9sbEFuaW1hdGluZyAmJiAhX3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBhbmltYXRlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgX3N0b3BBbGxBbmltYXRpb25zKCk7XG5cbiAgICAgICAgXG4gICAgICAgIGlmKCFfcmVsZWFzZUFuaW1EYXRhKSB7XG4gICAgICAgICAgICBfcmVsZWFzZUFuaW1EYXRhID0gX2luaXREcmFnUmVsZWFzZUFuaW1hdGlvbkRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgX3JlbGVhc2VBbmltRGF0YS5jYWxjdWxhdGVTd2lwZVNwZWVkKCd4Jyk7XG5cblxuICAgICAgICBpZihfdmVydGljYWxEcmFnSW5pdGlhdGVkKSB7XG5cbiAgICAgICAgICAgIHZhciBvcGFjaXR5UmF0aW8gPSBfY2FsY3VsYXRlVmVydGljYWxEcmFnT3BhY2l0eVJhdGlvKCk7XG5cbiAgICAgICAgICAgIGlmKG9wYWNpdHlSYXRpbyA8IF9vcHRpb25zLnZlcnRpY2FsRHJhZ1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGFsUGFuWSA9IF9wYW5PZmZzZXQueSxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEJnT3BhY2l0eSA9IF9iZ09wYWNpdHk7XG5cbiAgICAgICAgICAgICAgICBfYW5pbWF0ZVByb3AoJ3ZlcnRpY2FsRHJhZycsIDAsIDEsIDMwMCwgZnJhbWV3b3JrLmVhc2luZy5jdWJpYy5vdXQsIGZ1bmN0aW9uKG5vdykge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgX3Bhbk9mZnNldC55ID0gKHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFBvc2l0aW9uLnkgLSBpbml0YWxQYW5ZKSAqIG5vdyArIGluaXRhbFBhblk7XG5cbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5QmdPcGFjaXR5KCAgKDEgLSBpbml0aWFsQmdPcGFjaXR5KSAqIG5vdyArIGluaXRpYWxCZ09wYWNpdHkgKTtcbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIF9zaG91dCgnb25WZXJ0aWNhbERyYWcnLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBtYWluIHNjcm9sbCBcbiAgICAgICAgaWYoICAoX21haW5TY3JvbGxTaGlmdGVkIHx8IF9tYWluU2Nyb2xsQW5pbWF0aW5nKSAmJiBudW1Qb2ludHMgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBpdGVtQ2hhbmdlZCA9IF9maW5pc2hTd2lwZU1haW5TY3JvbGxHZXN0dXJlKGdlc3R1cmVUeXBlLCBfcmVsZWFzZUFuaW1EYXRhKTtcbiAgICAgICAgICAgIGlmKGl0ZW1DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VzdHVyZVR5cGUgPSAnem9vbVBvaW50ZXJVcCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IHpvb20vcGFuIGFuaW1hdGlvbiB3aGVuIG1haW4gc2Nyb2xsIGFuaW1hdGlvbiBydW5zXG4gICAgICAgIGlmKF9tYWluU2Nyb2xsQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENvbXBsZXRlIHNpbXBsZSB6b29tIGdlc3R1cmUgKHJlc2V0IHpvb20gbGV2ZWwgaWYgaXQncyBvdXQgb2YgdGhlIGJvdW5kcykgIFxuICAgICAgICBpZihnZXN0dXJlVHlwZSAhPT0gJ3N3aXBlJykge1xuICAgICAgICAgICAgX2NvbXBsZXRlWm9vbUdlc3R1cmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBDb21wbGV0ZSBwYW4gZ2VzdHVyZSBpZiBtYWluIHNjcm9sbCBpcyBub3Qgc2hpZnRlZCwgYW5kIGl0J3MgcG9zc2libGUgdG8gcGFuIGN1cnJlbnQgaW1hZ2VcbiAgICAgICAgaWYoIV9tYWluU2Nyb2xsU2hpZnRlZCAmJiBfY3Vyclpvb21MZXZlbCA+IHNlbGYuY3Vyckl0ZW0uZml0UmF0aW8pIHtcbiAgICAgICAgICAgIF9jb21wbGV0ZVBhbkdlc3R1cmUoX3JlbGVhc2VBbmltRGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvLyBSZXR1cm5zIG9iamVjdCB3aXRoIGRhdGEgYWJvdXQgZ2VzdHVyZVxuICAgIC8vIEl0J3MgY3JlYXRlZCBvbmx5IG9uY2UgYW5kIHRoZW4gcmV1c2VkXG4gICAgX2luaXREcmFnUmVsZWFzZUFuaW1hdGlvbkRhdGEgID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHRlbXAgbG9jYWwgdmFyc1xuICAgICAgICB2YXIgbGFzdEZsaWNrRHVyYXRpb24sXG4gICAgICAgICAgICB0ZW1wUmVsZWFzZVBvcztcblxuICAgICAgICAvLyBzID0gdGhpc1xuICAgICAgICB2YXIgcyA9IHtcbiAgICAgICAgICAgIGxhc3RGbGlja09mZnNldDoge30sXG4gICAgICAgICAgICBsYXN0RmxpY2tEaXN0OiB7fSxcbiAgICAgICAgICAgIGxhc3RGbGlja1NwZWVkOiB7fSxcbiAgICAgICAgICAgIHNsb3dEb3duUmF0aW86ICB7fSxcbiAgICAgICAgICAgIHNsb3dEb3duUmF0aW9SZXZlcnNlOiAge30sXG4gICAgICAgICAgICBzcGVlZERlY2VsZXJhdGlvblJhdGlvOiAge30sXG4gICAgICAgICAgICBzcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzOiAge30sXG4gICAgICAgICAgICBkaXN0YW5jZU9mZnNldDogIHt9LFxuICAgICAgICAgICAgYmFja0FuaW1EZXN0aW5hdGlvbjoge30sXG4gICAgICAgICAgICBiYWNrQW5pbVN0YXJ0ZWQ6IHt9LFxuICAgICAgICAgICAgY2FsY3VsYXRlU3dpcGVTcGVlZDogZnVuY3Rpb24oYXhpcykge1xuICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgaWYoIF9wb3NQb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RmxpY2tEdXJhdGlvbiA9IF9nZXRDdXJyZW50VGltZSgpIC0gX2dlc3R1cmVDaGVja1NwZWVkVGltZSArIDUwO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wUmVsZWFzZVBvcyA9IF9wb3NQb2ludHNbX3Bvc1BvaW50cy5sZW5ndGgtMl1bYXhpc107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZsaWNrRHVyYXRpb24gPSBfZ2V0Q3VycmVudFRpbWUoKSAtIF9nZXN0dXJlU3RhcnRUaW1lOyAvLyB0b3RhbCBnZXN0dXJlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRlbXBSZWxlYXNlUG9zID0gX3N0YXJ0UG9pbnRbYXhpc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMubGFzdEZsaWNrT2Zmc2V0W2F4aXNdID0gX2N1cnJQb2ludFtheGlzXSAtIHRlbXBSZWxlYXNlUG9zO1xuICAgICAgICAgICAgICAgIHMubGFzdEZsaWNrRGlzdFtheGlzXSA9IE1hdGguYWJzKHMubGFzdEZsaWNrT2Zmc2V0W2F4aXNdKTtcbiAgICAgICAgICAgICAgICBpZihzLmxhc3RGbGlja0Rpc3RbYXhpc10gPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICBzLmxhc3RGbGlja1NwZWVkW2F4aXNdID0gcy5sYXN0RmxpY2tPZmZzZXRbYXhpc10gLyBsYXN0RmxpY2tEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzLmxhc3RGbGlja1NwZWVkW2F4aXNdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIE1hdGguYWJzKHMubGFzdEZsaWNrU3BlZWRbYXhpc10pIDwgMC4xICkge1xuICAgICAgICAgICAgICAgICAgICBzLmxhc3RGbGlja1NwZWVkW2F4aXNdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcy5zbG93RG93blJhdGlvW2F4aXNdID0gMC45NTtcbiAgICAgICAgICAgICAgICBzLnNsb3dEb3duUmF0aW9SZXZlcnNlW2F4aXNdID0gMSAtIHMuc2xvd0Rvd25SYXRpb1theGlzXTtcbiAgICAgICAgICAgICAgICBzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9bYXhpc10gPSAxO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2FsY3VsYXRlT3ZlckJvdW5kc0FuaW1PZmZzZXQ6IGZ1bmN0aW9uKGF4aXMsIHNwZWVkKSB7XG4gICAgICAgICAgICAgICAgaWYoIXMuYmFja0FuaW1TdGFydGVkW2F4aXNdKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoX3Bhbk9mZnNldFtheGlzXSA+IF9jdXJyUGFuQm91bmRzLm1pbltheGlzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5iYWNrQW5pbURlc3RpbmF0aW9uW2F4aXNdID0gX2N1cnJQYW5Cb3VuZHMubWluW2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihfcGFuT2Zmc2V0W2F4aXNdIDwgX2N1cnJQYW5Cb3VuZHMubWF4W2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJhY2tBbmltRGVzdGluYXRpb25bYXhpc10gPSBfY3VyclBhbkJvdW5kcy5tYXhbYXhpc107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihzLmJhY2tBbmltRGVzdGluYXRpb25bYXhpc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5zbG93RG93blJhdGlvW2F4aXNdID0gMC43O1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5zbG93RG93blJhdGlvUmV2ZXJzZVtheGlzXSA9IDEgLSBzLnNsb3dEb3duUmF0aW9bYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnNbYXhpc10gPCAwLjA1KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmxhc3RGbGlja1NwZWVkW2F4aXNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJhY2tBbmltU3RhcnRlZFtheGlzXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYW5pbWF0ZVByb3AoJ2JvdW5jZVpvb21QYW4nK2F4aXMsX3Bhbk9mZnNldFtheGlzXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuYmFja0FuaW1EZXN0aW5hdGlvbltheGlzXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkIHx8IDMwMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1ld29yay5lYXNpbmcuc2luZS5vdXQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXRbYXhpc10gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gUmVkdWNlcyB0aGUgc3BlZWQgYnkgc2xvd0Rvd25SYXRpbyAocGVyIDEwbXMpXG4gICAgICAgICAgICBjYWxjdWxhdGVBbmltT2Zmc2V0OiBmdW5jdGlvbihheGlzKSB7XG4gICAgICAgICAgICAgICAgaWYoIXMuYmFja0FuaW1TdGFydGVkW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb1theGlzXSA9IHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb1theGlzXSAqIChzLnNsb3dEb3duUmF0aW9bYXhpc10gKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuc2xvd0Rvd25SYXRpb1JldmVyc2VbYXhpc10gLSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuc2xvd0Rvd25SYXRpb1JldmVyc2VbYXhpc10gKiBzLnRpbWVEaWZmIC8gMTApO1xuXG4gICAgICAgICAgICAgICAgICAgIHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb0Fic1theGlzXSA9IE1hdGguYWJzKHMubGFzdEZsaWNrU3BlZWRbYXhpc10gKiBzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9bYXhpc10pO1xuICAgICAgICAgICAgICAgICAgICBzLmRpc3RhbmNlT2Zmc2V0W2F4aXNdID0gcy5sYXN0RmxpY2tTcGVlZFtheGlzXSAqIHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb1theGlzXSAqIHMudGltZURpZmY7XG4gICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXRbYXhpc10gKz0gcy5kaXN0YW5jZU9mZnNldFtheGlzXTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhbkFuaW1Mb29wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIF9hbmltYXRpb25zLnpvb21QYW4gKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hbmltYXRpb25zLnpvb21QYW4ucmFmID0gX3JlcXVlc3RBRihzLnBhbkFuaW1Mb29wKTtcblxuICAgICAgICAgICAgICAgICAgICBzLm5vdyA9IF9nZXRDdXJyZW50VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICBzLnRpbWVEaWZmID0gcy5ub3cgLSBzLmxhc3ROb3c7XG4gICAgICAgICAgICAgICAgICAgIHMubGFzdE5vdyA9IHMubm93O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcy5jYWxjdWxhdGVBbmltT2Zmc2V0KCd4Jyk7XG4gICAgICAgICAgICAgICAgICAgIHMuY2FsY3VsYXRlQW5pbU9mZnNldCgneScpO1xuXG4gICAgICAgICAgICAgICAgICAgIF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzLmNhbGN1bGF0ZU92ZXJCb3VuZHNBbmltT2Zmc2V0KCd4Jyk7XG4gICAgICAgICAgICAgICAgICAgIHMuY2FsY3VsYXRlT3ZlckJvdW5kc0FuaW1PZmZzZXQoJ3knKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnMueCA8IDAuMDUgJiYgcy5zcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzLnkgPCAwLjA1KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdW5kIHBhbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgX3Bhbk9mZnNldC54ID0gTWF0aC5yb3VuZChfcGFuT2Zmc2V0LngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Bhbk9mZnNldC55ID0gTWF0aC5yb3VuZChfcGFuT2Zmc2V0LnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0b3BBbmltYXRpb24oJ3pvb21QYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcztcbiAgICB9LFxuXG4gICAgX2NvbXBsZXRlUGFuR2VzdHVyZSA9IGZ1bmN0aW9uKGFuaW1EYXRhKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBzd2lwZSBzcGVlZCBmb3IgWSBheGlzIChwYWFubmluZylcbiAgICAgICAgYW5pbURhdGEuY2FsY3VsYXRlU3dpcGVTcGVlZCgneScpO1xuXG4gICAgICAgIF9jdXJyUGFuQm91bmRzID0gc2VsZi5jdXJySXRlbS5ib3VuZHM7XG4gICAgICAgIFxuICAgICAgICBhbmltRGF0YS5iYWNrQW5pbURlc3RpbmF0aW9uID0ge307XG4gICAgICAgIGFuaW1EYXRhLmJhY2tBbmltU3RhcnRlZCA9IHt9O1xuXG4gICAgICAgIC8vIEF2b2lkIGFjY2VsZXJhdGlvbiBhbmltYXRpb24gaWYgc3BlZWQgaXMgdG9vIGxvd1xuICAgICAgICBpZihNYXRoLmFicyhhbmltRGF0YS5sYXN0RmxpY2tTcGVlZC54KSA8PSAwLjA1ICYmIE1hdGguYWJzKGFuaW1EYXRhLmxhc3RGbGlja1NwZWVkLnkpIDw9IDAuMDUgKSB7XG4gICAgICAgICAgICBhbmltRGF0YS5zcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzLnggPSBhbmltRGF0YS5zcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzLnkgPSAwO1xuXG4gICAgICAgICAgICAvLyBSdW4gcGFuIGRyYWcgcmVsZWFzZSBhbmltYXRpb24uIEUuZy4gaWYgeW91IGRyYWcgaW1hZ2UgYW5kIHJlbGVhc2UgZmluZ2VyIHdpdGhvdXQgbW9tZW50dW0uXG4gICAgICAgICAgICBhbmltRGF0YS5jYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldCgneCcpO1xuICAgICAgICAgICAgYW5pbURhdGEuY2FsY3VsYXRlT3ZlckJvdW5kc0FuaW1PZmZzZXQoJ3knKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5pbWF0aW9uIGxvb3AgdGhhdCBjb250cm9scyB0aGUgYWNjZWxlcmF0aW9uIGFmdGVyIHBhbiBnZXN0dXJlIGVuZHNcbiAgICAgICAgX3JlZ2lzdGVyU3RhcnRBbmltYXRpb24oJ3pvb21QYW4nKTtcbiAgICAgICAgYW5pbURhdGEubGFzdE5vdyA9IF9nZXRDdXJyZW50VGltZSgpO1xuICAgICAgICBhbmltRGF0YS5wYW5BbmltTG9vcCgpO1xuICAgIH0sXG5cblxuICAgIF9maW5pc2hTd2lwZU1haW5TY3JvbGxHZXN0dXJlID0gZnVuY3Rpb24oZ2VzdHVyZVR5cGUsIF9yZWxlYXNlQW5pbURhdGEpIHtcbiAgICAgICAgdmFyIGl0ZW1DaGFuZ2VkO1xuICAgICAgICBpZighX21haW5TY3JvbGxBbmltYXRpbmcpIHtcbiAgICAgICAgICAgIF9jdXJyWm9vbWVkSXRlbUluZGV4ID0gX2N1cnJlbnRJdGVtSW5kZXg7XG4gICAgICAgIH1cblxuXG4gICAgICAgIFxuICAgICAgICB2YXIgaXRlbXNEaWZmO1xuXG4gICAgICAgIGlmKGdlc3R1cmVUeXBlID09PSAnc3dpcGUnKSB7XG4gICAgICAgICAgICB2YXIgdG90YWxTaGlmdERpc3QgPSBfY3VyclBvaW50LnggLSBfc3RhcnRQb2ludC54LFxuICAgICAgICAgICAgICAgIGlzRmFzdExhc3RGbGljayA9IF9yZWxlYXNlQW5pbURhdGEubGFzdEZsaWNrRGlzdC54IDwgMTA7XG5cbiAgICAgICAgICAgIC8vIGlmIGNvbnRhaW5lciBpcyBzaGlmdGVkIGZvciBtb3JlIHRoYW4gTUlOX1NXSVBFX0RJU1RBTkNFLCBcbiAgICAgICAgICAgIC8vIGFuZCBsYXN0IGZsaWNrIGdlc3R1cmUgd2FzIGluIHJpZ2h0IGRpcmVjdGlvblxuICAgICAgICAgICAgaWYodG90YWxTaGlmdERpc3QgPiBNSU5fU1dJUEVfRElTVEFOQ0UgJiYgXG4gICAgICAgICAgICAgICAgKGlzRmFzdExhc3RGbGljayB8fCBfcmVsZWFzZUFuaW1EYXRhLmxhc3RGbGlja09mZnNldC54ID4gMjApICkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIHByZXYgaXRlbVxuICAgICAgICAgICAgICAgIGl0ZW1zRGlmZiA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHRvdGFsU2hpZnREaXN0IDwgLU1JTl9TV0lQRV9ESVNUQU5DRSAmJiBcbiAgICAgICAgICAgICAgICAoaXNGYXN0TGFzdEZsaWNrIHx8IF9yZWxlYXNlQW5pbURhdGEubGFzdEZsaWNrT2Zmc2V0LnggPCAtMjApICkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIG5leHQgaXRlbVxuICAgICAgICAgICAgICAgIGl0ZW1zRGlmZiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dENpcmNsZTtcblxuICAgICAgICBpZihpdGVtc0RpZmYpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgX2N1cnJlbnRJdGVtSW5kZXggKz0gaXRlbXNEaWZmO1xuXG4gICAgICAgICAgICBpZihfY3VycmVudEl0ZW1JbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBfY3VycmVudEl0ZW1JbmRleCA9IF9vcHRpb25zLmxvb3AgPyBfZ2V0TnVtSXRlbXMoKS0xIDogMDtcbiAgICAgICAgICAgICAgICBuZXh0Q2lyY2xlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihfY3VycmVudEl0ZW1JbmRleCA+PSBfZ2V0TnVtSXRlbXMoKSkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SXRlbUluZGV4ID0gX29wdGlvbnMubG9vcCA/IDAgOiBfZ2V0TnVtSXRlbXMoKS0xO1xuICAgICAgICAgICAgICAgIG5leHRDaXJjbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighbmV4dENpcmNsZSB8fCBfb3B0aW9ucy5sb29wKSB7XG4gICAgICAgICAgICAgICAgX2luZGV4RGlmZiArPSBpdGVtc0RpZmY7XG4gICAgICAgICAgICAgICAgX2N1cnJQb3NpdGlvbkluZGV4IC09IGl0ZW1zRGlmZjtcbiAgICAgICAgICAgICAgICBpdGVtQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5pbWF0ZVRvWCA9IF9zbGlkZVNpemUueCAqIF9jdXJyUG9zaXRpb25JbmRleDtcbiAgICAgICAgdmFyIGFuaW1hdGVUb0Rpc3QgPSBNYXRoLmFicyggYW5pbWF0ZVRvWCAtIF9tYWluU2Nyb2xsUG9zLnggKTtcbiAgICAgICAgdmFyIGZpbmlzaEFuaW1EdXJhdGlvbjtcblxuXG4gICAgICAgIGlmKCFpdGVtQ2hhbmdlZCAmJiBhbmltYXRlVG9YID4gX21haW5TY3JvbGxQb3MueCAhPT0gX3JlbGVhc2VBbmltRGF0YS5sYXN0RmxpY2tTcGVlZC54ID4gMCkge1xuICAgICAgICAgICAgLy8gXCJyZXR1cm4gdG8gY3VycmVudFwiIGR1cmF0aW9uLCBlLmcuIHdoZW4gZHJhZ2dpbmcgZnJvbSBzbGlkZSAwIHRvIC0xXG4gICAgICAgICAgICBmaW5pc2hBbmltRHVyYXRpb24gPSAzMzM7IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmluaXNoQW5pbUR1cmF0aW9uID0gTWF0aC5hYnMoX3JlbGVhc2VBbmltRGF0YS5sYXN0RmxpY2tTcGVlZC54KSA+IDAgPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVUb0Rpc3QgLyBNYXRoLmFicyhfcmVsZWFzZUFuaW1EYXRhLmxhc3RGbGlja1NwZWVkLngpIDogXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMzM7XG5cbiAgICAgICAgICAgIGZpbmlzaEFuaW1EdXJhdGlvbiA9IE1hdGgubWluKGZpbmlzaEFuaW1EdXJhdGlvbiwgNDAwKTtcbiAgICAgICAgICAgIGZpbmlzaEFuaW1EdXJhdGlvbiA9IE1hdGgubWF4KGZpbmlzaEFuaW1EdXJhdGlvbiwgMjUwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKF9jdXJyWm9vbWVkSXRlbUluZGV4ID09PSBfY3VycmVudEl0ZW1JbmRleCkge1xuICAgICAgICAgICAgaXRlbUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgX21haW5TY3JvbGxBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgX3Nob3V0KCdtYWluU2Nyb2xsQW5pbVN0YXJ0Jyk7XG5cbiAgICAgICAgX2FuaW1hdGVQcm9wKCdtYWluU2Nyb2xsJywgX21haW5TY3JvbGxQb3MueCwgYW5pbWF0ZVRvWCwgZmluaXNoQW5pbUR1cmF0aW9uLCBmcmFtZXdvcmsuZWFzaW5nLmN1YmljLm91dCwgXG4gICAgICAgICAgICBfbW92ZU1haW5TY3JvbGwsXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfc3RvcEFsbEFuaW1hdGlvbnMoKTtcbiAgICAgICAgICAgICAgICBfbWFpblNjcm9sbEFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9jdXJyWm9vbWVkSXRlbUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoaXRlbUNoYW5nZWQgfHwgX2N1cnJab29tZWRJdGVtSW5kZXggIT09IF9jdXJyZW50SXRlbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQ3Vyckl0ZW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgX3Nob3V0KCdtYWluU2Nyb2xsQW5pbUNvbXBsZXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYoaXRlbUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlQ3Vyckl0ZW0odHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbUNoYW5nZWQ7XG4gICAgfSxcblxuICAgIF9jYWxjdWxhdGVab29tTGV2ZWwgPSBmdW5jdGlvbih0b3VjaGVzRGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuICAxIC8gX3N0YXJ0UG9pbnRzRGlzdGFuY2UgKiB0b3VjaGVzRGlzdGFuY2UgKiBfc3RhcnRab29tTGV2ZWw7XG4gICAgfSxcblxuICAgIC8vIFJlc2V0cyB6b29tIGlmIGl0J3Mgb3V0IG9mIGJvdW5kc1xuICAgIF9jb21wbGV0ZVpvb21HZXN0dXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZXN0Wm9vbUxldmVsID0gX2N1cnJab29tTGV2ZWwsXG4gICAgICAgICAgICBtaW5ab29tTGV2ZWwgPSBfZ2V0TWluWm9vbUxldmVsKCksXG4gICAgICAgICAgICBtYXhab29tTGV2ZWwgPSBfZ2V0TWF4Wm9vbUxldmVsKCk7XG5cbiAgICAgICAgaWYgKCBfY3Vyclpvb21MZXZlbCA8IG1pblpvb21MZXZlbCApIHtcbiAgICAgICAgICAgIGRlc3Rab29tTGV2ZWwgPSBtaW5ab29tTGV2ZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoIF9jdXJyWm9vbUxldmVsID4gbWF4Wm9vbUxldmVsICkge1xuICAgICAgICAgICAgZGVzdFpvb21MZXZlbCA9IG1heFpvb21MZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXN0T3BhY2l0eSA9IDEsXG4gICAgICAgICAgICBvblVwZGF0ZSxcbiAgICAgICAgICAgIGluaXRpYWxPcGFjaXR5ID0gX2JnT3BhY2l0eTtcblxuICAgICAgICBpZihfb3BhY2l0eUNoYW5nZWQgJiYgIV9pc1pvb21pbmdJbiAmJiAhX3dhc092ZXJJbml0aWFsWm9vbSAmJiBfY3Vyclpvb21MZXZlbCA8IG1pblpvb21MZXZlbCkge1xuICAgICAgICAgICAgLy9fY2xvc2VkQnlTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZihfb3BhY2l0eUNoYW5nZWQpIHtcbiAgICAgICAgICAgIG9uVXBkYXRlID0gZnVuY3Rpb24obm93KSB7XG4gICAgICAgICAgICAgICAgX2FwcGx5QmdPcGFjaXR5KCAgKGRlc3RPcGFjaXR5IC0gaW5pdGlhbE9wYWNpdHkpICogbm93ICsgaW5pdGlhbE9wYWNpdHkgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnpvb21UbyhkZXN0Wm9vbUxldmVsLCAwLCAyMDAsICBmcmFtZXdvcmsuZWFzaW5nLmN1YmljLm91dCwgb25VcGRhdGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG5cbl9yZWdpc3Rlck1vZHVsZSgnR2VzdHVyZXMnLCB7XG4gICAgcHVibGljTWV0aG9kczoge1xuXG4gICAgICAgIGluaXRHZXN0dXJlczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8vIGhlbHBlciBmdW5jdGlvbiB0aGF0IGJ1aWxkcyB0b3VjaC9wb2ludGVyL21vdXNlIGV2ZW50c1xuICAgICAgICAgICAgdmFyIGFkZEV2ZW50TmFtZXMgPSBmdW5jdGlvbihwcmVmLCBkb3duLCBtb3ZlLCB1cCwgY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgX2RyYWdTdGFydEV2ZW50ID0gcHJlZiArIGRvd247XG4gICAgICAgICAgICAgICAgX2RyYWdNb3ZlRXZlbnQgPSBwcmVmICsgbW92ZTtcbiAgICAgICAgICAgICAgICBfZHJhZ0VuZEV2ZW50ID0gcHJlZiArIHVwO1xuICAgICAgICAgICAgICAgIGlmKGNhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICBfZHJhZ0NhbmNlbEV2ZW50ID0gcHJlZiArIGNhbmNlbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZHJhZ0NhbmNlbEV2ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX3BvaW50ZXJFdmVudEVuYWJsZWQgPSBfZmVhdHVyZXMucG9pbnRlckV2ZW50O1xuICAgICAgICAgICAgaWYoX3BvaW50ZXJFdmVudEVuYWJsZWQgJiYgX2ZlYXR1cmVzLnRvdWNoKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0b3VjaCBldmVudHMsIGlmIGJyb3dzZXIgc3VwcG9ydHMgcG9pbnRlciBldmVudHNcbiAgICAgICAgICAgICAgICBfZmVhdHVyZXMudG91Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZihuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnROYW1lcygncG9pbnRlcicsICdkb3duJywgJ21vdmUnLCAndXAnLCAnY2FuY2VsJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUxMCBwb2ludGVyIGV2ZW50cyBhcmUgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnROYW1lcygnTVNQb2ludGVyJywgJ0Rvd24nLCAnTW92ZScsICdVcCcsICdDYW5jZWwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoX2ZlYXR1cmVzLnRvdWNoKSB7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnROYW1lcygndG91Y2gnLCAnc3RhcnQnLCAnbW92ZScsICdlbmQnLCAnY2FuY2VsJyk7XG4gICAgICAgICAgICAgICAgX2xpa2VseVRvdWNoRGV2aWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnROYW1lcygnbW91c2UnLCAnZG93bicsICdtb3ZlJywgJ3VwJyk7ICAgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF91cE1vdmVFdmVudHMgPSBfZHJhZ01vdmVFdmVudCArICcgJyArIF9kcmFnRW5kRXZlbnQgICsgJyAnICsgIF9kcmFnQ2FuY2VsRXZlbnQ7XG4gICAgICAgICAgICBfZG93bkV2ZW50cyA9IF9kcmFnU3RhcnRFdmVudDtcblxuICAgICAgICAgICAgaWYoX3BvaW50ZXJFdmVudEVuYWJsZWQgJiYgIV9saWtlbHlUb3VjaERldmljZSkge1xuICAgICAgICAgICAgICAgIF9saWtlbHlUb3VjaERldmljZSA9IChuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxKSB8fCAobmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2UgdmFyaWFibGUgcHVibGljXG4gICAgICAgICAgICBzZWxmLmxpa2VseVRvdWNoRGV2aWNlID0gX2xpa2VseVRvdWNoRGV2aWNlOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgX2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdTdGFydEV2ZW50XSA9IF9vbkRyYWdTdGFydDtcbiAgICAgICAgICAgIF9nbG9iYWxFdmVudEhhbmRsZXJzW19kcmFnTW92ZUV2ZW50XSA9IF9vbkRyYWdNb3ZlO1xuICAgICAgICAgICAgX2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdFbmRFdmVudF0gPSBfb25EcmFnUmVsZWFzZTsgLy8gdGhlIEtyYWtlblxuXG4gICAgICAgICAgICBpZihfZHJhZ0NhbmNlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdDYW5jZWxFdmVudF0gPSBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ0VuZEV2ZW50XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQmluZCBtb3VzZSBldmVudHMgb24gZGV2aWNlIHdpdGggZGV0ZWN0ZWQgaGFyZHdhcmUgdG91Y2ggc3VwcG9ydCwgaW4gY2FzZSBpdCBzdXBwb3J0cyBtdWx0aXBsZSB0eXBlcyBvZiBpbnB1dC5cbiAgICAgICAgICAgIGlmKF9mZWF0dXJlcy50b3VjaCkge1xuICAgICAgICAgICAgICAgIF9kb3duRXZlbnRzICs9ICcgbW91c2Vkb3duJztcbiAgICAgICAgICAgICAgICBfdXBNb3ZlRXZlbnRzICs9ICcgbW91c2Vtb3ZlIG1vdXNldXAnO1xuICAgICAgICAgICAgICAgIF9nbG9iYWxFdmVudEhhbmRsZXJzLm1vdXNlZG93biA9IF9nbG9iYWxFdmVudEhhbmRsZXJzW19kcmFnU3RhcnRFdmVudF07XG4gICAgICAgICAgICAgICAgX2dsb2JhbEV2ZW50SGFuZGxlcnMubW91c2Vtb3ZlID0gX2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdNb3ZlRXZlbnRdO1xuICAgICAgICAgICAgICAgIF9nbG9iYWxFdmVudEhhbmRsZXJzLm1vdXNldXAgPSBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ0VuZEV2ZW50XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIV9saWtlbHlUb3VjaERldmljZSkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFsbG93IHBhbiB0byBuZXh0IHNsaWRlIGZyb20gem9vbWVkIHN0YXRlIG9uIERlc2t0b3BcbiAgICAgICAgICAgICAgICBfb3B0aW9ucy5hbGxvd1BhblRvTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG59KTtcblxuXG4vKj4+Z2VzdHVyZXMqL1xuXG4vKj4+c2hvdy1oaWRlLXRyYW5zaXRpb24qL1xuLyoqXG4gKiBzaG93LWhpZGUtdHJhbnNpdGlvbi5qczpcbiAqXG4gKiBNYW5hZ2VzIGluaXRpYWwgb3BlbmluZyBvciBjbG9zaW5nIHRyYW5zaXRpb24uXG4gKlxuICogSWYgeW91J3JlIG5vdCBwbGFubmluZyB0byB1c2UgdHJhbnNpdGlvbiBmb3IgZ2FsbGVyeSBhdCBhbGwsXG4gKiB5b3UgbWF5IHNldCBvcHRpb25zIGhpZGVBbmltYXRpb25EdXJhdGlvbiBhbmQgc2hvd0FuaW1hdGlvbkR1cmF0aW9uIHRvIDAsXG4gKiBhbmQganVzdCBkZWxldGUgc3RhcnRBbmltYXRpb24gZnVuY3Rpb24uXG4gKiBcbiAqL1xuXG5cbnZhciBfc2hvd09ySGlkZVRpbWVvdXQsXG4gICAgX3Nob3dPckhpZGUgPSBmdW5jdGlvbihpdGVtLCBpbWcsIG91dCwgY29tcGxldGVGbikge1xuXG4gICAgICAgIGlmKF9zaG93T3JIaWRlVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9zaG93T3JIaWRlVGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBfaW5pdGlhbFpvb21SdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgX2luaXRpYWxDb250ZW50U2V0ID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGRpbWVuc2lvbnMgb2Ygc21hbGwgdGh1bWJuYWlsIHt4Oix5Oix3On0uXG4gICAgICAgIC8vIEhlaWdodCBpcyBvcHRpb25hbCwgYXMgY2FsY3VsYXRlZCBiYXNlZCBvbiBsYXJnZSBpbWFnZS5cbiAgICAgICAgdmFyIHRodW1iQm91bmRzOyBcbiAgICAgICAgaWYoaXRlbS5pbml0aWFsTGF5b3V0KSB7XG4gICAgICAgICAgICB0aHVtYkJvdW5kcyA9IGl0ZW0uaW5pdGlhbExheW91dDtcbiAgICAgICAgICAgIGl0ZW0uaW5pdGlhbExheW91dCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHVtYkJvdW5kcyA9IF9vcHRpb25zLmdldFRodW1iQm91bmRzRm4gJiYgX29wdGlvbnMuZ2V0VGh1bWJCb3VuZHNGbihfY3VycmVudEl0ZW1JbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBvdXQgPyBfb3B0aW9ucy5oaWRlQW5pbWF0aW9uRHVyYXRpb24gOiBfb3B0aW9ucy5zaG93QW5pbWF0aW9uRHVyYXRpb247XG5cbiAgICAgICAgdmFyIG9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9zdG9wQW5pbWF0aW9uKCdpbml0aWFsWm9vbScpO1xuICAgICAgICAgICAgaWYoIW91dCkge1xuICAgICAgICAgICAgICAgIF9hcHBseUJnT3BhY2l0eSgxKTtcbiAgICAgICAgICAgICAgICBpZihpbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1hbmltYXRlZC1pbicpO1xuICAgICAgICAgICAgICAgIF9zaG91dCgnaW5pdGlhbFpvb20nICsgKG91dCA/ICdPdXRFbmQnIDogJ0luRW5kJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRlbXBsYXRlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICBzZWxmLmJnLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoY29tcGxldGVGbikge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9pbml0aWFsWm9vbVJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpZiBib3VuZHMgYXJlbid0IHByb3ZpZGVkLCBqdXN0IG9wZW4gZ2FsbGVyeSB3aXRob3V0IGFuaW1hdGlvblxuICAgICAgICBpZighZHVyYXRpb24gfHwgIXRodW1iQm91bmRzIHx8IHRodW1iQm91bmRzLnggPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBfc2hvdXQoJ2luaXRpYWxab29tJyArIChvdXQgPyAnT3V0JyA6ICdJbicpICk7XG5cbiAgICAgICAgICAgIF9jdXJyWm9vbUxldmVsID0gaXRlbS5pbml0aWFsWm9vbUxldmVsO1xuICAgICAgICAgICAgX2VxdWFsaXplUG9pbnRzKF9wYW5PZmZzZXQsICBpdGVtLmluaXRpYWxQb3NpdGlvbiApO1xuICAgICAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4oKTtcblxuICAgICAgICAgICAgdGVtcGxhdGUuc3R5bGUub3BhY2l0eSA9IG91dCA/IDAgOiAxO1xuICAgICAgICAgICAgX2FwcGx5QmdPcGFjaXR5KDEpO1xuXG4gICAgICAgICAgICBpZihkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2VXaXRoUmFmID0gX2Nsb3NlZEJ5U2Nyb2xsLFxuICAgICAgICAgICAgICAgIGZhZGVFdmVyeXRoaW5nID0gIXNlbGYuY3Vyckl0ZW0uc3JjIHx8IHNlbGYuY3Vyckl0ZW0ubG9hZEVycm9yIHx8IF9vcHRpb25zLnNob3dIaWRlT3BhY2l0eTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYXBwbHkgaHctYWNjZWxlcmF0aW9uIHRvIGltYWdlXG4gICAgICAgICAgICBpZihpdGVtLm1pbmlJbWcpIHtcbiAgICAgICAgICAgICAgICBpdGVtLm1pbmlJbWcuc3R5bGUud2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFvdXQpIHtcbiAgICAgICAgICAgICAgICBfY3Vyclpvb21MZXZlbCA9IHRodW1iQm91bmRzLncgLyBpdGVtLnc7XG4gICAgICAgICAgICAgICAgX3Bhbk9mZnNldC54ID0gdGh1bWJCb3VuZHMueDtcbiAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnkgPSB0aHVtYkJvdW5kcy55IC0gX2luaXRhbFdpbmRvd1Njcm9sbFk7XG5cbiAgICAgICAgICAgICAgICBzZWxmW2ZhZGVFdmVyeXRoaW5nID8gJ3RlbXBsYXRlJyA6ICdiZyddLnN0eWxlLm9wYWNpdHkgPSAwLjAwMTtcbiAgICAgICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfcmVnaXN0ZXJTdGFydEFuaW1hdGlvbignaW5pdGlhbFpvb20nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYob3V0ICYmICFjbG9zZVdpdGhSYWYpIHtcbiAgICAgICAgICAgICAgICBmcmFtZXdvcmsucmVtb3ZlQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1hbmltYXRlZC1pbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihmYWRlRXZlcnl0aGluZykge1xuICAgICAgICAgICAgICAgIGlmKG91dCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZXdvcmtbIChjbG9zZVdpdGhSYWYgPyAncmVtb3ZlJyA6ICdhZGQnKSArICdDbGFzcycgXSh0ZW1wbGF0ZSwgJ3Bzd3AtLWFuaW1hdGVfb3BhY2l0eScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1hbmltYXRlX29wYWNpdHknKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMzApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3Nob3dPckhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIF9zaG91dCgnaW5pdGlhbFpvb20nICsgKG91dCA/ICdPdXQnIDogJ0luJykgKTtcbiAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgIGlmKCFvdXQpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBcImluXCIgYW5pbWF0aW9uIGFsd2F5cyB1c2VzIENTUyB0cmFuc2l0aW9ucyAoaW5zdGVhZCBvZiByQUYpLlxuICAgICAgICAgICAgICAgICAgICAvLyBDU1MgdHJhbnNpdGlvbiB3b3JrIGZhc3RlciBoZXJlLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgZGV2ZWxvcGVyIG1heSBhbHNvIHdhbnQgdG8gYW5pbWF0ZSBvdGhlciB0aGluZ3MsIFxuICAgICAgICAgICAgICAgICAgICAvLyBsaWtlIHVpIG9uIHRvcCBvZiBzbGlkaW5nIGFyZWEsIHdoaWNoIGNhbiBiZSBhbmltYXRlZCBqdXN0IHZpYSBDU1NcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIF9jdXJyWm9vbUxldmVsID0gaXRlbS5pbml0aWFsWm9vbUxldmVsO1xuICAgICAgICAgICAgICAgICAgICBfZXF1YWxpemVQb2ludHMoX3Bhbk9mZnNldCwgIGl0ZW0uaW5pdGlhbFBvc2l0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgIF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgICAgICAgICAgICAgICAgIF9hcHBseUJnT3BhY2l0eSgxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihmYWRlRXZlcnl0aGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXBwbHlCZ09wYWNpdHkoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfc2hvd09ySGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uQ29tcGxldGUsIGR1cmF0aW9uICsgMjApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gXCJvdXRcIiBhbmltYXRpb24gdXNlcyByQUYgb25seSB3aGVuIFBob3RvU3dpcGUgaXMgY2xvc2VkIGJ5IGJyb3dzZXIgc2Nyb2xsLCB0byByZWNhbGN1bGF0ZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzdFpvb21MZXZlbCA9IHRodW1iQm91bmRzLncgLyBpdGVtLncsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsUGFuT2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IF9wYW5PZmZzZXQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBfcGFuT2Zmc2V0LnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsWm9vbUxldmVsID0gX2N1cnJab29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0YWxCZ09wYWNpdHkgPSBfYmdPcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25VcGRhdGUgPSBmdW5jdGlvbihub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihub3cgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJab29tTGV2ZWwgPSBkZXN0Wm9vbUxldmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnggPSB0aHVtYkJvdW5kcy54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnkgPSB0aHVtYkJvdW5kcy55ICAtIF9jdXJyZW50V2luZG93U2Nyb2xsWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3Vyclpvb21MZXZlbCA9IChkZXN0Wm9vbUxldmVsIC0gaW5pdGlhbFpvb21MZXZlbCkgKiBub3cgKyBpbml0aWFsWm9vbUxldmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnggPSAodGh1bWJCb3VuZHMueCAtIGluaXRpYWxQYW5PZmZzZXQueCkgKiBub3cgKyBpbml0aWFsUGFuT2Zmc2V0Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueSA9ICh0aHVtYkJvdW5kcy55IC0gX2N1cnJlbnRXaW5kb3dTY3JvbGxZIC0gaW5pdGlhbFBhbk9mZnNldC55KSAqIG5vdyArIGluaXRpYWxQYW5PZmZzZXQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmYWRlRXZlcnl0aGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5zdHlsZS5vcGFjaXR5ID0gMSAtIG5vdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXBwbHlCZ09wYWNpdHkoIGluaXRhbEJnT3BhY2l0eSAtIG5vdyAqIGluaXRhbEJnT3BhY2l0eSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoY2xvc2VXaXRoUmFmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYW5pbWF0ZVByb3AoJ2luaXRpYWxab29tJywgMCwgMSwgZHVyYXRpb24sIGZyYW1ld29yay5lYXNpbmcuY3ViaWMub3V0LCBvblVwZGF0ZSwgb25Db21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaG93T3JIaWRlVGltZW91dCA9IHNldFRpbWVvdXQob25Db21wbGV0ZSwgZHVyYXRpb24gKyAyMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH0sIG91dCA/IDI1IDogOTApOyAvLyBNYWluIHB1cnBvc2Ugb2YgdGhpcyBkZWxheSBpcyB0byBnaXZlIGJyb3dzZXIgdGltZSB0byBwYWludCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGNvbXBvc2l0ZSBsYXllcnMgb2YgUGhvdG9Td2lwZSBVSSBwYXJ0cyAoYmFja2dyb3VuZCwgY29udHJvbHMsIGNhcHRpb24sIGFycm93cykuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoaWNoIGF2b2lkcyBsYWcgYXQgdGhlIGJlZ2lubmluZyBvZiBzY2FsZSB0cmFuc2l0aW9uLlxuICAgICAgICB9O1xuICAgICAgICBzdGFydEFuaW1hdGlvbigpO1xuXG4gICAgICAgIFxuICAgIH07XG5cbi8qPj5zaG93LWhpZGUtdHJhbnNpdGlvbiovXG5cbi8qPj5pdGVtcy1jb250cm9sbGVyKi9cbi8qKlxuKlxuKiBDb250cm9sbGVyIG1hbmFnZXMgZ2FsbGVyeSBpdGVtcywgdGhlaXIgZGltZW5zaW9ucywgYW5kIHRoZWlyIGNvbnRlbnQuXG4qIFxuKi9cblxudmFyIF9pdGVtcyxcbiAgICBfdGVtcFBhbkFyZWFTaXplID0ge30sXG4gICAgX2ltYWdlc1RvQXBwZW5kUG9vbCA9IFtdLFxuICAgIF9pbml0aWFsQ29udGVudFNldCxcbiAgICBfaW5pdGlhbFpvb21SdW5uaW5nLFxuICAgIF9jb250cm9sbGVyRGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBlcnJvck1zZzogJzxkaXYgY2xhc3M9XCJwc3dwX19lcnJvci1tc2dcIj48YSBocmVmPVwiJXVybCVcIiB0YXJnZXQ9XCJfYmxhbmtcIj5UaGUgaW1hZ2U8L2E+IGNvdWxkIG5vdCBiZSBsb2FkZWQuPC9kaXY+JyxcbiAgICAgICAgZm9yY2VQcm9ncmVzc2l2ZUxvYWRpbmc6IGZhbHNlLCAvLyBUT0RPXG4gICAgICAgIHByZWxvYWQ6IFsxLDFdLFxuICAgICAgICBnZXROdW1JdGVtc0ZuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcblxuXG52YXIgX2dldEl0ZW1BdCxcbiAgICBfZ2V0TnVtSXRlbXMsXG4gICAgX2luaXRpYWxJc0xvb3AsXG4gICAgX2dldFplcm9Cb3VuZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNlbnRlcjp7eDowLHk6MH0sIFxuICAgICAgICAgICAgbWF4Ont4OjAseTowfSwgXG4gICAgICAgICAgICBtaW46e3g6MCx5OjB9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBfY2FsY3VsYXRlU2luZ2xlSXRlbVBhbkJvdW5kcyA9IGZ1bmN0aW9uKGl0ZW0sIHJlYWxQYW5FbGVtZW50VywgcmVhbFBhbkVsZW1lbnRIICkge1xuICAgICAgICB2YXIgYm91bmRzID0gaXRlbS5ib3VuZHM7XG5cbiAgICAgICAgLy8gcG9zaXRpb24gb2YgZWxlbWVudCB3aGVuIGl0J3MgY2VudGVyZWRcbiAgICAgICAgYm91bmRzLmNlbnRlci54ID0gTWF0aC5yb3VuZCgoX3RlbXBQYW5BcmVhU2l6ZS54IC0gcmVhbFBhbkVsZW1lbnRXKSAvIDIpO1xuICAgICAgICBib3VuZHMuY2VudGVyLnkgPSBNYXRoLnJvdW5kKChfdGVtcFBhbkFyZWFTaXplLnkgLSByZWFsUGFuRWxlbWVudEgpIC8gMikgKyBpdGVtLnZHYXAudG9wO1xuXG4gICAgICAgIC8vIG1heGltdW0gcGFuIHBvc2l0aW9uXG4gICAgICAgIGJvdW5kcy5tYXgueCA9IChyZWFsUGFuRWxlbWVudFcgPiBfdGVtcFBhbkFyZWFTaXplLngpID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChfdGVtcFBhbkFyZWFTaXplLnggLSByZWFsUGFuRWxlbWVudFcpIDogXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLmNlbnRlci54O1xuICAgICAgICBcbiAgICAgICAgYm91bmRzLm1heC55ID0gKHJlYWxQYW5FbGVtZW50SCA+IF90ZW1wUGFuQXJlYVNpemUueSkgPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKF90ZW1wUGFuQXJlYVNpemUueSAtIHJlYWxQYW5FbGVtZW50SCkgKyBpdGVtLnZHYXAudG9wIDogXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLmNlbnRlci55O1xuICAgICAgICBcbiAgICAgICAgLy8gbWluaW11bSBwYW4gcG9zaXRpb25cbiAgICAgICAgYm91bmRzLm1pbi54ID0gKHJlYWxQYW5FbGVtZW50VyA+IF90ZW1wUGFuQXJlYVNpemUueCkgPyAwIDogYm91bmRzLmNlbnRlci54O1xuICAgICAgICBib3VuZHMubWluLnkgPSAocmVhbFBhbkVsZW1lbnRIID4gX3RlbXBQYW5BcmVhU2l6ZS55KSA/IGl0ZW0udkdhcC50b3AgOiBib3VuZHMuY2VudGVyLnk7XG4gICAgfSxcbiAgICBfY2FsY3VsYXRlSXRlbVNpemUgPSBmdW5jdGlvbihpdGVtLCB2aWV3cG9ydFNpemUsIHpvb21MZXZlbCkge1xuXG4gICAgICAgIGlmIChpdGVtLnNyYyAmJiAhaXRlbS5sb2FkRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBpc0luaXRpYWwgPSAhem9vbUxldmVsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihpc0luaXRpYWwpIHtcbiAgICAgICAgICAgICAgICBpZighaXRlbS52R2FwKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udkdhcCA9IHt0b3A6MCxib3R0b206MH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFsbG93cyBvdmVycmlkaW5nIHZlcnRpY2FsIG1hcmdpbiBmb3IgaW5kaXZpZHVhbCBpdGVtc1xuICAgICAgICAgICAgICAgIF9zaG91dCgncGFyc2VWZXJ0aWNhbE1hcmdpbicsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIF90ZW1wUGFuQXJlYVNpemUueCA9IHZpZXdwb3J0U2l6ZS54O1xuICAgICAgICAgICAgX3RlbXBQYW5BcmVhU2l6ZS55ID0gdmlld3BvcnRTaXplLnkgLSBpdGVtLnZHYXAudG9wIC0gaXRlbS52R2FwLmJvdHRvbTtcblxuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIHZhciBoUmF0aW8gPSBfdGVtcFBhbkFyZWFTaXplLnggLyBpdGVtLnc7XG4gICAgICAgICAgICAgICAgdmFyIHZSYXRpbyA9IF90ZW1wUGFuQXJlYVNpemUueSAvIGl0ZW0uaDtcblxuICAgICAgICAgICAgICAgIGl0ZW0uZml0UmF0aW8gPSBoUmF0aW8gPCB2UmF0aW8gPyBoUmF0aW8gOiB2UmF0aW87XG4gICAgICAgICAgICAgICAgLy9pdGVtLmZpbGxSYXRpbyA9IGhSYXRpbyA+IHZSYXRpbyA/IGhSYXRpbyA6IHZSYXRpbztcblxuICAgICAgICAgICAgICAgIHZhciBzY2FsZU1vZGUgPSBfb3B0aW9ucy5zY2FsZU1vZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NhbGVNb2RlID09PSAnb3JpZycpIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbUxldmVsID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjYWxlTW9kZSA9PT0gJ2ZpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbUxldmVsID0gaXRlbS5maXRSYXRpbztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoem9vbUxldmVsID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB6b29tTGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0uaW5pdGlhbFpvb21MZXZlbCA9IHpvb21MZXZlbDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZighaXRlbS5ib3VuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV1c2UgYm91bmRzIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBpdGVtLmJvdW5kcyA9IF9nZXRaZXJvQm91bmRzKCk7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIXpvb21MZXZlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NhbGN1bGF0ZVNpbmdsZUl0ZW1QYW5Cb3VuZHMoaXRlbSwgaXRlbS53ICogem9vbUxldmVsLCBpdGVtLmggKiB6b29tTGV2ZWwpO1xuXG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsICYmIHpvb21MZXZlbCA9PT0gaXRlbS5pbml0aWFsWm9vbUxldmVsKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5pbml0aWFsUG9zaXRpb24gPSBpdGVtLmJvdW5kcy5jZW50ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtLmJvdW5kcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0udyA9IGl0ZW0uaCA9IDA7XG4gICAgICAgICAgICBpdGVtLmluaXRpYWxab29tTGV2ZWwgPSBpdGVtLmZpdFJhdGlvID0gMTtcbiAgICAgICAgICAgIGl0ZW0uYm91bmRzID0gX2dldFplcm9Cb3VuZHMoKTtcbiAgICAgICAgICAgIGl0ZW0uaW5pdGlhbFBvc2l0aW9uID0gaXRlbS5ib3VuZHMuY2VudGVyO1xuXG4gICAgICAgICAgICAvLyBpZiBpdCdzIG5vdCBpbWFnZSwgd2UgcmV0dXJuIHplcm8gYm91bmRzIChjb250ZW50IGlzIG5vdCB6b29tYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmJvdW5kcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9LFxuXG4gICAgXG5cblxuICAgIF9hcHBlbmRJbWFnZSA9IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBiYXNlRGl2LCBpbWcsIHByZXZlbnRBbmltYXRpb24sIGtlZXBQbGFjZWhvbGRlcikge1xuICAgICAgICBcblxuICAgICAgICBpZihpdGVtLmxvYWRFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaW1nKSB7XG5cbiAgICAgICAgICAgIGl0ZW0uaW1hZ2VBcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICBfc2V0SW1hZ2VTaXplKGl0ZW0sIGltZywgKGl0ZW0gPT09IHNlbGYuY3Vyckl0ZW0gJiYgX3JlbmRlck1heFJlc29sdXRpb24pICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGJhc2VEaXYuYXBwZW5kQ2hpbGQoaW1nKTtcblxuICAgICAgICAgICAgaWYoa2VlcFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbSAmJiBpdGVtLmxvYWRlZCAmJiBpdGVtLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuXG5cbiAgICBfcHJlbG9hZEltYWdlID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpdGVtLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICBpdGVtLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaW1nID0gaXRlbS5pbWcgPSBmcmFtZXdvcmsuY3JlYXRlRWwoJ3Bzd3BfX2ltZycsICdpbWcnKTtcbiAgICAgICAgdmFyIG9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGl0ZW0ubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaXRlbS5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZihpdGVtLmxvYWRDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0ubG9hZENvbXBsZXRlKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmltZyA9IG51bGw7IC8vIG5vIG5lZWQgdG8gc3RvcmUgaW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgaW1nID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9ubG9hZCA9IG9uQ29tcGxldGU7XG4gICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpdGVtLmxvYWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIH07ICAgICAgXG5cbiAgICAgICAgaW1nLnNyYyA9IGl0ZW0uc3JjOy8vICsgJz9hPScgKyBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgfSxcbiAgICBfY2hlY2tGb3JFcnJvciA9IGZ1bmN0aW9uKGl0ZW0sIGNsZWFuVXApIHtcbiAgICAgICAgaWYoaXRlbS5zcmMgJiYgaXRlbS5sb2FkRXJyb3IgJiYgaXRlbS5jb250YWluZXIpIHtcblxuICAgICAgICAgICAgaWYoY2xlYW5VcCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLmNvbnRhaW5lci5pbm5lckhUTUwgPSBfb3B0aW9ucy5lcnJvck1zZy5yZXBsYWNlKCcldXJsJScsICBpdGVtLnNyYyApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3NldEltYWdlU2l6ZSA9IGZ1bmN0aW9uKGl0ZW0sIGltZywgbWF4UmVzKSB7XG4gICAgICAgIGlmKCFpdGVtLnNyYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWltZykge1xuICAgICAgICAgICAgaW1nID0gaXRlbS5jb250YWluZXIubGFzdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHcgPSBtYXhSZXMgPyBpdGVtLncgOiBNYXRoLnJvdW5kKGl0ZW0udyAqIGl0ZW0uZml0UmF0aW8pLFxuICAgICAgICAgICAgaCA9IG1heFJlcyA/IGl0ZW0uaCA6IE1hdGgucm91bmQoaXRlbS5oICogaXRlbS5maXRSYXRpbyk7XG4gICAgICAgIFxuICAgICAgICBpZihpdGVtLnBsYWNlaG9sZGVyICYmICFpdGVtLmxvYWRlZCkge1xuICAgICAgICAgICAgaXRlbS5wbGFjZWhvbGRlci5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICAgICAgaXRlbS5wbGFjZWhvbGRlci5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGltZy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICBpbWcuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgfSxcbiAgICBfYXBwZW5kSW1hZ2VzUG9vbCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmKF9pbWFnZXNUb0FwcGVuZFBvb2wubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcG9vbEl0ZW07XG5cbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBfaW1hZ2VzVG9BcHBlbmRQb29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9vbEl0ZW0gPSBfaW1hZ2VzVG9BcHBlbmRQb29sW2ldO1xuICAgICAgICAgICAgICAgIGlmKCBwb29sSXRlbS5ob2xkZXIuaW5kZXggPT09IHBvb2xJdGVtLmluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICBfYXBwZW5kSW1hZ2UocG9vbEl0ZW0uaW5kZXgsIHBvb2xJdGVtLml0ZW0sIHBvb2xJdGVtLmJhc2VEaXYsIHBvb2xJdGVtLmltZywgZmFsc2UsIHBvb2xJdGVtLmNsZWFyUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9pbWFnZXNUb0FwcGVuZFBvb2wgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG5cblxuX3JlZ2lzdGVyTW9kdWxlKCdDb250cm9sbGVyJywge1xuXG4gICAgcHVibGljTWV0aG9kczoge1xuXG4gICAgICAgIGxhenlMb2FkSXRlbTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gX2dldExvb3BlZElkKGluZGV4KTtcbiAgICAgICAgICAgIHZhciBpdGVtID0gX2dldEl0ZW1BdChpbmRleCk7XG5cbiAgICAgICAgICAgIGlmKCFpdGVtIHx8ICgoaXRlbS5sb2FkZWQgfHwgaXRlbS5sb2FkaW5nKSAmJiAhX2l0ZW1zTmVlZFVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zaG91dCgnZ2V0dGluZ0RhdGEnLCBpbmRleCwgaXRlbSk7XG5cbiAgICAgICAgICAgIGlmICghaXRlbS5zcmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9wcmVsb2FkSW1hZ2UoaXRlbSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRDb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZyYW1ld29yay5leHRlbmQoX29wdGlvbnMsIF9jb250cm9sbGVyRGVmYXVsdE9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5pdGVtcyA9IF9pdGVtcyA9IGl0ZW1zO1xuICAgICAgICAgICAgX2dldEl0ZW1BdCA9IHNlbGYuZ2V0SXRlbUF0O1xuICAgICAgICAgICAgX2dldE51bUl0ZW1zID0gX29wdGlvbnMuZ2V0TnVtSXRlbXNGbjsgLy9zZWxmLmdldE51bUl0ZW1zO1xuXG5cblxuICAgICAgICAgICAgX2luaXRpYWxJc0xvb3AgPSBfb3B0aW9ucy5sb29wO1xuICAgICAgICAgICAgaWYoX2dldE51bUl0ZW1zKCkgPCAzKSB7XG4gICAgICAgICAgICAgICAgX29wdGlvbnMubG9vcCA9IGZhbHNlOyAvLyBkaXNhYmxlIGxvb3AgaWYgbGVzcyB0aGVuIDMgaXRlbXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2xpc3RlbignYmVmb3JlQ2hhbmdlJywgZnVuY3Rpb24oZGlmZikge1xuXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBfb3B0aW9ucy5wcmVsb2FkLFxuICAgICAgICAgICAgICAgICAgICBpc05leHQgPSBkaWZmID09PSBudWxsID8gdHJ1ZSA6IChkaWZmID49IDApLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkQmVmb3JlID0gTWF0aC5taW4ocFswXSwgX2dldE51bUl0ZW1zKCkgKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZEFmdGVyID0gTWF0aC5taW4ocFsxXSwgX2dldE51bUl0ZW1zKCkgKSxcbiAgICAgICAgICAgICAgICAgICAgaTtcblxuXG4gICAgICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDw9IChpc05leHQgPyBwcmVsb2FkQWZ0ZXIgOiBwcmVsb2FkQmVmb3JlKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF6eUxvYWRJdGVtKF9jdXJyZW50SXRlbUluZGV4K2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IoaSA9IDE7IGkgPD0gKGlzTmV4dCA/IHByZWxvYWRCZWZvcmUgOiBwcmVsb2FkQWZ0ZXIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXp5TG9hZEl0ZW0oX2N1cnJlbnRJdGVtSW5kZXgtaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF9saXN0ZW4oJ2luaXRpYWxMYXlvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJJdGVtLmluaXRpYWxMYXlvdXQgPSBfb3B0aW9ucy5nZXRUaHVtYkJvdW5kc0ZuICYmIF9vcHRpb25zLmdldFRodW1iQm91bmRzRm4oX2N1cnJlbnRJdGVtSW5kZXgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF9saXN0ZW4oJ21haW5TY3JvbGxBbmltQ29tcGxldGUnLCBfYXBwZW5kSW1hZ2VzUG9vbCk7XG4gICAgICAgICAgICBfbGlzdGVuKCdpbml0aWFsWm9vbUluRW5kJywgX2FwcGVuZEltYWdlc1Bvb2wpO1xuXG5cblxuICAgICAgICAgICAgX2xpc3RlbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBfaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IF9pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBET00gZWxlbWVudHMsIGZvciBHQ1xuICAgICAgICAgICAgICAgICAgICBpZihpdGVtLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb250YWluZXIgPSBudWxsOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihpdGVtLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihpdGVtLmltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5pbWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0ucHJlbG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnByZWxvYWRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5sb2FkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubG9hZGVkID0gaXRlbS5sb2FkRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfaW1hZ2VzVG9BcHBlbmRQb29sID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgZ2V0SXRlbUF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2l0ZW1zW2luZGV4XSAhPT0gdW5kZWZpbmVkID8gX2l0ZW1zW2luZGV4XSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFsbG93UHJvZ3Jlc3NpdmVJbWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gMS4gUHJvZ3Jlc3NpdmUgaW1hZ2UgbG9hZGluZyBpc24ndCB3b3JraW5nIG9uIHdlYmtpdC9ibGluayBcbiAgICAgICAgICAgIC8vICAgIHdoZW4gaHctYWNjZWxlcmF0aW9uIChlLmcuIHRyYW5zbGF0ZVopIGlzIGFwcGxpZWQgdG8gSU1HIGVsZW1lbnQuXG4gICAgICAgICAgICAvLyAgICBUaGF0J3Mgd2h5IGluIFBob3RvU3dpcGUgcGFyZW50IGVsZW1lbnQgZ2V0cyB6b29tIHRyYW5zZm9ybSwgbm90IGltYWdlIGl0c2VsZi5cbiAgICAgICAgICAgIC8vICAgIFxuICAgICAgICAgICAgLy8gMi4gUHJvZ3Jlc3NpdmUgaW1hZ2UgbG9hZGluZyBzb21ldGltZXMgYmxpbmtzIGluIHdlYmtpdC9ibGluayB3aGVuIGFwcGx5aW5nIGFuaW1hdGlvbiB0byBwYXJlbnQgZWxlbWVudC5cbiAgICAgICAgICAgIC8vICAgIFRoYXQncyB3aHkgaXQncyBkaXNhYmxlZCBvbiB0b3VjaCBkZXZpY2VzIChtYWlubHkgYmVjYXVzZSBvZiBzd2lwZSB0cmFuc2l0aW9uKVxuICAgICAgICAgICAgLy8gICAgXG4gICAgICAgICAgICAvLyAzLiBQcm9ncmVzc2l2ZSBpbWFnZSBsb2FkaW5nIHNvbWV0aW1lcyBkb2Vzbid0IHdvcmsgaW4gSUUgKHVwIHRvIDExKS5cblxuICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcHJvZ3Jlc3NpdmUgbG9hZGluZyBvbiBub24tbGFyZ2UgdG91Y2ggZGV2aWNlc1xuICAgICAgICAgICAgcmV0dXJuIF9vcHRpb25zLmZvcmNlUHJvZ3Jlc3NpdmVMb2FkaW5nIHx8ICFfbGlrZWx5VG91Y2hEZXZpY2UgfHwgX29wdGlvbnMubW91c2VVc2VkIHx8IHNjcmVlbi53aWR0aCA+IDEyMDA7IFxuICAgICAgICAgICAgLy8gMTIwMCAtIHRvIGVsaW1pbmF0ZSB0b3VjaCBkZXZpY2VzIHdpdGggbGFyZ2Ugc2NyZWVuIChsaWtlIENocm9tZWJvb2sgUGl4ZWwpXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0Q29udGVudDogZnVuY3Rpb24oaG9sZGVyLCBpbmRleCkge1xuXG4gICAgICAgICAgICBpZihfb3B0aW9ucy5sb29wKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBfZ2V0TG9vcGVkSWQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJldkl0ZW0gPSBzZWxmLmdldEl0ZW1BdChob2xkZXIuaW5kZXgpO1xuICAgICAgICAgICAgaWYocHJldkl0ZW0pIHtcbiAgICAgICAgICAgICAgICBwcmV2SXRlbS5jb250YWluZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBzZWxmLmdldEl0ZW1BdChpbmRleCksXG4gICAgICAgICAgICAgICAgaW1nO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighaXRlbSkge1xuICAgICAgICAgICAgICAgIGhvbGRlci5lbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsbG93IHRvIG92ZXJyaWRlIGRhdGFcbiAgICAgICAgICAgIF9zaG91dCgnZ2V0dGluZ0RhdGEnLCBpbmRleCwgaXRlbSk7XG5cbiAgICAgICAgICAgIGhvbGRlci5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaG9sZGVyLml0ZW0gPSBpdGVtO1xuXG4gICAgICAgICAgICAvLyBiYXNlIGNvbnRhaW5lciBESVYgaXMgY3JlYXRlZCBvbmx5IG9uY2UgZm9yIGVhY2ggb2YgMyBob2xkZXJzXG4gICAgICAgICAgICB2YXIgYmFzZURpdiA9IGl0ZW0uY29udGFpbmVyID0gZnJhbWV3b3JrLmNyZWF0ZUVsKCdwc3dwX196b29tLXdyYXAnKTsgXG5cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZighaXRlbS5zcmMgJiYgaXRlbS5odG1sKSB7XG4gICAgICAgICAgICAgICAgaWYoaXRlbS5odG1sLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZChpdGVtLmh0bWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VEaXYuaW5uZXJIVE1MID0gaXRlbS5odG1sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NoZWNrRm9yRXJyb3IoaXRlbSk7XG5cbiAgICAgICAgICAgIF9jYWxjdWxhdGVJdGVtU2l6ZShpdGVtLCBfdmlld3BvcnRTaXplKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoaXRlbS5zcmMgJiYgIWl0ZW0ubG9hZEVycm9yICYmICFpdGVtLmxvYWRlZCkge1xuXG4gICAgICAgICAgICAgICAgaXRlbS5sb2FkQ29tcGxldGUgPSBmdW5jdGlvbihpdGVtKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2FsbGVyeSBjbG9zZWQgYmVmb3JlIGltYWdlIGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYoIV9pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGhvbGRlciBoYXNuJ3QgY2hhbmdlZCB3aGlsZSBpbWFnZSB3YXMgbG9hZGluZ1xuICAgICAgICAgICAgICAgICAgICBpZihob2xkZXIgJiYgaG9sZGVyLmluZGV4ID09PSBpbmRleCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfY2hlY2tGb3JFcnJvcihpdGVtLCB0cnVlKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmxvYWRDb21wbGV0ZSA9IGl0ZW0uaW1nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2FsY3VsYXRlSXRlbVNpemUoaXRlbSwgX3ZpZXdwb3J0U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FwcGx5Wm9vbVBhblRvSXRlbShpdGVtKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGhvbGRlci5pbmRleCA9PT0gX2N1cnJlbnRJdGVtSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUN1cnJab29tSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggIWl0ZW0uaW1hZ2VBcHBlbmRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihfZmVhdHVyZXMudHJhbnNmb3JtICYmIChfbWFpblNjcm9sbEFuaW1hdGluZyB8fCBfaW5pdGlhbFpvb21SdW5uaW5nKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ltYWdlc1RvQXBwZW5kUG9vbC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06aXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VEaXY6YmFzZURpdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzppdGVtLmltZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyOmhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyUGxhY2Vob2xkZXI6dHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXBwZW5kSW1hZ2UoaW5kZXgsIGl0ZW0sIGJhc2VEaXYsIGl0ZW0uaW1nLCBfbWFpblNjcm9sbEFuaW1hdGluZyB8fCBfaW5pdGlhbFpvb21SdW5uaW5nLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwcmVsb2FkZXIgJiBtaW5pLWltZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFfaW5pdGlhbFpvb21SdW5uaW5nICYmIGl0ZW0ucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5wbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpdGVtLmxvYWRDb21wbGV0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaW1nID0gbnVsbDsgLy8gbm8gbmVlZCB0byBzdG9yZSBpbWFnZSBlbGVtZW50IGFmdGVyIGl0J3MgYWRkZWRcblxuICAgICAgICAgICAgICAgICAgICBfc2hvdXQoJ2ltYWdlTG9hZENvbXBsZXRlJywgaW5kZXgsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZihmcmFtZXdvcmsuZmVhdHVyZXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJDbGFzc05hbWUgPSAncHN3cF9faW1nIHBzd3BfX2ltZy0tcGxhY2Vob2xkZXInOyBcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJDbGFzc05hbWUgKz0gKGl0ZW0ubXNyYyA/ICcnIDogJyBwc3dwX19pbWctLXBsYWNlaG9sZGVyLS1ibGFuaycpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGZyYW1ld29yay5jcmVhdGVFbChwbGFjZWhvbGRlckNsYXNzTmFtZSwgaXRlbS5tc3JjID8gJ2ltZycgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0ubXNyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIuc3JjID0gaXRlbS5tc3JjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBfc2V0SW1hZ2VTaXplKGl0ZW0sIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgICAgICAgICAgICBiYXNlRGl2LmFwcGVuZENoaWxkKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICBpZighaXRlbS5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wcmVsb2FkSW1hZ2UoaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBpZiggc2VsZi5hbGxvd1Byb2dyZXNzaXZlSW1nKCkgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYXBwZW5kIGltYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmKCFfaW5pdGlhbENvbnRlbnRTZXQgJiYgX2ZlYXR1cmVzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ltYWdlc1RvQXBwZW5kUG9vbC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOml0ZW0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VEaXY6YmFzZURpdiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nOml0ZW0uaW1nLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDppbmRleCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyOmhvbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXBwZW5kSW1hZ2UoaW5kZXgsIGl0ZW0sIGJhc2VEaXYsIGl0ZW0uaW1nLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSBpZihpdGVtLnNyYyAmJiAhaXRlbS5sb2FkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBpbWFnZSBvYmplY3QgaXMgY3JlYXRlZCBldmVyeSB0aW1lLCBkdWUgdG8gYnVncyBvZiBpbWFnZSBsb2FkaW5nICYgZGVsYXkgd2hlbiBzd2l0Y2hpbmcgaW1hZ2VzXG4gICAgICAgICAgICAgICAgaW1nID0gZnJhbWV3b3JrLmNyZWF0ZUVsKCdwc3dwX19pbWcnLCAnaW1nJyk7XG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBpdGVtLnNyYztcbiAgICAgICAgICAgICAgICBfc2V0SW1hZ2VTaXplKGl0ZW0sIGltZyk7XG4gICAgICAgICAgICAgICAgX2FwcGVuZEltYWdlKGluZGV4LCBpdGVtLCBiYXNlRGl2LCBpbWcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGlmKCFfaW5pdGlhbENvbnRlbnRTZXQgJiYgaW5kZXggPT09IF9jdXJyZW50SXRlbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgX2N1cnJab29tRWxlbWVudFN0eWxlID0gYmFzZURpdi5zdHlsZTtcbiAgICAgICAgICAgICAgICBfc2hvd09ySGlkZShpdGVtLCAoaW1nIHx8aXRlbS5pbWcpICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9hcHBseVpvb21QYW5Ub0l0ZW0oaXRlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvbGRlci5lbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIGhvbGRlci5lbC5hcHBlbmRDaGlsZChiYXNlRGl2KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhblNsaWRlOiBmdW5jdGlvbiggaXRlbSApIHtcbiAgICAgICAgICAgIGlmKGl0ZW0uaW1nICkge1xuICAgICAgICAgICAgICAgIGl0ZW0uaW1nLm9ubG9hZCA9IGl0ZW0uaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5sb2FkZWQgPSBpdGVtLmxvYWRpbmcgPSBpdGVtLmltZyA9IGl0ZW0uaW1hZ2VBcHBlbmRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICB9XG59KTtcblxuLyo+Pml0ZW1zLWNvbnRyb2xsZXIqL1xuXG4vKj4+dGFwKi9cbi8qKlxuICogdGFwLmpzOlxuICpcbiAqIERpc3BsYXRjaGVzIHRhcCBhbmQgZG91YmxlLXRhcCBldmVudHMuXG4gKiBcbiAqL1xuXG52YXIgdGFwVGltZXIsXG4gICAgdGFwUmVsZWFzZVBvaW50ID0ge30sXG4gICAgX2Rpc3BhdGNoVGFwRXZlbnQgPSBmdW5jdGlvbihvcmlnRXZlbnQsIHJlbGVhc2VQb2ludCwgcG9pbnRlclR5cGUpIHsgICAgICAgIFxuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCAnQ3VzdG9tRXZlbnQnICksXG4gICAgICAgICAgICBlRGV0YWlsID0ge1xuICAgICAgICAgICAgICAgIG9yaWdFdmVudDpvcmlnRXZlbnQsIFxuICAgICAgICAgICAgICAgIHRhcmdldDpvcmlnRXZlbnQudGFyZ2V0LCBcbiAgICAgICAgICAgICAgICByZWxlYXNlUG9pbnQ6IHJlbGVhc2VQb2ludCwgXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6cG9pbnRlclR5cGUgfHwgJ3RvdWNoJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBlLmluaXRDdXN0b21FdmVudCggJ3Bzd3BUYXAnLCB0cnVlLCB0cnVlLCBlRGV0YWlsICk7XG4gICAgICAgIG9yaWdFdmVudC50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB9O1xuXG5fcmVnaXN0ZXJNb2R1bGUoJ1RhcCcsIHtcbiAgICBwdWJsaWNNZXRob2RzOiB7XG4gICAgICAgIGluaXRUYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX2xpc3RlbignZmlyc3RUb3VjaFN0YXJ0Jywgc2VsZi5vblRhcFN0YXJ0KTtcbiAgICAgICAgICAgIF9saXN0ZW4oJ3RvdWNoUmVsZWFzZScsIHNlbGYub25UYXBSZWxlYXNlKTtcbiAgICAgICAgICAgIF9saXN0ZW4oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0YXBSZWxlYXNlUG9pbnQgPSB7fTtcbiAgICAgICAgICAgICAgICB0YXBUaW1lciA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UYXBTdGFydDogZnVuY3Rpb24odG91Y2hMaXN0KSB7XG4gICAgICAgICAgICBpZih0b3VjaExpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0YXBUaW1lcik7XG4gICAgICAgICAgICAgICAgdGFwVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblRhcFJlbGVhc2U6IGZ1bmN0aW9uKGUsIHJlbGVhc2VQb2ludCkge1xuICAgICAgICAgICAgaWYoIXJlbGVhc2VQb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIV9tb3ZlZCAmJiAhX2lzTXVsdGl0b3VjaCAmJiAhX251bUFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcDAgPSByZWxlYXNlUG9pbnQ7XG4gICAgICAgICAgICAgICAgaWYodGFwVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcFRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGFwVGltZXIgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRhcGVkIG9uIHRoZSBzYW1lIHBsYWNlXG4gICAgICAgICAgICAgICAgICAgIGlmICggX2lzTmVhcmJ5UG9pbnRzKHAwLCB0YXBSZWxlYXNlUG9pbnQpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Nob3V0KCdkb3VibGVUYXAnLCBwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihyZWxlYXNlUG9pbnQudHlwZSA9PT0gJ21vdXNlJykge1xuICAgICAgICAgICAgICAgICAgICBfZGlzcGF0Y2hUYXBFdmVudChlLCByZWxlYXNlUG9pbnQsICdtb3VzZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNsaWNrZWRUYWdOYW1lID0gZS50YXJnZXQudGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIGRvdWJsZSB0YXAgZGVsYXkgb24gYnV0dG9ucyBhbmQgZWxlbWVudHMgdGhhdCBoYXZlIGNsYXNzIHBzd3BfX3NpbmdsZS10YXBcbiAgICAgICAgICAgICAgICBpZihjbGlja2VkVGFnTmFtZSA9PT0gJ0JVVFRPTicgfHwgZnJhbWV3b3JrLmhhc0NsYXNzKGUudGFyZ2V0LCAncHN3cF9fc2luZ2xlLXRhcCcpICkge1xuICAgICAgICAgICAgICAgICAgICBfZGlzcGF0Y2hUYXBFdmVudChlLCByZWxlYXNlUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2VxdWFsaXplUG9pbnRzKHRhcFJlbGVhc2VQb2ludCwgcDApO1xuXG4gICAgICAgICAgICAgICAgdGFwVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfZGlzcGF0Y2hUYXBFdmVudChlLCByZWxlYXNlUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB0YXBUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKj4+dGFwKi9cblxuLyo+PmRlc2t0b3Atem9vbSovXG4vKipcbiAqXG4gKiBkZXNrdG9wLXpvb20uanM6XG4gKlxuICogLSBCaW5kcyBtb3VzZXdoZWVsIGV2ZW50IGZvciBwYW5pbmcgem9vbWVkIGltYWdlLlxuICogLSBNYW5hZ2VzIFwiZHJhZ2dpbmdcIiwgXCJ6b29tZWQtaW5cIiwgXCJ6b29tLW91dFwiIGNsYXNzZXMuXG4gKiAgICh3aGljaCBhcmUgdXNlZCBmb3IgY3Vyc29ycyBhbmQgem9vbSBpY29uKVxuICogLSBBZGRzIHRvZ2dsZURlc2t0b3Bab29tIGZ1bmN0aW9uLlxuICogXG4gKi9cblxudmFyIF93aGVlbERlbHRhO1xuICAgIFxuX3JlZ2lzdGVyTW9kdWxlKCdEZXNrdG9wWm9vbScsIHtcblxuICAgIHB1YmxpY01ldGhvZHM6IHtcblxuICAgICAgICBpbml0RGVza3RvcFpvb206IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZihfb2xkSUUpIHtcbiAgICAgICAgICAgICAgICAvLyBubyB6b29tIGZvciBvbGQgSUUgKDw9OClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKF9saWtlbHlUb3VjaERldmljZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGRldGVjdGVkIGhhcmR3YXJlIHRvdWNoIHN1cHBvcnQsIHdlIHdhaXQgdW50aWwgbW91c2UgaXMgdXNlZCxcbiAgICAgICAgICAgICAgICAvLyBhbmQgb25seSB0aGVuIGFwcGx5IGRlc2t0b3Atem9vbSBmZWF0dXJlc1xuICAgICAgICAgICAgICAgIF9saXN0ZW4oJ21vdXNlVXNlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHVwRGVza3RvcFpvb20oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXR1cERlc2t0b3Bab29tKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0dXBEZXNrdG9wWm9vbTogZnVuY3Rpb24ob25Jbml0KSB7XG5cbiAgICAgICAgICAgIF93aGVlbERlbHRhID0ge307XG5cbiAgICAgICAgICAgIHZhciBldmVudHMgPSAnd2hlZWwgbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIF9saXN0ZW4oJ2JpbmRFdmVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmcmFtZXdvcmsuYmluZCh0ZW1wbGF0ZSwgZXZlbnRzLCAgc2VsZi5oYW5kbGVNb3VzZVdoZWVsKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfbGlzdGVuKCd1bmJpbmRFdmVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZihfd2hlZWxEZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZXdvcmsudW5iaW5kKHRlbXBsYXRlLCBldmVudHMsIHNlbGYuaGFuZGxlTW91c2VXaGVlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlbGYubW91c2Vab29tZWRJbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgaGFzRHJhZ2dpbmdDbGFzcyxcbiAgICAgICAgICAgICAgICB1cGRhdGVab29tYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZihzZWxmLm1vdXNlWm9vbWVkSW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1ld29yay5yZW1vdmVDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLXpvb21lZC1pbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tb3VzZVpvb21lZEluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoX2N1cnJab29tTGV2ZWwgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS16b29tLWFsbG93ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1ld29yay5yZW1vdmVDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLXpvb20tYWxsb3dlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZURyYWdnaW5nQ2xhc3MoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbW92ZURyYWdnaW5nQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzRHJhZ2dpbmdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWV3b3JrLnJlbW92ZUNsYXNzKHRlbXBsYXRlLCAncHN3cC0tZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0RyYWdnaW5nQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9saXN0ZW4oJ3Jlc2l6ZScgLCB1cGRhdGVab29tYWJsZSk7XG4gICAgICAgICAgICBfbGlzdGVuKCdhZnRlckNoYW5nZScgLCB1cGRhdGVab29tYWJsZSk7XG4gICAgICAgICAgICBfbGlzdGVuKCdwb2ludGVyRG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmKHNlbGYubW91c2Vab29tZWRJbikge1xuICAgICAgICAgICAgICAgICAgICBoYXNEcmFnZ2luZ0NsYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWV3b3JrLmFkZENsYXNzKHRlbXBsYXRlLCAncHN3cC0tZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9saXN0ZW4oJ3BvaW50ZXJVcCcsIHJlbW92ZURyYWdnaW5nQ2xhc3MpO1xuXG4gICAgICAgICAgICBpZighb25Jbml0KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlWm9vbWFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZU1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgaWYoX2N1cnJab29tTGV2ZWwgPD0gc2VsZi5jdXJySXRlbS5maXRSYXRpbykge1xuICAgICAgICAgICAgICAgIGlmKCBfb3B0aW9ucy5tb2RhbCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9vcHRpb25zLmNsb3NlT25TY3JvbGwgfHwgX251bUFuaW1hdGlvbnMgfHwgX2lzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKF90cmFuc2Zvcm1LZXkgJiYgTWF0aC5hYnMoZS5kZWx0YVkpID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgUGhvdG9Td2lwZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYnJvd3NlciBzdXBwb3J0cyB0cmFuc2Zvcm1zICYgc2Nyb2xsIGNoYW5nZWQgZW5vdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xvc2VkQnlTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsbG93IGp1c3Qgb25lIGV2ZW50IHRvIGZpcmVcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy93aGVlbFxuICAgICAgICAgICAgX3doZWVsRGVsdGEueCA9IDA7XG5cbiAgICAgICAgICAgIGlmKCdkZWx0YVgnIGluIGUpIHtcbiAgICAgICAgICAgICAgICBpZihlLmRlbHRhTW9kZSA9PT0gMSAvKiBET01fREVMVEFfTElORSAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyAxOCAtIGF2ZXJhZ2UgbGluZSBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgX3doZWVsRGVsdGEueCA9IGUuZGVsdGFYICogMTg7XG4gICAgICAgICAgICAgICAgICAgIF93aGVlbERlbHRhLnkgPSBlLmRlbHRhWSAqIDE4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF93aGVlbERlbHRhLnggPSBlLmRlbHRhWDtcbiAgICAgICAgICAgICAgICAgICAgX3doZWVsRGVsdGEueSA9IGUuZGVsdGFZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZignd2hlZWxEZWx0YScgaW4gZSkge1xuICAgICAgICAgICAgICAgIGlmKGUud2hlZWxEZWx0YVgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3doZWVsRGVsdGEueCA9IC0wLjE2ICogZS53aGVlbERlbHRhWDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoZS53aGVlbERlbHRhWSkge1xuICAgICAgICAgICAgICAgICAgICBfd2hlZWxEZWx0YS55ID0gLTAuMTYgKiBlLndoZWVsRGVsdGFZO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF93aGVlbERlbHRhLnkgPSAtMC4xNiAqIGUud2hlZWxEZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoJ2RldGFpbCcgaW4gZSkge1xuICAgICAgICAgICAgICAgIF93aGVlbERlbHRhLnkgPSBlLmRldGFpbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY2FsY3VsYXRlUGFuQm91bmRzKF9jdXJyWm9vbUxldmVsLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIG5ld1BhblggPSBfcGFuT2Zmc2V0LnggLSBfd2hlZWxEZWx0YS54LFxuICAgICAgICAgICAgICAgIG5ld1BhblkgPSBfcGFuT2Zmc2V0LnkgLSBfd2hlZWxEZWx0YS55O1xuXG4gICAgICAgICAgICAvLyBvbmx5IHByZXZlbnQgc2Nyb2xsaW5nIGluIG5vbm1vZGFsIG1vZGUgd2hlbiBub3QgYXQgZWRnZXNcbiAgICAgICAgICAgIGlmIChfb3B0aW9ucy5tb2RhbCB8fFxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBuZXdQYW5YIDw9IF9jdXJyUGFuQm91bmRzLm1pbi54ICYmIG5ld1BhblggPj0gX2N1cnJQYW5Cb3VuZHMubWF4LnggJiZcbiAgICAgICAgICAgICAgICBuZXdQYW5ZIDw9IF9jdXJyUGFuQm91bmRzLm1pbi55ICYmIG5ld1BhblkgPj0gX2N1cnJQYW5Cb3VuZHMubWF4LnlcbiAgICAgICAgICAgICAgICApICkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogdXNlIHJBRiBpbnN0ZWFkIG9mIG1vdXNld2hlZWw/XG4gICAgICAgICAgICBzZWxmLnBhblRvKG5ld1BhblgsIG5ld1BhblkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZURlc2t0b3Bab29tOiBmdW5jdGlvbihjZW50ZXJQb2ludCkge1xuICAgICAgICAgICAgY2VudGVyUG9pbnQgPSBjZW50ZXJQb2ludCB8fCB7eDpfdmlld3BvcnRTaXplLngvMiArIF9vZmZzZXQueCwgeTpfdmlld3BvcnRTaXplLnkvMiArIF9vZmZzZXQueSB9O1xuXG4gICAgICAgICAgICB2YXIgZG91YmxlVGFwWm9vbUxldmVsID0gX29wdGlvbnMuZ2V0RG91YmxlVGFwWm9vbSh0cnVlLCBzZWxmLmN1cnJJdGVtKTtcbiAgICAgICAgICAgIHZhciB6b29tT3V0ID0gX2N1cnJab29tTGV2ZWwgPT09IGRvdWJsZVRhcFpvb21MZXZlbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2VsZi5tb3VzZVpvb21lZEluID0gIXpvb21PdXQ7XG5cbiAgICAgICAgICAgIHNlbGYuem9vbVRvKHpvb21PdXQgPyBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwgOiBkb3VibGVUYXBab29tTGV2ZWwsIGNlbnRlclBvaW50LCAzMzMpO1xuICAgICAgICAgICAgZnJhbWV3b3JrWyAoIXpvb21PdXQgPyAnYWRkJyA6ICdyZW1vdmUnKSArICdDbGFzcyddKHRlbXBsYXRlLCAncHN3cC0tem9vbWVkLWluJyk7XG4gICAgICAgIH1cblxuICAgIH1cbn0pO1xuXG5cbi8qPj5kZXNrdG9wLXpvb20qL1xuXG4vKj4+aGlzdG9yeSovXG4vKipcbiAqXG4gKiBoaXN0b3J5LmpzOlxuICpcbiAqIC0gQmFjayBidXR0b24gdG8gY2xvc2UgZ2FsbGVyeS5cbiAqIFxuICogLSBVbmlxdWUgVVJMIGZvciBlYWNoIHNsaWRlOiBleGFtcGxlLmNvbS8mcGlkPTEmZ2lkPTNcbiAqICAgKHdoZXJlIFBJRCBpcyBwaWN0dXJlIGluZGV4LCBhbmQgR0lEIGFuZCBnYWxsZXJ5IGluZGV4KVxuICogICBcbiAqIC0gU3dpdGNoIFVSTCB3aGVuIHNsaWRlcyBjaGFuZ2UuXG4gKiBcbiAqL1xuXG5cbnZhciBfaGlzdG9yeURlZmF1bHRPcHRpb25zID0ge1xuICAgIGhpc3Rvcnk6IHRydWUsXG4gICAgZ2FsbGVyeVVJRDogMVxufTtcblxudmFyIF9oaXN0b3J5VXBkYXRlVGltZW91dCxcbiAgICBfaGFzaENoYW5nZVRpbWVvdXQsXG4gICAgX2hhc2hBbmltQ2hlY2tUaW1lb3V0LFxuICAgIF9oYXNoQ2hhbmdlZEJ5U2NyaXB0LFxuICAgIF9oYXNoQ2hhbmdlZEJ5SGlzdG9yeSxcbiAgICBfaGFzaFJlc2V0ZWQsXG4gICAgX2luaXRpYWxIYXNoLFxuICAgIF9oaXN0b3J5Q2hhbmdlZCxcbiAgICBfY2xvc2VkRnJvbVVSTCxcbiAgICBfdXJsQ2hhbmdlZE9uY2UsXG4gICAgX3dpbmRvd0xvYyxcblxuICAgIF9zdXBwb3J0c1B1c2hTdGF0ZSxcblxuICAgIF9nZXRIYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfd2luZG93TG9jLmhhc2guc3Vic3RyaW5nKDEpO1xuICAgIH0sXG4gICAgX2NsZWFuSGlzdG9yeVRpbWVvdXRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYoX2hpc3RvcnlVcGRhdGVUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX2hpc3RvcnlVcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKF9oYXNoQW5pbUNoZWNrVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9oYXNoQW5pbUNoZWNrVGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcGlkIC0gUGljdHVyZSBpbmRleFxuICAgIC8vIGdpZCAtIEdhbGxlcnkgaW5kZXhcbiAgICBfcGFyc2VJdGVtSW5kZXhGcm9tVVJMID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYXNoID0gX2dldEhhc2goKSxcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuXG4gICAgICAgIGlmKGhhc2gubGVuZ3RoIDwgNSkgeyAvLyBwaWQ9MVxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLCB2YXJzID0gaGFzaC5zcGxpdCgnJicpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYoIXZhcnNbaV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYWlyID0gdmFyc1tpXS5zcGxpdCgnPScpOyAgXG4gICAgICAgICAgICBpZihwYWlyLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtc1twYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYoX29wdGlvbnMuZ2FsbGVyeVBJRHMpIHtcbiAgICAgICAgICAgIC8vIGRldGVjdCBjdXN0b20gcGlkIGluIGhhc2ggYW5kIHNlYXJjaCBmb3IgaXQgYW1vbmcgdGhlIGl0ZW1zIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIHZhciBzZWFyY2hmb3IgPSBwYXJhbXMucGlkO1xuICAgICAgICAgICAgcGFyYW1zLnBpZCA9IDA7IC8vIGlmIGN1c3RvbSBwaWQgY2Fubm90IGJlIGZvdW5kLCBmYWxsYmFjayB0byB0aGUgZmlyc3QgaXRlbVxuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYoX2l0ZW1zW2ldLnBpZCA9PT0gc2VhcmNoZm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5waWQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMucGlkID0gcGFyc2VJbnQocGFyYW1zLnBpZCwxMCktMTtcbiAgICAgICAgfVxuICAgICAgICBpZiggcGFyYW1zLnBpZCA8IDAgKSB7XG4gICAgICAgICAgICBwYXJhbXMucGlkID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG4gICAgX3VwZGF0ZUhhc2ggPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZihfaGFzaEFuaW1DaGVja1RpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfaGFzaEFuaW1DaGVja1RpbWVvdXQpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZihfbnVtQW5pbWF0aW9ucyB8fCBfaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgLy8gY2hhbmdpbmcgYnJvd3NlciBVUkwgZm9yY2VzIGxheW91dC9wYWludCBpbiBzb21lIGJyb3dzZXJzLCB3aGljaCBjYXVzZXMgbm90aWNhYmxlIGxhZyBkdXJpbmcgYW5pbWF0aW9uXG4gICAgICAgICAgICAvLyB0aGF0J3Mgd2h5IHdlIHVwZGF0ZSBoYXNoIG9ubHkgd2hlbiBubyBhbmltYXRpb25zIHJ1bm5pbmdcbiAgICAgICAgICAgIF9oYXNoQW5pbUNoZWNrVGltZW91dCA9IHNldFRpbWVvdXQoX3VwZGF0ZUhhc2gsIDUwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKF9oYXNoQ2hhbmdlZEJ5U2NyaXB0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX2hhc2hDaGFuZ2VUaW1lb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9oYXNoQ2hhbmdlZEJ5U2NyaXB0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIHBpZCA9IChfY3VycmVudEl0ZW1JbmRleCArIDEpO1xuICAgICAgICB2YXIgaXRlbSA9IF9nZXRJdGVtQXQoIF9jdXJyZW50SXRlbUluZGV4ICk7XG4gICAgICAgIGlmKGl0ZW0uaGFzT3duUHJvcGVydHkoJ3BpZCcpKSB7XG4gICAgICAgICAgICAvLyBjYXJyeSBmb3J3YXJkIGFueSBjdXN0b20gcGlkIGFzc2lnbmVkIHRvIHRoZSBpdGVtXG4gICAgICAgICAgICBwaWQgPSBpdGVtLnBpZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SGFzaCA9IF9pbml0aWFsSGFzaCArICcmJyAgKyAgJ2dpZD0nICsgX29wdGlvbnMuZ2FsbGVyeVVJRCArICcmJyArICdwaWQ9JyArIHBpZDtcblxuICAgICAgICBpZighX2hpc3RvcnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZihfd2luZG93TG9jLmhhc2guaW5kZXhPZihuZXdIYXNoKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBfdXJsQ2hhbmdlZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmlyc3QgdGltZSAtIGFkZCBuZXcgaGlzb3J5IHJlY29yZCwgdGhlbiBqdXN0IHJlcGxhY2VcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdVUkwgPSBfd2luZG93TG9jLmhyZWYuc3BsaXQoJyMnKVswXSArICcjJyArICBuZXdIYXNoO1xuXG4gICAgICAgIGlmKCBfc3VwcG9ydHNQdXNoU3RhdGUgKSB7XG5cbiAgICAgICAgICAgIGlmKCcjJyArIG5ld0hhc2ggIT09IHdpbmRvdy5sb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeVtfaGlzdG9yeUNoYW5nZWQgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnXSgnJywgZG9jdW1lbnQudGl0bGUsIG5ld1VSTCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKF9oaXN0b3J5Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIF93aW5kb3dMb2MucmVwbGFjZSggbmV3VVJMICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF93aW5kb3dMb2MuaGFzaCA9IG5ld0hhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuXG4gICAgICAgIF9oaXN0b3J5Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgIF9oYXNoQ2hhbmdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfaGFzaENoYW5nZWRCeVNjcmlwdCA9IGZhbHNlO1xuICAgICAgICB9LCA2MCk7XG4gICAgfTtcblxuXG5cbiAgICBcblxuX3JlZ2lzdGVyTW9kdWxlKCdIaXN0b3J5Jywge1xuXG4gICAgXG5cbiAgICBwdWJsaWNNZXRob2RzOiB7XG4gICAgICAgIGluaXRIaXN0b3J5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnJhbWV3b3JrLmV4dGVuZChfb3B0aW9ucywgX2hpc3RvcnlEZWZhdWx0T3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmKCAhX29wdGlvbnMuaGlzdG9yeSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgX3dpbmRvd0xvYyA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgICAgIF91cmxDaGFuZ2VkT25jZSA9IGZhbHNlO1xuICAgICAgICAgICAgX2Nsb3NlZEZyb21VUkwgPSBmYWxzZTtcbiAgICAgICAgICAgIF9oaXN0b3J5Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgX2luaXRpYWxIYXNoID0gX2dldEhhc2goKTtcbiAgICAgICAgICAgIF9zdXBwb3J0c1B1c2hTdGF0ZSA9ICgncHVzaFN0YXRlJyBpbiBoaXN0b3J5KTtcblxuXG4gICAgICAgICAgICBpZihfaW5pdGlhbEhhc2guaW5kZXhPZignZ2lkPScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBfaW5pdGlhbEhhc2ggPSBfaW5pdGlhbEhhc2guc3BsaXQoJyZnaWQ9JylbMF07XG4gICAgICAgICAgICAgICAgX2luaXRpYWxIYXNoID0gX2luaXRpYWxIYXNoLnNwbGl0KCc/Z2lkPScpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIF9saXN0ZW4oJ2FmdGVyQ2hhbmdlJywgc2VsZi51cGRhdGVVUkwpO1xuICAgICAgICAgICAgX2xpc3RlbigndW5iaW5kRXZlbnRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZnJhbWV3b3JrLnVuYmluZCh3aW5kb3csICdoYXNoY2hhbmdlJywgc2VsZi5vbkhhc2hDaGFuZ2UpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgdmFyIHJldHVyblRvT3JpZ2luYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfaGFzaFJlc2V0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmKCFfY2xvc2VkRnJvbVVSTCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKF91cmxDaGFuZ2VkT25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS5iYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKF9pbml0aWFsSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF93aW5kb3dMb2MuaGFzaCA9IF9pbml0aWFsSGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBoYXNoIGZyb20gdXJsIHdpdGhvdXQgcmVmcmVzaGluZyBpdCBvciBzY3JvbGxpbmcgdG8gdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKCcnLCBkb2N1bWVudC50aXRsZSwgIF93aW5kb3dMb2MucGF0aG5hbWUgKyBfd2luZG93TG9jLnNlYXJjaCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF93aW5kb3dMb2MuaGFzaCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY2xlYW5IaXN0b3J5VGltZW91dHMoKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgX2xpc3RlbigndW5iaW5kRXZlbnRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoX2Nsb3NlZEJ5U2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIFBob3RvU3dpcGUgaXMgY2xvc2VkIGJ5IHNjcm9sbCwgd2UgZ28gXCJiYWNrXCIgYmVmb3JlIHRoZSBjbG9zaW5nIGFuaW1hdGlvbiBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBkb25lIHRvIGtlZXAgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Ub09yaWdpbmFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfbGlzdGVuKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoIV9oYXNoUmVzZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5Ub09yaWdpbmFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfbGlzdGVuKCdmaXJzdFVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SXRlbUluZGV4ID0gX3BhcnNlSXRlbUluZGV4RnJvbVVSTCgpLnBpZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBfaW5pdGlhbEhhc2guaW5kZXhPZigncGlkPScpO1xuICAgICAgICAgICAgaWYoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIF9pbml0aWFsSGFzaCA9IF9pbml0aWFsSGFzaC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmKF9pbml0aWFsSGFzaC5zbGljZSgtMSkgPT09ICcmJykge1xuICAgICAgICAgICAgICAgICAgICBfaW5pdGlhbEhhc2ggPSBfaW5pdGlhbEhhc2guc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmKF9pc09wZW4pIHsgLy8gaGFzbid0IGRlc3Ryb3llZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgZnJhbWV3b3JrLmJpbmQod2luZG93LCAnaGFzaGNoYW5nZScsIHNlbGYub25IYXNoQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA0MCk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgb25IYXNoQ2hhbmdlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYoX2dldEhhc2goKSA9PT0gX2luaXRpYWxIYXNoKSB7XG5cbiAgICAgICAgICAgICAgICBfY2xvc2VkRnJvbVVSTCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFfaGFzaENoYW5nZWRCeVNjcmlwdCkge1xuXG4gICAgICAgICAgICAgICAgX2hhc2hDaGFuZ2VkQnlIaXN0b3J5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLmdvVG8oIF9wYXJzZUl0ZW1JbmRleEZyb21VUkwoKS5waWQgKTtcbiAgICAgICAgICAgICAgICBfaGFzaENoYW5nZWRCeUhpc3RvcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVVUkw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvLyBEZWxheSB0aGUgdXBkYXRlIG9mIFVSTCwgdG8gYXZvaWQgbGFnIGR1cmluZyB0cmFuc2l0aW9uLCBcbiAgICAgICAgICAgIC8vIGFuZCB0byBub3QgdG8gdHJpZ2dlciBhY3Rpb25zIGxpa2UgXCJyZWZyZXNoIHBhZ2Ugc291bmRcIiBvciBcImJsaW5raW5nIGZhdmljb25cIiB0byBvZnRlblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBfY2xlYW5IaXN0b3J5VGltZW91dHMoKTtcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZihfaGFzaENoYW5nZWRCeUhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFfaGlzdG9yeUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSGFzaCgpOyAvLyBmaXJzdCB0aW1lXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9oaXN0b3J5VXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoX3VwZGF0ZUhhc2gsIDgwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICB9XG59KTtcblxuXG4vKj4+aGlzdG9yeSovXG4gICAgZnJhbWV3b3JrLmV4dGVuZChzZWxmLCBwdWJsaWNNZXRob2RzKTsgfTtcbiAgICByZXR1cm4gUGhvdG9Td2lwZTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL3Bob3Rvc3dpcGUuanMiLCIvKiEgUGhvdG9Td2lwZSAtIHY0LjEuMSAtIDIwMTUtMTItMjRcbiogaHR0cDovL3Bob3Rvc3dpcGUuY29tXG4qIENvcHlyaWdodCAoYykgMjAxNSBEbWl0cnkgU2VtZW5vdjsgKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkgeyBcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlBob3RvU3dpcGUgPSBmYWN0b3J5KCk7XG4gICAgfVxufSkodGhpcywgZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBQaG90b1N3aXBlID0gZnVuY3Rpb24odGVtcGxhdGUsIFVpQ2xhc3MsIGl0ZW1zLCBvcHRpb25zKXtcblxuLyo+PmZyYW1ld29yay1icmlkZ2UqL1xuLyoqXG4gKlxuICogU2V0IG9mIGdlbmVyaWMgZnVuY3Rpb25zIHVzZWQgYnkgZ2FsbGVyeS5cbiAqIFxuICogWW91J3JlIGZyZWUgdG8gbW9kaWZ5IGFueXRoaW5nIGhlcmUgYXMgbG9uZyBhcyBmdW5jdGlvbmFsaXR5IGlzIGtlcHQuXG4gKiBcbiAqL1xudmFyIGZyYW1ld29yayA9IHtcbiAgICBmZWF0dXJlczogbnVsbCxcbiAgICBiaW5kOiBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB1bmJpbmQpIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSAodW5iaW5kID8gJ3JlbW92ZScgOiAnYWRkJykgKyAnRXZlbnRMaXN0ZW5lcic7XG4gICAgICAgIHR5cGUgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZih0eXBlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W21ldGhvZE5hbWVdKCB0eXBlW2ldLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBpc0FycmF5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgfSxcbiAgICBjcmVhdGVFbDogZnVuY3Rpb24oY2xhc3NlcywgdGFnKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnIHx8ICdkaXYnKTtcbiAgICAgICAgaWYoY2xhc3Nlcykge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gY2xhc3NlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcbiAgICBnZXRTY3JvbGxZOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHJldHVybiB5T2Zmc2V0ICE9PSB1bmRlZmluZWQgPyB5T2Zmc2V0IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICB9LFxuICAgIHVuYmluZDogZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBmcmFtZXdvcmsuYmluZCh0YXJnZXQsdHlwZSxsaXN0ZW5lcix0cnVlKTtcbiAgICB9LFxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKCcoXFxcXHN8XiknICsgY2xhc3NOYW1lICsgJyhcXFxcc3wkKScpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShyZWcsICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7IFxuICAgIH0sXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYoICFmcmFtZXdvcmsuaGFzQ2xhc3MoZWwsY2xhc3NOYW1lKSApIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSArPSAoZWwuY2xhc3NOYW1lID8gJyAnIDogJycpICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoYXNDbGFzczogZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gZWwuY2xhc3NOYW1lICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKFxcXFxzfCQpJykudGVzdChlbC5jbGFzc05hbWUpO1xuICAgIH0sXG4gICAgZ2V0Q2hpbGRCeUNsYXNzOiBmdW5jdGlvbihwYXJlbnRFbCwgY2hpbGRDbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwYXJlbnRFbC5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZShub2RlKSB7XG4gICAgICAgICAgICBpZiggZnJhbWV3b3JrLmhhc0NsYXNzKG5vZGUsIGNoaWxkQ2xhc3NOYW1lKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhcnJheVNlYXJjaDogZnVuY3Rpb24oYXJyYXksIHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIGkgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGktLSkge1xuICAgICAgICAgICAgaWYoYXJyYXlbaV1ba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgZXh0ZW5kOiBmdW5jdGlvbihvMSwgbzIsIHByZXZlbnRPdmVyd3JpdGUpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvMikge1xuICAgICAgICAgICAgaWYgKG8yLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYocHJldmVudE92ZXJ3cml0ZSAmJiBvMS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbzFbcHJvcF0gPSBvMltwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZWFzaW5nOiB7XG4gICAgICAgIHNpbmU6IHtcbiAgICAgICAgICAgIG91dDogZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbihrICogKE1hdGguUEkgLyAyKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5PdXQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLSAoTWF0aC5jb3MoTWF0aC5QSSAqIGspIC0gMSkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdWJpYzoge1xuICAgICAgICAgICAgb3V0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgICAgZWxhc3RpYzoge1xuICAgICAgICAgICAgICAgIG91dDogZnVuY3Rpb24gKCBrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzLCBhID0gMC4xLCBwID0gMC40O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBrID09PSAxICkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWEgfHwgYSA8IDEgKSB7IGEgPSAxOyBzID0gcCAvIDQ7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBzID0gcCAqIE1hdGguYXNpbiggMSAvIGEgKSAvICggMiAqIE1hdGguUEkgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggYSAqIE1hdGgucG93KCAyLCAtIDEwICogaykgKiBNYXRoLnNpbiggKCBrIC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICsgMSApO1xuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrOiB7XG4gICAgICAgICAgICAgICAgb3V0OiBmdW5jdGlvbiAoIGsgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiAoICggcyArIDEgKSAqIGsgKyBzICkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIFxuICAgICAqIHtcbiAgICAgKiAgcmFmIDogcmVxdWVzdCBhbmltYXRpb24gZnJhbWUgZnVuY3Rpb25cbiAgICAgKiAgY2FmIDogY2FuY2VsIGFuaW1hdGlvbiBmcmFtZSBmdW5jdGlvblxuICAgICAqICB0cmFuc2Zyb20gOiB0cmFuc2Zvcm0gcHJvcGVydHkga2V5ICh3aXRoIHZlbmRvciksIG9yIG51bGwgaWYgbm90IHN1cHBvcnRlZFxuICAgICAqICBvbGRJRSA6IElFOCBvciBiZWxvd1xuICAgICAqIH1cbiAgICAgKiBcbiAgICAgKi9cbiAgICBkZXRlY3RGZWF0dXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGZyYW1ld29yay5mZWF0dXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZyYW1ld29yay5mZWF0dXJlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVscGVyRWwgPSBmcmFtZXdvcmsuY3JlYXRlRWwoKSxcbiAgICAgICAgICAgIGhlbHBlclN0eWxlID0gaGVscGVyRWwuc3R5bGUsXG4gICAgICAgICAgICB2ZW5kb3IgPSAnJyxcbiAgICAgICAgICAgIGZlYXR1cmVzID0ge307XG5cbiAgICAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAgICBmZWF0dXJlcy5vbGRJRSA9IGRvY3VtZW50LmFsbCAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICAgICAgICBmZWF0dXJlcy50b3VjaCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcblxuICAgICAgICBpZih3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5yYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICAgICAgZmVhdHVyZXMuY2FmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgZmVhdHVyZXMucG9pbnRlckV2ZW50ID0gbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuXG4gICAgICAgIC8vIGZpeCBmYWxzZS1wb3NpdGl2ZSBkZXRlY3Rpb24gb2Ygb2xkIEFuZHJvaWQgaW4gbmV3IElFXG4gICAgICAgIC8vIChJRTExIHVhIHN0cmluZyBjb250YWlucyBcIkFuZHJvaWQgNC4wXCIpXG4gICAgICAgIFxuICAgICAgICBpZighZmVhdHVyZXMucG9pbnRlckV2ZW50KSB7IFxuXG4gICAgICAgICAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gICAgICAgICAgICAvLyBEZXRlY3QgaWYgZGV2aWNlIGlzIGlQaG9uZSBvciBpUG9kIGFuZCBpZiBpdCdzIG9sZGVyIHRoYW4gaU9TIDhcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0MjIzOTIwXG4gICAgICAgICAgICAvLyBcbiAgICAgICAgICAgIC8vIFRoaXMgZGV0ZWN0aW9uIGlzIG1hZGUgYmVjYXVzZSBvZiBidWdneSB0b3AvYm90dG9tIHRvb2xiYXJzXG4gICAgICAgICAgICAvLyB0aGF0IGRvbid0IHRyaWdnZXIgd2luZG93LnJlc2l6ZSBldmVudC5cbiAgICAgICAgICAgIC8vIEZvciBtb3JlIGluZm8gcmVmZXIgdG8gX2lzRml4ZWRQb3NpdGlvbiB2YXJpYWJsZSBpbiBjb3JlLmpzXG5cbiAgICAgICAgICAgIGlmICgvaVAoaG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gKG5hdmlnYXRvci5hcHBWZXJzaW9uKS5tYXRjaCgvT1MgKFxcZCspXyhcXGQrKV8/KFxcZCspPy8pO1xuICAgICAgICAgICAgICAgIGlmKHYgJiYgdi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBwYXJzZUludCh2WzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHYgPj0gMSAmJiB2IDwgOCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzLmlzT2xkSU9TUGhvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlY3Qgb2xkIEFuZHJvaWQgKGJlZm9yZSBLaXRLYXQpXG4gICAgICAgICAgICAvLyBkdWUgdG8gYnVncyByZWxhdGVkIHRvIHBvc2l0aW9uOmZpeGVkXG4gICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcxODQ1NzMvcGljay11cC10aGUtYW5kcm9pZC12ZXJzaW9uLWluLXRoZS1icm93c2VyLWJ5LWphdmFzY3JpcHRcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG1hdGNoID0gdWEubWF0Y2goL0FuZHJvaWRcXHMoWzAtOVxcLl0qKS8pO1xuICAgICAgICAgICAgdmFyIGFuZHJvaWR2ZXJzaW9uID0gIG1hdGNoID8gbWF0Y2hbMV0gOiAwO1xuICAgICAgICAgICAgYW5kcm9pZHZlcnNpb24gPSBwYXJzZUZsb2F0KGFuZHJvaWR2ZXJzaW9uKTtcbiAgICAgICAgICAgIGlmKGFuZHJvaWR2ZXJzaW9uID49IDEgKSB7XG4gICAgICAgICAgICAgICAgaWYoYW5kcm9pZHZlcnNpb24gPCA0LjQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMuaXNPbGRBbmRyb2lkID0gdHJ1ZTsgLy8gZm9yIGZpeGVkIHBvc2l0aW9uIGJ1ZyAmIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZlYXR1cmVzLmFuZHJvaWRWZXJzaW9uID0gYW5kcm9pZHZlcnNpb247IC8vIGZvciB0b3VjaGVuZCBidWdcbiAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgIGZlYXR1cmVzLmlzTW9iaWxlT3BlcmEgPSAvb3BlcmEgbWluaXxvcGVyYSBtb2JpL2kudGVzdCh1YSk7XG5cbiAgICAgICAgICAgIC8vIHAucy4geWVzLCB5ZXMsIFVBIHNuaWZmaW5nIGlzIGJhZCwgcHJvcG9zZSB5b3VyIHNvbHV0aW9uIGZvciBhYm92ZSBidWdzLlxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgc3R5bGVDaGVja3MgPSBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZScsICdhbmltYXRpb25OYW1lJ10sXG4gICAgICAgICAgICB2ZW5kb3JzID0gWycnLCAnd2Via2l0JywnTW96JywnbXMnLCdPJ10sXG4gICAgICAgICAgICBzdHlsZUNoZWNrSXRlbSxcbiAgICAgICAgICAgIHN0eWxlTmFtZTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB2ZW5kb3IgPSB2ZW5kb3JzW2ldO1xuXG4gICAgICAgICAgICBmb3IodmFyIGEgPSAwOyBhIDwgMzsgYSsrKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVDaGVja0l0ZW0gPSBzdHlsZUNoZWNrc1thXTtcblxuICAgICAgICAgICAgICAgIC8vIHVwcGVyY2FzZSBmaXJzdCBsZXR0ZXIgb2YgcHJvcGVydHkgbmFtZSwgaWYgdmVuZG9yIGlzIHByZXNlbnRcbiAgICAgICAgICAgICAgICBzdHlsZU5hbWUgPSB2ZW5kb3IgKyAodmVuZG9yID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVDaGVja0l0ZW0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHlsZUNoZWNrSXRlbS5zbGljZSgxKSA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlQ2hlY2tJdGVtKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCFmZWF0dXJlc1tzdHlsZUNoZWNrSXRlbV0gJiYgc3R5bGVOYW1lIGluIGhlbHBlclN0eWxlICkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1tzdHlsZUNoZWNrSXRlbV0gPSBzdHlsZU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih2ZW5kb3IgJiYgIWZlYXR1cmVzLnJhZikge1xuICAgICAgICAgICAgICAgIHZlbmRvciA9IHZlbmRvci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnJhZiA9IHdpbmRvd1t2ZW5kb3IrJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICAgICAgICAgIGlmKGZlYXR1cmVzLnJhZikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5jYWYgPSB3aW5kb3dbdmVuZG9yKydDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93W3ZlbmRvcisnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgaWYoIWZlYXR1cmVzLnJhZikge1xuICAgICAgICAgICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICAgICAgICAgIGZlYXR1cmVzLnJhZiA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZuKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7IH0sIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmZWF0dXJlcy5jYWYgPSBmdW5jdGlvbihpZCkgeyBjbGVhclRpbWVvdXQoaWQpOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZWN0IFNWRyBzdXBwb3J0XG4gICAgICAgIGZlYXR1cmVzLnN2ZyA9ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpLmNyZWF0ZVNWR1JlY3Q7XG5cbiAgICAgICAgZnJhbWV3b3JrLmZlYXR1cmVzID0gZmVhdHVyZXM7XG5cbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbn07XG5cbmZyYW1ld29yay5kZXRlY3RGZWF0dXJlcygpO1xuXG4vLyBPdmVycmlkZSBhZGRFdmVudExpc3RlbmVyIGZvciBvbGQgdmVyc2lvbnMgb2YgSUVcbmlmKGZyYW1ld29yay5mZWF0dXJlcy5vbGRJRSkge1xuXG4gICAgZnJhbWV3b3JrLmJpbmQgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB1bmJpbmQpIHtcbiAgICAgICAgXG4gICAgICAgIHR5cGUgPSB0eXBlLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSAodW5iaW5kID8gJ2RldGFjaCcgOiAnYXR0YWNoJykgKyAnRXZlbnQnLFxuICAgICAgICAgICAgZXZOYW1lLFxuICAgICAgICAgICAgX2hhbmRsZUV2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQuY2FsbChsaXN0ZW5lcik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBldk5hbWUgPSB0eXBlW2ldO1xuICAgICAgICAgICAgaWYoZXZOYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnICYmIGxpc3RlbmVyLmhhbmRsZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCF1bmJpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyWydvbGRJRScgKyBldk5hbWVdID0gX2hhbmRsZUV2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWxpc3RlbmVyWydvbGRJRScgKyBldk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W21ldGhvZE5hbWVdKCAnb24nICsgZXZOYW1lLCBsaXN0ZW5lclsnb2xkSUUnICsgZXZOYW1lXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W21ldGhvZE5hbWVdKCAnb24nICsgZXZOYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxufVxuXG4vKj4+ZnJhbWV3b3JrLWJyaWRnZSovXG5cbi8qPj5jb3JlKi9cbi8vZnVuY3Rpb24odGVtcGxhdGUsIFVpQ2xhc3MsIGl0ZW1zLCBvcHRpb25zKVxuXG52YXIgc2VsZiA9IHRoaXM7XG5cbi8qKlxuICogU3RhdGljIHZhcnMsIGRvbid0IGNoYW5nZSB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gKi9cbnZhciBET1VCTEVfVEFQX1JBRElVUyA9IDI1LCBcbiAgICBOVU1fSE9MREVSUyA9IDM7XG5cbi8qKlxuICogT3B0aW9uc1xuICovXG52YXIgX29wdGlvbnMgPSB7XG4gICAgYWxsb3dQYW5Ub05leHQ6dHJ1ZSxcbiAgICBzcGFjaW5nOiAwLjEyLFxuICAgIGJnT3BhY2l0eTogMSxcbiAgICBtb3VzZVVzZWQ6IGZhbHNlLFxuICAgIGxvb3A6IHRydWUsXG4gICAgcGluY2hUb0Nsb3NlOiB0cnVlLFxuICAgIGNsb3NlT25TY3JvbGw6IHRydWUsXG4gICAgY2xvc2VPblZlcnRpY2FsRHJhZzogdHJ1ZSxcbiAgICB2ZXJ0aWNhbERyYWdSYW5nZTogMC43NSxcbiAgICBoaWRlQW5pbWF0aW9uRHVyYXRpb246IDMzMyxcbiAgICBzaG93QW5pbWF0aW9uRHVyYXRpb246IDMzMyxcbiAgICBzaG93SGlkZU9wYWNpdHk6IGZhbHNlLFxuICAgIGZvY3VzOiB0cnVlLFxuICAgIGVzY0tleTogdHJ1ZSxcbiAgICBhcnJvd0tleXM6IHRydWUsXG4gICAgbWFpblNjcm9sbEVuZEZyaWN0aW9uOiAwLjM1LFxuICAgIHBhbkVuZEZyaWN0aW9uOiAwLjM1LFxuICAgIGlzQ2xpY2thYmxlRWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLnRhZ05hbWUgPT09ICdBJztcbiAgICB9LFxuICAgIGdldERvdWJsZVRhcFpvb206IGZ1bmN0aW9uKGlzTW91c2VDbGljaywgaXRlbSkge1xuICAgICAgICBpZihpc01vdXNlQ2xpY2spIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW5pdGlhbFpvb21MZXZlbCA8IDAuNyA/IDEgOiAxLjMzO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXhTcHJlYWRab29tOiAxLjMzLFxuICAgIG1vZGFsOiB0cnVlLFxuXG4gICAgLy8gbm90IGZ1bGx5IGltcGxlbWVudGVkIHlldFxuICAgIHNjYWxlTW9kZTogJ2ZpdCcgLy8gVE9ET1xufTtcbmZyYW1ld29yay5leHRlbmQoX29wdGlvbnMsIG9wdGlvbnMpO1xuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdmFyaWFibGVzICYgZnVuY3Rpb25zXG4gKi9cblxudmFyIF9nZXRFbXB0eVBvaW50ID0gZnVuY3Rpb24oKSB7IFxuICAgICAgICByZXR1cm4ge3g6MCx5OjB9OyBcbiAgICB9O1xuXG52YXIgX2lzT3BlbixcbiAgICBfaXNEZXN0cm95aW5nLFxuICAgIF9jbG9zZWRCeVNjcm9sbCxcbiAgICBfY3VycmVudEl0ZW1JbmRleCxcbiAgICBfY29udGFpbmVyU3R5bGUsXG4gICAgX2NvbnRhaW5lclNoaWZ0SW5kZXgsXG4gICAgX2N1cnJQYW5EaXN0ID0gX2dldEVtcHR5UG9pbnQoKSxcbiAgICBfc3RhcnRQYW5PZmZzZXQgPSBfZ2V0RW1wdHlQb2ludCgpLFxuICAgIF9wYW5PZmZzZXQgPSBfZ2V0RW1wdHlQb2ludCgpLFxuICAgIF91cE1vdmVFdmVudHMsIC8vIGRyYWcgbW92ZSwgZHJhZyBlbmQgJiBkcmFnIGNhbmNlbCBldmVudHMgYXJyYXlcbiAgICBfZG93bkV2ZW50cywgLy8gZHJhZyBzdGFydCBldmVudHMgYXJyYXlcbiAgICBfZ2xvYmFsRXZlbnRIYW5kbGVycyxcbiAgICBfdmlld3BvcnRTaXplID0ge30sXG4gICAgX2N1cnJab29tTGV2ZWwsXG4gICAgX3N0YXJ0Wm9vbUxldmVsLFxuICAgIF90cmFuc2xhdGVQcmVmaXgsXG4gICAgX3RyYW5zbGF0ZVN1Zml4LFxuICAgIF91cGRhdGVTaXplSW50ZXJ2YWwsXG4gICAgX2l0ZW1zTmVlZFVwZGF0ZSxcbiAgICBfY3VyclBvc2l0aW9uSW5kZXggPSAwLFxuICAgIF9vZmZzZXQgPSB7fSxcbiAgICBfc2xpZGVTaXplID0gX2dldEVtcHR5UG9pbnQoKSwgLy8gc2l6ZSBvZiBzbGlkZSBhcmVhLCBpbmNsdWRpbmcgc3BhY2luZ1xuICAgIF9pdGVtSG9sZGVycyxcbiAgICBfcHJldkl0ZW1JbmRleCxcbiAgICBfaW5kZXhEaWZmID0gMCwgLy8gZGlmZmVyZW5jZSBvZiBpbmRleGVzIHNpbmNlIGxhc3QgY29udGVudCB1cGRhdGVcbiAgICBfZHJhZ1N0YXJ0RXZlbnQsXG4gICAgX2RyYWdNb3ZlRXZlbnQsXG4gICAgX2RyYWdFbmRFdmVudCxcbiAgICBfZHJhZ0NhbmNlbEV2ZW50LFxuICAgIF90cmFuc2Zvcm1LZXksXG4gICAgX3BvaW50ZXJFdmVudEVuYWJsZWQsXG4gICAgX2lzRml4ZWRQb3NpdGlvbiA9IHRydWUsXG4gICAgX2xpa2VseVRvdWNoRGV2aWNlLFxuICAgIF9tb2R1bGVzID0gW10sXG4gICAgX3JlcXVlc3RBRixcbiAgICBfY2FuY2VsQUYsXG4gICAgX2luaXRhbENsYXNzTmFtZSxcbiAgICBfaW5pdGFsV2luZG93U2Nyb2xsWSxcbiAgICBfb2xkSUUsXG4gICAgX2N1cnJlbnRXaW5kb3dTY3JvbGxZLFxuICAgIF9mZWF0dXJlcyxcbiAgICBfd2luZG93VmlzaWJsZVNpemUgPSB7fSxcbiAgICBfcmVuZGVyTWF4UmVzb2x1dGlvbiA9IGZhbHNlLFxuXG4gICAgLy8gUmVnaXN0ZXJzIFBob3RvU1dpcGUgbW9kdWxlIChIaXN0b3J5LCBDb250cm9sbGVyIC4uLilcbiAgICBfcmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbihuYW1lLCBtb2R1bGUpIHtcbiAgICAgICAgZnJhbWV3b3JrLmV4dGVuZChzZWxmLCBtb2R1bGUucHVibGljTWV0aG9kcyk7XG4gICAgICAgIF9tb2R1bGVzLnB1c2gobmFtZSk7XG4gICAgfSxcblxuICAgIF9nZXRMb29wZWRJZCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBudW1TbGlkZXMgPSBfZ2V0TnVtSXRlbXMoKTtcbiAgICAgICAgaWYoaW5kZXggPiBudW1TbGlkZXMgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggLSBudW1TbGlkZXM7XG4gICAgICAgIH0gZWxzZSAgaWYoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtU2xpZGVzICsgaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgXG4gICAgLy8gTWljcm8gYmluZC90cmlnZ2VyXG4gICAgX2xpc3RlbmVycyA9IHt9LFxuICAgIF9saXN0ZW4gPSBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgICAgICBpZighX2xpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgICAgICAgX2xpc3RlbmVyc1tuYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfbGlzdGVuZXJzW25hbWVdLnB1c2goZm4pO1xuICAgIH0sXG4gICAgX3Nob3V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gX2xpc3RlbmVyc1tuYW1lXTtcblxuICAgICAgICBpZihsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGFyZ3Muc2hpZnQoKTtcblxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH0sXG4gICAgX2FwcGx5QmdPcGFjaXR5ID0gZnVuY3Rpb24ob3BhY2l0eSkge1xuICAgICAgICBfYmdPcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgc2VsZi5iZy5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eSAqIF9vcHRpb25zLmJnT3BhY2l0eTtcbiAgICB9LFxuXG4gICAgX2FwcGx5Wm9vbVRyYW5zZm9ybSA9IGZ1bmN0aW9uKHN0eWxlT2JqLHgseSx6b29tLGl0ZW0pIHtcbiAgICAgICAgaWYoIV9yZW5kZXJNYXhSZXNvbHV0aW9uIHx8IChpdGVtICYmIGl0ZW0gIT09IHNlbGYuY3Vyckl0ZW0pICkge1xuICAgICAgICAgICAgem9vbSA9IHpvb20gLyAoaXRlbSA/IGl0ZW0uZml0UmF0aW8gOiBzZWxmLmN1cnJJdGVtLmZpdFJhdGlvKTsgIFxuICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgc3R5bGVPYmpbX3RyYW5zZm9ybUtleV0gPSBfdHJhbnNsYXRlUHJlZml4ICsgeCArICdweCwgJyArIHkgKyAncHgnICsgX3RyYW5zbGF0ZVN1Zml4ICsgJyBzY2FsZSgnICsgem9vbSArICcpJztcbiAgICB9LFxuICAgIF9hcHBseUN1cnJlbnRab29tUGFuID0gZnVuY3Rpb24oIGFsbG93UmVuZGVyUmVzb2x1dGlvbiApIHtcbiAgICAgICAgaWYoX2N1cnJab29tRWxlbWVudFN0eWxlKSB7XG5cbiAgICAgICAgICAgIGlmKGFsbG93UmVuZGVyUmVzb2x1dGlvbikge1xuICAgICAgICAgICAgICAgIGlmKF9jdXJyWm9vbUxldmVsID4gc2VsZi5jdXJySXRlbS5maXRSYXRpbykge1xuICAgICAgICAgICAgICAgICAgICBpZighX3JlbmRlck1heFJlc29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zZXRJbWFnZVNpemUoc2VsZi5jdXJySXRlbSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlbmRlck1heFJlc29sdXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoX3JlbmRlck1heFJlc29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zZXRJbWFnZVNpemUoc2VsZi5jdXJySXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVuZGVyTWF4UmVzb2x1dGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIF9hcHBseVpvb21UcmFuc2Zvcm0oX2N1cnJab29tRWxlbWVudFN0eWxlLCBfcGFuT2Zmc2V0LngsIF9wYW5PZmZzZXQueSwgX2N1cnJab29tTGV2ZWwpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfYXBwbHlab29tUGFuVG9JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZihpdGVtLmNvbnRhaW5lcikge1xuXG4gICAgICAgICAgICBfYXBwbHlab29tVHJhbnNmb3JtKGl0ZW0uY29udGFpbmVyLnN0eWxlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5pbml0aWFsUG9zaXRpb24ueCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaW5pdGlhbFBvc2l0aW9uLnksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmluaXRpYWxab29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfc2V0VHJhbnNsYXRlWCA9IGZ1bmN0aW9uKHgsIGVsU3R5bGUpIHtcbiAgICAgICAgZWxTdHlsZVtfdHJhbnNmb3JtS2V5XSA9IF90cmFuc2xhdGVQcmVmaXggKyB4ICsgJ3B4LCAwcHgnICsgX3RyYW5zbGF0ZVN1Zml4O1xuICAgIH0sXG4gICAgX21vdmVNYWluU2Nyb2xsID0gZnVuY3Rpb24oeCwgZHJhZ2dpbmcpIHtcblxuICAgICAgICBpZighX29wdGlvbnMubG9vcCAmJiBkcmFnZ2luZykge1xuICAgICAgICAgICAgdmFyIG5ld1NsaWRlSW5kZXhPZmZzZXQgPSBfY3VycmVudEl0ZW1JbmRleCArIChfc2xpZGVTaXplLnggKiBfY3VyclBvc2l0aW9uSW5kZXggLSB4KSAvIF9zbGlkZVNpemUueCxcbiAgICAgICAgICAgICAgICBkZWx0YSA9IE1hdGgucm91bmQoeCAtIF9tYWluU2Nyb2xsUG9zLngpO1xuXG4gICAgICAgICAgICBpZiggKG5ld1NsaWRlSW5kZXhPZmZzZXQgPCAwICYmIGRlbHRhID4gMCkgfHwgXG4gICAgICAgICAgICAgICAgKG5ld1NsaWRlSW5kZXhPZmZzZXQgPj0gX2dldE51bUl0ZW1zKCkgLSAxICYmIGRlbHRhIDwgMCkgKSB7XG4gICAgICAgICAgICAgICAgeCA9IF9tYWluU2Nyb2xsUG9zLnggKyBkZWx0YSAqIF9vcHRpb25zLm1haW5TY3JvbGxFbmRGcmljdGlvbjtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIF9tYWluU2Nyb2xsUG9zLnggPSB4O1xuICAgICAgICBfc2V0VHJhbnNsYXRlWCh4LCBfY29udGFpbmVyU3R5bGUpO1xuICAgIH0sXG4gICAgX2NhbGN1bGF0ZVBhbk9mZnNldCA9IGZ1bmN0aW9uKGF4aXMsIHpvb21MZXZlbCkge1xuICAgICAgICB2YXIgbSA9IF9taWRab29tUG9pbnRbYXhpc10gLSBfb2Zmc2V0W2F4aXNdO1xuICAgICAgICByZXR1cm4gX3N0YXJ0UGFuT2Zmc2V0W2F4aXNdICsgX2N1cnJQYW5EaXN0W2F4aXNdICsgbSAtIG0gKiAoIHpvb21MZXZlbCAvIF9zdGFydFpvb21MZXZlbCApO1xuICAgIH0sXG4gICAgXG4gICAgX2VxdWFsaXplUG9pbnRzID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgICAgIHAxLnggPSBwMi54O1xuICAgICAgICBwMS55ID0gcDIueTtcbiAgICAgICAgaWYocDIuaWQpIHtcbiAgICAgICAgICAgIHAxLmlkID0gcDIuaWQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9yb3VuZFBvaW50ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICBwLnggPSBNYXRoLnJvdW5kKHAueCk7XG4gICAgICAgIHAueSA9IE1hdGgucm91bmQocC55KTtcbiAgICB9LFxuXG4gICAgX21vdXNlTW92ZVRpbWVvdXQgPSBudWxsLFxuICAgIF9vbkZpcnN0TW91c2VNb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdhaXQgdW50aWwgbW91c2UgbW92ZSBldmVudCBpcyBmaXJlZCBhdCBsZWFzdCB0d2ljZSBkdXJpbmcgMTAwbXNcbiAgICAgICAgLy8gV2UgZG8gdGhpcywgYmVjYXVzZSBzb21lIG1vYmlsZSBicm93c2VycyB0cmlnZ2VyIGl0IG9uIHRvdWNoc3RhcnRcbiAgICAgICAgaWYoX21vdXNlTW92ZVRpbWVvdXQgKSB7IFxuICAgICAgICAgICAgZnJhbWV3b3JrLnVuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIF9vbkZpcnN0TW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLWhhc19tb3VzZScpO1xuICAgICAgICAgICAgX29wdGlvbnMubW91c2VVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIF9zaG91dCgnbW91c2VVc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgX21vdXNlTW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX21vdXNlTW92ZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICBfYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmcmFtZXdvcmsuYmluZChkb2N1bWVudCwgJ2tleWRvd24nLCBzZWxmKTtcblxuICAgICAgICBpZihfZmVhdHVyZXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBiaW5kIGNsaWNrIGV2ZW50IGluIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0cmFuc2Zvcm0gKG1vc3RseSBJRTgpXG4gICAgICAgICAgICBmcmFtZXdvcmsuYmluZChzZWxmLnNjcm9sbFdyYXAsICdjbGljaycsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIGlmKCFfb3B0aW9ucy5tb3VzZVVzZWQpIHtcbiAgICAgICAgICAgIGZyYW1ld29yay5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX29uRmlyc3RNb3VzZU1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhbWV3b3JrLmJpbmQod2luZG93LCAncmVzaXplIHNjcm9sbCcsIHNlbGYpO1xuXG4gICAgICAgIF9zaG91dCgnYmluZEV2ZW50cycpO1xuICAgIH0sXG5cbiAgICBfdW5iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZyYW1ld29yay51bmJpbmQod2luZG93LCAncmVzaXplJywgc2VsZik7XG4gICAgICAgIGZyYW1ld29yay51bmJpbmQod2luZG93LCAnc2Nyb2xsJywgX2dsb2JhbEV2ZW50SGFuZGxlcnMuc2Nyb2xsKTtcbiAgICAgICAgZnJhbWV3b3JrLnVuYmluZChkb2N1bWVudCwgJ2tleWRvd24nLCBzZWxmKTtcbiAgICAgICAgZnJhbWV3b3JrLnVuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIF9vbkZpcnN0TW91c2VNb3ZlKTtcblxuICAgICAgICBpZihfZmVhdHVyZXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBmcmFtZXdvcmsudW5iaW5kKHNlbGYuc2Nyb2xsV3JhcCwgJ2NsaWNrJywgc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihfaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgZnJhbWV3b3JrLnVuYmluZCh3aW5kb3csIF91cE1vdmVFdmVudHMsIHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Nob3V0KCd1bmJpbmRFdmVudHMnKTtcbiAgICB9LFxuICAgIFxuICAgIF9jYWxjdWxhdGVQYW5Cb3VuZHMgPSBmdW5jdGlvbih6b29tTGV2ZWwsIHVwZGF0ZSkge1xuICAgICAgICB2YXIgYm91bmRzID0gX2NhbGN1bGF0ZUl0ZW1TaXplKCBzZWxmLmN1cnJJdGVtLCBfdmlld3BvcnRTaXplLCB6b29tTGV2ZWwgKTtcbiAgICAgICAgaWYodXBkYXRlKSB7XG4gICAgICAgICAgICBfY3VyclBhbkJvdW5kcyA9IGJvdW5kcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH0sXG4gICAgXG4gICAgX2dldE1pblpvb21MZXZlbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYoIWl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSBzZWxmLmN1cnJJdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLmluaXRpYWxab29tTGV2ZWw7XG4gICAgfSxcbiAgICBfZ2V0TWF4Wm9vbUxldmVsID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZighaXRlbSkge1xuICAgICAgICAgICAgaXRlbSA9IHNlbGYuY3Vyckl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0udyA+IDAgPyBfb3B0aW9ucy5tYXhTcHJlYWRab29tIDogMTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgb2Zmc2V0IGlzIG91dCBvZiB0aGUgYm91bmRzXG4gICAgX21vZGlmeURlc3RQYW5PZmZzZXQgPSBmdW5jdGlvbihheGlzLCBkZXN0UGFuQm91bmRzLCBkZXN0UGFuT2Zmc2V0LCBkZXN0Wm9vbUxldmVsKSB7XG4gICAgICAgIGlmKGRlc3Rab29tTGV2ZWwgPT09IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCkge1xuICAgICAgICAgICAgZGVzdFBhbk9mZnNldFtheGlzXSA9IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFBvc2l0aW9uW2F4aXNdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXN0UGFuT2Zmc2V0W2F4aXNdID0gX2NhbGN1bGF0ZVBhbk9mZnNldChheGlzLCBkZXN0Wm9vbUxldmVsKTsgXG5cbiAgICAgICAgICAgIGlmKGRlc3RQYW5PZmZzZXRbYXhpc10gPiBkZXN0UGFuQm91bmRzLm1pbltheGlzXSkge1xuICAgICAgICAgICAgICAgIGRlc3RQYW5PZmZzZXRbYXhpc10gPSBkZXN0UGFuQm91bmRzLm1pbltheGlzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihkZXN0UGFuT2Zmc2V0W2F4aXNdIDwgZGVzdFBhbkJvdW5kcy5tYXhbYXhpc10gKSB7XG4gICAgICAgICAgICAgICAgZGVzdFBhbk9mZnNldFtheGlzXSA9IGRlc3RQYW5Cb3VuZHMubWF4W2F4aXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgX3NldHVwVHJhbnNmb3JtcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmKF90cmFuc2Zvcm1LZXkpIHtcbiAgICAgICAgICAgIC8vIHNldHVwIDNkIHRyYW5zZm9ybXNcbiAgICAgICAgICAgIHZhciBhbGxvdzNkVHJhbnNmb3JtID0gX2ZlYXR1cmVzLnBlcnNwZWN0aXZlICYmICFfbGlrZWx5VG91Y2hEZXZpY2U7XG4gICAgICAgICAgICBfdHJhbnNsYXRlUHJlZml4ID0gJ3RyYW5zbGF0ZScgKyAoYWxsb3czZFRyYW5zZm9ybSA/ICczZCgnIDogJygnKTtcbiAgICAgICAgICAgIF90cmFuc2xhdGVTdWZpeCA9IF9mZWF0dXJlcy5wZXJzcGVjdGl2ZSA/ICcsIDBweCknIDogJyknOyAgIFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgem9vbS9wYW4vbW92ZSBmdW5jdGlvbnMgaW4gY2FzZSBvbGQgYnJvd3NlciBpcyB1c2VkIChtb3N0IGxpa2VseSBJRSlcbiAgICAgICAgLy8gKHNvIHRoZXkgdXNlIGxlZnQvdG9wL3dpZHRoL2hlaWdodCwgaW5zdGVhZCBvZiBDU1MgdHJhbnNmb3JtKVxuICAgIFxuICAgICAgICBfdHJhbnNmb3JtS2V5ID0gJ2xlZnQnO1xuICAgICAgICBmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1pZScpO1xuXG4gICAgICAgIF9zZXRUcmFuc2xhdGVYID0gZnVuY3Rpb24oeCwgZWxTdHlsZSkge1xuICAgICAgICAgICAgZWxTdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIH07XG4gICAgICAgIF9hcHBseVpvb21QYW5Ub0l0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG5cbiAgICAgICAgICAgIHZhciB6b29tUmF0aW8gPSBpdGVtLmZpdFJhdGlvID4gMSA/IDEgOiBpdGVtLmZpdFJhdGlvLFxuICAgICAgICAgICAgICAgIHMgPSBpdGVtLmNvbnRhaW5lci5zdHlsZSxcbiAgICAgICAgICAgICAgICB3ID0gem9vbVJhdGlvICogaXRlbS53LFxuICAgICAgICAgICAgICAgIGggPSB6b29tUmF0aW8gKiBpdGVtLmg7XG5cbiAgICAgICAgICAgIHMud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgICAgIHMuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgICAgICAgICBzLmxlZnQgPSBpdGVtLmluaXRpYWxQb3NpdGlvbi54ICsgJ3B4JztcbiAgICAgICAgICAgIHMudG9wID0gaXRlbS5pbml0aWFsUG9zaXRpb24ueSArICdweCc7XG5cbiAgICAgICAgfTtcbiAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKF9jdXJyWm9vbUVsZW1lbnRTdHlsZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBfY3Vyclpvb21FbGVtZW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBzZWxmLmN1cnJJdGVtLFxuICAgICAgICAgICAgICAgICAgICB6b29tUmF0aW8gPSBpdGVtLmZpdFJhdGlvID4gMSA/IDEgOiBpdGVtLmZpdFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICB3ID0gem9vbVJhdGlvICogaXRlbS53LFxuICAgICAgICAgICAgICAgICAgICBoID0gem9vbVJhdGlvICogaXRlbS5oO1xuXG4gICAgICAgICAgICAgICAgcy53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICAgICAgICAgIHMuaGVpZ2h0ID0gaCArICdweCc7XG5cblxuICAgICAgICAgICAgICAgIHMubGVmdCA9IF9wYW5PZmZzZXQueCArICdweCc7XG4gICAgICAgICAgICAgICAgcy50b3AgPSBfcGFuT2Zmc2V0LnkgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9vbktleURvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBrZXlkb3duQWN0aW9uID0gJyc7XG4gICAgICAgIGlmKF9vcHRpb25zLmVzY0tleSAmJiBlLmtleUNvZGUgPT09IDI3KSB7IFxuICAgICAgICAgICAga2V5ZG93bkFjdGlvbiA9ICdjbG9zZSc7XG4gICAgICAgIH0gZWxzZSBpZihfb3B0aW9ucy5hcnJvd0tleXMpIHtcbiAgICAgICAgICAgIGlmKGUua2V5Q29kZSA9PT0gMzcpIHtcbiAgICAgICAgICAgICAgICBrZXlkb3duQWN0aW9uID0gJ3ByZXYnO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGUua2V5Q29kZSA9PT0gMzkpIHsgXG4gICAgICAgICAgICAgICAga2V5ZG93bkFjdGlvbiA9ICduZXh0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGtleWRvd25BY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHNwZWNpYWwga2V5IHByZXNzZWQgdG8gcHJldmVudCBmcm9tIG92ZXJyaWRpbmcgZGVmYXVsdCBicm93c2VyIGFjdGlvbnNcbiAgICAgICAgICAgIC8vIGUuZy4gaW4gQ2hyb21lIG9uIE1hYyBjbWQrYXJyb3ctbGVmdCByZXR1cm5zIHRvIHByZXZpb3VzIHBhZ2VcbiAgICAgICAgICAgIGlmKCAhZS5jdHJsS2V5ICYmICFlLmFsdEtleSAmJiAhZS5zaGlmdEtleSAmJiAhZS5tZXRhS2V5ICkge1xuICAgICAgICAgICAgICAgIGlmKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIHNlbGZba2V5ZG93bkFjdGlvbl0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25HbG9iYWxDbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoIWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbid0IGFsbG93IGNsaWNrIGV2ZW50IHRvIHBhc3MgdGhyb3VnaCB3aGVuIHRyaWdnZXJpbmcgYWZ0ZXIgZHJhZyBvciBzb21lIG90aGVyIGdlc3R1cmVcbiAgICAgICAgaWYoX21vdmVkIHx8IF96b29tU3RhcnRlZCB8fCBfbWFpblNjcm9sbEFuaW1hdGluZyB8fCBfdmVydGljYWxEcmFnSW5pdGlhdGVkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVQYWdlU2Nyb2xsT2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuc2V0U2Nyb2xsT2Zmc2V0KDAsIGZyYW1ld29yay5nZXRTY3JvbGxZKCkpOyAgICAgICAgXG4gICAgfTtcbiAgICBcblxuXG4gICAgXG5cblxuXG4vLyBNaWNybyBhbmltYXRpb24gZW5naW5lXG52YXIgX2FuaW1hdGlvbnMgPSB7fSxcbiAgICBfbnVtQW5pbWF0aW9ucyA9IDAsXG4gICAgX3N0b3BBbmltYXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmKF9hbmltYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICBpZihfYW5pbWF0aW9uc1tuYW1lXS5yYWYpIHtcbiAgICAgICAgICAgICAgICBfY2FuY2VsQUYoIF9hbmltYXRpb25zW25hbWVdLnJhZiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX251bUFuaW1hdGlvbnMtLTtcbiAgICAgICAgICAgIGRlbGV0ZSBfYW5pbWF0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3JlZ2lzdGVyU3RhcnRBbmltYXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmKF9hbmltYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICBfc3RvcEFuaW1hdGlvbihuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZighX2FuaW1hdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIF9udW1BbmltYXRpb25zKys7XG4gICAgICAgICAgICBfYW5pbWF0aW9uc1tuYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfc3RvcEFsbEFuaW1hdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBfYW5pbWF0aW9ucykge1xuXG4gICAgICAgICAgICBpZiggX2FuaW1hdGlvbnMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcbiAgICAgICAgICAgICAgICBfc3RvcEFuaW1hdGlvbihwcm9wKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2FuaW1hdGVQcm9wID0gZnVuY3Rpb24obmFtZSwgYiwgZW5kUHJvcCwgZCwgZWFzaW5nRm4sIG9uVXBkYXRlLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzdGFydEFuaW1UaW1lID0gX2dldEN1cnJlbnRUaW1lKCksIHQ7XG4gICAgICAgIF9yZWdpc3RlclN0YXJ0QW5pbWF0aW9uKG5hbWUpO1xuXG4gICAgICAgIHZhciBhbmltbG9vcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoIF9hbmltYXRpb25zW25hbWVdICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHQgPSBfZ2V0Q3VycmVudFRpbWUoKSAtIHN0YXJ0QW5pbVRpbWU7IC8vIHRpbWUgZGlmZlxuICAgICAgICAgICAgICAgIC8vYiAtIGJlZ2lubmluZyAoc3RhcnQgcHJvcClcbiAgICAgICAgICAgICAgICAvL2QgLSBhbmltIGR1cmF0aW9uXG5cbiAgICAgICAgICAgICAgICBpZiAoIHQgPj0gZCApIHtcbiAgICAgICAgICAgICAgICAgICAgX3N0b3BBbmltYXRpb24obmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG9uVXBkYXRlKGVuZFByb3ApO1xuICAgICAgICAgICAgICAgICAgICBpZihvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblVwZGF0ZSggKGVuZFByb3AgLSBiKSAqIGVhc2luZ0ZuKHQvZCkgKyBiICk7XG5cbiAgICAgICAgICAgICAgICBfYW5pbWF0aW9uc1tuYW1lXS5yYWYgPSBfcmVxdWVzdEFGKGFuaW1sb29wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYW5pbWxvb3AoKTtcbiAgICB9O1xuICAgIFxuXG5cbnZhciBwdWJsaWNNZXRob2RzID0ge1xuXG4gICAgLy8gbWFrZSBhIGZldyBsb2NhbCB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9ucyBwdWJsaWNcbiAgICBzaG91dDogX3Nob3V0LFxuICAgIGxpc3RlbjogX2xpc3RlbixcbiAgICB2aWV3cG9ydFNpemU6IF92aWV3cG9ydFNpemUsXG4gICAgb3B0aW9uczogX29wdGlvbnMsXG5cbiAgICBpc01haW5TY3JvbGxBbmltYXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX21haW5TY3JvbGxBbmltYXRpbmc7XG4gICAgfSxcbiAgICBnZXRab29tTGV2ZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2N1cnJab29tTGV2ZWw7XG4gICAgfSxcbiAgICBnZXRDdXJyZW50SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2N1cnJlbnRJdGVtSW5kZXg7XG4gICAgfSxcbiAgICBpc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9pc0RyYWdnaW5nO1xuICAgIH0sICBcbiAgICBpc1pvb21pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2lzWm9vbWluZztcbiAgICB9LFxuICAgIHNldFNjcm9sbE9mZnNldDogZnVuY3Rpb24oeCx5KSB7XG4gICAgICAgIF9vZmZzZXQueCA9IHg7XG4gICAgICAgIF9jdXJyZW50V2luZG93U2Nyb2xsWSA9IF9vZmZzZXQueSA9IHk7XG4gICAgICAgIF9zaG91dCgndXBkYXRlU2Nyb2xsT2Zmc2V0JywgX29mZnNldCk7XG4gICAgfSxcbiAgICBhcHBseVpvb21QYW46IGZ1bmN0aW9uKHpvb21MZXZlbCxwYW5YLHBhblksYWxsb3dSZW5kZXJSZXNvbHV0aW9uKSB7XG4gICAgICAgIF9wYW5PZmZzZXQueCA9IHBhblg7XG4gICAgICAgIF9wYW5PZmZzZXQueSA9IHBhblk7XG4gICAgICAgIF9jdXJyWm9vbUxldmVsID0gem9vbUxldmVsO1xuICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbiggYWxsb3dSZW5kZXJSZXNvbHV0aW9uICk7XG4gICAgfSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmKF9pc09wZW4gfHwgX2lzRGVzdHJveWluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgc2VsZi5mcmFtZXdvcmsgPSBmcmFtZXdvcms7IC8vIGJhc2ljIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgc2VsZi50ZW1wbGF0ZSA9IHRlbXBsYXRlOyAvLyByb290IERPTSBlbGVtZW50IG9mIFBob3RvU3dpcGVcbiAgICAgICAgc2VsZi5iZyA9IGZyYW1ld29yay5nZXRDaGlsZEJ5Q2xhc3ModGVtcGxhdGUsICdwc3dwX19iZycpO1xuXG4gICAgICAgIF9pbml0YWxDbGFzc05hbWUgPSB0ZW1wbGF0ZS5jbGFzc05hbWU7XG4gICAgICAgIF9pc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICBfZmVhdHVyZXMgPSBmcmFtZXdvcmsuZGV0ZWN0RmVhdHVyZXMoKTtcbiAgICAgICAgX3JlcXVlc3RBRiA9IF9mZWF0dXJlcy5yYWY7XG4gICAgICAgIF9jYW5jZWxBRiA9IF9mZWF0dXJlcy5jYWY7XG4gICAgICAgIF90cmFuc2Zvcm1LZXkgPSBfZmVhdHVyZXMudHJhbnNmb3JtO1xuICAgICAgICBfb2xkSUUgPSBfZmVhdHVyZXMub2xkSUU7XG4gICAgICAgIFxuICAgICAgICBzZWxmLnNjcm9sbFdyYXAgPSBmcmFtZXdvcmsuZ2V0Q2hpbGRCeUNsYXNzKHRlbXBsYXRlLCAncHN3cF9fc2Nyb2xsLXdyYXAnKTtcbiAgICAgICAgc2VsZi5jb250YWluZXIgPSBmcmFtZXdvcmsuZ2V0Q2hpbGRCeUNsYXNzKHNlbGYuc2Nyb2xsV3JhcCwgJ3Bzd3BfX2NvbnRhaW5lcicpO1xuXG4gICAgICAgIF9jb250YWluZXJTdHlsZSA9IHNlbGYuY29udGFpbmVyLnN0eWxlOyAvLyBmb3IgZmFzdCBhY2Nlc3NcblxuICAgICAgICAvLyBPYmplY3RzIHRoYXQgaG9sZCBzbGlkZXMgKHRoZXJlIGFyZSBvbmx5IDMgaW4gRE9NKVxuICAgICAgICBzZWxmLml0ZW1Ib2xkZXJzID0gX2l0ZW1Ib2xkZXJzID0gW1xuICAgICAgICAgICAge2VsOnNlbGYuY29udGFpbmVyLmNoaWxkcmVuWzBdICwgd3JhcDowLCBpbmRleDogLTF9LFxuICAgICAgICAgICAge2VsOnNlbGYuY29udGFpbmVyLmNoaWxkcmVuWzFdICwgd3JhcDowLCBpbmRleDogLTF9LFxuICAgICAgICAgICAge2VsOnNlbGYuY29udGFpbmVyLmNoaWxkcmVuWzJdICwgd3JhcDowLCBpbmRleDogLTF9XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gaGlkZSBuZWFyYnkgaXRlbSBob2xkZXJzIHVudGlsIGluaXRpYWwgem9vbSBhbmltYXRpb24gZmluaXNoZXMgKHRvIGF2b2lkIGV4dHJhIFBhaW50cylcbiAgICAgICAgX2l0ZW1Ib2xkZXJzWzBdLmVsLnN0eWxlLmRpc3BsYXkgPSBfaXRlbUhvbGRlcnNbMl0uZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBfc2V0dXBUcmFuc2Zvcm1zKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgZ2xvYmFsIGV2ZW50c1xuICAgICAgICBfZ2xvYmFsRXZlbnRIYW5kbGVycyA9IHtcbiAgICAgICAgICAgIHJlc2l6ZTogc2VsZi51cGRhdGVTaXplLFxuICAgICAgICAgICAgc2Nyb2xsOiBfdXBkYXRlUGFnZVNjcm9sbE9mZnNldCxcbiAgICAgICAgICAgIGtleWRvd246IF9vbktleURvd24sXG4gICAgICAgICAgICBjbGljazogX29uR2xvYmFsQ2xpY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkaXNhYmxlIHNob3cvaGlkZSBlZmZlY3RzIG9uIG9sZCBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgQ1NTIGFuaW1hdGlvbnMgb3IgdHJhbnNmb3JtcywgXG4gICAgICAgIC8vIG9sZCBJT1MsIEFuZHJvaWQgYW5kIE9wZXJhIG1vYmlsZS4gQmxhY2tiZXJyeSBzZWVtcyB0byB3b3JrIGZpbmUsIGV2ZW4gb2xkZXIgbW9kZWxzLlxuICAgICAgICB2YXIgb2xkUGhvbmUgPSBfZmVhdHVyZXMuaXNPbGRJT1NQaG9uZSB8fCBfZmVhdHVyZXMuaXNPbGRBbmRyb2lkIHx8IF9mZWF0dXJlcy5pc01vYmlsZU9wZXJhO1xuICAgICAgICBpZighX2ZlYXR1cmVzLmFuaW1hdGlvbk5hbWUgfHwgIV9mZWF0dXJlcy50cmFuc2Zvcm0gfHwgb2xkUGhvbmUpIHtcbiAgICAgICAgICAgIF9vcHRpb25zLnNob3dBbmltYXRpb25EdXJhdGlvbiA9IF9vcHRpb25zLmhpZGVBbmltYXRpb25EdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0IG1vZHVsZXNcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbJ2luaXQnICsgX21vZHVsZXNbaV1dKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGluaXRcbiAgICAgICAgaWYoVWlDbGFzcykge1xuICAgICAgICAgICAgdmFyIHVpID0gc2VsZi51aSA9IG5ldyBVaUNsYXNzKHNlbGYsIGZyYW1ld29yayk7XG4gICAgICAgICAgICB1aS5pbml0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBfc2hvdXQoJ2ZpcnN0VXBkYXRlJyk7XG4gICAgICAgIF9jdXJyZW50SXRlbUluZGV4ID0gX2N1cnJlbnRJdGVtSW5kZXggfHwgX29wdGlvbnMuaW5kZXggfHwgMDtcbiAgICAgICAgLy8gdmFsaWRhdGUgaW5kZXhcbiAgICAgICAgaWYoIGlzTmFOKF9jdXJyZW50SXRlbUluZGV4KSB8fCBfY3VycmVudEl0ZW1JbmRleCA8IDAgfHwgX2N1cnJlbnRJdGVtSW5kZXggPj0gX2dldE51bUl0ZW1zKCkgKSB7XG4gICAgICAgICAgICBfY3VycmVudEl0ZW1JbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5jdXJySXRlbSA9IF9nZXRJdGVtQXQoIF9jdXJyZW50SXRlbUluZGV4ICk7XG5cbiAgICAgICAgXG4gICAgICAgIGlmKF9mZWF0dXJlcy5pc09sZElPU1Bob25lIHx8IF9mZWF0dXJlcy5pc09sZEFuZHJvaWQpIHtcbiAgICAgICAgICAgIF9pc0ZpeGVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGVtcGxhdGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuICAgICAgICBpZihfb3B0aW9ucy5tb2RhbCkge1xuICAgICAgICAgICAgaWYoIV9pc0ZpeGVkUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUuc3R5bGUudG9wID0gZnJhbWV3b3JrLmdldFNjcm9sbFkoKSArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKF9jdXJyZW50V2luZG93U2Nyb2xsWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfc2hvdXQoJ2luaXRpYWxMYXlvdXQnKTtcbiAgICAgICAgICAgIF9jdXJyZW50V2luZG93U2Nyb2xsWSA9IF9pbml0YWxXaW5kb3dTY3JvbGxZID0gZnJhbWV3b3JrLmdldFNjcm9sbFkoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gYWRkIGNsYXNzZXMgdG8gcm9vdCBlbGVtZW50IG9mIFBob3RvU3dpcGVcbiAgICAgICAgdmFyIHJvb3RDbGFzc2VzID0gJ3Bzd3AtLW9wZW4gJztcbiAgICAgICAgaWYoX29wdGlvbnMubWFpbkNsYXNzKSB7XG4gICAgICAgICAgICByb290Q2xhc3NlcyArPSBfb3B0aW9ucy5tYWluQ2xhc3MgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYoX29wdGlvbnMuc2hvd0hpZGVPcGFjaXR5KSB7XG4gICAgICAgICAgICByb290Q2xhc3NlcyArPSAncHN3cC0tYW5pbWF0ZV9vcGFjaXR5ICc7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdENsYXNzZXMgKz0gX2xpa2VseVRvdWNoRGV2aWNlID8gJ3Bzd3AtLXRvdWNoJyA6ICdwc3dwLS1ub3RvdWNoJztcbiAgICAgICAgcm9vdENsYXNzZXMgKz0gX2ZlYXR1cmVzLmFuaW1hdGlvbk5hbWUgPyAnIHBzd3AtLWNzc19hbmltYXRpb24nIDogJyc7XG4gICAgICAgIHJvb3RDbGFzc2VzICs9IF9mZWF0dXJlcy5zdmcgPyAnIHBzd3AtLXN2ZycgOiAnJztcbiAgICAgICAgZnJhbWV3b3JrLmFkZENsYXNzKHRlbXBsYXRlLCByb290Q2xhc3Nlcyk7XG5cbiAgICAgICAgc2VsZi51cGRhdGVTaXplKCk7XG5cbiAgICAgICAgLy8gaW5pdGlhbCB1cGRhdGVcbiAgICAgICAgX2NvbnRhaW5lclNoaWZ0SW5kZXggPSAtMTtcbiAgICAgICAgX2luZGV4RGlmZiA9IG51bGw7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IE5VTV9IT0xERVJTOyBpKyspIHtcbiAgICAgICAgICAgIF9zZXRUcmFuc2xhdGVYKCAoaStfY29udGFpbmVyU2hpZnRJbmRleCkgKiBfc2xpZGVTaXplLngsIF9pdGVtSG9sZGVyc1tpXS5lbC5zdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighX29sZElFKSB7XG4gICAgICAgICAgICBmcmFtZXdvcmsuYmluZChzZWxmLnNjcm9sbFdyYXAsIF9kb3duRXZlbnRzLCBzZWxmKTsgLy8gbm8gZHJhZ2dpbmcgZm9yIG9sZCBJRVxuICAgICAgICB9ICAgXG5cbiAgICAgICAgX2xpc3RlbignaW5pdGlhbFpvb21JbkVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zZXRDb250ZW50KF9pdGVtSG9sZGVyc1swXSwgX2N1cnJlbnRJdGVtSW5kZXgtMSk7XG4gICAgICAgICAgICBzZWxmLnNldENvbnRlbnQoX2l0ZW1Ib2xkZXJzWzJdLCBfY3VycmVudEl0ZW1JbmRleCsxKTtcblxuICAgICAgICAgICAgX2l0ZW1Ib2xkZXJzWzBdLmVsLnN0eWxlLmRpc3BsYXkgPSBfaXRlbUhvbGRlcnNbMl0uZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgICAgIGlmKF9vcHRpb25zLmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9jdXMgY2F1c2VzIGxheW91dCwgXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggY2F1c2VzIGxhZyBkdXJpbmcgdGhlIGFuaW1hdGlvbiwgXG4gICAgICAgICAgICAgICAgLy8gdGhhdCdzIHdoeSB3ZSBkZWxheSBpdCB1bnRpbGwgdGhlIGluaXRpYWwgem9vbSB0cmFuc2l0aW9uIGVuZHNcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBfYmluZEV2ZW50cygpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgY29udGVudCBmb3IgY2VudGVyIHNsaWRlIChmaXJzdCB0aW1lKVxuICAgICAgICBzZWxmLnNldENvbnRlbnQoX2l0ZW1Ib2xkZXJzWzFdLCBfY3VycmVudEl0ZW1JbmRleCk7XG4gICAgICAgIFxuICAgICAgICBzZWxmLnVwZGF0ZUN1cnJJdGVtKCk7XG5cbiAgICAgICAgX3Nob3V0KCdhZnRlckluaXQnKTtcblxuICAgICAgICBpZighX2lzRml4ZWRQb3NpdGlvbikge1xuXG4gICAgICAgICAgICAvLyBPbiBhbGwgdmVyc2lvbnMgb2YgaU9TIGxvd2VyIHRoYW4gOC4wLCB3ZSBjaGVjayBzaXplIG9mIHZpZXdwb3J0IGV2ZXJ5IHNlY29uZC5cbiAgICAgICAgICAgIC8vIFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIGRldGVjdCB3aGVuIFNhZmFyaSB0b3AgJiBib3R0b20gYmFycyBhcHBlYXIsIFxuICAgICAgICAgICAgLy8gYXMgdGhpcyBhY3Rpb24gZG9lc24ndCB0cmlnZ2VyIGFueSBldmVudHMgKGxpa2UgcmVzaXplKS4gXG4gICAgICAgICAgICAvLyBcbiAgICAgICAgICAgIC8vIE9uIGlPUzggdGhleSBmaXhlZCB0aGlzLlxuICAgICAgICAgICAgLy8gXG4gICAgICAgICAgICAvLyAxMCBOb3YgMjAxNDogaU9TIDcgdXNhZ2UgfjQwJS4gaU9TIDggdXNhZ2UgNTYlLlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBfdXBkYXRlU2l6ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoIV9udW1BbmltYXRpb25zICYmICFfaXNEcmFnZ2luZyAmJiAhX2lzWm9vbWluZyAmJiAoX2N1cnJab29tTGV2ZWwgPT09IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCkgICkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLXZpc2libGUnKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xvc2UgdGhlIGdhbGxlcnksIHRoZW4gZGVzdHJveSBpdFxuICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoIV9pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgX2lzRGVzdHJveWluZyA9IHRydWU7XG4gICAgICAgIF9zaG91dCgnY2xvc2UnKTtcbiAgICAgICAgX3VuYmluZEV2ZW50cygpO1xuXG4gICAgICAgIF9zaG93T3JIaWRlKHNlbGYuY3Vyckl0ZW0sIG51bGwsIHRydWUsIHNlbGYuZGVzdHJveSk7XG4gICAgfSxcblxuICAgIC8vIGRlc3Ryb3lzIHRoZSBnYWxsZXJ5ICh1bmJpbmRzIGV2ZW50cywgY2xlYW5zIHVwIGludGVydmFscyBhbmQgdGltZW91dHMgdG8gYXZvaWQgbWVtb3J5IGxlYWtzKVxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfc2hvdXQoJ2Rlc3Ryb3knKTtcblxuICAgICAgICBpZihfc2hvd09ySGlkZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfc2hvd09ySGlkZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0ZW1wbGF0ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgdGVtcGxhdGUuY2xhc3NOYW1lID0gX2luaXRhbENsYXNzTmFtZTtcblxuICAgICAgICBpZihfdXBkYXRlU2l6ZUludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKF91cGRhdGVTaXplSW50ZXJ2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhbWV3b3JrLnVuYmluZChzZWxmLnNjcm9sbFdyYXAsIF9kb3duRXZlbnRzLCBzZWxmKTtcblxuICAgICAgICAvLyB3ZSB1bmJpbmQgc2Nyb2xsIGV2ZW50IGF0IHRoZSBlbmQsIGFzIGNsb3NpbmcgYW5pbWF0aW9uIG1heSBkZXBlbmQgb24gaXRcbiAgICAgICAgZnJhbWV3b3JrLnVuYmluZCh3aW5kb3csICdzY3JvbGwnLCBzZWxmKTtcblxuICAgICAgICBfc3RvcERyYWdVcGRhdGVMb29wKCk7XG5cbiAgICAgICAgX3N0b3BBbGxBbmltYXRpb25zKCk7XG5cbiAgICAgICAgX2xpc3RlbmVycyA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbiBpbWFnZSB0byBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4ICAgICBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAgICAgXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBXaWxsIGlnbm9yZSBib3VuZHMgaWYgc2V0IHRvIHRydWUuXG4gICAgICovXG4gICAgcGFuVG86IGZ1bmN0aW9uKHgseSxmb3JjZSkge1xuICAgICAgICBpZighZm9yY2UpIHtcbiAgICAgICAgICAgIGlmKHggPiBfY3VyclBhbkJvdW5kcy5taW4ueCkge1xuICAgICAgICAgICAgICAgIHggPSBfY3VyclBhbkJvdW5kcy5taW4ueDtcbiAgICAgICAgICAgIH0gZWxzZSBpZih4IDwgX2N1cnJQYW5Cb3VuZHMubWF4LngpIHtcbiAgICAgICAgICAgICAgICB4ID0gX2N1cnJQYW5Cb3VuZHMubWF4Lng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHkgPiBfY3VyclBhbkJvdW5kcy5taW4ueSkge1xuICAgICAgICAgICAgICAgIHkgPSBfY3VyclBhbkJvdW5kcy5taW4ueTtcbiAgICAgICAgICAgIH0gZWxzZSBpZih5IDwgX2N1cnJQYW5Cb3VuZHMubWF4LnkpIHtcbiAgICAgICAgICAgICAgICB5ID0gX2N1cnJQYW5Cb3VuZHMubWF4Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIF9wYW5PZmZzZXQueCA9IHg7XG4gICAgICAgIF9wYW5PZmZzZXQueSA9IHk7XG4gICAgICAgIF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgfSxcbiAgICBcbiAgICBoYW5kbGVFdmVudDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICBpZihfZ2xvYmFsRXZlbnRIYW5kbGVyc1tlLnR5cGVdKSB7XG4gICAgICAgICAgICBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tlLnR5cGVdKGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgZ29UbzogZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICBpbmRleCA9IF9nZXRMb29wZWRJZChpbmRleCk7XG5cbiAgICAgICAgdmFyIGRpZmYgPSBpbmRleCAtIF9jdXJyZW50SXRlbUluZGV4O1xuICAgICAgICBfaW5kZXhEaWZmID0gZGlmZjtcblxuICAgICAgICBfY3VycmVudEl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgICBzZWxmLmN1cnJJdGVtID0gX2dldEl0ZW1BdCggX2N1cnJlbnRJdGVtSW5kZXggKTtcbiAgICAgICAgX2N1cnJQb3NpdGlvbkluZGV4IC09IGRpZmY7XG4gICAgICAgIFxuICAgICAgICBfbW92ZU1haW5TY3JvbGwoX3NsaWRlU2l6ZS54ICogX2N1cnJQb3NpdGlvbkluZGV4KTtcbiAgICAgICAgXG5cbiAgICAgICAgX3N0b3BBbGxBbmltYXRpb25zKCk7XG4gICAgICAgIF9tYWluU2Nyb2xsQW5pbWF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgc2VsZi51cGRhdGVDdXJySXRlbSgpO1xuICAgIH0sXG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuZ29UbyggX2N1cnJlbnRJdGVtSW5kZXggKyAxKTtcbiAgICB9LFxuICAgIHByZXY6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmdvVG8oIF9jdXJyZW50SXRlbUluZGV4IC0gMSk7XG4gICAgfSxcblxuICAgIC8vIHVwZGF0ZSBjdXJyZW50IHpvb20vcGFuIG9iamVjdHNcbiAgICB1cGRhdGVDdXJyWm9vbUl0ZW06IGZ1bmN0aW9uKGVtdWxhdGVTZXRDb250ZW50KSB7XG4gICAgICAgIGlmKGVtdWxhdGVTZXRDb250ZW50KSB7XG4gICAgICAgICAgICBfc2hvdXQoJ2JlZm9yZUNoYW5nZScsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXRlbUhvbGRlclsxXSBpcyBtaWRkbGUgKGN1cnJlbnQpIGl0ZW1cbiAgICAgICAgaWYoX2l0ZW1Ib2xkZXJzWzFdLmVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHpvb21FbGVtZW50ID0gX2l0ZW1Ib2xkZXJzWzFdLmVsLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYoIGZyYW1ld29yay5oYXNDbGFzcyh6b29tRWxlbWVudCwgJ3Bzd3BfX3pvb20td3JhcCcpICkge1xuICAgICAgICAgICAgICAgIF9jdXJyWm9vbUVsZW1lbnRTdHlsZSA9IHpvb21FbGVtZW50LnN0eWxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY3Vyclpvb21FbGVtZW50U3R5bGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2N1cnJab29tRWxlbWVudFN0eWxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgX2N1cnJQYW5Cb3VuZHMgPSBzZWxmLmN1cnJJdGVtLmJvdW5kczsgIFxuICAgICAgICBfc3RhcnRab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbCA9IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbDtcblxuICAgICAgICBfcGFuT2Zmc2V0LnggPSBfY3VyclBhbkJvdW5kcy5jZW50ZXIueDtcbiAgICAgICAgX3Bhbk9mZnNldC55ID0gX2N1cnJQYW5Cb3VuZHMuY2VudGVyLnk7XG5cbiAgICAgICAgaWYoZW11bGF0ZVNldENvbnRlbnQpIHtcbiAgICAgICAgICAgIF9zaG91dCgnYWZ0ZXJDaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIGludmFsaWRhdGVDdXJySXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfaXRlbXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IE5VTV9IT0xERVJTOyBpKyspIHtcbiAgICAgICAgICAgIGlmKCBfaXRlbUhvbGRlcnNbaV0uaXRlbSApIHtcbiAgICAgICAgICAgICAgICBfaXRlbUhvbGRlcnNbaV0uaXRlbS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlQ3Vyckl0ZW06IGZ1bmN0aW9uKGJlZm9yZUFuaW1hdGlvbikge1xuXG4gICAgICAgIGlmKF9pbmRleERpZmYgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmQWJzID0gTWF0aC5hYnMoX2luZGV4RGlmZiksXG4gICAgICAgICAgICB0ZW1wSG9sZGVyO1xuXG4gICAgICAgIGlmKGJlZm9yZUFuaW1hdGlvbiAmJiBkaWZmQWJzIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICBzZWxmLmN1cnJJdGVtID0gX2dldEl0ZW1BdCggX2N1cnJlbnRJdGVtSW5kZXggKTtcbiAgICAgICAgX3JlbmRlck1heFJlc29sdXRpb24gPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIF9zaG91dCgnYmVmb3JlQ2hhbmdlJywgX2luZGV4RGlmZik7XG5cbiAgICAgICAgaWYoZGlmZkFicyA+PSBOVU1fSE9MREVSUykge1xuICAgICAgICAgICAgX2NvbnRhaW5lclNoaWZ0SW5kZXggKz0gX2luZGV4RGlmZiArIChfaW5kZXhEaWZmID4gMCA/IC1OVU1fSE9MREVSUyA6IE5VTV9IT0xERVJTKTtcbiAgICAgICAgICAgIGRpZmZBYnMgPSBOVU1fSE9MREVSUztcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGlmZkFiczsgaSsrKSB7XG4gICAgICAgICAgICBpZihfaW5kZXhEaWZmID4gMCkge1xuICAgICAgICAgICAgICAgIHRlbXBIb2xkZXIgPSBfaXRlbUhvbGRlcnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBfaXRlbUhvbGRlcnNbTlVNX0hPTERFUlMtMV0gPSB0ZW1wSG9sZGVyOyAvLyBtb3ZlIGZpcnN0IHRvIGxhc3RcblxuICAgICAgICAgICAgICAgIF9jb250YWluZXJTaGlmdEluZGV4Kys7XG4gICAgICAgICAgICAgICAgX3NldFRyYW5zbGF0ZVgoIChfY29udGFpbmVyU2hpZnRJbmRleCsyKSAqIF9zbGlkZVNpemUueCwgdGVtcEhvbGRlci5lbC5zdHlsZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRDb250ZW50KHRlbXBIb2xkZXIsIF9jdXJyZW50SXRlbUluZGV4IC0gZGlmZkFicyArIGkgKyAxICsgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBIb2xkZXIgPSBfaXRlbUhvbGRlcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgX2l0ZW1Ib2xkZXJzLnVuc2hpZnQoIHRlbXBIb2xkZXIgKTsgLy8gbW92ZSBsYXN0IHRvIGZpcnN0XG5cbiAgICAgICAgICAgICAgICBfY29udGFpbmVyU2hpZnRJbmRleC0tO1xuICAgICAgICAgICAgICAgIF9zZXRUcmFuc2xhdGVYKCBfY29udGFpbmVyU2hpZnRJbmRleCAqIF9zbGlkZVNpemUueCwgdGVtcEhvbGRlci5lbC5zdHlsZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRDb250ZW50KHRlbXBIb2xkZXIsIF9jdXJyZW50SXRlbUluZGV4ICsgZGlmZkFicyAtIGkgLSAxIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHpvb20vcGFuIG9uIHByZXZpb3VzIGl0ZW1cbiAgICAgICAgaWYoX2N1cnJab29tRWxlbWVudFN0eWxlICYmIE1hdGguYWJzKF9pbmRleERpZmYpID09PSAxKSB7XG5cbiAgICAgICAgICAgIHZhciBwcmV2SXRlbSA9IF9nZXRJdGVtQXQoX3ByZXZJdGVtSW5kZXgpO1xuICAgICAgICAgICAgaWYocHJldkl0ZW0uaW5pdGlhbFpvb21MZXZlbCAhPT0gX2N1cnJab29tTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBfY2FsY3VsYXRlSXRlbVNpemUocHJldkl0ZW0gLCBfdmlld3BvcnRTaXplICk7XG4gICAgICAgICAgICAgICAgX3NldEltYWdlU2l6ZShwcmV2SXRlbSk7XG4gICAgICAgICAgICAgICAgX2FwcGx5Wm9vbVBhblRvSXRlbSggcHJldkl0ZW0gKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IGRpZmYgYWZ0ZXIgdXBkYXRlXG4gICAgICAgIF9pbmRleERpZmYgPSAwO1xuXG4gICAgICAgIHNlbGYudXBkYXRlQ3Vyclpvb21JdGVtKCk7XG5cbiAgICAgICAgX3ByZXZJdGVtSW5kZXggPSBfY3VycmVudEl0ZW1JbmRleDtcblxuICAgICAgICBfc2hvdXQoJ2FmdGVyQ2hhbmdlJyk7XG4gICAgICAgIFxuICAgIH0sXG5cblxuXG4gICAgdXBkYXRlU2l6ZTogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgXG4gICAgICAgIGlmKCFfaXNGaXhlZFBvc2l0aW9uICYmIF9vcHRpb25zLm1vZGFsKSB7XG4gICAgICAgICAgICB2YXIgd2luZG93U2Nyb2xsWSA9IGZyYW1ld29yay5nZXRTY3JvbGxZKCk7XG4gICAgICAgICAgICBpZihfY3VycmVudFdpbmRvd1Njcm9sbFkgIT09IHdpbmRvd1Njcm9sbFkpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5zdHlsZS50b3AgPSB3aW5kb3dTY3JvbGxZICsgJ3B4JztcbiAgICAgICAgICAgICAgICBfY3VycmVudFdpbmRvd1Njcm9sbFkgPSB3aW5kb3dTY3JvbGxZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWZvcmNlICYmIF93aW5kb3dWaXNpYmxlU2l6ZS54ID09PSB3aW5kb3cuaW5uZXJXaWR0aCAmJiBfd2luZG93VmlzaWJsZVNpemUueSA9PT0gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3dpbmRvd1Zpc2libGVTaXplLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgIF93aW5kb3dWaXNpYmxlU2l6ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgICAvL3RlbXBsYXRlLnN0eWxlLndpZHRoID0gX3dpbmRvd1Zpc2libGVTaXplLnggKyAncHgnO1xuICAgICAgICAgICAgdGVtcGxhdGUuc3R5bGUuaGVpZ2h0ID0gX3dpbmRvd1Zpc2libGVTaXplLnkgKyAncHgnO1xuICAgICAgICB9XG5cblxuXG4gICAgICAgIF92aWV3cG9ydFNpemUueCA9IHNlbGYuc2Nyb2xsV3JhcC5jbGllbnRXaWR0aDtcbiAgICAgICAgX3ZpZXdwb3J0U2l6ZS55ID0gc2VsZi5zY3JvbGxXcmFwLmNsaWVudEhlaWdodDtcblxuICAgICAgICBfdXBkYXRlUGFnZVNjcm9sbE9mZnNldCgpO1xuXG4gICAgICAgIF9zbGlkZVNpemUueCA9IF92aWV3cG9ydFNpemUueCArIE1hdGgucm91bmQoX3ZpZXdwb3J0U2l6ZS54ICogX29wdGlvbnMuc3BhY2luZyk7XG4gICAgICAgIF9zbGlkZVNpemUueSA9IF92aWV3cG9ydFNpemUueTtcblxuICAgICAgICBfbW92ZU1haW5TY3JvbGwoX3NsaWRlU2l6ZS54ICogX2N1cnJQb3NpdGlvbkluZGV4KTtcblxuICAgICAgICBfc2hvdXQoJ2JlZm9yZVJlc2l6ZScpOyAvLyBldmVuIG1heSBiZSB1c2VkIGZvciBleGFtcGxlIHRvIHN3aXRjaCBpbWFnZSBzb3VyY2VzXG5cblxuICAgICAgICAvLyBkb24ndCByZS1jYWxjdWxhdGUgc2l6ZSBvbiBpbml0YWwgc2l6ZSB1cGRhdGVcbiAgICAgICAgaWYoX2NvbnRhaW5lclNoaWZ0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICB2YXIgaG9sZGVyLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgaEluZGV4O1xuXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgTlVNX0hPTERFUlM7IGkrKykge1xuICAgICAgICAgICAgICAgIGhvbGRlciA9IF9pdGVtSG9sZGVyc1tpXTtcbiAgICAgICAgICAgICAgICBfc2V0VHJhbnNsYXRlWCggKGkrX2NvbnRhaW5lclNoaWZ0SW5kZXgpICogX3NsaWRlU2l6ZS54LCBob2xkZXIuZWwuc3R5bGUpO1xuXG4gICAgICAgICAgICAgICAgaEluZGV4ID0gX2N1cnJlbnRJdGVtSW5kZXgraS0xO1xuXG4gICAgICAgICAgICAgICAgaWYoX29wdGlvbnMubG9vcCAmJiBfZ2V0TnVtSXRlbXMoKSA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaEluZGV4ID0gX2dldExvb3BlZElkKGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHpvb20gbGV2ZWwgb24gaXRlbXMgYW5kIHJlZnJlc2ggc291cmNlIChpZiBuZWVkc1VwZGF0ZSlcbiAgICAgICAgICAgICAgICBpdGVtID0gX2dldEl0ZW1BdCggaEluZGV4ICk7XG5cbiAgICAgICAgICAgICAgICAvLyByZS1yZW5kZXIgZ2FsbGVyeSBpdGVtIGlmIGBuZWVkc1VwZGF0ZWAsXG4gICAgICAgICAgICAgICAgLy8gb3IgZG9lc24ndCBoYXZlIGBib3VuZHNgIChlbnRpcmVseSBuZXcgc2xpZGUgb2JqZWN0KVxuICAgICAgICAgICAgICAgIGlmKCBpdGVtICYmIChfaXRlbXNOZWVkVXBkYXRlIHx8IGl0ZW0ubmVlZHNVcGRhdGUgfHwgIWl0ZW0uYm91bmRzKSApIHtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFuU2xpZGUoIGl0ZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudCggaG9sZGVyLCBoSW5kZXggKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBcImNlbnRlclwiIHNsaWRlXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3Vyckl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDdXJyWm9vbUl0ZW0odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpdGVtLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaG9sZGVyLmluZGV4ID09PSAtMSAmJiBoSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgY29udGVudCBmaXJzdCB0aW1lXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudCggaG9sZGVyLCBoSW5kZXggKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoaXRlbSAmJiBpdGVtLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBfY2FsY3VsYXRlSXRlbVNpemUoaXRlbSwgX3ZpZXdwb3J0U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIF9zZXRJbWFnZVNpemUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIF9hcHBseVpvb21QYW5Ub0l0ZW0oIGl0ZW0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfaXRlbXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIH0gICBcblxuICAgICAgICBfc3RhcnRab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbCA9IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbDtcbiAgICAgICAgX2N1cnJQYW5Cb3VuZHMgPSBzZWxmLmN1cnJJdGVtLmJvdW5kcztcblxuICAgICAgICBpZihfY3VyclBhbkJvdW5kcykge1xuICAgICAgICAgICAgX3Bhbk9mZnNldC54ID0gX2N1cnJQYW5Cb3VuZHMuY2VudGVyLng7XG4gICAgICAgICAgICBfcGFuT2Zmc2V0LnkgPSBfY3VyclBhbkJvdW5kcy5jZW50ZXIueTtcbiAgICAgICAgICAgIF9hcHBseUN1cnJlbnRab29tUGFuKCB0cnVlICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIF9zaG91dCgncmVzaXplJyk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBab29tIGN1cnJlbnQgaXRlbSB0b1xuICAgIHpvb21UbzogZnVuY3Rpb24oZGVzdFpvb21MZXZlbCwgY2VudGVyUG9pbnQsIHNwZWVkLCBlYXNpbmdGbiwgdXBkYXRlRm4pIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIGlmKGRlc3Rab29tTGV2ZWwgPT09ICdmaXQnKSB7XG4gICAgICAgICAgICAgICAgZGVzdFpvb21MZXZlbCA9IHNlbGYuY3Vyckl0ZW0uZml0UmF0aW87XG4gICAgICAgICAgICB9IGVsc2UgaWYoZGVzdFpvb21MZXZlbCA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgICAgICAgICAgZGVzdFpvb21MZXZlbCA9IHNlbGYuY3Vyckl0ZW0uZmlsbFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgICAgIGlmKGNlbnRlclBvaW50KSB7XG4gICAgICAgICAgICBfc3RhcnRab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbDtcbiAgICAgICAgICAgIF9taWRab29tUG9pbnQueCA9IE1hdGguYWJzKGNlbnRlclBvaW50LngpIC0gX3Bhbk9mZnNldC54IDtcbiAgICAgICAgICAgIF9taWRab29tUG9pbnQueSA9IE1hdGguYWJzKGNlbnRlclBvaW50LnkpIC0gX3Bhbk9mZnNldC55IDtcbiAgICAgICAgICAgIF9lcXVhbGl6ZVBvaW50cyhfc3RhcnRQYW5PZmZzZXQsIF9wYW5PZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlc3RQYW5Cb3VuZHMgPSBfY2FsY3VsYXRlUGFuQm91bmRzKGRlc3Rab29tTGV2ZWwsIGZhbHNlKSxcbiAgICAgICAgICAgIGRlc3RQYW5PZmZzZXQgPSB7fTtcblxuICAgICAgICBfbW9kaWZ5RGVzdFBhbk9mZnNldCgneCcsIGRlc3RQYW5Cb3VuZHMsIGRlc3RQYW5PZmZzZXQsIGRlc3Rab29tTGV2ZWwpO1xuICAgICAgICBfbW9kaWZ5RGVzdFBhbk9mZnNldCgneScsIGRlc3RQYW5Cb3VuZHMsIGRlc3RQYW5PZmZzZXQsIGRlc3Rab29tTGV2ZWwpO1xuXG4gICAgICAgIHZhciBpbml0aWFsWm9vbUxldmVsID0gX2N1cnJab29tTGV2ZWw7XG4gICAgICAgIHZhciBpbml0aWFsUGFuT2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogX3Bhbk9mZnNldC54LFxuICAgICAgICAgICAgeTogX3Bhbk9mZnNldC55XG4gICAgICAgIH07XG5cbiAgICAgICAgX3JvdW5kUG9pbnQoZGVzdFBhbk9mZnNldCk7XG5cbiAgICAgICAgdmFyIG9uVXBkYXRlID0gZnVuY3Rpb24obm93KSB7XG4gICAgICAgICAgICBpZihub3cgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBfY3Vyclpvb21MZXZlbCA9IGRlc3Rab29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgX3Bhbk9mZnNldC54ID0gZGVzdFBhbk9mZnNldC54O1xuICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueSA9IGRlc3RQYW5PZmZzZXQueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2N1cnJab29tTGV2ZWwgPSAoZGVzdFpvb21MZXZlbCAtIGluaXRpYWxab29tTGV2ZWwpICogbm93ICsgaW5pdGlhbFpvb21MZXZlbDtcbiAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnggPSAoZGVzdFBhbk9mZnNldC54IC0gaW5pdGlhbFBhbk9mZnNldC54KSAqIG5vdyArIGluaXRpYWxQYW5PZmZzZXQueDtcbiAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnkgPSAoZGVzdFBhbk9mZnNldC55IC0gaW5pdGlhbFBhbk9mZnNldC55KSAqIG5vdyArIGluaXRpYWxQYW5PZmZzZXQueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodXBkYXRlRm4pIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVGbihub3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbiggbm93ID09PSAxICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoc3BlZWQpIHtcbiAgICAgICAgICAgIF9hbmltYXRlUHJvcCgnY3VzdG9tWm9vbVRvJywgMCwgMSwgc3BlZWQsIGVhc2luZ0ZuIHx8IGZyYW1ld29yay5lYXNpbmcuc2luZS5pbk91dCwgb25VcGRhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25VcGRhdGUoMSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcblxuXG4vKj4+Y29yZSovXG5cbi8qPj5nZXN0dXJlcyovXG4vKipcbiAqIE1vdXNlL3RvdWNoL3BvaW50ZXIgZXZlbnQgaGFuZGxlcnMuXG4gKiBcbiAqIHNlcGFyYXRlZCBmcm9tIEBjb3JlLmpzIGZvciByZWFkYWJpbGl0eVxuICovXG5cbnZhciBNSU5fU1dJUEVfRElTVEFOQ0UgPSAzMCxcbiAgICBESVJFQ1RJT05fQ0hFQ0tfT0ZGU0VUID0gMTA7IC8vIGFtb3VudCBvZiBwaXhlbHMgdG8gZHJhZyB0byBkZXRlcm1pbmUgZGlyZWN0aW9uIG9mIHN3aXBlXG5cbnZhciBfZ2VzdHVyZVN0YXJ0VGltZSxcbiAgICBfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lLFxuXG4gICAgLy8gcG9vbCBvZiBvYmplY3RzIHRoYXQgYXJlIHVzZWQgZHVyaW5nIGRyYWdnaW5nIG9mIHpvb21pbmdcbiAgICBwID0ge30sIC8vIGZpcnN0IHBvaW50XG4gICAgcDIgPSB7fSwgLy8gc2Vjb25kIHBvaW50IChmb3Igem9vbSBnZXN0dXJlKVxuICAgIGRlbHRhID0ge30sXG4gICAgX2N1cnJQb2ludCA9IHt9LFxuICAgIF9zdGFydFBvaW50ID0ge30sXG4gICAgX2N1cnJQb2ludGVycyA9IFtdLFxuICAgIF9zdGFydE1haW5TY3JvbGxQb3MgPSB7fSxcbiAgICBfcmVsZWFzZUFuaW1EYXRhLFxuICAgIF9wb3NQb2ludHMgPSBbXSwgLy8gYXJyYXkgb2YgcG9pbnRzIGR1cmluZyBkcmFnZ2luZywgdXNlZCB0byBkZXRlcm1pbmUgdHlwZSBvZiBnZXN0dXJlXG4gICAgX3RlbXBQb2ludCA9IHt9LFxuXG4gICAgX2lzWm9vbWluZ0luLFxuICAgIF92ZXJ0aWNhbERyYWdJbml0aWF0ZWQsXG4gICAgX29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQsXG4gICAgX2N1cnJab29tZWRJdGVtSW5kZXggPSAwLFxuICAgIF9jZW50ZXJQb2ludCA9IF9nZXRFbXB0eVBvaW50KCksXG4gICAgX2xhc3RSZWxlYXNlVGltZSA9IDAsXG4gICAgX2lzRHJhZ2dpbmcsIC8vIGF0IGxlYXN0IG9uZSBwb2ludGVyIGlzIGRvd25cbiAgICBfaXNNdWx0aXRvdWNoLCAvLyBhdCBsZWFzdCB0d28gX3BvaW50ZXJzIGFyZSBkb3duXG4gICAgX3pvb21TdGFydGVkLCAvLyB6b29tIGxldmVsIGNoYW5nZWQgZHVyaW5nIHpvb20gZ2VzdHVyZVxuICAgIF9tb3ZlZCxcbiAgICBfZHJhZ0FuaW1GcmFtZSxcbiAgICBfbWFpblNjcm9sbFNoaWZ0ZWQsXG4gICAgX2N1cnJlbnRQb2ludHMsIC8vIGFycmF5IG9mIGN1cnJlbnQgdG91Y2ggcG9pbnRzXG4gICAgX2lzWm9vbWluZyxcbiAgICBfY3VyclBvaW50c0Rpc3RhbmNlLFxuICAgIF9zdGFydFBvaW50c0Rpc3RhbmNlLFxuICAgIF9jdXJyUGFuQm91bmRzLFxuICAgIF9tYWluU2Nyb2xsUG9zID0gX2dldEVtcHR5UG9pbnQoKSxcbiAgICBfY3Vyclpvb21FbGVtZW50U3R5bGUsXG4gICAgX21haW5TY3JvbGxBbmltYXRpbmcsIC8vIHRydWUsIGlmIGFuaW1hdGlvbiBhZnRlciBzd2lwZSBnZXN0dXJlIGlzIHJ1bm5pbmdcbiAgICBfbWlkWm9vbVBvaW50ID0gX2dldEVtcHR5UG9pbnQoKSxcbiAgICBfY3VyckNlbnRlclBvaW50ID0gX2dldEVtcHR5UG9pbnQoKSxcbiAgICBfZGlyZWN0aW9uLFxuICAgIF9pc0ZpcnN0TW92ZSxcbiAgICBfb3BhY2l0eUNoYW5nZWQsXG4gICAgX2JnT3BhY2l0eSxcbiAgICBfd2FzT3ZlckluaXRpYWxab29tLFxuXG4gICAgX2lzRXF1YWxQb2ludHMgPSBmdW5jdGlvbihwMSwgcDIpIHtcbiAgICAgICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbiAgICB9LFxuICAgIF9pc05lYXJieVBvaW50cyA9IGZ1bmN0aW9uKHRvdWNoMCwgdG91Y2gxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0b3VjaDAueCAtIHRvdWNoMS54KSA8IERPVUJMRV9UQVBfUkFESVVTICYmIE1hdGguYWJzKHRvdWNoMC55IC0gdG91Y2gxLnkpIDwgRE9VQkxFX1RBUF9SQURJVVM7XG4gICAgfSxcbiAgICBfY2FsY3VsYXRlUG9pbnRzRGlzdGFuY2UgPSBmdW5jdGlvbihwMSwgcDIpIHtcbiAgICAgICAgX3RlbXBQb2ludC54ID0gTWF0aC5hYnMoIHAxLnggLSBwMi54ICk7XG4gICAgICAgIF90ZW1wUG9pbnQueSA9IE1hdGguYWJzKCBwMS55IC0gcDIueSApO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KF90ZW1wUG9pbnQueCAqIF90ZW1wUG9pbnQueCArIF90ZW1wUG9pbnQueSAqIF90ZW1wUG9pbnQueSk7XG4gICAgfSxcbiAgICBfc3RvcERyYWdVcGRhdGVMb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKF9kcmFnQW5pbUZyYW1lKSB7XG4gICAgICAgICAgICBfY2FuY2VsQUYoX2RyYWdBbmltRnJhbWUpO1xuICAgICAgICAgICAgX2RyYWdBbmltRnJhbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZHJhZ1VwZGF0ZUxvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoX2lzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIF9kcmFnQW5pbUZyYW1lID0gX3JlcXVlc3RBRihfZHJhZ1VwZGF0ZUxvb3ApO1xuICAgICAgICAgICAgX3JlbmRlck1vdmVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9jYW5QYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEoX29wdGlvbnMuc2NhbGVNb2RlID09PSAnZml0JyAmJiBfY3Vyclpvb21MZXZlbCA9PT0gIHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBmaW5kIHRoZSBjbG9zZXN0IHBhcmVudCBET00gZWxlbWVudFxuICAgIF9jbG9zZXN0RWxlbWVudCA9IGZ1bmN0aW9uKGVsLCBmbikge1xuICAgICAgICBpZighZWwgfHwgZWwgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb24ndCBzZWFyY2ggZWxlbWVudHMgYWJvdmUgcHN3cF9fc2Nyb2xsLXdyYXBcbiAgICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpICYmIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKS5pbmRleE9mKCdwc3dwX19zY3JvbGwtd3JhcCcpID4gLTEgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZm4oZWwpICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jbG9zZXN0RWxlbWVudChlbC5wYXJlbnROb2RlLCBmbik7XG4gICAgfSxcblxuICAgIF9wcmV2ZW50T2JqID0ge30sXG4gICAgX3ByZXZlbnREZWZhdWx0RXZlbnRCZWhhdmlvdXIgPSBmdW5jdGlvbihlLCBpc0Rvd24pIHtcbiAgICAgICAgX3ByZXZlbnRPYmoucHJldmVudCA9ICFfY2xvc2VzdEVsZW1lbnQoZS50YXJnZXQsIF9vcHRpb25zLmlzQ2xpY2thYmxlRWxlbWVudCk7XG5cbiAgICAgICAgX3Nob3V0KCdwcmV2ZW50RHJhZ0V2ZW50JywgZSwgaXNEb3duLCBfcHJldmVudE9iaik7XG4gICAgICAgIHJldHVybiBfcHJldmVudE9iai5wcmV2ZW50O1xuXG4gICAgfSxcbiAgICBfY29udmVydFRvdWNoVG9Qb2ludCA9IGZ1bmN0aW9uKHRvdWNoLCBwKSB7XG4gICAgICAgIHAueCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgICBwLnkgPSB0b3VjaC5wYWdlWTtcbiAgICAgICAgcC5pZCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgX2ZpbmRDZW50ZXJPZlBvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMiwgcENlbnRlcikge1xuICAgICAgICBwQ2VudGVyLnggPSAocDEueCArIHAyLngpICogMC41O1xuICAgICAgICBwQ2VudGVyLnkgPSAocDEueSArIHAyLnkpICogMC41O1xuICAgIH0sXG4gICAgX3B1c2hQb3NQb2ludCA9IGZ1bmN0aW9uKHRpbWUsIHgsIHkpIHtcbiAgICAgICAgaWYodGltZSAtIF9nZXN0dXJlQ2hlY2tTcGVlZFRpbWUgPiA1MCkge1xuICAgICAgICAgICAgdmFyIG8gPSBfcG9zUG9pbnRzLmxlbmd0aCA+IDIgPyBfcG9zUG9pbnRzLnNoaWZ0KCkgOiB7fTtcbiAgICAgICAgICAgIG8ueCA9IHg7XG4gICAgICAgICAgICBvLnkgPSB5OyBcbiAgICAgICAgICAgIF9wb3NQb2ludHMucHVzaChvKTtcbiAgICAgICAgICAgIF9nZXN0dXJlQ2hlY2tTcGVlZFRpbWUgPSB0aW1lO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jYWxjdWxhdGVWZXJ0aWNhbERyYWdPcGFjaXR5UmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSBfcGFuT2Zmc2V0LnkgLSBzZWxmLmN1cnJJdGVtLmluaXRpYWxQb3NpdGlvbi55OyAvLyBkaWZmZXJlbmNlIGJldHdlZW4gaW5pdGlhbCBhbmQgY3VycmVudCBwb3NpdGlvblxuICAgICAgICByZXR1cm4gMSAtICBNYXRoLmFicyggeU9mZnNldCAvIChfdmlld3BvcnRTaXplLnkgLyAyKSAgKTtcbiAgICB9LFxuXG4gICAgXG4gICAgLy8gcG9pbnRzIHBvb2wsIHJldXNlZCBkdXJpbmcgdG91Y2ggZXZlbnRzXG4gICAgX2VQb2ludDEgPSB7fSxcbiAgICBfZVBvaW50MiA9IHt9LFxuICAgIF90ZW1wUG9pbnRzQXJyID0gW10sXG4gICAgX3RlbXBDb3VudGVyLFxuICAgIF9nZXRUb3VjaFBvaW50cyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gY2xlYW4gdXAgcHJldmlvdXMgcG9pbnRzLCB3aXRob3V0IHJlY3JlYXRpbmcgYXJyYXlcbiAgICAgICAgd2hpbGUoX3RlbXBQb2ludHNBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgX3RlbXBQb2ludHNBcnIucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmKGUudHlwZS5pbmRleE9mKCd0b3VjaCcpID4gLTEpIHtcblxuICAgICAgICAgICAgICAgIGlmKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGVtcFBvaW50c0FyclswXSA9IF9jb252ZXJ0VG91Y2hUb1BvaW50KGUudG91Y2hlc1swXSwgX2VQb2ludDEpO1xuICAgICAgICAgICAgICAgICAgICBpZihlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RlbXBQb2ludHNBcnJbMV0gPSBfY29udmVydFRvdWNoVG9Qb2ludChlLnRvdWNoZXNbMV0sIF9lUG9pbnQyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2VQb2ludDEueCA9IGUucGFnZVg7XG4gICAgICAgICAgICAgICAgX2VQb2ludDEueSA9IGUucGFnZVk7XG4gICAgICAgICAgICAgICAgX2VQb2ludDEuaWQgPSAnJztcbiAgICAgICAgICAgICAgICBfdGVtcFBvaW50c0FyclswXSA9IF9lUG9pbnQxOy8vX2VQb2ludDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGVtcENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgLy8gd2UgY2FuIHVzZSBmb3JFYWNoLCBhcyBwb2ludGVyIGV2ZW50cyBhcmUgc3VwcG9ydGVkIG9ubHkgaW4gbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgICAgICBfY3VyclBvaW50ZXJzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIGlmKF90ZW1wQ291bnRlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGVtcFBvaW50c0FyclswXSA9IHA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKF90ZW1wQ291bnRlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBfdGVtcFBvaW50c0FyclsxXSA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90ZW1wQ291bnRlcisrO1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RlbXBQb2ludHNBcnI7XG4gICAgfSxcblxuICAgIF9wYW5Pck1vdmVNYWluU2Nyb2xsID0gZnVuY3Rpb24oYXhpcywgZGVsdGEpIHtcblxuICAgICAgICB2YXIgcGFuRnJpY3Rpb24sXG4gICAgICAgICAgICBvdmVyRGlmZiA9IDAsXG4gICAgICAgICAgICBuZXdPZmZzZXQgPSBfcGFuT2Zmc2V0W2F4aXNdICsgZGVsdGFbYXhpc10sXG4gICAgICAgICAgICBzdGFydE92ZXJEaWZmLFxuICAgICAgICAgICAgZGlyID0gZGVsdGFbYXhpc10gPiAwLFxuICAgICAgICAgICAgbmV3TWFpblNjcm9sbFBvc2l0aW9uID0gX21haW5TY3JvbGxQb3MueCArIGRlbHRhLngsXG4gICAgICAgICAgICBtYWluU2Nyb2xsRGlmZiA9IF9tYWluU2Nyb2xsUG9zLnggLSBfc3RhcnRNYWluU2Nyb2xsUG9zLngsXG4gICAgICAgICAgICBuZXdQYW5Qb3MsXG4gICAgICAgICAgICBuZXdNYWluU2Nyb2xsUG9zO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmZGlzdGFuY2Ugb3ZlciB0aGUgYm91bmRzIGFuZCBmcmljdGlvblxuICAgICAgICBpZihuZXdPZmZzZXQgPiBfY3VyclBhbkJvdW5kcy5taW5bYXhpc10gfHwgbmV3T2Zmc2V0IDwgX2N1cnJQYW5Cb3VuZHMubWF4W2F4aXNdKSB7XG4gICAgICAgICAgICBwYW5GcmljdGlvbiA9IF9vcHRpb25zLnBhbkVuZEZyaWN0aW9uO1xuICAgICAgICAgICAgLy8gTGluZWFyIGluY3JlYXNpbmcgb2YgZnJpY3Rpb24sIHNvIGF0IDEvNCBvZiB2aWV3cG9ydCBpdCdzIGF0IG1heCB2YWx1ZS4gXG4gICAgICAgICAgICAvLyBMb29rcyBub3QgYXMgbmljZSBhcyB3YXMgZXhwZWN0ZWQuIExlZnQgZm9yIGhpc3RvcnkuXG4gICAgICAgICAgICAvLyBwYW5GcmljdGlvbiA9ICgxIC0gKF9wYW5PZmZzZXRbYXhpc10gKyBkZWx0YVtheGlzXSArIHBhbkJvdW5kcy5taW5bYXhpc10pIC8gKF92aWV3cG9ydFNpemVbYXhpc10gLyA0KSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFuRnJpY3Rpb24gPSAxO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBuZXdPZmZzZXQgPSBfcGFuT2Zmc2V0W2F4aXNdICsgZGVsdGFbYXhpc10gKiBwYW5GcmljdGlvbjtcblxuICAgICAgICAvLyBtb3ZlIG1haW4gc2Nyb2xsIG9yIHN0YXJ0IHBhbm5pbmdcbiAgICAgICAgaWYoX29wdGlvbnMuYWxsb3dQYW5Ub05leHQgfHwgX2N1cnJab29tTGV2ZWwgPT09IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCkge1xuXG5cbiAgICAgICAgICAgIGlmKCFfY3Vyclpvb21FbGVtZW50U3R5bGUpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZXdNYWluU2Nyb2xsUG9zID0gbmV3TWFpblNjcm9sbFBvc2l0aW9uO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYoX2RpcmVjdGlvbiA9PT0gJ2gnICYmIGF4aXMgPT09ICd4JyAmJiAhX3pvb21TdGFydGVkICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKGRpcikge1xuICAgICAgICAgICAgICAgICAgICBpZihuZXdPZmZzZXQgPiBfY3VyclBhbkJvdW5kcy5taW5bYXhpc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbkZyaWN0aW9uID0gX29wdGlvbnMucGFuRW5kRnJpY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyRGlmZiA9IF9jdXJyUGFuQm91bmRzLm1pbltheGlzXSAtIG5ld09mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0T3ZlckRpZmYgPSBfY3VyclBhbkJvdW5kcy5taW5bYXhpc10gLSBfc3RhcnRQYW5PZmZzZXRbYXhpc107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGRyYWcgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgaWYoIChzdGFydE92ZXJEaWZmIDw9IDAgfHwgbWFpblNjcm9sbERpZmYgPCAwKSAmJiBfZ2V0TnVtSXRlbXMoKSA+IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdNYWluU2Nyb2xsUG9zID0gbmV3TWFpblNjcm9sbFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWFpblNjcm9sbERpZmYgPCAwICYmIG5ld01haW5TY3JvbGxQb3NpdGlvbiA+IF9zdGFydE1haW5TY3JvbGxQb3MueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld01haW5TY3JvbGxQb3MgPSBfc3RhcnRNYWluU2Nyb2xsUG9zLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihfY3VyclBhbkJvdW5kcy5taW4ueCAhPT0gX2N1cnJQYW5Cb3VuZHMubWF4LngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYW5Qb3MgPSBuZXdPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZihuZXdPZmZzZXQgPCBfY3VyclBhbkJvdW5kcy5tYXhbYXhpc10gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5GcmljdGlvbiA9X29wdGlvbnMucGFuRW5kRnJpY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyRGlmZiA9IG5ld09mZnNldCAtIF9jdXJyUGFuQm91bmRzLm1heFtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0T3ZlckRpZmYgPSBfc3RhcnRQYW5PZmZzZXRbYXhpc10gLSBfY3VyclBhbkJvdW5kcy5tYXhbYXhpc107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiggKHN0YXJ0T3ZlckRpZmYgPD0gMCB8fCBtYWluU2Nyb2xsRGlmZiA+IDApICYmIF9nZXROdW1JdGVtcygpID4gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld01haW5TY3JvbGxQb3MgPSBuZXdNYWluU2Nyb2xsUG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1haW5TY3JvbGxEaWZmID4gMCAmJiBuZXdNYWluU2Nyb2xsUG9zaXRpb24gPCBfc3RhcnRNYWluU2Nyb2xsUG9zLngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdNYWluU2Nyb2xsUG9zID0gX3N0YXJ0TWFpblNjcm9sbFBvcy54O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihfY3VyclBhbkJvdW5kcy5taW4ueCAhPT0gX2N1cnJQYW5Cb3VuZHMubWF4LngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYW5Qb3MgPSBuZXdPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoYXhpcyA9PT0gJ3gnKSB7XG5cbiAgICAgICAgICAgICAgICBpZihuZXdNYWluU2Nyb2xsUG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX21vdmVNYWluU2Nyb2xsKG5ld01haW5TY3JvbGxQb3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZihuZXdNYWluU2Nyb2xsUG9zID09PSBfc3RhcnRNYWluU2Nyb2xsUG9zLngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tYWluU2Nyb2xsU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX21haW5TY3JvbGxTaGlmdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKF9jdXJyUGFuQm91bmRzLm1pbi54ICE9PSBfY3VyclBhbkJvdW5kcy5tYXgueCkge1xuICAgICAgICAgICAgICAgICAgICBpZihuZXdQYW5Qb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Bhbk9mZnNldC54ID0gbmV3UGFuUG9zO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIV9tYWluU2Nyb2xsU2hpZnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Bhbk9mZnNldC54ICs9IGRlbHRhLnggKiBwYW5GcmljdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdNYWluU2Nyb2xsUG9zICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFfbWFpblNjcm9sbEFuaW1hdGluZykge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighX21haW5TY3JvbGxTaGlmdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYoX2N1cnJab29tTGV2ZWwgPiBzZWxmLmN1cnJJdGVtLmZpdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXRbYXhpc10gKz0gZGVsdGFbYXhpc10gKiBwYW5GcmljdGlvbjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sXG5cbiAgICAvLyBQb2ludGVyZG93bi90b3VjaHN0YXJ0L21vdXNlZG93biBoYW5kbGVyXG4gICAgX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZSkge1xuXG4gICAgICAgIC8vIEFsbG93IGRyYWdnaW5nIG9ubHkgdmlhIGxlZnQgbW91c2UgYnV0dG9uLlxuICAgICAgICAvLyBBcyB0aGlzIGhhbmRsZXIgaXMgbm90IGFkZGVkIGluIElFOCAtIHdlIGlnbm9yZSBlLndoaWNoXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LmJ1dHRvblxuICAgICAgICBpZihlLnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGUuYnV0dG9uID4gMCAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZihfaW5pdGlhbFpvb21SdW5uaW5nKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZihfb2xkQW5kcm9pZFRvdWNoRW5kVGltZW91dCAmJiBlLnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZihfcHJldmVudERlZmF1bHRFdmVudEJlaGF2aW91cihlLCB0cnVlKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cblxuXG4gICAgICAgIF9zaG91dCgncG9pbnRlckRvd24nKTtcblxuICAgICAgICBpZihfcG9pbnRlckV2ZW50RW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJJbmRleCA9IGZyYW1ld29yay5hcnJheVNlYXJjaChfY3VyclBvaW50ZXJzLCBlLnBvaW50ZXJJZCwgJ2lkJyk7XG4gICAgICAgICAgICBpZihwb2ludGVySW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlckluZGV4ID0gX2N1cnJQb2ludGVycy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY3VyclBvaW50ZXJzW3BvaW50ZXJJbmRleF0gPSB7eDplLnBhZ2VYLCB5OmUucGFnZVksIGlkOiBlLnBvaW50ZXJJZH07XG4gICAgICAgIH1cbiAgICAgICAgXG5cblxuICAgICAgICB2YXIgc3RhcnRQb2ludHNMaXN0ID0gX2dldFRvdWNoUG9pbnRzKGUpLFxuICAgICAgICAgICAgbnVtUG9pbnRzID0gc3RhcnRQb2ludHNMaXN0Lmxlbmd0aDtcblxuICAgICAgICBfY3VycmVudFBvaW50cyA9IG51bGw7XG5cbiAgICAgICAgX3N0b3BBbGxBbmltYXRpb25zKCk7XG5cbiAgICAgICAgLy8gaW5pdCBkcmFnXG4gICAgICAgIGlmKCFfaXNEcmFnZ2luZyB8fCBudW1Qb2ludHMgPT09IDEpIHtcblxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIF9pc0RyYWdnaW5nID0gX2lzRmlyc3RNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZyYW1ld29yay5iaW5kKHdpbmRvdywgX3VwTW92ZUV2ZW50cywgc2VsZik7XG5cbiAgICAgICAgICAgIF9pc1pvb21pbmdJbiA9IFxuICAgICAgICAgICAgICAgIF93YXNPdmVySW5pdGlhbFpvb20gPSBcbiAgICAgICAgICAgICAgICBfb3BhY2l0eUNoYW5nZWQgPSBcbiAgICAgICAgICAgICAgICBfdmVydGljYWxEcmFnSW5pdGlhdGVkID0gXG4gICAgICAgICAgICAgICAgX21haW5TY3JvbGxTaGlmdGVkID0gXG4gICAgICAgICAgICAgICAgX21vdmVkID0gXG4gICAgICAgICAgICAgICAgX2lzTXVsdGl0b3VjaCA9IFxuICAgICAgICAgICAgICAgIF96b29tU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBfZGlyZWN0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgX3Nob3V0KCdmaXJzdFRvdWNoU3RhcnQnLCBzdGFydFBvaW50c0xpc3QpO1xuXG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMoX3N0YXJ0UGFuT2Zmc2V0LCBfcGFuT2Zmc2V0KTtcblxuICAgICAgICAgICAgX2N1cnJQYW5EaXN0LnggPSBfY3VyclBhbkRpc3QueSA9IDA7XG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMoX2N1cnJQb2ludCwgc3RhcnRQb2ludHNMaXN0WzBdKTtcbiAgICAgICAgICAgIF9lcXVhbGl6ZVBvaW50cyhfc3RhcnRQb2ludCwgX2N1cnJQb2ludCk7XG5cbiAgICAgICAgICAgIC8vX2VxdWFsaXplUG9pbnRzKF9zdGFydE1haW5TY3JvbGxQb3MsIF9tYWluU2Nyb2xsUG9zKTtcbiAgICAgICAgICAgIF9zdGFydE1haW5TY3JvbGxQb3MueCA9IF9zbGlkZVNpemUueCAqIF9jdXJyUG9zaXRpb25JbmRleDtcblxuICAgICAgICAgICAgX3Bvc1BvaW50cyA9IFt7XG4gICAgICAgICAgICAgICAgeDogX2N1cnJQb2ludC54LFxuICAgICAgICAgICAgICAgIHk6IF9jdXJyUG9pbnQueVxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIF9nZXN0dXJlQ2hlY2tTcGVlZFRpbWUgPSBfZ2VzdHVyZVN0YXJ0VGltZSA9IF9nZXRDdXJyZW50VGltZSgpO1xuXG4gICAgICAgICAgICAvL19tYWluU2Nyb2xsQW5pbWF0aW9uRW5kKHRydWUpO1xuICAgICAgICAgICAgX2NhbGN1bGF0ZVBhbkJvdW5kcyggX2N1cnJab29tTGV2ZWwsIHRydWUgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RhcnQgcmVuZGVyaW5nXG4gICAgICAgICAgICBfc3RvcERyYWdVcGRhdGVMb29wKCk7XG4gICAgICAgICAgICBfZHJhZ1VwZGF0ZUxvb3AoKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdCB6b29tXG4gICAgICAgIGlmKCFfaXNab29taW5nICYmIG51bVBvaW50cyA+IDEgJiYgIV9tYWluU2Nyb2xsQW5pbWF0aW5nICYmICFfbWFpblNjcm9sbFNoaWZ0ZWQpIHtcbiAgICAgICAgICAgIF9zdGFydFpvb21MZXZlbCA9IF9jdXJyWm9vbUxldmVsO1xuICAgICAgICAgICAgX3pvb21TdGFydGVkID0gZmFsc2U7IC8vIHRydWUgaWYgem9vbSBjaGFuZ2VkIGF0IGxlYXN0IG9uY2VcblxuICAgICAgICAgICAgX2lzWm9vbWluZyA9IF9pc011bHRpdG91Y2ggPSB0cnVlO1xuICAgICAgICAgICAgX2N1cnJQYW5EaXN0LnkgPSBfY3VyclBhbkRpc3QueCA9IDA7XG5cbiAgICAgICAgICAgIF9lcXVhbGl6ZVBvaW50cyhfc3RhcnRQYW5PZmZzZXQsIF9wYW5PZmZzZXQpO1xuXG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMocCwgc3RhcnRQb2ludHNMaXN0WzBdKTtcbiAgICAgICAgICAgIF9lcXVhbGl6ZVBvaW50cyhwMiwgc3RhcnRQb2ludHNMaXN0WzFdKTtcblxuICAgICAgICAgICAgX2ZpbmRDZW50ZXJPZlBvaW50cyhwLCBwMiwgX2N1cnJDZW50ZXJQb2ludCk7XG5cbiAgICAgICAgICAgIF9taWRab29tUG9pbnQueCA9IE1hdGguYWJzKF9jdXJyQ2VudGVyUG9pbnQueCkgLSBfcGFuT2Zmc2V0Lng7XG4gICAgICAgICAgICBfbWlkWm9vbVBvaW50LnkgPSBNYXRoLmFicyhfY3VyckNlbnRlclBvaW50LnkpIC0gX3Bhbk9mZnNldC55O1xuICAgICAgICAgICAgX2N1cnJQb2ludHNEaXN0YW5jZSA9IF9zdGFydFBvaW50c0Rpc3RhbmNlID0gX2NhbGN1bGF0ZVBvaW50c0Rpc3RhbmNlKHAsIHAyKTtcbiAgICAgICAgfVxuXG5cbiAgICB9LFxuXG4gICAgLy8gUG9pbnRlcm1vdmUvdG91Y2htb3ZlL21vdXNlbW92ZSBoYW5kbGVyXG4gICAgX29uRHJhZ01vdmUgPSBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmKF9wb2ludGVyRXZlbnRFbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRlckluZGV4ID0gZnJhbWV3b3JrLmFycmF5U2VhcmNoKF9jdXJyUG9pbnRlcnMsIGUucG9pbnRlcklkLCAnaWQnKTtcbiAgICAgICAgICAgIGlmKHBvaW50ZXJJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBfY3VyclBvaW50ZXJzW3BvaW50ZXJJbmRleF07XG4gICAgICAgICAgICAgICAgcC54ID0gZS5wYWdlWDtcbiAgICAgICAgICAgICAgICBwLnkgPSBlLnBhZ2VZOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKF9pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICB2YXIgdG91Y2hlc0xpc3QgPSBfZ2V0VG91Y2hQb2ludHMoZSk7XG4gICAgICAgICAgICBpZighX2RpcmVjdGlvbiAmJiAhX21vdmVkICYmICFfaXNab29taW5nKSB7XG5cbiAgICAgICAgICAgICAgICBpZihfbWFpblNjcm9sbFBvcy54ICE9PSBfc2xpZGVTaXplLnggKiBfY3VyclBvc2l0aW9uSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbWFpbiBzY3JvbGwgcG9zaXRpb24gaXMgc2hpZnRlZCDigJMgZGlyZWN0aW9uIGlzIGFsd2F5cyBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24gPSAnaCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyh0b3VjaGVzTGlzdFswXS54IC0gX2N1cnJQb2ludC54KSAtIE1hdGguYWJzKHRvdWNoZXNMaXN0WzBdLnkgLSBfY3VyclBvaW50LnkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgZGlyZWN0aW9uIG9mIG1vdmVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGRpZmYpID49IERJUkVDVElPTl9DSEVDS19PRkZTRVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24gPSBkaWZmID4gMCA/ICdoJyA6ICd2JztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50UG9pbnRzID0gdG91Y2hlc0xpc3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50UG9pbnRzID0gdG91Y2hlc0xpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gICBcbiAgICB9LFxuICAgIC8vIFxuICAgIF9yZW5kZXJNb3ZlbWVudCA9ICBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZighX2N1cnJlbnRQb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBfY3VycmVudFBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgaWYobnVtUG9pbnRzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfZXF1YWxpemVQb2ludHMocCwgX2N1cnJlbnRQb2ludHNbMF0pO1xuXG4gICAgICAgIGRlbHRhLnggPSBwLnggLSBfY3VyclBvaW50Lng7XG4gICAgICAgIGRlbHRhLnkgPSBwLnkgLSBfY3VyclBvaW50Lnk7XG5cbiAgICAgICAgaWYoX2lzWm9vbWluZyAmJiBudW1Qb2ludHMgPiAxKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgYmVoYXZpb3VyIGZvciBtb3JlIHRoYW4gMSBwb2ludFxuXG4gICAgICAgICAgICBfY3VyclBvaW50LnggPSBwLng7XG4gICAgICAgICAgICBfY3VyclBvaW50LnkgPSBwLnk7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgb25lIG9mIHR3byBwb2ludHMgY2hhbmdlZFxuICAgICAgICAgICAgaWYoICFkZWx0YS54ICYmICFkZWx0YS55ICYmIF9pc0VxdWFsUG9pbnRzKF9jdXJyZW50UG9pbnRzWzFdLCBwMikgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMocDIsIF9jdXJyZW50UG9pbnRzWzFdKTtcblxuXG4gICAgICAgICAgICBpZighX3pvb21TdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgX3pvb21TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfc2hvdXQoJ3pvb21HZXN0dXJlU3RhcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBEaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICAgICAgICAgIHZhciBwb2ludHNEaXN0YW5jZSA9IF9jYWxjdWxhdGVQb2ludHNEaXN0YW5jZShwLHAyKTtcblxuICAgICAgICAgICAgdmFyIHpvb21MZXZlbCA9IF9jYWxjdWxhdGVab29tTGV2ZWwocG9pbnRzRGlzdGFuY2UpO1xuXG4gICAgICAgICAgICAvLyBzbGlnaHRseSBvdmVyIHRoZSBvZiBpbml0aWFsIHpvb20gbGV2ZWxcbiAgICAgICAgICAgIGlmKHpvb21MZXZlbCA+IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCArIHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCAvIDE1KSB7XG4gICAgICAgICAgICAgICAgX3dhc092ZXJJbml0aWFsWm9vbSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBmcmljdGlvbiBpZiB6b29tIGxldmVsIGlzIG91dCBvZiB0aGUgYm91bmRzXG4gICAgICAgICAgICB2YXIgem9vbUZyaWN0aW9uID0gMSxcbiAgICAgICAgICAgICAgICBtaW5ab29tTGV2ZWwgPSBfZ2V0TWluWm9vbUxldmVsKCksXG4gICAgICAgICAgICAgICAgbWF4Wm9vbUxldmVsID0gX2dldE1heFpvb21MZXZlbCgpO1xuXG4gICAgICAgICAgICBpZiAoIHpvb21MZXZlbCA8IG1pblpvb21MZXZlbCApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihfb3B0aW9ucy5waW5jaFRvQ2xvc2UgJiYgIV93YXNPdmVySW5pdGlhbFpvb20gJiYgX3N0YXJ0Wm9vbUxldmVsIDw9IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWRlIG91dCBiYWNrZ3JvdW5kIGlmIHpvb21pbmcgb3V0XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW51c0RpZmYgPSBtaW5ab29tTGV2ZWwgLSB6b29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gMSAtIG1pbnVzRGlmZiAvIChtaW5ab29tTGV2ZWwgLyAxLjIpO1xuXG4gICAgICAgICAgICAgICAgICAgIF9hcHBseUJnT3BhY2l0eShwZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgX3Nob3V0KCdvblBpbmNoQ2xvc2UnLCBwZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgX29wYWNpdHlDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB6b29tRnJpY3Rpb24gPSAobWluWm9vbUxldmVsIC0gem9vbUxldmVsKSAvIG1pblpvb21MZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYoem9vbUZyaWN0aW9uID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgem9vbUZyaWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB6b29tTGV2ZWwgPSBtaW5ab29tTGV2ZWwgLSB6b29tRnJpY3Rpb24gKiAobWluWm9vbUxldmVsIC8gMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmICggem9vbUxldmVsID4gbWF4Wm9vbUxldmVsICkge1xuICAgICAgICAgICAgICAgIC8vIDEuNSAtIGV4dHJhIHpvb20gbGV2ZWwgYWJvdmUgdGhlIG1heC4gRS5nLiBpZiBtYXggaXMgeDYsIHJlYWwgbWF4IDYgKyAxLjUgPSA3LjVcbiAgICAgICAgICAgICAgICB6b29tRnJpY3Rpb24gPSAoem9vbUxldmVsIC0gbWF4Wm9vbUxldmVsKSAvICggbWluWm9vbUxldmVsICogNiApO1xuICAgICAgICAgICAgICAgIGlmKHpvb21GcmljdGlvbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbUZyaWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgem9vbUxldmVsID0gbWF4Wm9vbUxldmVsICsgem9vbUZyaWN0aW9uICogbWluWm9vbUxldmVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih6b29tRnJpY3Rpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgem9vbUZyaWN0aW9uID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGlzdGFuY2UgYmV0d2VlbiB0b3VjaCBwb2ludHMgYWZ0ZXIgZnJpY3Rpb24gaXMgYXBwbGllZFxuICAgICAgICAgICAgX2N1cnJQb2ludHNEaXN0YW5jZSA9IHBvaW50c0Rpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBfY2VudGVyUG9pbnQgLSBUaGUgcG9pbnQgaW4gdGhlIG1pZGRsZSBvZiB0d28gcG9pbnRlcnNcbiAgICAgICAgICAgIF9maW5kQ2VudGVyT2ZQb2ludHMocCwgcDIsIF9jZW50ZXJQb2ludCk7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gcGFuaW5nIHdpdGggdHdvIHBvaW50ZXJzIHByZXNzZWRcbiAgICAgICAgICAgIF9jdXJyUGFuRGlzdC54ICs9IF9jZW50ZXJQb2ludC54IC0gX2N1cnJDZW50ZXJQb2ludC54O1xuICAgICAgICAgICAgX2N1cnJQYW5EaXN0LnkgKz0gX2NlbnRlclBvaW50LnkgLSBfY3VyckNlbnRlclBvaW50Lnk7XG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMoX2N1cnJDZW50ZXJQb2ludCwgX2NlbnRlclBvaW50KTtcblxuICAgICAgICAgICAgX3Bhbk9mZnNldC54ID0gX2NhbGN1bGF0ZVBhbk9mZnNldCgneCcsIHpvb21MZXZlbCk7XG4gICAgICAgICAgICBfcGFuT2Zmc2V0LnkgPSBfY2FsY3VsYXRlUGFuT2Zmc2V0KCd5Jywgem9vbUxldmVsKTtcblxuICAgICAgICAgICAgX2lzWm9vbWluZ0luID0gem9vbUxldmVsID4gX2N1cnJab29tTGV2ZWw7XG4gICAgICAgICAgICBfY3Vyclpvb21MZXZlbCA9IHpvb21MZXZlbDtcbiAgICAgICAgICAgIF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGJlaGF2aW91ciBmb3Igb25lIHBvaW50IChkcmFnZ2luZyBvciBwYW5uaW5nKVxuXG4gICAgICAgICAgICBpZighX2RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoX2lzRmlyc3RNb3ZlKSB7XG4gICAgICAgICAgICAgICAgX2lzRmlyc3RNb3ZlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCBkcmFnIGRpc3RhbmNlIHRoYXQgd2FzIHVzZWQgZHVyaW5nIHRoZSBkZXRlY3Rpb24gZGlyZWN0aW9uICBcblxuICAgICAgICAgICAgICAgIGlmKCBNYXRoLmFicyhkZWx0YS54KSA+PSBESVJFQ1RJT05fQ0hFQ0tfT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLnggLT0gX2N1cnJlbnRQb2ludHNbMF0ueCAtIF9zdGFydFBvaW50Lng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCBNYXRoLmFicyhkZWx0YS55KSA+PSBESVJFQ1RJT05fQ0hFQ0tfT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLnkgLT0gX2N1cnJlbnRQb2ludHNbMF0ueSAtIF9zdGFydFBvaW50Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3VyclBvaW50LnggPSBwLng7XG4gICAgICAgICAgICBfY3VyclBvaW50LnkgPSBwLnk7XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgaWYgcG9pbnRlcnMgcG9zaXRpb24gaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgIGlmKGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoX2RpcmVjdGlvbiA9PT0gJ3YnICYmIF9vcHRpb25zLmNsb3NlT25WZXJ0aWNhbERyYWcpIHtcbiAgICAgICAgICAgICAgICBpZighX2NhblBhbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jdXJyUGFuRGlzdC55ICs9IGRlbHRhLnk7XG4gICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueSArPSBkZWx0YS55O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5UmF0aW8gPSBfY2FsY3VsYXRlVmVydGljYWxEcmFnT3BhY2l0eVJhdGlvKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgX3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9zaG91dCgnb25WZXJ0aWNhbERyYWcnLCBvcGFjaXR5UmF0aW8pO1xuXG4gICAgICAgICAgICAgICAgICAgIF9hcHBseUJnT3BhY2l0eShvcGFjaXR5UmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3B1c2hQb3NQb2ludChfZ2V0Q3VycmVudFRpbWUoKSwgcC54LCBwLnkpO1xuXG4gICAgICAgICAgICBfbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgX2N1cnJQYW5Cb3VuZHMgPSBzZWxmLmN1cnJJdGVtLmJvdW5kcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG1haW5TY3JvbGxDaGFuZ2VkID0gX3Bhbk9yTW92ZU1haW5TY3JvbGwoJ3gnLCBkZWx0YSk7XG4gICAgICAgICAgICBpZighbWFpblNjcm9sbENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBfcGFuT3JNb3ZlTWFpblNjcm9sbCgneScsIGRlbHRhKTtcblxuICAgICAgICAgICAgICAgIF9yb3VuZFBvaW50KF9wYW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcbiAgICBcbiAgICAvLyBQb2ludGVydXAvcG9pbnRlcmNhbmNlbC90b3VjaGVuZC90b3VjaGNhbmNlbC9tb3VzZXVwIGV2ZW50IGhhbmRsZXJcbiAgICBfb25EcmFnUmVsZWFzZSA9IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICBpZihfZmVhdHVyZXMuaXNPbGRBbmRyb2lkICkge1xuXG4gICAgICAgICAgICBpZihfb2xkQW5kcm9pZFRvdWNoRW5kVGltZW91dCAmJiBlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb24gQW5kcm9pZCAodjQuMSwgNC4yLCA0LjMgJiBwb3NzaWJseSBvbGRlcikgXG4gICAgICAgICAgICAvLyBnaG9zdCBtb3VzZWRvd24vdXAgZXZlbnQgaXNuJ3QgcHJldmVudGFibGUgdmlhIGUucHJldmVudERlZmF1bHQsXG4gICAgICAgICAgICAvLyB3aGljaCBjYXVzZXMgZmFrZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgICAgICAgIC8vIHNvIHdlIGJsb2NrIG1vdXNlZG93bi91cCBmb3IgNjAwbXNcbiAgICAgICAgICAgIGlmKCBlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA+IC0xICkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfb2xkQW5kcm9pZFRvdWNoRW5kVGltZW91dCk7XG4gICAgICAgICAgICAgICAgX29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfb2xkQW5kcm9pZFRvdWNoRW5kVGltZW91dCA9IDA7XG4gICAgICAgICAgICAgICAgfSwgNjAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgX3Nob3V0KCdwb2ludGVyVXAnKTtcblxuICAgICAgICBpZihfcHJldmVudERlZmF1bHRFdmVudEJlaGF2aW91cihlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWxlYXNlUG9pbnQ7XG5cbiAgICAgICAgaWYoX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBwb2ludGVySW5kZXggPSBmcmFtZXdvcmsuYXJyYXlTZWFyY2goX2N1cnJQb2ludGVycywgZS5wb2ludGVySWQsICdpZCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihwb2ludGVySW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VQb2ludCA9IF9jdXJyUG9pbnRlcnMuc3BsaWNlKHBvaW50ZXJJbmRleCwgMSlbMF07XG5cbiAgICAgICAgICAgICAgICBpZihuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZVBvaW50LnR5cGUgPSBlLnBvaW50ZXJUeXBlIHx8ICdtb3VzZSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIE1TUE9JTlRFUl9UWVBFUyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIDQ6ICdtb3VzZScsIC8vIGV2ZW50Lk1TUE9JTlRFUl9UWVBFX01PVVNFXG4gICAgICAgICAgICAgICAgICAgICAgICAyOiAndG91Y2gnLCAvLyBldmVudC5NU1BPSU5URVJfVFlQRV9UT1VDSCBcbiAgICAgICAgICAgICAgICAgICAgICAgIDM6ICdwZW4nIC8vIGV2ZW50Lk1TUE9JTlRFUl9UWVBFX1BFTlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlUG9pbnQudHlwZSA9IE1TUE9JTlRFUl9UWVBFU1tlLnBvaW50ZXJUeXBlXTtcblxuICAgICAgICAgICAgICAgICAgICBpZighcmVsZWFzZVBvaW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VQb2ludC50eXBlID0gZS5wb2ludGVyVHlwZSB8fCAnbW91c2UnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hMaXN0ID0gX2dldFRvdWNoUG9pbnRzKGUpLFxuICAgICAgICAgICAgZ2VzdHVyZVR5cGUsXG4gICAgICAgICAgICBudW1Qb2ludHMgPSB0b3VjaExpc3QubGVuZ3RoO1xuXG4gICAgICAgIGlmKGUudHlwZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICAgICAgICBudW1Qb2ludHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGVyZSB3ZXJlIDMgdG91Y2ggcG9pbnRzIG9yIG1vcmVcbiAgICAgICAgaWYobnVtUG9pbnRzID09PSAyKSB7XG4gICAgICAgICAgICBfY3VycmVudFBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHNlY29uZCBwb2ludGVyIHJlbGVhc2VkXG4gICAgICAgIGlmKG51bVBvaW50cyA9PT0gMSkge1xuICAgICAgICAgICAgX2VxdWFsaXplUG9pbnRzKF9zdGFydFBvaW50LCB0b3VjaExpc3RbMF0pO1xuICAgICAgICB9ICAgICAgICAgICAgICAgXG5cblxuICAgICAgICAvLyBwb2ludGVyIGhhc24ndCBtb3ZlZCwgc2VuZCBcInRhcCByZWxlYXNlXCIgcG9pbnRcbiAgICAgICAgaWYobnVtUG9pbnRzID09PSAwICYmICFfZGlyZWN0aW9uICYmICFfbWFpblNjcm9sbEFuaW1hdGluZykge1xuICAgICAgICAgICAgaWYoIXJlbGVhc2VQb2ludCkge1xuICAgICAgICAgICAgICAgIGlmKGUudHlwZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VQb2ludCA9IHt4OiBlLnBhZ2VYLCB5OiBlLnBhZ2VZLCB0eXBlOidtb3VzZSd9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZVBvaW50ID0ge3g6IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVgsIHk6IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVksIHR5cGU6J3RvdWNoJ307XG4gICAgICAgICAgICAgICAgfSAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3Nob3V0KCd0b3VjaFJlbGVhc2UnLCBlLCByZWxlYXNlUG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlmZmVyZW5jZSBpbiB0aW1lIGJldHdlZW4gcmVsZWFzaW5nIG9mIHR3byBsYXN0IHRvdWNoIHBvaW50cyAoem9vbSBnZXN0dXJlKVxuICAgICAgICB2YXIgcmVsZWFzZVRpbWVEaWZmID0gLTE7XG5cbiAgICAgICAgLy8gR2VzdHVyZSBjb21wbGV0ZWQsIG5vIHBvaW50ZXJzIGxlZnRcbiAgICAgICAgaWYobnVtUG9pbnRzID09PSAwKSB7XG4gICAgICAgICAgICBfaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZnJhbWV3b3JrLnVuYmluZCh3aW5kb3csIF91cE1vdmVFdmVudHMsIHNlbGYpO1xuXG4gICAgICAgICAgICBfc3RvcERyYWdVcGRhdGVMb29wKCk7XG5cbiAgICAgICAgICAgIGlmKF9pc1pvb21pbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBUd28gcG9pbnRzIHJlbGVhc2VkIGF0IHRoZSBzYW1lIHRpbWVcbiAgICAgICAgICAgICAgICByZWxlYXNlVGltZURpZmYgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmKF9sYXN0UmVsZWFzZVRpbWUgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZVRpbWVEaWZmID0gX2dldEN1cnJlbnRUaW1lKCkgLSBfbGFzdFJlbGVhc2VUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9sYXN0UmVsZWFzZVRpbWUgPSBudW1Qb2ludHMgPT09IDEgPyBfZ2V0Q3VycmVudFRpbWUoKSA6IC0xO1xuICAgICAgICBcbiAgICAgICAgaWYocmVsZWFzZVRpbWVEaWZmICE9PSAtMSAmJiByZWxlYXNlVGltZURpZmYgPCAxNTApIHtcbiAgICAgICAgICAgIGdlc3R1cmVUeXBlID0gJ3pvb20nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VzdHVyZVR5cGUgPSAnc3dpcGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoX2lzWm9vbWluZyAmJiBudW1Qb2ludHMgPCAyKSB7XG4gICAgICAgICAgICBfaXNab29taW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgc2Vjb25kIHBvaW50IHJlbGVhc2VkXG4gICAgICAgICAgICBpZihudW1Qb2ludHMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlVHlwZSA9ICd6b29tUG9pbnRlclVwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zaG91dCgnem9vbUdlc3R1cmVFbmRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2N1cnJlbnRQb2ludHMgPSBudWxsO1xuICAgICAgICBpZighX21vdmVkICYmICFfem9vbVN0YXJ0ZWQgJiYgIV9tYWluU2Nyb2xsQW5pbWF0aW5nICYmICFfdmVydGljYWxEcmFnSW5pdGlhdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBfc3RvcEFsbEFuaW1hdGlvbnMoKTtcblxuICAgICAgICBcbiAgICAgICAgaWYoIV9yZWxlYXNlQW5pbURhdGEpIHtcbiAgICAgICAgICAgIF9yZWxlYXNlQW5pbURhdGEgPSBfaW5pdERyYWdSZWxlYXNlQW5pbWF0aW9uRGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBfcmVsZWFzZUFuaW1EYXRhLmNhbGN1bGF0ZVN3aXBlU3BlZWQoJ3gnKTtcblxuXG4gICAgICAgIGlmKF92ZXJ0aWNhbERyYWdJbml0aWF0ZWQpIHtcblxuICAgICAgICAgICAgdmFyIG9wYWNpdHlSYXRpbyA9IF9jYWxjdWxhdGVWZXJ0aWNhbERyYWdPcGFjaXR5UmF0aW8oKTtcblxuICAgICAgICAgICAgaWYob3BhY2l0eVJhdGlvIDwgX29wdGlvbnMudmVydGljYWxEcmFnUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbml0YWxQYW5ZID0gX3Bhbk9mZnNldC55LFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQmdPcGFjaXR5ID0gX2JnT3BhY2l0eTtcblxuICAgICAgICAgICAgICAgIF9hbmltYXRlUHJvcCgndmVydGljYWxEcmFnJywgMCwgMSwgMzAwLCBmcmFtZXdvcmsuZWFzaW5nLmN1YmljLm91dCwgZnVuY3Rpb24obm93KSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnkgPSAoc2VsZi5jdXJySXRlbS5pbml0aWFsUG9zaXRpb24ueSAtIGluaXRhbFBhblkpICogbm93ICsgaW5pdGFsUGFuWTtcblxuICAgICAgICAgICAgICAgICAgICBfYXBwbHlCZ09wYWNpdHkoICAoMSAtIGluaXRpYWxCZ09wYWNpdHkpICogbm93ICsgaW5pdGlhbEJnT3BhY2l0eSApO1xuICAgICAgICAgICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgX3Nob3V0KCdvblZlcnRpY2FsRHJhZycsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIG1haW4gc2Nyb2xsIFxuICAgICAgICBpZiggIChfbWFpblNjcm9sbFNoaWZ0ZWQgfHwgX21haW5TY3JvbGxBbmltYXRpbmcpICYmIG51bVBvaW50cyA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1DaGFuZ2VkID0gX2ZpbmlzaFN3aXBlTWFpblNjcm9sbEdlc3R1cmUoZ2VzdHVyZVR5cGUsIF9yZWxlYXNlQW5pbURhdGEpO1xuICAgICAgICAgICAgaWYoaXRlbUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXN0dXJlVHlwZSA9ICd6b29tUG9pbnRlclVwJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgem9vbS9wYW4gYW5pbWF0aW9uIHdoZW4gbWFpbiBzY3JvbGwgYW5pbWF0aW9uIHJ1bnNcbiAgICAgICAgaWYoX21haW5TY3JvbGxBbmltYXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ29tcGxldGUgc2ltcGxlIHpvb20gZ2VzdHVyZSAocmVzZXQgem9vbSBsZXZlbCBpZiBpdCdzIG91dCBvZiB0aGUgYm91bmRzKSAgXG4gICAgICAgIGlmKGdlc3R1cmVUeXBlICE9PSAnc3dpcGUnKSB7XG4gICAgICAgICAgICBfY29tcGxldGVab29tR2VzdHVyZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIENvbXBsZXRlIHBhbiBnZXN0dXJlIGlmIG1haW4gc2Nyb2xsIGlzIG5vdCBzaGlmdGVkLCBhbmQgaXQncyBwb3NzaWJsZSB0byBwYW4gY3VycmVudCBpbWFnZVxuICAgICAgICBpZighX21haW5TY3JvbGxTaGlmdGVkICYmIF9jdXJyWm9vbUxldmVsID4gc2VsZi5jdXJySXRlbS5maXRSYXRpbykge1xuICAgICAgICAgICAgX2NvbXBsZXRlUGFuR2VzdHVyZShfcmVsZWFzZUFuaW1EYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8vIFJldHVybnMgb2JqZWN0IHdpdGggZGF0YSBhYm91dCBnZXN0dXJlXG4gICAgLy8gSXQncyBjcmVhdGVkIG9ubHkgb25jZSBhbmQgdGhlbiByZXVzZWRcbiAgICBfaW5pdERyYWdSZWxlYXNlQW5pbWF0aW9uRGF0YSAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdGVtcCBsb2NhbCB2YXJzXG4gICAgICAgIHZhciBsYXN0RmxpY2tEdXJhdGlvbixcbiAgICAgICAgICAgIHRlbXBSZWxlYXNlUG9zO1xuXG4gICAgICAgIC8vIHMgPSB0aGlzXG4gICAgICAgIHZhciBzID0ge1xuICAgICAgICAgICAgbGFzdEZsaWNrT2Zmc2V0OiB7fSxcbiAgICAgICAgICAgIGxhc3RGbGlja0Rpc3Q6IHt9LFxuICAgICAgICAgICAgbGFzdEZsaWNrU3BlZWQ6IHt9LFxuICAgICAgICAgICAgc2xvd0Rvd25SYXRpbzogIHt9LFxuICAgICAgICAgICAgc2xvd0Rvd25SYXRpb1JldmVyc2U6ICB7fSxcbiAgICAgICAgICAgIHNwZWVkRGVjZWxlcmF0aW9uUmF0aW86ICB7fSxcbiAgICAgICAgICAgIHNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnM6ICB7fSxcbiAgICAgICAgICAgIGRpc3RhbmNlT2Zmc2V0OiAge30sXG4gICAgICAgICAgICBiYWNrQW5pbURlc3RpbmF0aW9uOiB7fSxcbiAgICAgICAgICAgIGJhY2tBbmltU3RhcnRlZDoge30sXG4gICAgICAgICAgICBjYWxjdWxhdGVTd2lwZVNwZWVkOiBmdW5jdGlvbihheGlzKSB7XG4gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICBpZiggX3Bvc1BvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RGbGlja0R1cmF0aW9uID0gX2dldEN1cnJlbnRUaW1lKCkgLSBfZ2VzdHVyZUNoZWNrU3BlZWRUaW1lICsgNTA7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBSZWxlYXNlUG9zID0gX3Bvc1BvaW50c1tfcG9zUG9pbnRzLmxlbmd0aC0yXVtheGlzXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RmxpY2tEdXJhdGlvbiA9IF9nZXRDdXJyZW50VGltZSgpIC0gX2dlc3R1cmVTdGFydFRpbWU7IC8vIHRvdGFsIGdlc3R1cmUgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdGVtcFJlbGVhc2VQb3MgPSBfc3RhcnRQb2ludFtheGlzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcy5sYXN0RmxpY2tPZmZzZXRbYXhpc10gPSBfY3VyclBvaW50W2F4aXNdIC0gdGVtcFJlbGVhc2VQb3M7XG4gICAgICAgICAgICAgICAgcy5sYXN0RmxpY2tEaXN0W2F4aXNdID0gTWF0aC5hYnMocy5sYXN0RmxpY2tPZmZzZXRbYXhpc10pO1xuICAgICAgICAgICAgICAgIGlmKHMubGFzdEZsaWNrRGlzdFtheGlzXSA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIHMubGFzdEZsaWNrU3BlZWRbYXhpc10gPSBzLmxhc3RGbGlja09mZnNldFtheGlzXSAvIGxhc3RGbGlja0R1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMubGFzdEZsaWNrU3BlZWRbYXhpc10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiggTWF0aC5hYnMocy5sYXN0RmxpY2tTcGVlZFtheGlzXSkgPCAwLjEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHMubGFzdEZsaWNrU3BlZWRbYXhpc10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzLnNsb3dEb3duUmF0aW9bYXhpc10gPSAwLjk1O1xuICAgICAgICAgICAgICAgIHMuc2xvd0Rvd25SYXRpb1JldmVyc2VbYXhpc10gPSAxIC0gcy5zbG93RG93blJhdGlvW2F4aXNdO1xuICAgICAgICAgICAgICAgIHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb1theGlzXSA9IDE7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldDogZnVuY3Rpb24oYXhpcywgc3BlZWQpIHtcbiAgICAgICAgICAgICAgICBpZighcy5iYWNrQW5pbVN0YXJ0ZWRbYXhpc10pIHtcblxuICAgICAgICAgICAgICAgICAgICBpZihfcGFuT2Zmc2V0W2F4aXNdID4gX2N1cnJQYW5Cb3VuZHMubWluW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJhY2tBbmltRGVzdGluYXRpb25bYXhpc10gPSBfY3VyclBhbkJvdW5kcy5taW5bYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKF9wYW5PZmZzZXRbYXhpc10gPCBfY3VyclBhbkJvdW5kcy5tYXhbYXhpc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuYmFja0FuaW1EZXN0aW5hdGlvbltheGlzXSA9IF9jdXJyUGFuQm91bmRzLm1heFtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHMuYmFja0FuaW1EZXN0aW5hdGlvbltheGlzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnNsb3dEb3duUmF0aW9bYXhpc10gPSAwLjc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnNsb3dEb3duUmF0aW9SZXZlcnNlW2F4aXNdID0gMSAtIHMuc2xvd0Rvd25SYXRpb1theGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb0Fic1theGlzXSA8IDAuMDUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMubGFzdEZsaWNrU3BlZWRbYXhpc10gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuYmFja0FuaW1TdGFydGVkW2F4aXNdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hbmltYXRlUHJvcCgnYm91bmNlWm9vbVBhbicrYXhpcyxfcGFuT2Zmc2V0W2F4aXNdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iYWNrQW5pbURlc3RpbmF0aW9uW2F4aXNdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlZWQgfHwgMzAwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWV3b3JrLmVhc2luZy5zaW5lLm91dCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Bhbk9mZnNldFtheGlzXSA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBSZWR1Y2VzIHRoZSBzcGVlZCBieSBzbG93RG93blJhdGlvIChwZXIgMTBtcylcbiAgICAgICAgICAgIGNhbGN1bGF0ZUFuaW1PZmZzZXQ6IGZ1bmN0aW9uKGF4aXMpIHtcbiAgICAgICAgICAgICAgICBpZighcy5iYWNrQW5pbVN0YXJ0ZWRbYXhpc10pIHtcbiAgICAgICAgICAgICAgICAgICAgcy5zcGVlZERlY2VsZXJhdGlvblJhdGlvW2F4aXNdID0gcy5zcGVlZERlY2VsZXJhdGlvblJhdGlvW2F4aXNdICogKHMuc2xvd0Rvd25SYXRpb1theGlzXSArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zbG93RG93blJhdGlvUmV2ZXJzZVtheGlzXSAtIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zbG93RG93blJhdGlvUmV2ZXJzZVtheGlzXSAqIHMudGltZURpZmYgLyAxMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcy5zcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzW2F4aXNdID0gTWF0aC5hYnMocy5sYXN0RmxpY2tTcGVlZFtheGlzXSAqIHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb1theGlzXSk7XG4gICAgICAgICAgICAgICAgICAgIHMuZGlzdGFuY2VPZmZzZXRbYXhpc10gPSBzLmxhc3RGbGlja1NwZWVkW2F4aXNdICogcy5zcGVlZERlY2VsZXJhdGlvblJhdGlvW2F4aXNdICogcy50aW1lRGlmZjtcbiAgICAgICAgICAgICAgICAgICAgX3Bhbk9mZnNldFtheGlzXSArPSBzLmRpc3RhbmNlT2Zmc2V0W2F4aXNdO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGFuQW5pbUxvb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggX2FuaW1hdGlvbnMuem9vbVBhbiApIHtcbiAgICAgICAgICAgICAgICAgICAgX2FuaW1hdGlvbnMuem9vbVBhbi5yYWYgPSBfcmVxdWVzdEFGKHMucGFuQW5pbUxvb3ApO1xuXG4gICAgICAgICAgICAgICAgICAgIHMubm93ID0gX2dldEN1cnJlbnRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHMudGltZURpZmYgPSBzLm5vdyAtIHMubGFzdE5vdztcbiAgICAgICAgICAgICAgICAgICAgcy5sYXN0Tm93ID0gcy5ub3c7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzLmNhbGN1bGF0ZUFuaW1PZmZzZXQoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgcy5jYWxjdWxhdGVBbmltT2Zmc2V0KCd5Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHMuY2FsY3VsYXRlT3ZlckJvdW5kc0FuaW1PZmZzZXQoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgcy5jYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldCgneScpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb0Ficy54IDwgMC4wNSAmJiBzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnMueSA8IDAuMDUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm91bmQgcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnggPSBNYXRoLnJvdW5kKF9wYW5PZmZzZXQueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnkgPSBNYXRoLnJvdW5kKF9wYW5PZmZzZXQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RvcEFuaW1hdGlvbignem9vbVBhbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzO1xuICAgIH0sXG5cbiAgICBfY29tcGxldGVQYW5HZXN0dXJlID0gZnVuY3Rpb24oYW5pbURhdGEpIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHN3aXBlIHNwZWVkIGZvciBZIGF4aXMgKHBhYW5uaW5nKVxuICAgICAgICBhbmltRGF0YS5jYWxjdWxhdGVTd2lwZVNwZWVkKCd5Jyk7XG5cbiAgICAgICAgX2N1cnJQYW5Cb3VuZHMgPSBzZWxmLmN1cnJJdGVtLmJvdW5kcztcbiAgICAgICAgXG4gICAgICAgIGFuaW1EYXRhLmJhY2tBbmltRGVzdGluYXRpb24gPSB7fTtcbiAgICAgICAgYW5pbURhdGEuYmFja0FuaW1TdGFydGVkID0ge307XG5cbiAgICAgICAgLy8gQXZvaWQgYWNjZWxlcmF0aW9uIGFuaW1hdGlvbiBpZiBzcGVlZCBpcyB0b28gbG93XG4gICAgICAgIGlmKE1hdGguYWJzKGFuaW1EYXRhLmxhc3RGbGlja1NwZWVkLngpIDw9IDAuMDUgJiYgTWF0aC5hYnMoYW5pbURhdGEubGFzdEZsaWNrU3BlZWQueSkgPD0gMC4wNSApIHtcbiAgICAgICAgICAgIGFuaW1EYXRhLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnMueCA9IGFuaW1EYXRhLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnMueSA9IDA7XG5cbiAgICAgICAgICAgIC8vIFJ1biBwYW4gZHJhZyByZWxlYXNlIGFuaW1hdGlvbi4gRS5nLiBpZiB5b3UgZHJhZyBpbWFnZSBhbmQgcmVsZWFzZSBmaW5nZXIgd2l0aG91dCBtb21lbnR1bS5cbiAgICAgICAgICAgIGFuaW1EYXRhLmNhbGN1bGF0ZU92ZXJCb3VuZHNBbmltT2Zmc2V0KCd4Jyk7XG4gICAgICAgICAgICBhbmltRGF0YS5jYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldCgneScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmltYXRpb24gbG9vcCB0aGF0IGNvbnRyb2xzIHRoZSBhY2NlbGVyYXRpb24gYWZ0ZXIgcGFuIGdlc3R1cmUgZW5kc1xuICAgICAgICBfcmVnaXN0ZXJTdGFydEFuaW1hdGlvbignem9vbVBhbicpO1xuICAgICAgICBhbmltRGF0YS5sYXN0Tm93ID0gX2dldEN1cnJlbnRUaW1lKCk7XG4gICAgICAgIGFuaW1EYXRhLnBhbkFuaW1Mb29wKCk7XG4gICAgfSxcblxuXG4gICAgX2ZpbmlzaFN3aXBlTWFpblNjcm9sbEdlc3R1cmUgPSBmdW5jdGlvbihnZXN0dXJlVHlwZSwgX3JlbGVhc2VBbmltRGF0YSkge1xuICAgICAgICB2YXIgaXRlbUNoYW5nZWQ7XG4gICAgICAgIGlmKCFfbWFpblNjcm9sbEFuaW1hdGluZykge1xuICAgICAgICAgICAgX2N1cnJab29tZWRJdGVtSW5kZXggPSBfY3VycmVudEl0ZW1JbmRleDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgXG4gICAgICAgIHZhciBpdGVtc0RpZmY7XG5cbiAgICAgICAgaWYoZ2VzdHVyZVR5cGUgPT09ICdzd2lwZScpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbFNoaWZ0RGlzdCA9IF9jdXJyUG9pbnQueCAtIF9zdGFydFBvaW50LngsXG4gICAgICAgICAgICAgICAgaXNGYXN0TGFzdEZsaWNrID0gX3JlbGVhc2VBbmltRGF0YS5sYXN0RmxpY2tEaXN0LnggPCAxMDtcblxuICAgICAgICAgICAgLy8gaWYgY29udGFpbmVyIGlzIHNoaWZ0ZWQgZm9yIG1vcmUgdGhhbiBNSU5fU1dJUEVfRElTVEFOQ0UsIFxuICAgICAgICAgICAgLy8gYW5kIGxhc3QgZmxpY2sgZ2VzdHVyZSB3YXMgaW4gcmlnaHQgZGlyZWN0aW9uXG4gICAgICAgICAgICBpZih0b3RhbFNoaWZ0RGlzdCA+IE1JTl9TV0lQRV9ESVNUQU5DRSAmJiBcbiAgICAgICAgICAgICAgICAoaXNGYXN0TGFzdEZsaWNrIHx8IF9yZWxlYXNlQW5pbURhdGEubGFzdEZsaWNrT2Zmc2V0LnggPiAyMCkgKSB7XG4gICAgICAgICAgICAgICAgLy8gZ28gdG8gcHJldiBpdGVtXG4gICAgICAgICAgICAgICAgaXRlbXNEaWZmID0gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYodG90YWxTaGlmdERpc3QgPCAtTUlOX1NXSVBFX0RJU1RBTkNFICYmIFxuICAgICAgICAgICAgICAgIChpc0Zhc3RMYXN0RmxpY2sgfHwgX3JlbGVhc2VBbmltRGF0YS5sYXN0RmxpY2tPZmZzZXQueCA8IC0yMCkgKSB7XG4gICAgICAgICAgICAgICAgLy8gZ28gdG8gbmV4dCBpdGVtXG4gICAgICAgICAgICAgICAgaXRlbXNEaWZmID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0Q2lyY2xlO1xuXG4gICAgICAgIGlmKGl0ZW1zRGlmZikge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBfY3VycmVudEl0ZW1JbmRleCArPSBpdGVtc0RpZmY7XG5cbiAgICAgICAgICAgIGlmKF9jdXJyZW50SXRlbUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SXRlbUluZGV4ID0gX29wdGlvbnMubG9vcCA/IF9nZXROdW1JdGVtcygpLTEgOiAwO1xuICAgICAgICAgICAgICAgIG5leHRDaXJjbGUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmKF9jdXJyZW50SXRlbUluZGV4ID49IF9nZXROdW1JdGVtcygpKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJdGVtSW5kZXggPSBfb3B0aW9ucy5sb29wID8gMCA6IF9nZXROdW1JdGVtcygpLTE7XG4gICAgICAgICAgICAgICAgbmV4dENpcmNsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFuZXh0Q2lyY2xlIHx8IF9vcHRpb25zLmxvb3ApIHtcbiAgICAgICAgICAgICAgICBfaW5kZXhEaWZmICs9IGl0ZW1zRGlmZjtcbiAgICAgICAgICAgICAgICBfY3VyclBvc2l0aW9uSW5kZXggLT0gaXRlbXNEaWZmO1xuICAgICAgICAgICAgICAgIGl0ZW1DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmltYXRlVG9YID0gX3NsaWRlU2l6ZS54ICogX2N1cnJQb3NpdGlvbkluZGV4O1xuICAgICAgICB2YXIgYW5pbWF0ZVRvRGlzdCA9IE1hdGguYWJzKCBhbmltYXRlVG9YIC0gX21haW5TY3JvbGxQb3MueCApO1xuICAgICAgICB2YXIgZmluaXNoQW5pbUR1cmF0aW9uO1xuXG5cbiAgICAgICAgaWYoIWl0ZW1DaGFuZ2VkICYmIGFuaW1hdGVUb1ggPiBfbWFpblNjcm9sbFBvcy54ICE9PSBfcmVsZWFzZUFuaW1EYXRhLmxhc3RGbGlja1NwZWVkLnggPiAwKSB7XG4gICAgICAgICAgICAvLyBcInJldHVybiB0byBjdXJyZW50XCIgZHVyYXRpb24sIGUuZy4gd2hlbiBkcmFnZ2luZyBmcm9tIHNsaWRlIDAgdG8gLTFcbiAgICAgICAgICAgIGZpbmlzaEFuaW1EdXJhdGlvbiA9IDMzMzsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaW5pc2hBbmltRHVyYXRpb24gPSBNYXRoLmFicyhfcmVsZWFzZUFuaW1EYXRhLmxhc3RGbGlja1NwZWVkLngpID4gMCA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZVRvRGlzdCAvIE1hdGguYWJzKF9yZWxlYXNlQW5pbURhdGEubGFzdEZsaWNrU3BlZWQueCkgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMzMztcblxuICAgICAgICAgICAgZmluaXNoQW5pbUR1cmF0aW9uID0gTWF0aC5taW4oZmluaXNoQW5pbUR1cmF0aW9uLCA0MDApO1xuICAgICAgICAgICAgZmluaXNoQW5pbUR1cmF0aW9uID0gTWF0aC5tYXgoZmluaXNoQW5pbUR1cmF0aW9uLCAyNTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoX2N1cnJab29tZWRJdGVtSW5kZXggPT09IF9jdXJyZW50SXRlbUluZGV4KSB7XG4gICAgICAgICAgICBpdGVtQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBfbWFpblNjcm9sbEFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBfc2hvdXQoJ21haW5TY3JvbGxBbmltU3RhcnQnKTtcblxuICAgICAgICBfYW5pbWF0ZVByb3AoJ21haW5TY3JvbGwnLCBfbWFpblNjcm9sbFBvcy54LCBhbmltYXRlVG9YLCBmaW5pc2hBbmltRHVyYXRpb24sIGZyYW1ld29yay5lYXNpbmcuY3ViaWMub3V0LCBcbiAgICAgICAgICAgIF9tb3ZlTWFpblNjcm9sbCxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9zdG9wQWxsQW5pbWF0aW9ucygpO1xuICAgICAgICAgICAgICAgIF9tYWluU2Nyb2xsQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX2N1cnJab29tZWRJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihpdGVtQ2hhbmdlZCB8fCBfY3Vyclpvb21lZEl0ZW1JbmRleCAhPT0gX2N1cnJlbnRJdGVtSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDdXJySXRlbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBfc2hvdXQoJ21haW5TY3JvbGxBbmltQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBpZihpdGVtQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVDdXJySXRlbSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtQ2hhbmdlZDtcbiAgICB9LFxuXG4gICAgX2NhbGN1bGF0ZVpvb21MZXZlbCA9IGZ1bmN0aW9uKHRvdWNoZXNEaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gIDEgLyBfc3RhcnRQb2ludHNEaXN0YW5jZSAqIHRvdWNoZXNEaXN0YW5jZSAqIF9zdGFydFpvb21MZXZlbDtcbiAgICB9LFxuXG4gICAgLy8gUmVzZXRzIHpvb20gaWYgaXQncyBvdXQgb2YgYm91bmRzXG4gICAgX2NvbXBsZXRlWm9vbUdlc3R1cmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlc3Rab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbCxcbiAgICAgICAgICAgIG1pblpvb21MZXZlbCA9IF9nZXRNaW5ab29tTGV2ZWwoKSxcbiAgICAgICAgICAgIG1heFpvb21MZXZlbCA9IF9nZXRNYXhab29tTGV2ZWwoKTtcblxuICAgICAgICBpZiAoIF9jdXJyWm9vbUxldmVsIDwgbWluWm9vbUxldmVsICkge1xuICAgICAgICAgICAgZGVzdFpvb21MZXZlbCA9IG1pblpvb21MZXZlbDtcbiAgICAgICAgfSBlbHNlIGlmICggX2N1cnJab29tTGV2ZWwgPiBtYXhab29tTGV2ZWwgKSB7XG4gICAgICAgICAgICBkZXN0Wm9vbUxldmVsID0gbWF4Wm9vbUxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlc3RPcGFjaXR5ID0gMSxcbiAgICAgICAgICAgIG9uVXBkYXRlLFxuICAgICAgICAgICAgaW5pdGlhbE9wYWNpdHkgPSBfYmdPcGFjaXR5O1xuXG4gICAgICAgIGlmKF9vcGFjaXR5Q2hhbmdlZCAmJiAhX2lzWm9vbWluZ0luICYmICFfd2FzT3ZlckluaXRpYWxab29tICYmIF9jdXJyWm9vbUxldmVsIDwgbWluWm9vbUxldmVsKSB7XG4gICAgICAgICAgICAvL19jbG9zZWRCeVNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKF9vcGFjaXR5Q2hhbmdlZCkge1xuICAgICAgICAgICAgb25VcGRhdGUgPSBmdW5jdGlvbihub3cpIHtcbiAgICAgICAgICAgICAgICBfYXBwbHlCZ09wYWNpdHkoICAoZGVzdE9wYWNpdHkgLSBpbml0aWFsT3BhY2l0eSkgKiBub3cgKyBpbml0aWFsT3BhY2l0eSApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuem9vbVRvKGRlc3Rab29tTGV2ZWwsIDAsIDIwMCwgIGZyYW1ld29yay5lYXNpbmcuY3ViaWMub3V0LCBvblVwZGF0ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cblxuX3JlZ2lzdGVyTW9kdWxlKCdHZXN0dXJlcycsIHtcbiAgICBwdWJsaWNNZXRob2RzOiB7XG5cbiAgICAgICAgaW5pdEdlc3R1cmVzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLy8gaGVscGVyIGZ1bmN0aW9uIHRoYXQgYnVpbGRzIHRvdWNoL3BvaW50ZXIvbW91c2UgZXZlbnRzXG4gICAgICAgICAgICB2YXIgYWRkRXZlbnROYW1lcyA9IGZ1bmN0aW9uKHByZWYsIGRvd24sIG1vdmUsIHVwLCBjYW5jZWwpIHtcbiAgICAgICAgICAgICAgICBfZHJhZ1N0YXJ0RXZlbnQgPSBwcmVmICsgZG93bjtcbiAgICAgICAgICAgICAgICBfZHJhZ01vdmVFdmVudCA9IHByZWYgKyBtb3ZlO1xuICAgICAgICAgICAgICAgIF9kcmFnRW5kRXZlbnQgPSBwcmVmICsgdXA7XG4gICAgICAgICAgICAgICAgaWYoY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kcmFnQ2FuY2VsRXZlbnQgPSBwcmVmICsgY2FuY2VsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9kcmFnQ2FuY2VsRXZlbnQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfcG9pbnRlckV2ZW50RW5hYmxlZCA9IF9mZWF0dXJlcy5wb2ludGVyRXZlbnQ7XG4gICAgICAgICAgICBpZihfcG9pbnRlckV2ZW50RW5hYmxlZCAmJiBfZmVhdHVyZXMudG91Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvdWNoIGV2ZW50cywgaWYgYnJvd3NlciBzdXBwb3J0cyBwb2ludGVyIGV2ZW50c1xuICAgICAgICAgICAgICAgIF9mZWF0dXJlcy50b3VjaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihfcG9pbnRlckV2ZW50RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmKG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRFdmVudE5hbWVzKCdwb2ludGVyJywgJ2Rvd24nLCAnbW92ZScsICd1cCcsICdjYW5jZWwnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRTEwIHBvaW50ZXIgZXZlbnRzIGFyZSBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAgICAgICBhZGRFdmVudE5hbWVzKCdNU1BvaW50ZXInLCAnRG93bicsICdNb3ZlJywgJ1VwJywgJ0NhbmNlbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZihfZmVhdHVyZXMudG91Y2gpIHtcbiAgICAgICAgICAgICAgICBhZGRFdmVudE5hbWVzKCd0b3VjaCcsICdzdGFydCcsICdtb3ZlJywgJ2VuZCcsICdjYW5jZWwnKTtcbiAgICAgICAgICAgICAgICBfbGlrZWx5VG91Y2hEZXZpY2UgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRFdmVudE5hbWVzKCdtb3VzZScsICdkb3duJywgJ21vdmUnLCAndXAnKTsgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3VwTW92ZUV2ZW50cyA9IF9kcmFnTW92ZUV2ZW50ICsgJyAnICsgX2RyYWdFbmRFdmVudCAgKyAnICcgKyAgX2RyYWdDYW5jZWxFdmVudDtcbiAgICAgICAgICAgIF9kb3duRXZlbnRzID0gX2RyYWdTdGFydEV2ZW50O1xuXG4gICAgICAgICAgICBpZihfcG9pbnRlckV2ZW50RW5hYmxlZCAmJiAhX2xpa2VseVRvdWNoRGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgX2xpa2VseVRvdWNoRGV2aWNlID0gKG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpIHx8IChuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSB2YXJpYWJsZSBwdWJsaWNcbiAgICAgICAgICAgIHNlbGYubGlrZWx5VG91Y2hEZXZpY2UgPSBfbGlrZWx5VG91Y2hEZXZpY2U7IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ1N0YXJ0RXZlbnRdID0gX29uRHJhZ1N0YXJ0O1xuICAgICAgICAgICAgX2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdNb3ZlRXZlbnRdID0gX29uRHJhZ01vdmU7XG4gICAgICAgICAgICBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ0VuZEV2ZW50XSA9IF9vbkRyYWdSZWxlYXNlOyAvLyB0aGUgS3Jha2VuXG5cbiAgICAgICAgICAgIGlmKF9kcmFnQ2FuY2VsRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ0NhbmNlbEV2ZW50XSA9IF9nbG9iYWxFdmVudEhhbmRsZXJzW19kcmFnRW5kRXZlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCaW5kIG1vdXNlIGV2ZW50cyBvbiBkZXZpY2Ugd2l0aCBkZXRlY3RlZCBoYXJkd2FyZSB0b3VjaCBzdXBwb3J0LCBpbiBjYXNlIGl0IHN1cHBvcnRzIG11bHRpcGxlIHR5cGVzIG9mIGlucHV0LlxuICAgICAgICAgICAgaWYoX2ZlYXR1cmVzLnRvdWNoKSB7XG4gICAgICAgICAgICAgICAgX2Rvd25FdmVudHMgKz0gJyBtb3VzZWRvd24nO1xuICAgICAgICAgICAgICAgIF91cE1vdmVFdmVudHMgKz0gJyBtb3VzZW1vdmUgbW91c2V1cCc7XG4gICAgICAgICAgICAgICAgX2dsb2JhbEV2ZW50SGFuZGxlcnMubW91c2Vkb3duID0gX2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdTdGFydEV2ZW50XTtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsRXZlbnRIYW5kbGVycy5tb3VzZW1vdmUgPSBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ01vdmVFdmVudF07XG4gICAgICAgICAgICAgICAgX2dsb2JhbEV2ZW50SGFuZGxlcnMubW91c2V1cCA9IF9nbG9iYWxFdmVudEhhbmRsZXJzW19kcmFnRW5kRXZlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighX2xpa2VseVRvdWNoRGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWxsb3cgcGFuIHRvIG5leHQgc2xpZGUgZnJvbSB6b29tZWQgc3RhdGUgb24gRGVza3RvcFxuICAgICAgICAgICAgICAgIF9vcHRpb25zLmFsbG93UGFuVG9OZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbn0pO1xuXG5cbi8qPj5nZXN0dXJlcyovXG5cbi8qPj5zaG93LWhpZGUtdHJhbnNpdGlvbiovXG4vKipcbiAqIHNob3ctaGlkZS10cmFuc2l0aW9uLmpzOlxuICpcbiAqIE1hbmFnZXMgaW5pdGlhbCBvcGVuaW5nIG9yIGNsb3NpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiBJZiB5b3UncmUgbm90IHBsYW5uaW5nIHRvIHVzZSB0cmFuc2l0aW9uIGZvciBnYWxsZXJ5IGF0IGFsbCxcbiAqIHlvdSBtYXkgc2V0IG9wdGlvbnMgaGlkZUFuaW1hdGlvbkR1cmF0aW9uIGFuZCBzaG93QW5pbWF0aW9uRHVyYXRpb24gdG8gMCxcbiAqIGFuZCBqdXN0IGRlbGV0ZSBzdGFydEFuaW1hdGlvbiBmdW5jdGlvbi5cbiAqIFxuICovXG5cblxudmFyIF9zaG93T3JIaWRlVGltZW91dCxcbiAgICBfc2hvd09ySGlkZSA9IGZ1bmN0aW9uKGl0ZW0sIGltZywgb3V0LCBjb21wbGV0ZUZuKSB7XG5cbiAgICAgICAgaWYoX3Nob3dPckhpZGVUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3Nob3dPckhpZGVUaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9pbml0aWFsWm9vbVJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBfaW5pdGlhbENvbnRlbnRTZXQgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgLy8gZGltZW5zaW9ucyBvZiBzbWFsbCB0aHVtYm5haWwge3g6LHk6LHc6fS5cbiAgICAgICAgLy8gSGVpZ2h0IGlzIG9wdGlvbmFsLCBhcyBjYWxjdWxhdGVkIGJhc2VkIG9uIGxhcmdlIGltYWdlLlxuICAgICAgICB2YXIgdGh1bWJCb3VuZHM7IFxuICAgICAgICBpZihpdGVtLmluaXRpYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHRodW1iQm91bmRzID0gaXRlbS5pbml0aWFsTGF5b3V0O1xuICAgICAgICAgICAgaXRlbS5pbml0aWFsTGF5b3V0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRodW1iQm91bmRzID0gX29wdGlvbnMuZ2V0VGh1bWJCb3VuZHNGbiAmJiBfb3B0aW9ucy5nZXRUaHVtYkJvdW5kc0ZuKF9jdXJyZW50SXRlbUluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG91dCA/IF9vcHRpb25zLmhpZGVBbmltYXRpb25EdXJhdGlvbiA6IF9vcHRpb25zLnNob3dBbmltYXRpb25EdXJhdGlvbjtcblxuICAgICAgICB2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3N0b3BBbmltYXRpb24oJ2luaXRpYWxab29tJyk7XG4gICAgICAgICAgICBpZighb3V0KSB7XG4gICAgICAgICAgICAgICAgX2FwcGx5QmdPcGFjaXR5KDEpO1xuICAgICAgICAgICAgICAgIGlmKGltZykge1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLWFuaW1hdGVkLWluJyk7XG4gICAgICAgICAgICAgICAgX3Nob3V0KCdpbml0aWFsWm9vbScgKyAob3V0ID8gJ091dEVuZCcgOiAnSW5FbmQnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYudGVtcGxhdGUucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIHNlbGYuYmcucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihjb21wbGV0ZUZuKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2luaXRpYWxab29tUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIGJvdW5kcyBhcmVuJ3QgcHJvdmlkZWQsIGp1c3Qgb3BlbiBnYWxsZXJ5IHdpdGhvdXQgYW5pbWF0aW9uXG4gICAgICAgIGlmKCFkdXJhdGlvbiB8fCAhdGh1bWJCb3VuZHMgfHwgdGh1bWJCb3VuZHMueCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIF9zaG91dCgnaW5pdGlhbFpvb20nICsgKG91dCA/ICdPdXQnIDogJ0luJykgKTtcblxuICAgICAgICAgICAgX2N1cnJab29tTGV2ZWwgPSBpdGVtLmluaXRpYWxab29tTGV2ZWw7XG4gICAgICAgICAgICBfZXF1YWxpemVQb2ludHMoX3Bhbk9mZnNldCwgIGl0ZW0uaW5pdGlhbFBvc2l0aW9uICk7XG4gICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXG4gICAgICAgICAgICB0ZW1wbGF0ZS5zdHlsZS5vcGFjaXR5ID0gb3V0ID8gMCA6IDE7XG4gICAgICAgICAgICBfYXBwbHlCZ09wYWNpdHkoMSk7XG5cbiAgICAgICAgICAgIGlmKGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRBbmltYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZVdpdGhSYWYgPSBfY2xvc2VkQnlTY3JvbGwsXG4gICAgICAgICAgICAgICAgZmFkZUV2ZXJ5dGhpbmcgPSAhc2VsZi5jdXJySXRlbS5zcmMgfHwgc2VsZi5jdXJySXRlbS5sb2FkRXJyb3IgfHwgX29wdGlvbnMuc2hvd0hpZGVPcGFjaXR5O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBhcHBseSBody1hY2NlbGVyYXRpb24gdG8gaW1hZ2VcbiAgICAgICAgICAgIGlmKGl0ZW0ubWluaUltZykge1xuICAgICAgICAgICAgICAgIGl0ZW0ubWluaUltZy5zdHlsZS53ZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIW91dCkge1xuICAgICAgICAgICAgICAgIF9jdXJyWm9vbUxldmVsID0gdGh1bWJCb3VuZHMudyAvIGl0ZW0udztcbiAgICAgICAgICAgICAgICBfcGFuT2Zmc2V0LnggPSB0aHVtYkJvdW5kcy54O1xuICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueSA9IHRodW1iQm91bmRzLnkgLSBfaW5pdGFsV2luZG93U2Nyb2xsWTtcblxuICAgICAgICAgICAgICAgIHNlbGZbZmFkZUV2ZXJ5dGhpbmcgPyAndGVtcGxhdGUnIDogJ2JnJ10uc3R5bGUub3BhY2l0eSA9IDAuMDAxO1xuICAgICAgICAgICAgICAgIF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9yZWdpc3RlclN0YXJ0QW5pbWF0aW9uKCdpbml0aWFsWm9vbScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihvdXQgJiYgIWNsb3NlV2l0aFJhZikge1xuICAgICAgICAgICAgICAgIGZyYW1ld29yay5yZW1vdmVDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLWFuaW1hdGVkLWluJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGZhZGVFdmVyeXRoaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYob3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1ld29ya1sgKGNsb3NlV2l0aFJhZiA/ICdyZW1vdmUnIDogJ2FkZCcpICsgJ0NsYXNzJyBdKHRlbXBsYXRlLCAncHN3cC0tYW5pbWF0ZV9vcGFjaXR5Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLWFuaW1hdGVfb3BhY2l0eScpO1xuICAgICAgICAgICAgICAgICAgICB9LCAzMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc2hvd09ySGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgX3Nob3V0KCdpbml0aWFsWm9vbScgKyAob3V0ID8gJ091dCcgOiAnSW4nKSApO1xuICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgaWYoIW91dCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiaW5cIiBhbmltYXRpb24gYWx3YXlzIHVzZXMgQ1NTIHRyYW5zaXRpb25zIChpbnN0ZWFkIG9mIHJBRikuXG4gICAgICAgICAgICAgICAgICAgIC8vIENTUyB0cmFuc2l0aW9uIHdvcmsgZmFzdGVyIGhlcmUsIFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBkZXZlbG9wZXIgbWF5IGFsc28gd2FudCB0byBhbmltYXRlIG90aGVyIHRoaW5ncywgXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpa2UgdWkgb24gdG9wIG9mIHNsaWRpbmcgYXJlYSwgd2hpY2ggY2FuIGJlIGFuaW1hdGVkIGp1c3QgdmlhIENTU1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJab29tTGV2ZWwgPSBpdGVtLmluaXRpYWxab29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIF9lcXVhbGl6ZVBvaW50cyhfcGFuT2Zmc2V0LCAgaXRlbS5pbml0aWFsUG9zaXRpb24gKTtcbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5QmdPcGFjaXR5KDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGZhZGVFdmVyeXRoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hcHBseUJnT3BhY2l0eSgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9zaG93T3JIaWRlVGltZW91dCA9IHNldFRpbWVvdXQob25Db21wbGV0ZSwgZHVyYXRpb24gKyAyMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBcIm91dFwiIGFuaW1hdGlvbiB1c2VzIHJBRiBvbmx5IHdoZW4gUGhvdG9Td2lwZSBpcyBjbG9zZWQgYnkgYnJvd3NlciBzY3JvbGwsIHRvIHJlY2FsY3VsYXRlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXN0Wm9vbUxldmVsID0gdGh1bWJCb3VuZHMudyAvIGl0ZW0udyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxQYW5PZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogX3Bhbk9mZnNldC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IF9wYW5PZmZzZXQueVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRhbEJnT3BhY2l0eSA9IF9iZ09wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZSA9IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vdyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3Vyclpvb21MZXZlbCA9IGRlc3Rab29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueCA9IHRodW1iQm91bmRzLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueSA9IHRodW1iQm91bmRzLnkgIC0gX2N1cnJlbnRXaW5kb3dTY3JvbGxZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyWm9vbUxldmVsID0gKGRlc3Rab29tTGV2ZWwgLSBpbml0aWFsWm9vbUxldmVsKSAqIG5vdyArIGluaXRpYWxab29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYW5PZmZzZXQueCA9ICh0aHVtYkJvdW5kcy54IC0gaW5pdGlhbFBhbk9mZnNldC54KSAqIG5vdyArIGluaXRpYWxQYW5PZmZzZXQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Bhbk9mZnNldC55ID0gKHRodW1iQm91bmRzLnkgLSBfY3VycmVudFdpbmRvd1Njcm9sbFkgLSBpbml0aWFsUGFuT2Zmc2V0LnkpICogbm93ICsgaW5pdGlhbFBhbk9mZnNldC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZhZGVFdmVyeXRoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLnN0eWxlLm9wYWNpdHkgPSAxIC0gbm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hcHBseUJnT3BhY2l0eSggaW5pdGFsQmdPcGFjaXR5IC0gbm93ICogaW5pdGFsQmdPcGFjaXR5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZihjbG9zZVdpdGhSYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hbmltYXRlUHJvcCgnaW5pdGlhbFpvb20nLCAwLCAxLCBkdXJhdGlvbiwgZnJhbWV3b3JrLmVhc2luZy5jdWJpYy5vdXQsIG9uVXBkYXRlLCBvbkNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVXBkYXRlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Nob3dPckhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChvbkNvbXBsZXRlLCBkdXJhdGlvbiArIDIwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfSwgb3V0ID8gMjUgOiA5MCk7IC8vIE1haW4gcHVycG9zZSBvZiB0aGlzIGRlbGF5IGlzIHRvIGdpdmUgYnJvd3NlciB0aW1lIHRvIHBhaW50IGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgY29tcG9zaXRlIGxheWVycyBvZiBQaG90b1N3aXBlIFVJIHBhcnRzIChiYWNrZ3JvdW5kLCBjb250cm9scywgY2FwdGlvbiwgYXJyb3dzKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hpY2ggYXZvaWRzIGxhZyBhdCB0aGUgYmVnaW5uaW5nIG9mIHNjYWxlIHRyYW5zaXRpb24uXG4gICAgICAgIH07XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKCk7XG5cbiAgICAgICAgXG4gICAgfTtcblxuLyo+PnNob3ctaGlkZS10cmFuc2l0aW9uKi9cblxuLyo+Pml0ZW1zLWNvbnRyb2xsZXIqL1xuLyoqXG4qXG4qIENvbnRyb2xsZXIgbWFuYWdlcyBnYWxsZXJ5IGl0ZW1zLCB0aGVpciBkaW1lbnNpb25zLCBhbmQgdGhlaXIgY29udGVudC5cbiogXG4qL1xuXG52YXIgX2l0ZW1zLFxuICAgIF90ZW1wUGFuQXJlYVNpemUgPSB7fSxcbiAgICBfaW1hZ2VzVG9BcHBlbmRQb29sID0gW10sXG4gICAgX2luaXRpYWxDb250ZW50U2V0LFxuICAgIF9pbml0aWFsWm9vbVJ1bm5pbmcsXG4gICAgX2NvbnRyb2xsZXJEZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGVycm9yTXNnOiAnPGRpdiBjbGFzcz1cInBzd3BfX2Vycm9yLW1zZ1wiPjxhIGhyZWY9XCIldXJsJVwiIHRhcmdldD1cIl9ibGFua1wiPlRoZSBpbWFnZTwvYT4gY291bGQgbm90IGJlIGxvYWRlZC48L2Rpdj4nLFxuICAgICAgICBmb3JjZVByb2dyZXNzaXZlTG9hZGluZzogZmFsc2UsIC8vIFRPRE9cbiAgICAgICAgcHJlbG9hZDogWzEsMV0sXG4gICAgICAgIGdldE51bUl0ZW1zRm46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVtcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbnZhciBfZ2V0SXRlbUF0LFxuICAgIF9nZXROdW1JdGVtcyxcbiAgICBfaW5pdGlhbElzTG9vcCxcbiAgICBfZ2V0WmVyb0JvdW5kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VudGVyOnt4OjAseTowfSwgXG4gICAgICAgICAgICBtYXg6e3g6MCx5OjB9LCBcbiAgICAgICAgICAgIG1pbjp7eDowLHk6MH1cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIF9jYWxjdWxhdGVTaW5nbGVJdGVtUGFuQm91bmRzID0gZnVuY3Rpb24oaXRlbSwgcmVhbFBhbkVsZW1lbnRXLCByZWFsUGFuRWxlbWVudEggKSB7XG4gICAgICAgIHZhciBib3VuZHMgPSBpdGVtLmJvdW5kcztcblxuICAgICAgICAvLyBwb3NpdGlvbiBvZiBlbGVtZW50IHdoZW4gaXQncyBjZW50ZXJlZFxuICAgICAgICBib3VuZHMuY2VudGVyLnggPSBNYXRoLnJvdW5kKChfdGVtcFBhbkFyZWFTaXplLnggLSByZWFsUGFuRWxlbWVudFcpIC8gMik7XG4gICAgICAgIGJvdW5kcy5jZW50ZXIueSA9IE1hdGgucm91bmQoKF90ZW1wUGFuQXJlYVNpemUueSAtIHJlYWxQYW5FbGVtZW50SCkgLyAyKSArIGl0ZW0udkdhcC50b3A7XG5cbiAgICAgICAgLy8gbWF4aW11bSBwYW4gcG9zaXRpb25cbiAgICAgICAgYm91bmRzLm1heC54ID0gKHJlYWxQYW5FbGVtZW50VyA+IF90ZW1wUGFuQXJlYVNpemUueCkgPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKF90ZW1wUGFuQXJlYVNpemUueCAtIHJlYWxQYW5FbGVtZW50VykgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMuY2VudGVyLng7XG4gICAgICAgIFxuICAgICAgICBib3VuZHMubWF4LnkgPSAocmVhbFBhbkVsZW1lbnRIID4gX3RlbXBQYW5BcmVhU2l6ZS55KSA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoX3RlbXBQYW5BcmVhU2l6ZS55IC0gcmVhbFBhbkVsZW1lbnRIKSArIGl0ZW0udkdhcC50b3AgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMuY2VudGVyLnk7XG4gICAgICAgIFxuICAgICAgICAvLyBtaW5pbXVtIHBhbiBwb3NpdGlvblxuICAgICAgICBib3VuZHMubWluLnggPSAocmVhbFBhbkVsZW1lbnRXID4gX3RlbXBQYW5BcmVhU2l6ZS54KSA/IDAgOiBib3VuZHMuY2VudGVyLng7XG4gICAgICAgIGJvdW5kcy5taW4ueSA9IChyZWFsUGFuRWxlbWVudEggPiBfdGVtcFBhbkFyZWFTaXplLnkpID8gaXRlbS52R2FwLnRvcCA6IGJvdW5kcy5jZW50ZXIueTtcbiAgICB9LFxuICAgIF9jYWxjdWxhdGVJdGVtU2l6ZSA9IGZ1bmN0aW9uKGl0ZW0sIHZpZXdwb3J0U2l6ZSwgem9vbUxldmVsKSB7XG5cbiAgICAgICAgaWYgKGl0ZW0uc3JjICYmICFpdGVtLmxvYWRFcnJvcikge1xuICAgICAgICAgICAgdmFyIGlzSW5pdGlhbCA9ICF6b29tTGV2ZWw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGlzSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIGlmKCFpdGVtLnZHYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS52R2FwID0ge3RvcDowLGJvdHRvbTowfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIG92ZXJyaWRpbmcgdmVydGljYWwgbWFyZ2luIGZvciBpbmRpdmlkdWFsIGl0ZW1zXG4gICAgICAgICAgICAgICAgX3Nob3V0KCdwYXJzZVZlcnRpY2FsTWFyZ2luJywgaXRlbSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgX3RlbXBQYW5BcmVhU2l6ZS54ID0gdmlld3BvcnRTaXplLng7XG4gICAgICAgICAgICBfdGVtcFBhbkFyZWFTaXplLnkgPSB2aWV3cG9ydFNpemUueSAtIGl0ZW0udkdhcC50b3AgLSBpdGVtLnZHYXAuYm90dG9tO1xuXG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhSYXRpbyA9IF90ZW1wUGFuQXJlYVNpemUueCAvIGl0ZW0udztcbiAgICAgICAgICAgICAgICB2YXIgdlJhdGlvID0gX3RlbXBQYW5BcmVhU2l6ZS55IC8gaXRlbS5oO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5maXRSYXRpbyA9IGhSYXRpbyA8IHZSYXRpbyA/IGhSYXRpbyA6IHZSYXRpbztcbiAgICAgICAgICAgICAgICAvL2l0ZW0uZmlsbFJhdGlvID0gaFJhdGlvID4gdlJhdGlvID8gaFJhdGlvIDogdlJhdGlvO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlTW9kZSA9IF9vcHRpb25zLnNjYWxlTW9kZTtcblxuICAgICAgICAgICAgICAgIGlmIChzY2FsZU1vZGUgPT09ICdvcmlnJykge1xuICAgICAgICAgICAgICAgICAgICB6b29tTGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NhbGVNb2RlID09PSAnZml0Jykge1xuICAgICAgICAgICAgICAgICAgICB6b29tTGV2ZWwgPSBpdGVtLmZpdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh6b29tTGV2ZWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvb21MZXZlbCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbS5pbml0aWFsWm9vbUxldmVsID0gem9vbUxldmVsO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCFpdGVtLmJvdW5kcykge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXVzZSBib3VuZHMgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYm91bmRzID0gX2dldFplcm9Cb3VuZHMoKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighem9vbUxldmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY2FsY3VsYXRlU2luZ2xlSXRlbVBhbkJvdW5kcyhpdGVtLCBpdGVtLncgKiB6b29tTGV2ZWwsIGl0ZW0uaCAqIHpvb21MZXZlbCk7XG5cbiAgICAgICAgICAgIGlmIChpc0luaXRpYWwgJiYgem9vbUxldmVsID09PSBpdGVtLmluaXRpYWxab29tTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmluaXRpYWxQb3NpdGlvbiA9IGl0ZW0uYm91bmRzLmNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uYm91bmRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS53ID0gaXRlbS5oID0gMDtcbiAgICAgICAgICAgIGl0ZW0uaW5pdGlhbFpvb21MZXZlbCA9IGl0ZW0uZml0UmF0aW8gPSAxO1xuICAgICAgICAgICAgaXRlbS5ib3VuZHMgPSBfZ2V0WmVyb0JvdW5kcygpO1xuICAgICAgICAgICAgaXRlbS5pbml0aWFsUG9zaXRpb24gPSBpdGVtLmJvdW5kcy5jZW50ZXI7XG5cbiAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IGltYWdlLCB3ZSByZXR1cm4gemVybyBib3VuZHMgKGNvbnRlbnQgaXMgbm90IHpvb21hYmxlKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uYm91bmRzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sXG5cbiAgICBcblxuXG4gICAgX2FwcGVuZEltYWdlID0gZnVuY3Rpb24oaW5kZXgsIGl0ZW0sIGJhc2VEaXYsIGltZywgcHJldmVudEFuaW1hdGlvbiwga2VlcFBsYWNlaG9sZGVyKSB7XG4gICAgICAgIFxuXG4gICAgICAgIGlmKGl0ZW0ubG9hZEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZihpbWcpIHtcblxuICAgICAgICAgICAgaXRlbS5pbWFnZUFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF9zZXRJbWFnZVNpemUoaXRlbSwgaW1nLCAoaXRlbSA9PT0gc2VsZi5jdXJySXRlbSAmJiBfcmVuZGVyTWF4UmVzb2x1dGlvbikgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZChpbWcpO1xuXG4gICAgICAgICAgICBpZihrZWVwUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZihpdGVtICYmIGl0ZW0ubG9hZGVkICYmIGl0ZW0ucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG5cblxuICAgIF9wcmVsb2FkSW1hZ2UgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGl0ZW0ubG9hZGluZyA9IHRydWU7XG4gICAgICAgIGl0ZW0ubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBpbWcgPSBpdGVtLmltZyA9IGZyYW1ld29yay5jcmVhdGVFbCgncHN3cF9faW1nJywgJ2ltZycpO1xuICAgICAgICB2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaXRlbS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpdGVtLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKGl0ZW0ubG9hZENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5sb2FkQ29tcGxldGUoaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uaW1nID0gbnVsbDsgLy8gbm8gbmVlZCB0byBzdG9yZSBpbWFnZSBvYmplY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBpbWcgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBpbWcub25sb2FkID0gb25Db21wbGV0ZTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGl0ZW0ubG9hZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgfTsgICAgICBcblxuICAgICAgICBpbWcuc3JjID0gaXRlbS5zcmM7Ly8gKyAnP2E9JyArIE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgcmV0dXJuIGltZztcbiAgICB9LFxuICAgIF9jaGVja0ZvckVycm9yID0gZnVuY3Rpb24oaXRlbSwgY2xlYW5VcCkge1xuICAgICAgICBpZihpdGVtLnNyYyAmJiBpdGVtLmxvYWRFcnJvciAmJiBpdGVtLmNvbnRhaW5lcikge1xuXG4gICAgICAgICAgICBpZihjbGVhblVwKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0uY29udGFpbmVyLmlubmVySFRNTCA9IF9vcHRpb25zLmVycm9yTXNnLnJlcGxhY2UoJyV1cmwlJywgIGl0ZW0uc3JjICk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfSxcbiAgICBfc2V0SW1hZ2VTaXplID0gZnVuY3Rpb24oaXRlbSwgaW1nLCBtYXhSZXMpIHtcbiAgICAgICAgaWYoIWl0ZW0uc3JjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZighaW1nKSB7XG4gICAgICAgICAgICBpbWcgPSBpdGVtLmNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdyA9IG1heFJlcyA/IGl0ZW0udyA6IE1hdGgucm91bmQoaXRlbS53ICogaXRlbS5maXRSYXRpbyksXG4gICAgICAgICAgICBoID0gbWF4UmVzID8gaXRlbS5oIDogTWF0aC5yb3VuZChpdGVtLmggKiBpdGVtLmZpdFJhdGlvKTtcbiAgICAgICAgXG4gICAgICAgIGlmKGl0ZW0ucGxhY2Vob2xkZXIgJiYgIWl0ZW0ubG9hZGVkKSB7XG4gICAgICAgICAgICBpdGVtLnBsYWNlaG9sZGVyLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICAgICAgICBpdGVtLnBsYWNlaG9sZGVyLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1nLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICAgIGltZy5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICB9LFxuICAgIF9hcHBlbmRJbWFnZXNQb29sID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYoX2ltYWdlc1RvQXBwZW5kUG9vbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwb29sSXRlbTtcblxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IF9pbWFnZXNUb0FwcGVuZFBvb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb29sSXRlbSA9IF9pbWFnZXNUb0FwcGVuZFBvb2xbaV07XG4gICAgICAgICAgICAgICAgaWYoIHBvb2xJdGVtLmhvbGRlci5pbmRleCA9PT0gcG9vbEl0ZW0uaW5kZXggKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hcHBlbmRJbWFnZShwb29sSXRlbS5pbmRleCwgcG9vbEl0ZW0uaXRlbSwgcG9vbEl0ZW0uYmFzZURpdiwgcG9vbEl0ZW0uaW1nLCBmYWxzZSwgcG9vbEl0ZW0uY2xlYXJQbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2ltYWdlc1RvQXBwZW5kUG9vbCA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcblxuXG5fcmVnaXN0ZXJNb2R1bGUoJ0NvbnRyb2xsZXInLCB7XG5cbiAgICBwdWJsaWNNZXRob2RzOiB7XG5cbiAgICAgICAgbGF6eUxvYWRJdGVtOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgaW5kZXggPSBfZ2V0TG9vcGVkSWQoaW5kZXgpO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBfZ2V0SXRlbUF0KGluZGV4KTtcblxuICAgICAgICAgICAgaWYoIWl0ZW0gfHwgKChpdGVtLmxvYWRlZCB8fCBpdGVtLmxvYWRpbmcpICYmICFfaXRlbXNOZWVkVXBkYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3Nob3V0KCdnZXR0aW5nRGF0YScsIGluZGV4LCBpdGVtKTtcblxuICAgICAgICAgICAgaWYgKCFpdGVtLnNyYykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3ByZWxvYWRJbWFnZShpdGVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdENvbnRyb2xsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnJhbWV3b3JrLmV4dGVuZChfb3B0aW9ucywgX2NvbnRyb2xsZXJEZWZhdWx0T3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgICAgICBzZWxmLml0ZW1zID0gX2l0ZW1zID0gaXRlbXM7XG4gICAgICAgICAgICBfZ2V0SXRlbUF0ID0gc2VsZi5nZXRJdGVtQXQ7XG4gICAgICAgICAgICBfZ2V0TnVtSXRlbXMgPSBfb3B0aW9ucy5nZXROdW1JdGVtc0ZuOyAvL3NlbGYuZ2V0TnVtSXRlbXM7XG5cblxuXG4gICAgICAgICAgICBfaW5pdGlhbElzTG9vcCA9IF9vcHRpb25zLmxvb3A7XG4gICAgICAgICAgICBpZihfZ2V0TnVtSXRlbXMoKSA8IDMpIHtcbiAgICAgICAgICAgICAgICBfb3B0aW9ucy5sb29wID0gZmFsc2U7IC8vIGRpc2FibGUgbG9vcCBpZiBsZXNzIHRoZW4gMyBpdGVtc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfbGlzdGVuKCdiZWZvcmVDaGFuZ2UnLCBmdW5jdGlvbihkaWZmKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcCA9IF9vcHRpb25zLnByZWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGlzTmV4dCA9IGRpZmYgPT09IG51bGwgPyB0cnVlIDogKGRpZmYgPj0gMCksXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRCZWZvcmUgPSBNYXRoLm1pbihwWzBdLCBfZ2V0TnVtSXRlbXMoKSApLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkQWZ0ZXIgPSBNYXRoLm1pbihwWzFdLCBfZ2V0TnVtSXRlbXMoKSApLFxuICAgICAgICAgICAgICAgICAgICBpO1xuXG5cbiAgICAgICAgICAgICAgICBmb3IoaSA9IDE7IGkgPD0gKGlzTmV4dCA/IHByZWxvYWRBZnRlciA6IHByZWxvYWRCZWZvcmUpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXp5TG9hZEl0ZW0oX2N1cnJlbnRJdGVtSW5kZXgraSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcihpID0gMTsgaSA8PSAoaXNOZXh0ID8gcHJlbG9hZEJlZm9yZSA6IHByZWxvYWRBZnRlcik7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxhenlMb2FkSXRlbShfY3VycmVudEl0ZW1JbmRleC1pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX2xpc3RlbignaW5pdGlhbExheW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3Vyckl0ZW0uaW5pdGlhbExheW91dCA9IF9vcHRpb25zLmdldFRodW1iQm91bmRzRm4gJiYgX29wdGlvbnMuZ2V0VGh1bWJCb3VuZHNGbihfY3VycmVudEl0ZW1JbmRleCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX2xpc3RlbignbWFpblNjcm9sbEFuaW1Db21wbGV0ZScsIF9hcHBlbmRJbWFnZXNQb29sKTtcbiAgICAgICAgICAgIF9saXN0ZW4oJ2luaXRpYWxab29tSW5FbmQnLCBfYXBwZW5kSW1hZ2VzUG9vbCk7XG5cblxuXG4gICAgICAgICAgICBfbGlzdGVuKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IF9pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gX2l0ZW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBlbGVtZW50cywgZm9yIEdDXG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbnRhaW5lciA9IG51bGw7IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0ucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uaW1nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmltZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5wcmVsb2FkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJlbG9hZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihpdGVtLmxvYWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5sb2FkZWQgPSBpdGVtLmxvYWRFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9pbWFnZXNUb0FwcGVuZFBvb2wgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICBnZXRJdGVtQXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfaXRlbXNbaW5kZXhdICE9PSB1bmRlZmluZWQgPyBfaXRlbXNbaW5kZXhdIDogZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWxsb3dQcm9ncmVzc2l2ZUltZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyAxLiBQcm9ncmVzc2l2ZSBpbWFnZSBsb2FkaW5nIGlzbid0IHdvcmtpbmcgb24gd2Via2l0L2JsaW5rIFxuICAgICAgICAgICAgLy8gICAgd2hlbiBody1hY2NlbGVyYXRpb24gKGUuZy4gdHJhbnNsYXRlWikgaXMgYXBwbGllZCB0byBJTUcgZWxlbWVudC5cbiAgICAgICAgICAgIC8vICAgIFRoYXQncyB3aHkgaW4gUGhvdG9Td2lwZSBwYXJlbnQgZWxlbWVudCBnZXRzIHpvb20gdHJhbnNmb3JtLCBub3QgaW1hZ2UgaXRzZWxmLlxuICAgICAgICAgICAgLy8gICAgXG4gICAgICAgICAgICAvLyAyLiBQcm9ncmVzc2l2ZSBpbWFnZSBsb2FkaW5nIHNvbWV0aW1lcyBibGlua3MgaW4gd2Via2l0L2JsaW5rIHdoZW4gYXBwbHlpbmcgYW5pbWF0aW9uIHRvIHBhcmVudCBlbGVtZW50LlxuICAgICAgICAgICAgLy8gICAgVGhhdCdzIHdoeSBpdCdzIGRpc2FibGVkIG9uIHRvdWNoIGRldmljZXMgKG1haW5seSBiZWNhdXNlIG9mIHN3aXBlIHRyYW5zaXRpb24pXG4gICAgICAgICAgICAvLyAgICBcbiAgICAgICAgICAgIC8vIDMuIFByb2dyZXNzaXZlIGltYWdlIGxvYWRpbmcgc29tZXRpbWVzIGRvZXNuJ3Qgd29yayBpbiBJRSAodXAgdG8gMTEpLlxuXG4gICAgICAgICAgICAvLyBEb24ndCBhbGxvdyBwcm9ncmVzc2l2ZSBsb2FkaW5nIG9uIG5vbi1sYXJnZSB0b3VjaCBkZXZpY2VzXG4gICAgICAgICAgICByZXR1cm4gX29wdGlvbnMuZm9yY2VQcm9ncmVzc2l2ZUxvYWRpbmcgfHwgIV9saWtlbHlUb3VjaERldmljZSB8fCBfb3B0aW9ucy5tb3VzZVVzZWQgfHwgc2NyZWVuLndpZHRoID4gMTIwMDsgXG4gICAgICAgICAgICAvLyAxMjAwIC0gdG8gZWxpbWluYXRlIHRvdWNoIGRldmljZXMgd2l0aCBsYXJnZSBzY3JlZW4gKGxpa2UgQ2hyb21lYm9vayBQaXhlbClcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRDb250ZW50OiBmdW5jdGlvbihob2xkZXIsIGluZGV4KSB7XG5cbiAgICAgICAgICAgIGlmKF9vcHRpb25zLmxvb3ApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IF9nZXRMb29wZWRJZChpbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcmV2SXRlbSA9IHNlbGYuZ2V0SXRlbUF0KGhvbGRlci5pbmRleCk7XG4gICAgICAgICAgICBpZihwcmV2SXRlbSkge1xuICAgICAgICAgICAgICAgIHByZXZJdGVtLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHNlbGYuZ2V0SXRlbUF0KGluZGV4KSxcbiAgICAgICAgICAgICAgICBpbWc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgaG9sZGVyLmVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsb3cgdG8gb3ZlcnJpZGUgZGF0YVxuICAgICAgICAgICAgX3Nob3V0KCdnZXR0aW5nRGF0YScsIGluZGV4LCBpdGVtKTtcblxuICAgICAgICAgICAgaG9sZGVyLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBob2xkZXIuaXRlbSA9IGl0ZW07XG5cbiAgICAgICAgICAgIC8vIGJhc2UgY29udGFpbmVyIERJViBpcyBjcmVhdGVkIG9ubHkgb25jZSBmb3IgZWFjaCBvZiAzIGhvbGRlcnNcbiAgICAgICAgICAgIHZhciBiYXNlRGl2ID0gaXRlbS5jb250YWluZXIgPSBmcmFtZXdvcmsuY3JlYXRlRWwoJ3Bzd3BfX3pvb20td3JhcCcpOyBcblxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGlmKCFpdGVtLnNyYyAmJiBpdGVtLmh0bWwpIHtcbiAgICAgICAgICAgICAgICBpZihpdGVtLmh0bWwudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlRGl2LmFwcGVuZENoaWxkKGl0ZW0uaHRtbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZURpdi5pbm5lckhUTUwgPSBpdGVtLmh0bWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY2hlY2tGb3JFcnJvcihpdGVtKTtcblxuICAgICAgICAgICAgX2NhbGN1bGF0ZUl0ZW1TaXplKGl0ZW0sIF92aWV3cG9ydFNpemUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihpdGVtLnNyYyAmJiAhaXRlbS5sb2FkRXJyb3IgJiYgIWl0ZW0ubG9hZGVkKSB7XG5cbiAgICAgICAgICAgICAgICBpdGVtLmxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnYWxsZXJ5IGNsb3NlZCBiZWZvcmUgaW1hZ2UgZmluaXNoZWQgbG9hZGluZ1xuICAgICAgICAgICAgICAgICAgICBpZighX2lzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaG9sZGVyIGhhc24ndCBjaGFuZ2VkIHdoaWxlIGltYWdlIHdhcyBsb2FkaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmKGhvbGRlciAmJiBob2xkZXIuaW5kZXggPT09IGluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9jaGVja0ZvckVycm9yKGl0ZW0sIHRydWUpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubG9hZENvbXBsZXRlID0gaXRlbS5pbWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVJdGVtU2l6ZShpdGVtLCBfdmlld3BvcnRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXBwbHlab29tUGFuVG9JdGVtKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaG9sZGVyLmluZGV4ID09PSBfY3VycmVudEl0ZW1JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQ3Vyclpvb21JdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCAhaXRlbS5pbWFnZUFwcGVuZGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKF9mZWF0dXJlcy50cmFuc2Zvcm0gJiYgKF9tYWluU2Nyb2xsQW5pbWF0aW5nIHx8IF9pbml0aWFsWm9vbVJ1bm5pbmcpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaW1hZ2VzVG9BcHBlbmRQb29sLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTppdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZURpdjpiYXNlRGl2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nOml0ZW0uaW1nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6aW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXI6aG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJQbGFjZWhvbGRlcjp0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hcHBlbmRJbWFnZShpbmRleCwgaXRlbSwgYmFzZURpdiwgaXRlbS5pbWcsIF9tYWluU2Nyb2xsQW5pbWF0aW5nIHx8IF9pbml0aWFsWm9vbVJ1bm5pbmcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHByZWxvYWRlciAmIG1pbmktaW1nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIV9pbml0aWFsWm9vbVJ1bm5pbmcgJiYgaXRlbS5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubG9hZENvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5pbWcgPSBudWxsOyAvLyBubyBuZWVkIHRvIHN0b3JlIGltYWdlIGVsZW1lbnQgYWZ0ZXIgaXQncyBhZGRlZFxuXG4gICAgICAgICAgICAgICAgICAgIF9zaG91dCgnaW1hZ2VMb2FkQ29tcGxldGUnLCBpbmRleCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmKGZyYW1ld29yay5mZWF0dXJlcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlckNsYXNzTmFtZSA9ICdwc3dwX19pbWcgcHN3cF9faW1nLS1wbGFjZWhvbGRlcic7IFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckNsYXNzTmFtZSArPSAoaXRlbS5tc3JjID8gJycgOiAnIHBzd3BfX2ltZy0tcGxhY2Vob2xkZXItLWJsYW5rJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZnJhbWV3b3JrLmNyZWF0ZUVsKHBsYWNlaG9sZGVyQ2xhc3NOYW1lLCBpdGVtLm1zcmMgPyAnaW1nJyA6ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5tc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlci5zcmMgPSBpdGVtLm1zcmM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIF9zZXRJbWFnZVNpemUoaXRlbSwgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJhc2VEaXYuYXBwZW5kQ2hpbGQocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgIGlmKCFpdGVtLmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ByZWxvYWRJbWFnZShpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGlmKCBzZWxmLmFsbG93UHJvZ3Jlc3NpdmVJbWcoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBhcHBlbmQgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYoIV9pbml0aWFsQ29udGVudFNldCAmJiBfZmVhdHVyZXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1hZ2VzVG9BcHBlbmRQb29sLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06aXRlbSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZURpdjpiYXNlRGl2LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6aXRlbS5pbWcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OmluZGV4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXI6aG9sZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hcHBlbmRJbWFnZShpbmRleCwgaXRlbSwgYmFzZURpdiwgaXRlbS5pbWcsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmKGl0ZW0uc3JjICYmICFpdGVtLmxvYWRFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGltYWdlIG9iamVjdCBpcyBjcmVhdGVkIGV2ZXJ5IHRpbWUsIGR1ZSB0byBidWdzIG9mIGltYWdlIGxvYWRpbmcgJiBkZWxheSB3aGVuIHN3aXRjaGluZyBpbWFnZXNcbiAgICAgICAgICAgICAgICBpbWcgPSBmcmFtZXdvcmsuY3JlYXRlRWwoJ3Bzd3BfX2ltZycsICdpbWcnKTtcbiAgICAgICAgICAgICAgICBpbWcuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IGl0ZW0uc3JjO1xuICAgICAgICAgICAgICAgIF9zZXRJbWFnZVNpemUoaXRlbSwgaW1nKTtcbiAgICAgICAgICAgICAgICBfYXBwZW5kSW1hZ2UoaW5kZXgsIGl0ZW0sIGJhc2VEaXYsIGltZywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgaWYoIV9pbml0aWFsQ29udGVudFNldCAmJiBpbmRleCA9PT0gX2N1cnJlbnRJdGVtSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBfY3Vyclpvb21FbGVtZW50U3R5bGUgPSBiYXNlRGl2LnN0eWxlO1xuICAgICAgICAgICAgICAgIF9zaG93T3JIaWRlKGl0ZW0sIChpbWcgfHxpdGVtLmltZykgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2FwcGx5Wm9vbVBhblRvSXRlbShpdGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG9sZGVyLmVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgaG9sZGVyLmVsLmFwcGVuZENoaWxkKGJhc2VEaXYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFuU2xpZGU6IGZ1bmN0aW9uKCBpdGVtICkge1xuICAgICAgICAgICAgaWYoaXRlbS5pbWcgKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5pbWcub25sb2FkID0gaXRlbS5pbWcub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLmxvYWRlZCA9IGl0ZW0ubG9hZGluZyA9IGl0ZW0uaW1nID0gaXRlbS5pbWFnZUFwcGVuZGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH1cbn0pO1xuXG4vKj4+aXRlbXMtY29udHJvbGxlciovXG5cbi8qPj50YXAqL1xuLyoqXG4gKiB0YXAuanM6XG4gKlxuICogRGlzcGxhdGNoZXMgdGFwIGFuZCBkb3VibGUtdGFwIGV2ZW50cy5cbiAqIFxuICovXG5cbnZhciB0YXBUaW1lcixcbiAgICB0YXBSZWxlYXNlUG9pbnQgPSB7fSxcbiAgICBfZGlzcGF0Y2hUYXBFdmVudCA9IGZ1bmN0aW9uKG9yaWdFdmVudCwgcmVsZWFzZVBvaW50LCBwb2ludGVyVHlwZSkgeyAgICAgICAgXG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoICdDdXN0b21FdmVudCcgKSxcbiAgICAgICAgICAgIGVEZXRhaWwgPSB7XG4gICAgICAgICAgICAgICAgb3JpZ0V2ZW50Om9yaWdFdmVudCwgXG4gICAgICAgICAgICAgICAgdGFyZ2V0Om9yaWdFdmVudC50YXJnZXQsIFxuICAgICAgICAgICAgICAgIHJlbGVhc2VQb2ludDogcmVsZWFzZVBvaW50LCBcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTpwb2ludGVyVHlwZSB8fCAndG91Y2gnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGUuaW5pdEN1c3RvbUV2ZW50KCAncHN3cFRhcCcsIHRydWUsIHRydWUsIGVEZXRhaWwgKTtcbiAgICAgICAgb3JpZ0V2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH07XG5cbl9yZWdpc3Rlck1vZHVsZSgnVGFwJywge1xuICAgIHB1YmxpY01ldGhvZHM6IHtcbiAgICAgICAgaW5pdFRhcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfbGlzdGVuKCdmaXJzdFRvdWNoU3RhcnQnLCBzZWxmLm9uVGFwU3RhcnQpO1xuICAgICAgICAgICAgX2xpc3RlbigndG91Y2hSZWxlYXNlJywgc2VsZi5vblRhcFJlbGVhc2UpO1xuICAgICAgICAgICAgX2xpc3RlbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRhcFJlbGVhc2VQb2ludCA9IHt9O1xuICAgICAgICAgICAgICAgIHRhcFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblRhcFN0YXJ0OiBmdW5jdGlvbih0b3VjaExpc3QpIHtcbiAgICAgICAgICAgIGlmKHRvdWNoTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcFRpbWVyKTtcbiAgICAgICAgICAgICAgICB0YXBUaW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGFwUmVsZWFzZTogZnVuY3Rpb24oZSwgcmVsZWFzZVBvaW50KSB7XG4gICAgICAgICAgICBpZighcmVsZWFzZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighX21vdmVkICYmICFfaXNNdWx0aXRvdWNoICYmICFfbnVtQW5pbWF0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBwMCA9IHJlbGVhc2VQb2ludDtcbiAgICAgICAgICAgICAgICBpZih0YXBUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGFwVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICB0YXBUaW1lciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGFwZWQgb24gdGhlIHNhbWUgcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBfaXNOZWFyYnlQb2ludHMocDAsIHRhcFJlbGVhc2VQb2ludCkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc2hvdXQoJ2RvdWJsZVRhcCcsIHAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHJlbGVhc2VQb2ludC50eXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaFRhcEV2ZW50KGUsIHJlbGVhc2VQb2ludCwgJ21vdXNlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2xpY2tlZFRhZ05hbWUgPSBlLnRhcmdldC50YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgZG91YmxlIHRhcCBkZWxheSBvbiBidXR0b25zIGFuZCBlbGVtZW50cyB0aGF0IGhhdmUgY2xhc3MgcHN3cF9fc2luZ2xlLXRhcFxuICAgICAgICAgICAgICAgIGlmKGNsaWNrZWRUYWdOYW1lID09PSAnQlVUVE9OJyB8fCBmcmFtZXdvcmsuaGFzQ2xhc3MoZS50YXJnZXQsICdwc3dwX19zaW5nbGUtdGFwJykgKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaFRhcEV2ZW50KGUsIHJlbGVhc2VQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfZXF1YWxpemVQb2ludHModGFwUmVsZWFzZVBvaW50LCBwMCk7XG5cbiAgICAgICAgICAgICAgICB0YXBUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaFRhcEV2ZW50KGUsIHJlbGVhc2VQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qPj50YXAqL1xuXG4vKj4+ZGVza3RvcC16b29tKi9cbi8qKlxuICpcbiAqIGRlc2t0b3Atem9vbS5qczpcbiAqXG4gKiAtIEJpbmRzIG1vdXNld2hlZWwgZXZlbnQgZm9yIHBhbmluZyB6b29tZWQgaW1hZ2UuXG4gKiAtIE1hbmFnZXMgXCJkcmFnZ2luZ1wiLCBcInpvb21lZC1pblwiLCBcInpvb20tb3V0XCIgY2xhc3Nlcy5cbiAqICAgKHdoaWNoIGFyZSB1c2VkIGZvciBjdXJzb3JzIGFuZCB6b29tIGljb24pXG4gKiAtIEFkZHMgdG9nZ2xlRGVza3RvcFpvb20gZnVuY3Rpb24uXG4gKiBcbiAqL1xuXG52YXIgX3doZWVsRGVsdGE7XG4gICAgXG5fcmVnaXN0ZXJNb2R1bGUoJ0Rlc2t0b3Bab29tJywge1xuXG4gICAgcHVibGljTWV0aG9kczoge1xuXG4gICAgICAgIGluaXREZXNrdG9wWm9vbTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmKF9vbGRJRSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIHpvb20gZm9yIG9sZCBJRSAoPD04KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoX2xpa2VseVRvdWNoRGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZGV0ZWN0ZWQgaGFyZHdhcmUgdG91Y2ggc3VwcG9ydCwgd2Ugd2FpdCB1bnRpbCBtb3VzZSBpcyB1c2VkLFxuICAgICAgICAgICAgICAgIC8vIGFuZCBvbmx5IHRoZW4gYXBwbHkgZGVza3RvcC16b29tIGZlYXR1cmVzXG4gICAgICAgICAgICAgICAgX2xpc3RlbignbW91c2VVc2VkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0dXBEZXNrdG9wWm9vbSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldHVwRGVza3RvcFpvb20odHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXR1cERlc2t0b3Bab29tOiBmdW5jdGlvbihvbkluaXQpIHtcblxuICAgICAgICAgICAgX3doZWVsRGVsdGEgPSB7fTtcblxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9ICd3aGVlbCBtb3VzZXdoZWVsIERPTU1vdXNlU2Nyb2xsJztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgX2xpc3RlbignYmluZEV2ZW50cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZyYW1ld29yay5iaW5kKHRlbXBsYXRlLCBldmVudHMsICBzZWxmLmhhbmRsZU1vdXNlV2hlZWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF9saXN0ZW4oJ3VuYmluZEV2ZW50cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmKF93aGVlbERlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1ld29yay51bmJpbmQodGVtcGxhdGUsIGV2ZW50cywgc2VsZi5oYW5kbGVNb3VzZVdoZWVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2VsZi5tb3VzZVpvb21lZEluID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBoYXNEcmFnZ2luZ0NsYXNzLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVpvb21hYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNlbGYubW91c2Vab29tZWRJbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWV3b3JrLnJlbW92ZUNsYXNzKHRlbXBsYXRlLCAncHN3cC0tem9vbWVkLWluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vdXNlWm9vbWVkSW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihfY3Vyclpvb21MZXZlbCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLXpvb20tYWxsb3dlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWV3b3JrLnJlbW92ZUNsYXNzKHRlbXBsYXRlLCAncHN3cC0tem9vbS1hbGxvd2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRHJhZ2dpbmdDbGFzcygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlRHJhZ2dpbmdDbGFzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZihoYXNEcmFnZ2luZ0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZXdvcmsucmVtb3ZlQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1kcmFnZ2luZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHJhZ2dpbmdDbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX2xpc3RlbigncmVzaXplJyAsIHVwZGF0ZVpvb21hYmxlKTtcbiAgICAgICAgICAgIF9saXN0ZW4oJ2FmdGVyQ2hhbmdlJyAsIHVwZGF0ZVpvb21hYmxlKTtcbiAgICAgICAgICAgIF9saXN0ZW4oJ3BvaW50ZXJEb3duJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoc2VsZi5tb3VzZVpvb21lZEluKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0RyYWdnaW5nQ2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1kcmFnZ2luZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX2xpc3RlbigncG9pbnRlclVwJywgcmVtb3ZlRHJhZ2dpbmdDbGFzcyk7XG5cbiAgICAgICAgICAgIGlmKCFvbkluaXQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVab29tYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlTW91c2VXaGVlbDogZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgICBpZihfY3Vyclpvb21MZXZlbCA8PSBzZWxmLmN1cnJJdGVtLmZpdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgaWYoIF9vcHRpb25zLm1vZGFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghX29wdGlvbnMuY2xvc2VPblNjcm9sbCB8fCBfbnVtQW5pbWF0aW9ucyB8fCBfaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoX3RyYW5zZm9ybUtleSAmJiBNYXRoLmFicyhlLmRlbHRhWSkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSBQaG90b1N3aXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBicm93c2VyIHN1cHBvcnRzIHRyYW5zZm9ybXMgJiBzY3JvbGwgY2hhbmdlZCBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbG9zZWRCeVNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsb3cganVzdCBvbmUgZXZlbnQgdG8gZmlyZVxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXG4gICAgICAgICAgICBfd2hlZWxEZWx0YS54ID0gMDtcblxuICAgICAgICAgICAgaWYoJ2RlbHRhWCcgaW4gZSkge1xuICAgICAgICAgICAgICAgIGlmKGUuZGVsdGFNb2RlID09PSAxIC8qIERPTV9ERUxUQV9MSU5FICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDE4IC0gYXZlcmFnZSBsaW5lIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICBfd2hlZWxEZWx0YS54ID0gZS5kZWx0YVggKiAxODtcbiAgICAgICAgICAgICAgICAgICAgX3doZWVsRGVsdGEueSA9IGUuZGVsdGFZICogMTg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3doZWVsRGVsdGEueCA9IGUuZGVsdGFYO1xuICAgICAgICAgICAgICAgICAgICBfd2hlZWxEZWx0YS55ID0gZS5kZWx0YVk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKCd3aGVlbERlbHRhJyBpbiBlKSB7XG4gICAgICAgICAgICAgICAgaWYoZS53aGVlbERlbHRhWCkge1xuICAgICAgICAgICAgICAgICAgICBfd2hlZWxEZWx0YS54ID0gLTAuMTYgKiBlLndoZWVsRGVsdGFYO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihlLndoZWVsRGVsdGFZKSB7XG4gICAgICAgICAgICAgICAgICAgIF93aGVlbERlbHRhLnkgPSAtMC4xNiAqIGUud2hlZWxEZWx0YVk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3doZWVsRGVsdGEueSA9IC0wLjE2ICogZS53aGVlbERlbHRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZignZGV0YWlsJyBpbiBlKSB7XG4gICAgICAgICAgICAgICAgX3doZWVsRGVsdGEueSA9IGUuZGV0YWlsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jYWxjdWxhdGVQYW5Cb3VuZHMoX2N1cnJab29tTGV2ZWwsIHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgbmV3UGFuWCA9IF9wYW5PZmZzZXQueCAtIF93aGVlbERlbHRhLngsXG4gICAgICAgICAgICAgICAgbmV3UGFuWSA9IF9wYW5PZmZzZXQueSAtIF93aGVlbERlbHRhLnk7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgcHJldmVudCBzY3JvbGxpbmcgaW4gbm9ubW9kYWwgbW9kZSB3aGVuIG5vdCBhdCBlZGdlc1xuICAgICAgICAgICAgaWYgKF9vcHRpb25zLm1vZGFsIHx8XG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIG5ld1BhblggPD0gX2N1cnJQYW5Cb3VuZHMubWluLnggJiYgbmV3UGFuWCA+PSBfY3VyclBhbkJvdW5kcy5tYXgueCAmJlxuICAgICAgICAgICAgICAgIG5ld1BhblkgPD0gX2N1cnJQYW5Cb3VuZHMubWluLnkgJiYgbmV3UGFuWSA+PSBfY3VyclBhbkJvdW5kcy5tYXgueVxuICAgICAgICAgICAgICAgICkgKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiB1c2UgckFGIGluc3RlYWQgb2YgbW91c2V3aGVlbD9cbiAgICAgICAgICAgIHNlbGYucGFuVG8obmV3UGFuWCwgbmV3UGFuWSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlRGVza3RvcFpvb206IGZ1bmN0aW9uKGNlbnRlclBvaW50KSB7XG4gICAgICAgICAgICBjZW50ZXJQb2ludCA9IGNlbnRlclBvaW50IHx8IHt4Ol92aWV3cG9ydFNpemUueC8yICsgX29mZnNldC54LCB5Ol92aWV3cG9ydFNpemUueS8yICsgX29mZnNldC55IH07XG5cbiAgICAgICAgICAgIHZhciBkb3VibGVUYXBab29tTGV2ZWwgPSBfb3B0aW9ucy5nZXREb3VibGVUYXBab29tKHRydWUsIHNlbGYuY3Vyckl0ZW0pO1xuICAgICAgICAgICAgdmFyIHpvb21PdXQgPSBfY3Vyclpvb21MZXZlbCA9PT0gZG91YmxlVGFwWm9vbUxldmVsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZWxmLm1vdXNlWm9vbWVkSW4gPSAhem9vbU91dDtcblxuICAgICAgICAgICAgc2VsZi56b29tVG8oem9vbU91dCA/IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCA6IGRvdWJsZVRhcFpvb21MZXZlbCwgY2VudGVyUG9pbnQsIDMzMyk7XG4gICAgICAgICAgICBmcmFtZXdvcmtbICghem9vbU91dCA/ICdhZGQnIDogJ3JlbW92ZScpICsgJ0NsYXNzJ10odGVtcGxhdGUsICdwc3dwLS16b29tZWQtaW4nKTtcbiAgICAgICAgfVxuXG4gICAgfVxufSk7XG5cblxuLyo+PmRlc2t0b3Atem9vbSovXG5cbi8qPj5oaXN0b3J5Ki9cbi8qKlxuICpcbiAqIGhpc3RvcnkuanM6XG4gKlxuICogLSBCYWNrIGJ1dHRvbiB0byBjbG9zZSBnYWxsZXJ5LlxuICogXG4gKiAtIFVuaXF1ZSBVUkwgZm9yIGVhY2ggc2xpZGU6IGV4YW1wbGUuY29tLyZwaWQ9MSZnaWQ9M1xuICogICAod2hlcmUgUElEIGlzIHBpY3R1cmUgaW5kZXgsIGFuZCBHSUQgYW5kIGdhbGxlcnkgaW5kZXgpXG4gKiAgIFxuICogLSBTd2l0Y2ggVVJMIHdoZW4gc2xpZGVzIGNoYW5nZS5cbiAqIFxuICovXG5cblxudmFyIF9oaXN0b3J5RGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgaGlzdG9yeTogdHJ1ZSxcbiAgICBnYWxsZXJ5VUlEOiAxXG59O1xuXG52YXIgX2hpc3RvcnlVcGRhdGVUaW1lb3V0LFxuICAgIF9oYXNoQ2hhbmdlVGltZW91dCxcbiAgICBfaGFzaEFuaW1DaGVja1RpbWVvdXQsXG4gICAgX2hhc2hDaGFuZ2VkQnlTY3JpcHQsXG4gICAgX2hhc2hDaGFuZ2VkQnlIaXN0b3J5LFxuICAgIF9oYXNoUmVzZXRlZCxcbiAgICBfaW5pdGlhbEhhc2gsXG4gICAgX2hpc3RvcnlDaGFuZ2VkLFxuICAgIF9jbG9zZWRGcm9tVVJMLFxuICAgIF91cmxDaGFuZ2VkT25jZSxcbiAgICBfd2luZG93TG9jLFxuXG4gICAgX3N1cHBvcnRzUHVzaFN0YXRlLFxuXG4gICAgX2dldEhhc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF93aW5kb3dMb2MuaGFzaC5zdWJzdHJpbmcoMSk7XG4gICAgfSxcbiAgICBfY2xlYW5IaXN0b3J5VGltZW91dHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZihfaGlzdG9yeVVwZGF0ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfaGlzdG9yeVVwZGF0ZVRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoX2hhc2hBbmltQ2hlY2tUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX2hhc2hBbmltQ2hlY2tUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBwaWQgLSBQaWN0dXJlIGluZGV4XG4gICAgLy8gZ2lkIC0gR2FsbGVyeSBpbmRleFxuICAgIF9wYXJzZUl0ZW1JbmRleEZyb21VUkwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhhc2ggPSBfZ2V0SGFzaCgpLFxuICAgICAgICAgICAgcGFyYW1zID0ge307XG5cbiAgICAgICAgaWYoaGFzaC5sZW5ndGggPCA1KSB7IC8vIHBpZD0xXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksIHZhcnMgPSBoYXNoLnNwbGl0KCcmJyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZighdmFyc1tpXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KCc9Jyk7ICBcbiAgICAgICAgICAgIGlmKHBhaXIubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zW3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZihfb3B0aW9ucy5nYWxsZXJ5UElEcykge1xuICAgICAgICAgICAgLy8gZGV0ZWN0IGN1c3RvbSBwaWQgaW4gaGFzaCBhbmQgc2VhcmNoIGZvciBpdCBhbW9uZyB0aGUgaXRlbXMgY29sbGVjdGlvblxuICAgICAgICAgICAgdmFyIHNlYXJjaGZvciA9IHBhcmFtcy5waWQ7XG4gICAgICAgICAgICBwYXJhbXMucGlkID0gMDsgLy8gaWYgY3VzdG9tIHBpZCBjYW5ub3QgYmUgZm91bmQsIGZhbGxiYWNrIHRvIHRoZSBmaXJzdCBpdGVtXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBfaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZihfaXRlbXNbaV0ucGlkID09PSBzZWFyY2hmb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBpZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5waWQgPSBwYXJzZUludChwYXJhbXMucGlkLDEwKS0xO1xuICAgICAgICB9XG4gICAgICAgIGlmKCBwYXJhbXMucGlkIDwgMCApIHtcbiAgICAgICAgICAgIHBhcmFtcy5waWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcbiAgICBfdXBkYXRlSGFzaCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmKF9oYXNoQW5pbUNoZWNrVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9oYXNoQW5pbUNoZWNrVGltZW91dCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmKF9udW1BbmltYXRpb25zIHx8IF9pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2luZyBicm93c2VyIFVSTCBmb3JjZXMgbGF5b3V0L3BhaW50IGluIHNvbWUgYnJvd3NlcnMsIHdoaWNoIGNhdXNlcyBub3RpY2FibGUgbGFnIGR1cmluZyBhbmltYXRpb25cbiAgICAgICAgICAgIC8vIHRoYXQncyB3aHkgd2UgdXBkYXRlIGhhc2ggb25seSB3aGVuIG5vIGFuaW1hdGlvbnMgcnVubmluZ1xuICAgICAgICAgICAgX2hhc2hBbmltQ2hlY2tUaW1lb3V0ID0gc2V0VGltZW91dChfdXBkYXRlSGFzaCwgNTAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoX2hhc2hDaGFuZ2VkQnlTY3JpcHQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfaGFzaENoYW5nZVRpbWVvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2hhc2hDaGFuZ2VkQnlTY3JpcHQgPSB0cnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgcGlkID0gKF9jdXJyZW50SXRlbUluZGV4ICsgMSk7XG4gICAgICAgIHZhciBpdGVtID0gX2dldEl0ZW1BdCggX2N1cnJlbnRJdGVtSW5kZXggKTtcbiAgICAgICAgaWYoaXRlbS5oYXNPd25Qcm9wZXJ0eSgncGlkJykpIHtcbiAgICAgICAgICAgIC8vIGNhcnJ5IGZvcndhcmQgYW55IGN1c3RvbSBwaWQgYXNzaWduZWQgdG8gdGhlIGl0ZW1cbiAgICAgICAgICAgIHBpZCA9IGl0ZW0ucGlkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdIYXNoID0gX2luaXRpYWxIYXNoICsgJyYnICArICAnZ2lkPScgKyBfb3B0aW9ucy5nYWxsZXJ5VUlEICsgJyYnICsgJ3BpZD0nICsgcGlkO1xuXG4gICAgICAgIGlmKCFfaGlzdG9yeUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmKF93aW5kb3dMb2MuaGFzaC5pbmRleE9mKG5ld0hhc2gpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIF91cmxDaGFuZ2VkT25jZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaXJzdCB0aW1lIC0gYWRkIG5ldyBoaXNvcnkgcmVjb3JkLCB0aGVuIGp1c3QgcmVwbGFjZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1VSTCA9IF93aW5kb3dMb2MuaHJlZi5zcGxpdCgnIycpWzBdICsgJyMnICsgIG5ld0hhc2g7XG5cbiAgICAgICAgaWYoIF9zdXBwb3J0c1B1c2hTdGF0ZSApIHtcblxuICAgICAgICAgICAgaWYoJyMnICsgbmV3SGFzaCAhPT0gd2luZG93LmxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5W19oaXN0b3J5Q2hhbmdlZCA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKCcnLCBkb2N1bWVudC50aXRsZSwgbmV3VVJMKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoX2hpc3RvcnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgX3dpbmRvd0xvYy5yZXBsYWNlKCBuZXdVUkwgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3dpbmRvd0xvYy5oYXNoID0gbmV3SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG5cbiAgICAgICAgX2hpc3RvcnlDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgX2hhc2hDaGFuZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9oYXNoQ2hhbmdlZEJ5U2NyaXB0ID0gZmFsc2U7XG4gICAgICAgIH0sIDYwKTtcbiAgICB9O1xuXG5cblxuICAgIFxuXG5fcmVnaXN0ZXJNb2R1bGUoJ0hpc3RvcnknLCB7XG5cbiAgICBcblxuICAgIHB1YmxpY01ldGhvZHM6IHtcbiAgICAgICAgaW5pdEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBmcmFtZXdvcmsuZXh0ZW5kKF9vcHRpb25zLCBfaGlzdG9yeURlZmF1bHRPcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYoICFfb3B0aW9ucy5oaXN0b3J5ICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBfd2luZG93TG9jID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICAgICAgX3VybENoYW5nZWRPbmNlID0gZmFsc2U7XG4gICAgICAgICAgICBfY2xvc2VkRnJvbVVSTCA9IGZhbHNlO1xuICAgICAgICAgICAgX2hpc3RvcnlDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBfaW5pdGlhbEhhc2ggPSBfZ2V0SGFzaCgpO1xuICAgICAgICAgICAgX3N1cHBvcnRzUHVzaFN0YXRlID0gKCdwdXNoU3RhdGUnIGluIGhpc3RvcnkpO1xuXG5cbiAgICAgICAgICAgIGlmKF9pbml0aWFsSGFzaC5pbmRleE9mKCdnaWQ9JykgPiAtMSkge1xuICAgICAgICAgICAgICAgIF9pbml0aWFsSGFzaCA9IF9pbml0aWFsSGFzaC5zcGxpdCgnJmdpZD0nKVswXTtcbiAgICAgICAgICAgICAgICBfaW5pdGlhbEhhc2ggPSBfaW5pdGlhbEhhc2guc3BsaXQoJz9naWQ9JylbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgX2xpc3RlbignYWZ0ZXJDaGFuZ2UnLCBzZWxmLnVwZGF0ZVVSTCk7XG4gICAgICAgICAgICBfbGlzdGVuKCd1bmJpbmRFdmVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmcmFtZXdvcmsudW5iaW5kKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBzZWxmLm9uSGFzaENoYW5nZSk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICB2YXIgcmV0dXJuVG9PcmlnaW5hbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9oYXNoUmVzZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYoIV9jbG9zZWRGcm9tVVJMKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoX3VybENoYW5nZWRPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5LmJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoX2luaXRpYWxIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3dpbmRvd0xvYy5oYXNoID0gX2luaXRpYWxIYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRzUHVzaFN0YXRlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGhhc2ggZnJvbSB1cmwgd2l0aG91dCByZWZyZXNoaW5nIGl0IG9yIHNjcm9sbGluZyB0byB0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoJycsIGRvY3VtZW50LnRpdGxlLCAgX3dpbmRvd0xvYy5wYXRobmFtZSArIF93aW5kb3dMb2Muc2VhcmNoICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3dpbmRvd0xvYy5oYXNoID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jbGVhbkhpc3RvcnlUaW1lb3V0cygpO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICBfbGlzdGVuKCd1bmJpbmRFdmVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZihfY2xvc2VkQnlTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgUGhvdG9Td2lwZSBpcyBjbG9zZWQgYnkgc2Nyb2xsLCB3ZSBnbyBcImJhY2tcIiBiZWZvcmUgdGhlIGNsb3NpbmcgYW5pbWF0aW9uIHN0YXJ0c1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGRvbmUgdG8ga2VlcCB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblRvT3JpZ2luYWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9saXN0ZW4oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZighX2hhc2hSZXNldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblRvT3JpZ2luYWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9saXN0ZW4oJ2ZpcnN0VXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJdGVtSW5kZXggPSBfcGFyc2VJdGVtSW5kZXhGcm9tVVJMKCkucGlkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF9pbml0aWFsSGFzaC5pbmRleE9mKCdwaWQ9Jyk7XG4gICAgICAgICAgICBpZihpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgX2luaXRpYWxIYXNoID0gX2luaXRpYWxIYXNoLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYoX2luaXRpYWxIYXNoLnNsaWNlKC0xKSA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pbml0aWFsSGFzaCA9IF9pbml0aWFsSGFzaC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoX2lzT3BlbikgeyAvLyBoYXNuJ3QgZGVzdHJveWVkIHlldFxuICAgICAgICAgICAgICAgICAgICBmcmFtZXdvcmsuYmluZCh3aW5kb3csICdoYXNoY2hhbmdlJywgc2VsZi5vbkhhc2hDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDQwKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBvbkhhc2hDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZihfZ2V0SGFzaCgpID09PSBfaW5pdGlhbEhhc2gpIHtcblxuICAgICAgICAgICAgICAgIF9jbG9zZWRGcm9tVVJMID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIV9oYXNoQ2hhbmdlZEJ5U2NyaXB0KSB7XG5cbiAgICAgICAgICAgICAgICBfaGFzaENoYW5nZWRCeUhpc3RvcnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYuZ29UbyggX3BhcnNlSXRlbUluZGV4RnJvbVVSTCgpLnBpZCApO1xuICAgICAgICAgICAgICAgIF9oYXNoQ2hhbmdlZEJ5SGlzdG9yeSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVVSTDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8vIERlbGF5IHRoZSB1cGRhdGUgb2YgVVJMLCB0byBhdm9pZCBsYWcgZHVyaW5nIHRyYW5zaXRpb24sIFxuICAgICAgICAgICAgLy8gYW5kIHRvIG5vdCB0byB0cmlnZ2VyIGFjdGlvbnMgbGlrZSBcInJlZnJlc2ggcGFnZSBzb3VuZFwiIG9yIFwiYmxpbmtpbmcgZmF2aWNvblwiIHRvIG9mdGVuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIF9jbGVhbkhpc3RvcnlUaW1lb3V0cygpO1xuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGlmKF9oYXNoQ2hhbmdlZEJ5SGlzdG9yeSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIV9oaXN0b3J5Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIF91cGRhdGVIYXNoKCk7IC8vIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2hpc3RvcnlVcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChfdXBkYXRlSGFzaCwgODAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgIH1cbn0pO1xuXG5cbi8qPj5oaXN0b3J5Ki9cbiAgICBmcmFtZXdvcmsuZXh0ZW5kKHNlbGYsIHB1YmxpY01ldGhvZHMpOyB9O1xuICAgIHJldHVybiBQaG90b1N3aXBlO1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92ZW5kb3IvcGhvdG9zd2lwZS11aS1kZWZhdWx0LmpzIiwiaW1wb3J0IHNlbGVjdENvbXBvbmVudCBmcm9tICd1dGlsaXRpZXMvc2VsZWN0LWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhcmUge1xuXG4gICAgYW5pbWF0aW5nQ2xhc3MgPSAndmVsb2NpdHktYW5pbWF0aW5nJztcbiAgICB2ZWxvY2l0eUNvbmZpZyA9IHtcbiAgICAgICAgZHVyYXRpb246IDI1MFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuJGNvbXBvbmVudCA9IHNlbGVjdENvbXBvbmVudChlbGVtZW50KVxuICAgICAgICB0aGlzLiRsaXN0ID0gdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLmxpc3RcbiAgICAgICAgdGhpcy4kYnV0dG9uID0gdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLmJ1dHRvblxuXG4gICAgICAgICQuVmVsb2NpdHkuaG9vayh0aGlzLiRsaXN0LCAndHJhbnNsYXRlWCcsICctNTAlJylcblxuICAgICAgICB0aGlzLiRidXR0b24ub24oJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlTGlzdCgpXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy4kbGlzdC5vbignY2xpY2snLCBldmVudCA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSlcblxuICAgICAgICAkKHdpbmRvdykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGxpc3QuaXMoJzp2aXNpYmxlJykgJiYgIXRoaXMuJGxpc3QuaGFzQ2xhc3ModGhpcy5hbmltYXRpbmdDbGFzcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVMaXN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBoYW5kZUJ1dHRvbkNsaWNrID0gZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnRvZ2dsZUxpc3QoKVxuICAgIH07XG5cbiAgICBzaG93TGlzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRsaXN0Lmhhc0NsYXNzKHRoaXMuYW5pbWF0aW5nQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aGlzLiRsaXN0LnZlbG9jaXR5KCd0cmFuc2l0aW9uLnNsaWRlRG93bkluJywgdGhpcy52ZWxvY2l0eUNvbmZpZylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpZGVMaXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuJGxpc3QuaGFzQ2xhc3ModGhpcy5hbmltYXRpbmdDbGFzcykpIHtcbiAgICAgICAgICAgIHRoaXMuJGxpc3QudmVsb2NpdHkoJ3RyYW5zaXRpb24uc2xpZGVVcE91dCcsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnZlbG9jaXR5Q29uZmlnLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxpc3QuY3NzKCdkaXNwbGF5JywgJycpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZUxpc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLiRsaXN0LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVMaXN0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0xpc3QoKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50L1NoYXJlLmpzIiwiaW1wb3J0ICd2ZWxvY2l0eS1hbmltYXRlJ1xuaW1wb3J0ICd2ZWxvY2l0eS1hbmltYXRlL3ZlbG9jaXR5LnVpLm1pbidcbmltcG9ydCBzZWxlY3RDb21wb25lbnQgZnJvbSAndXRpbGl0aWVzL3NlbGVjdC1jb21wb25lbnQnXG5pbXBvcnQgJ3ZlbmRvci9qcXVlcnkuZGVib3VuY2VkcmVzaXplJ1xuaW1wb3J0IHskYnBMYXB0b3B9IGZyb20gJ3V0aWxpdGllcy9ncmlkLXNldHRpbmdzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJOYXYge1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuJGNvbXBvbmVudCA9IHNlbGVjdENvbXBvbmVudChlbGVtZW50KVxuICAgICAgICB0aGlzLiRuYXYgPSB0aGlzLiRjb21wb25lbnQuZWxlbWVudHMuc3VibmF2Q29udGVudHNcbiAgICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uKClcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdkZWJvdW5jZWRyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zaXRpb24oKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHNldFRyYW5zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuc3RvcFRvZ2dsZSgpXG4gICAgICAgIGlmICgkYnBMYXB0b3AubWF0Y2hlcykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uSW4gPSAndHJhbnNpdGlvbi5zbGlkZURvd25JbidcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbk91dCA9ICd0cmFuc2l0aW9uLnNsaWRlVXBPdXQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25JbiA9ICdzbGlkZURvd24nXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25PdXQgPSAnc2xpZGVVcCdcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5zdGFydFRvZ2dsZSgpXG4gICAgfVxuXG4gICAgc3RhcnRUb2dnbGUoKSB7XG4gICAgICAgICQoJ2JvZHknKS5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLnRvZ2dsZS5hdHRyKCdkYXRhLXByb3BlcnR5JykgPT0gJ29wZW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLnRvZ2dsZS5hdHRyKCdkYXRhLXByb3BlcnR5JywgJ2Nsb3NlZCcpXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZU5hdigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLnRvZ2dsZS5vbignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAgICAgICAgIGlmICh0aGlzLiRjb21wb25lbnQuZWxlbWVudHMudG9nZ2xlLmF0dHIoJ2RhdGEtcHJvcGVydHknKSA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb21wb25lbnQuZWxlbWVudHMudG9nZ2xlLmF0dHIoJ2RhdGEtcHJvcGVydHknLCAnY2xvc2VkJylcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlTmF2KClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29tcG9uZW50LmVsZW1lbnRzLnRvZ2dsZS5hdHRyKCdkYXRhLXByb3BlcnR5JywgJ29wZW4nKVxuICAgICAgICAgICAgICAgIHRoaXMub3Blbk5hdigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy4kY29tcG9uZW50Lm9uKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBzdG9wVG9nZ2xlKCkge1xuICAgICAgICB0aGlzLiRjb21wb25lbnQuZWxlbWVudHMudG9nZ2xlLm9mZigpXG4gICAgICAgICQoJ2JvZHknKS5vZmYoKVxuICAgIH1cblxuICAgIG9wZW5OYXYoKSB7XG4gICAgICAgIHRoaXMuJG5hdi52ZWxvY2l0eSh0aGlzLnRyYW5zaXRpb25Jbiwge1xuICAgICAgICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbmF2LnJlbW92ZUF0dHIoJ3N0eWxlJylcbiAgICAgICAgICAgICAgICB0aGlzLiRuYXYuYXR0cignZGF0YS1wcm9wZXJ0eScsICdvcGVuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjbG9zZU5hdigpIHtcbiAgICAgICAgdGhpcy4kbmF2LnZlbG9jaXR5KHRoaXMudHJhbnNpdGlvbk91dCwge1xuICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbmF2LnJlbW92ZUF0dHIoJ3N0eWxlJylcbiAgICAgICAgICAgICAgICB0aGlzLiRuYXYuYXR0cignZGF0YS1wcm9wZXJ0eScsICdjbG9zZWQnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50L3N1Ym5hdi5qcyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL3Nhc3Mvc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL3Nhc3Mvd3lzaXd5Zy1zdHlsZXMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=